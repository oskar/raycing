/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(1);
	var Menu = __webpack_require__(5);
	var MapEditor = __webpack_require__(6);
	var GameGui = __webpack_require__(7);
	
	var currentView = new Menu(function (data) {
	  return onDone(data);
	});
	
	function onDone(data) {
	  currentView.dispose();
	
	  switch (data.view) {
	    case 'Create map':
	      currentView = new MapEditor(function (data) {
	        return onDone(data);
	      });
	      break;
	    case 'Game':
	      currentView = new GameGui(function (data) {
	        return onDone(data);
	      }, data.params);
	      break;
	    default:
	      currentView = new Menu(function (data) {
	        return onDone(data);
	      }, data.params);
	      break;
	  }
	}

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports.setView = setView;
	exports.reset = reset;
	exports.addCourse = addCourse;
	var Paper = __webpack_require__(2);
	var changeCenter = __webpack_require__(3).changeCenter;
	var changeZoom = __webpack_require__(3).changeZoom;
	var animation = __webpack_require__(4);
	
	var canvas = document.createElement('canvas');
	
	var width = document.body.clientWidth;
	var height = document.body.clientHeight;
	
	initPaper(canvas, width, height);
	
	var mouseControls;
	
	var outerBounds = new Paper.Rectangle(0, 0, width * 2, height * 2);
	
	var course = new Paper.Group(createGrid(outerBounds));
	course.clipped = true;
	
	var initialBounds = Paper.view.bounds.clone();
	
	Paper.view.draw();
	
	function setView(bounds) {
	  if (isSameBounds(Paper.view.bounds, bounds)) return;
	  var aspectRatio = width / height;
	  var size = bounds.size.clone();
	  var newRatio = size.width / size.height;
	  if (newRatio !== aspectRatio) {
	    if (newRatio < aspectRatio) {
	      size.width = size.width * aspectRatio / newRatio;
	    } else {
	      size.height = size.height * newRatio / aspectRatio;
	    }
	  }
	  var newZoom = Paper.view.viewSize.width / size.width;
	  newZoom = newZoom > 1 ? newZoom : 1;
	  console.log('New view:', bounds.center, newZoom);
	  animateView(bounds.center, newZoom);
	}
	
	function reset() {
	  setView(initialBounds);
	}
	
	function addCourse(element) {
	  course.appendBottom(element);
	}
	
	function initPaper(canvas, width, height) {
	  canvas.setAttribute('width', width);
	  canvas.setAttribute('height', height);
	  document.body.appendChild(canvas);
	  Paper.setup(canvas);
	  animation.init();
	}
	
	function createGrid(viewBounds) {
	  var grid = new Paper.Group();
	  for (var x = viewBounds.left; x < viewBounds.right; x += 20) {
	    var line = new Paper.Path.Rectangle(new Paper.Point(x - 0.5, viewBounds.top), new Paper.Point(x + 0.5, Paper.view.bounds.bottom));
	    line.fillColor = 'white';
	
	    grid.addChild(line);
	  }
	  for (var y = viewBounds.top; y < viewBounds.bottom; y += 20) {
	    var line = new Paper.Path.Rectangle(new Paper.Point(viewBounds.left, y), new Paper.Point(Paper.view.bounds.right, y + 1));
	    line.fillColor = 'white';
	
	    grid.addChild(line);
	  }
	
	  return grid;
	}
	
	function isSameBounds(view1, view2) {
	  var diff = view1.center.subtract(view2.center).length;
	  return diff < 1;
	}
	
	function animateView(center, zoom) {
	  var animationDuration = 0.3;
	  var startCenter = Paper.view.center.clone();
	  var deltaCenter = center.clone().subtract(startCenter);
	  var startZoom = Paper.view.zoom;
	  var deltaZoom = zoom - startZoom;
	  animation.add(function (elapsedTime) {
	    if (elapsedTime > animationDuration) {
	      Paper.view.center = center;
	      Paper.view.zoom = zoom;
	      return false;
	    } else {
	      var easeValue = elapsedTime / animationDuration;
	      var dtCenter = deltaCenter.multiply(easeValue);
	      Paper.view.center = startCenter.add(dtCenter);
	      var dtZoom = deltaZoom * easeValue;
	      Paper.view.zoom = startZoom + dtZoom;
	    }
	  });
	}
	
	function createStar(start) {
	  animateStar(start, new Paper.Point(100, 1), 4 + Math.random() * 11);
	}
	
	function animateStar(start, velocity, distance) {
	  var star = new Paper.Path.Circle(start, 5 / distance);
	  star.fillColor = 'white';
	  animation.add(function (elapsedTime) {
	    star.position = start.add(velocity.multiply(elapsedTime / distance));
	    if (!outerBounds.contains(star.position)) {
	      var newStart = new Paper.Point.random().multiply(outerBounds.bottomLeft);
	      createStar(newStart);
	      return false;
	    }
	  });
	}
	
	for (var i = 0; i < 100; i++) {
	  var start = new Paper.Point.random().multiply(outerBounds.bottomRight);
	  createStar(start);
	}

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Paper.js v0.9.24 - The Swiss Army Knife of Vector Graphics Scripting.
	 * http://paperjs.org/
	 *
	 * Copyright (c) 2011 - 2014, Juerg Lehni & Jonathan Puckey
	 * http://scratchdisk.com/ & http://jonathanpuckey.com/
	 *
	 * Distributed under the MIT license. See LICENSE file for details.
	 *
	 * All rights reserved.
	 *
	 * Date: Fri Aug 21 16:39:41 2015 +0200
	 *
	 ***
	 *
	 * Straps.js - Class inheritance library with support for bean-style accessors
	 *
	 * Copyright (c) 2006 - 2013 Juerg Lehni
	 * http://scratchdisk.com/
	 *
	 * Distributed under the MIT license.
	 *
	 ***
	 *
	 * Acorn.js
	 * http://marijnhaverbeke.nl/acorn/
	 *
	 * Acorn is a tiny, fast JavaScript parser written in JavaScript,
	 * created by Marijn Haverbeke and released under an MIT license.
	 *
	 */
	
	var paper = new function(undefined) {
	
	var Base = new function() {
		var hidden = /^(statics|enumerable|beans|preserve)$/,
	
			forEach = [].forEach || function(iter, bind) {
				for (var i = 0, l = this.length; i < l; i++)
					iter.call(bind, this[i], i, this);
			},
	
			forIn = function(iter, bind) {
				for (var i in this)
					if (this.hasOwnProperty(i))
						iter.call(bind, this[i], i, this);
			},
	
			create = Object.create || function(proto) {
				return { __proto__: proto };
			},
	
			describe = Object.getOwnPropertyDescriptor || function(obj, name) {
				var get = obj.__lookupGetter__ && obj.__lookupGetter__(name);
				return get
						? { get: get, set: obj.__lookupSetter__(name),
							enumerable: true, configurable: true }
						: obj.hasOwnProperty(name)
							? { value: obj[name], enumerable: true,
								configurable: true, writable: true }
							: null;
			},
	
			_define = Object.defineProperty || function(obj, name, desc) {
				if ((desc.get || desc.set) && obj.__defineGetter__) {
					if (desc.get)
						obj.__defineGetter__(name, desc.get);
					if (desc.set)
						obj.__defineSetter__(name, desc.set);
				} else {
					obj[name] = desc.value;
				}
				return obj;
			},
	
			define = function(obj, name, desc) {
				delete obj[name];
				return _define(obj, name, desc);
			};
	
		function inject(dest, src, enumerable, beans, preserve) {
			var beansNames = {};
	
			function field(name, val) {
				val = val || (val = describe(src, name))
						&& (val.get ? val : val.value);
				if (typeof val === 'string' && val[0] === '#')
					val = dest[val.substring(1)] || val;
				var isFunc = typeof val === 'function',
					res = val,
					prev = preserve || isFunc && !val.base
							? (val && val.get ? name in dest : dest[name])
							: null,
					bean;
				if (!preserve || !prev) {
					if (isFunc && prev)
						val.base = prev;
					if (isFunc && beans !== false
							&& (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/)))
						beansNames[bean[3].toLowerCase() + bean[4]] = bean[2];
					if (!res || isFunc || !res.get || typeof res.get !== 'function'
							|| !Base.isPlainObject(res))
						res = { value: res, writable: true };
					if ((describe(dest, name)
							|| { configurable: true }).configurable) {
						res.configurable = true;
						res.enumerable = enumerable;
					}
					define(dest, name, res);
				}
			}
			if (src) {
				for (var name in src) {
					if (src.hasOwnProperty(name) && !hidden.test(name))
						field(name);
				}
				for (var name in beansNames) {
					var part = beansNames[name],
						set = dest['set' + part],
						get = dest['get' + part] || set && dest['is' + part];
					if (get && (beans === true || get.length === 0))
						field(name, { get: get, set: set });
				}
			}
			return dest;
		}
	
		function each(obj, iter, bind) {
			if (obj)
				('length' in obj && !obj.getLength
						&& typeof obj.length === 'number'
					? forEach
					: forIn).call(obj, iter, bind = bind || obj);
			return bind;
		}
	
		function set(obj, props, exclude) {
			for (var key in props)
				if (props.hasOwnProperty(key) && !(exclude && exclude[key]))
					obj[key] = props[key];
			return obj;
		}
	
		return inject(function Base() {
			for (var i = 0, l = arguments.length; i < l; i++)
				set(this, arguments[i]);
		}, {
			inject: function(src) {
				if (src) {
					var statics = src.statics === true ? src : src.statics,
						beans = src.beans,
						preserve = src.preserve;
					if (statics !== src)
						inject(this.prototype, src, src.enumerable, beans, preserve);
					inject(this, statics, true, beans, preserve);
				}
				for (var i = 1, l = arguments.length; i < l; i++)
					this.inject(arguments[i]);
				return this;
			},
	
			extend: function() {
				var base = this,
					ctor,
					proto;
				for (var i = 0, l = arguments.length; i < l; i++)
					if (ctor = arguments[i].initialize)
						break;
				ctor = ctor || function() {
					base.apply(this, arguments);
				};
				proto = ctor.prototype = create(this.prototype);
				define(proto, 'constructor',
						{ value: ctor, writable: true, configurable: true });
				inject(ctor, this, true);
				if (arguments.length)
					this.inject.apply(ctor, arguments);
				ctor.base = base;
				return ctor;
			}
		}, true).inject({
			inject: function() {
				for (var i = 0, l = arguments.length; i < l; i++) {
					var src = arguments[i];
					if (src)
						inject(this, src, src.enumerable, src.beans, src.preserve);
				}
				return this;
			},
	
			extend: function() {
				var res = create(this);
				return res.inject.apply(res, arguments);
			},
	
			each: function(iter, bind) {
				return each(this, iter, bind);
			},
	
			set: function(props) {
				return set(this, props);
			},
	
			clone: function() {
				return new this.constructor(this);
			},
	
			statics: {
				each: each,
				create: create,
				define: define,
				describe: describe,
				set: set,
	
				clone: function(obj) {
					return set(new obj.constructor(), obj);
				},
	
				isPlainObject: function(obj) {
					var ctor = obj != null && obj.constructor;
					return ctor && (ctor === Object || ctor === Base
							|| ctor.name === 'Object');
				},
	
				pick: function(a, b) {
					return a !== undefined ? a : b;
				}
			}
		});
	};
	
	if (true)
		module.exports = Base;
	
	Base.inject({
		toString: function() {
			return this._id != null
				?  (this._class || 'Object') + (this._name
					? " '" + this._name + "'"
					: ' @' + this._id)
				: '{ ' + Base.each(this, function(value, key) {
					if (!/^_/.test(key)) {
						var type = typeof value;
						this.push(key + ': ' + (type === 'number'
								? Formatter.instance.number(value)
								: type === 'string' ? "'" + value + "'" : value));
					}
				}, []).join(', ') + ' }';
		},
	
		getClassName: function() {
			return this._class || '';
		},
	
		exportJSON: function(options) {
			return Base.exportJSON(this, options);
		},
	
		toJSON: function() {
			return Base.serialize(this);
		},
	
		_set: function(props, exclude, dontCheck) {
			if (props && (dontCheck || Base.isPlainObject(props))) {
				var keys = Object.keys(props._filtering || props);
				for (var i = 0, l = keys.length; i < l; i++) {
					var key = keys[i];
					if (!(exclude && exclude[key])) {
						var value = props[key];
						if (value !== undefined)
							this[key] = value;
					}
				}
				return true;
			}
		},
	
		statics: {
	
			exports: {
				enumerable: true
			},
	
			extend: function extend() {
				var res = extend.base.apply(this, arguments),
					name = res.prototype._class;
				if (name && !Base.exports[name])
					Base.exports[name] = res;
				return res;
			},
	
			equals: function(obj1, obj2) {
				if (obj1 === obj2)
					return true;
				if (obj1 && obj1.equals)
					return obj1.equals(obj2);
				if (obj2 && obj2.equals)
					return obj2.equals(obj1);
				if (obj1 && obj2
						&& typeof obj1 === 'object' && typeof obj2 === 'object') {
					if (Array.isArray(obj1) && Array.isArray(obj2)) {
						var length = obj1.length;
						if (length !== obj2.length)
							return false;
						while (length--) {
							if (!Base.equals(obj1[length], obj2[length]))
								return false;
						}
					} else {
						var keys = Object.keys(obj1),
							length = keys.length;
						if (length !== Object.keys(obj2).length)
							return false;
						while (length--) {
							var key = keys[length];
							if (!(obj2.hasOwnProperty(key)
									&& Base.equals(obj1[key], obj2[key])))
								return false;
						}
					}
					return true;
				}
				return false;
			},
	
			read: function(list, start, options, length) {
				if (this === Base) {
					var value = this.peek(list, start);
					list.__index++;
					return value;
				}
				var proto = this.prototype,
					readIndex = proto._readIndex,
					index = start || readIndex && list.__index || 0;
				if (!length)
					length = list.length - index;
				var obj = list[index];
				if (obj instanceof this
					|| options && options.readNull && obj == null && length <= 1) {
					if (readIndex)
						list.__index = index + 1;
					return obj && options && options.clone ? obj.clone() : obj;
				}
				obj = Base.create(this.prototype);
				if (readIndex)
					obj.__read = true;
				obj = obj.initialize.apply(obj, index > 0 || length < list.length
					? Array.prototype.slice.call(list, index, index + length)
					: list) || obj;
				if (readIndex) {
					list.__index = index + obj.__read;
					obj.__read = undefined;
				}
				return obj;
			},
	
			peek: function(list, start) {
				return list[list.__index = start || list.__index || 0];
			},
	
			remain: function(list) {
				return list.length - (list.__index || 0);
			},
	
			readAll: function(list, start, options) {
				var res = [],
					entry;
				for (var i = start || 0, l = list.length; i < l; i++) {
					res.push(Array.isArray(entry = list[i])
							? this.read(entry, 0, options)
							: this.read(list, i, options, 1));
				}
				return res;
			},
	
			readNamed: function(list, name, start, options, length) {
				var value = this.getNamed(list, name),
					hasObject = value !== undefined;
				if (hasObject) {
					var filtered = list._filtered;
					if (!filtered) {
						filtered = list._filtered = Base.create(list[0]);
						filtered._filtering = list[0];
					}
					filtered[name] = undefined;
				}
				return this.read(hasObject ? [value] : list, start, options, length);
			},
	
			getNamed: function(list, name) {
				var arg = list[0];
				if (list._hasObject === undefined)
					list._hasObject = list.length === 1 && Base.isPlainObject(arg);
				if (list._hasObject)
					return name ? arg[name] : list._filtered || arg;
			},
	
			hasNamed: function(list, name) {
				return !!this.getNamed(list, name);
			},
	
			isPlainValue: function(obj, asString) {
				return this.isPlainObject(obj) || Array.isArray(obj)
						|| asString && typeof obj === 'string';
			},
	
			serialize: function(obj, options, compact, dictionary) {
				options = options || {};
	
				var root = !dictionary,
					res;
				if (root) {
					options.formatter = new Formatter(options.precision);
					dictionary = {
						length: 0,
						definitions: {},
						references: {},
						add: function(item, create) {
							var id = '#' + item._id,
								ref = this.references[id];
							if (!ref) {
								this.length++;
								var res = create.call(item),
									name = item._class;
								if (name && res[0] !== name)
									res.unshift(name);
								this.definitions[id] = res;
								ref = this.references[id] = [id];
							}
							return ref;
						}
					};
				}
				if (obj && obj._serialize) {
					res = obj._serialize(options, dictionary);
					var name = obj._class;
					if (name && !compact && !res._compact && res[0] !== name)
						res.unshift(name);
				} else if (Array.isArray(obj)) {
					res = [];
					for (var i = 0, l = obj.length; i < l; i++)
						res[i] = Base.serialize(obj[i], options, compact,
								dictionary);
					if (compact)
						res._compact = true;
				} else if (Base.isPlainObject(obj)) {
					res = {};
					var keys = Object.keys(obj);
					for (var i = 0, l = keys.length; i < l; i++) {
						var key = keys[i];
						res[key] = Base.serialize(obj[key], options, compact,
								dictionary);
					}
				} else if (typeof obj === 'number') {
					res = options.formatter.number(obj, options.precision);
				} else {
					res = obj;
				}
				return root && dictionary.length > 0
						? [['dictionary', dictionary.definitions], res]
						: res;
			},
	
			deserialize: function(json, create, _data, _isDictionary) {
				var res = json,
					isRoot = !_data;
				_data = _data || {};
				if (Array.isArray(json)) {
					var type = json[0],
						isDictionary = type === 'dictionary';
					if (json.length == 1 && /^#/.test(type))
						return _data.dictionary[type];
					type = Base.exports[type];
					res = [];
					if (_isDictionary)
						_data.dictionary = res;
					for (var i = type ? 1 : 0, l = json.length; i < l; i++)
						res.push(Base.deserialize(json[i], create, _data,
								isDictionary));
					if (type) {
						var args = res;
						if (create) {
							res = create(type, args);
						} else {
							res = Base.create(type.prototype);
							type.apply(res, args);
						}
					}
				} else if (Base.isPlainObject(json)) {
					res = {};
					if (_isDictionary)
						_data.dictionary = res;
					for (var key in json)
						res[key] = Base.deserialize(json[key], create, _data);
				}
				return isRoot && json && json.length && json[0][0] === 'dictionary'
						? res[1]
						: res;
			},
	
			exportJSON: function(obj, options) {
				var json = Base.serialize(obj, options);
				return options && options.asString === false
						? json
						: JSON.stringify(json);
			},
	
			importJSON: function(json, target) {
				return Base.deserialize(
						typeof json === 'string' ? JSON.parse(json) : json,
						function(type, args) {
							var obj = target && target.constructor === type
									? target
									: Base.create(type.prototype),
								isTarget = obj === target;
							if (args.length === 1 && obj instanceof Item
									&& (isTarget || !(obj instanceof Layer))) {
								var arg = args[0];
								if (Base.isPlainObject(arg))
									arg.insert = false;
							}
							type.apply(obj, args);
							if (isTarget)
								target = null;
							return obj;
						});
			},
	
			splice: function(list, items, index, remove) {
				var amount = items && items.length,
					append = index === undefined;
				index = append ? list.length : index;
				if (index > list.length)
					index = list.length;
				for (var i = 0; i < amount; i++)
					items[i]._index = index + i;
				if (append) {
					list.push.apply(list, items);
					return [];
				} else {
					var args = [index, remove];
					if (items)
						args.push.apply(args, items);
					var removed = list.splice.apply(list, args);
					for (var i = 0, l = removed.length; i < l; i++)
						removed[i]._index = undefined;
					for (var i = index + amount, l = list.length; i < l; i++)
						list[i]._index = i;
					return removed;
				}
			},
	
			capitalize: function(str) {
				return str.replace(/\b[a-z]/g, function(match) {
					return match.toUpperCase();
				});
			},
	
			camelize: function(str) {
				return str.replace(/-(.)/g, function(all, chr) {
					return chr.toUpperCase();
				});
			},
	
			hyphenate: function(str) {
				return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
			}
		}
	});
	
	var Emitter = {
		on: function(type, func) {
			if (typeof type !== 'string') {
				Base.each(type, function(value, key) {
					this.on(key, value);
				}, this);
			} else {
				var types = this._eventTypes,
					entry = types && types[type],
					handlers = this._callbacks = this._callbacks || {};
				handlers = handlers[type] = handlers[type] || [];
				if (handlers.indexOf(func) === -1) {
					handlers.push(func);
					if (entry && entry.install && handlers.length == 1)
						entry.install.call(this, type);
				}
			}
			return this;
		},
	
		off: function(type, func) {
			if (typeof type !== 'string') {
				Base.each(type, function(value, key) {
					this.off(key, value);
				}, this);
				return;
			}
			var types = this._eventTypes,
				entry = types && types[type],
				handlers = this._callbacks && this._callbacks[type],
				index;
			if (handlers) {
				if (!func || (index = handlers.indexOf(func)) !== -1
						&& handlers.length === 1) {
					if (entry && entry.uninstall)
						entry.uninstall.call(this, type);
					delete this._callbacks[type];
				} else if (index !== -1) {
					handlers.splice(index, 1);
				}
			}
			return this;
		},
	
		once: function(type, func) {
			return this.on(type, function() {
				func.apply(this, arguments);
				this.off(type, func);
			});
		},
	
		emit: function(type, event) {
			var handlers = this._callbacks && this._callbacks[type];
			if (!handlers)
				return false;
			var args = [].slice.call(arguments, 1);
			handlers = handlers.slice();
			for (var i = 0, l = handlers.length; i < l; i++) {
				if (handlers[i].apply(this, args) === false) {
					if (event && event.stop)
						event.stop();
					break;
				}
			}
			return true;
		},
	
		responds: function(type) {
			return !!(this._callbacks && this._callbacks[type]);
		},
	
		attach: '#on',
		detach: '#off',
		fire: '#emit',
	
		_installEvents: function(install) {
			var handlers = this._callbacks,
				key = install ? 'install' : 'uninstall';
			for (var type in handlers) {
				if (handlers[type].length > 0) {
					var types = this._eventTypes,
						entry = types && types[type],
						func = entry && entry[key];
					if (func)
						func.call(this, type);
				}
			}
		},
	
		statics: {
			inject: function inject(src) {
				var events = src._events;
				if (events) {
					var types = {};
					Base.each(events, function(entry, key) {
						var isString = typeof entry === 'string',
							name = isString ? entry : key,
							part = Base.capitalize(name),
							type = name.substring(2).toLowerCase();
						types[type] = isString ? {} : entry;
						name = '_' + name;
						src['get' + part] = function() {
							return this[name];
						};
						src['set' + part] = function(func) {
							var prev = this[name];
							if (prev)
								this.off(type, prev);
							if (func)
								this.on(type, func);
							this[name] = func;
						};
					});
					src._eventTypes = types;
				}
				return inject.base.apply(this, arguments);
			}
		}
	};
	
	var PaperScope = Base.extend({
		_class: 'PaperScope',
	
		initialize: function PaperScope() {
			paper = this;
			this.settings = new Base({
				applyMatrix: true,
				handleSize: 4,
				hitTolerance: 0
			});
			this.project = null;
			this.projects = [];
			this.tools = [];
			this.palettes = [];
			this._id = PaperScope._id++;
			PaperScope._scopes[this._id] = this;
			var proto = PaperScope.prototype;
			if (!this.support) {
				var ctx = CanvasProvider.getContext(1, 1);
				proto.support = {
					nativeDash: 'setLineDash' in ctx || 'mozDash' in ctx,
					nativeBlendModes: BlendMode.nativeModes
				};
				CanvasProvider.release(ctx);
			}
	
			if (!this.browser) {
				var agent = navigator.userAgent.toLowerCase(),
					platform = (/(win)/.exec(agent)
							|| /(mac)/.exec(agent)
							|| /(linux)/.exec(agent)
							|| [])[0],
					browser = proto.browser = { platform: platform };
				if (platform)
					browser[platform] = true;
				agent.replace(
					/(opera|chrome|safari|webkit|firefox|msie|trident|atom)\/?\s*([.\d]+)(?:.*version\/([.\d]+))?(?:.*rv\:([.\d]+))?/g,
					function(all, n, v1, v2, rv) {
						if (!browser.chrome) {
							var v = n === 'opera' ? v2 : v1;
							if (n === 'trident') {
								v = rv;
								n = 'msie';
							}
							browser.version = v;
							browser.versionNumber = parseFloat(v);
							browser.name = n;
							browser[n] = true;
						}
					}
				);
				if (browser.chrome)
					delete browser.webkit;
				if (browser.atom)
					delete browser.chrome;
			}
		},
	
		version: '0.9.24',
	
		getView: function() {
			return this.project && this.project.getView();
		},
	
		getPaper: function() {
			return this;
		},
	
		execute: function(code, url, options) {
			paper.PaperScript.execute(code, this, url, options);
			View.updateFocus();
		},
	
		install: function(scope) {
			var that = this;
			Base.each(['project', 'view', 'tool'], function(key) {
				Base.define(scope, key, {
					configurable: true,
					get: function() {
						return that[key];
					}
				});
			});
			for (var key in this)
				if (!/^_/.test(key) && this[key])
					scope[key] = this[key];
		},
	
		setup: function(element) {
			paper = this;
			this.project = new Project(element);
			return this;
		},
	
		activate: function() {
			paper = this;
		},
	
		clear: function() {
			for (var i = this.projects.length - 1; i >= 0; i--)
				this.projects[i].remove();
			for (var i = this.tools.length - 1; i >= 0; i--)
				this.tools[i].remove();
			for (var i = this.palettes.length - 1; i >= 0; i--)
				this.palettes[i].remove();
		},
	
		remove: function() {
			this.clear();
			delete PaperScope._scopes[this._id];
		},
	
		statics: new function() {
			function handleAttribute(name) {
				name += 'Attribute';
				return function(el, attr) {
					return el[name](attr) || el[name]('data-paper-' + attr);
				};
			}
	
			return {
				_scopes: {},
				_id: 0,
	
				get: function(id) {
					return this._scopes[id] || null;
				},
	
				getAttribute: handleAttribute('get'),
				hasAttribute: handleAttribute('has')
			};
		}
	});
	
	var PaperScopeItem = Base.extend(Emitter, {
	
		initialize: function(activate) {
			this._scope = paper;
			this._index = this._scope[this._list].push(this) - 1;
			if (activate || !this._scope[this._reference])
				this.activate();
		},
	
		activate: function() {
			if (!this._scope)
				return false;
			var prev = this._scope[this._reference];
			if (prev && prev !== this)
				prev.emit('deactivate');
			this._scope[this._reference] = this;
			this.emit('activate', prev);
			return true;
		},
	
		isActive: function() {
			return this._scope[this._reference] === this;
		},
	
		remove: function() {
			if (this._index == null)
				return false;
			Base.splice(this._scope[this._list], null, this._index, 1);
			if (this._scope[this._reference] == this)
				this._scope[this._reference] = null;
			this._scope = null;
			return true;
		}
	});
	
	var Formatter = Base.extend({
		initialize: function(precision) {
			this.precision = precision || 5;
			this.multiplier = Math.pow(10, this.precision);
		},
	
		number: function(val) {
			return Math.round(val * this.multiplier) / this.multiplier;
		},
	
		pair: function(val1, val2, separator) {
			return this.number(val1) + (separator || ',') + this.number(val2);
		},
	
		point: function(val, separator) {
			return this.number(val.x) + (separator || ',') + this.number(val.y);
		},
	
		size: function(val, separator) {
			return this.number(val.width) + (separator || ',')
					+ this.number(val.height);
		},
	
		rectangle: function(val, separator) {
			return this.point(val, separator) + (separator || ',')
					+ this.size(val, separator);
		}
	});
	
	Formatter.instance = new Formatter();
	
	var Numerical = new function() {
	
		var abscissas = [
			[  0.5773502691896257645091488],
			[0,0.7745966692414833770358531],
			[  0.3399810435848562648026658,0.8611363115940525752239465],
			[0,0.5384693101056830910363144,0.9061798459386639927976269],
			[  0.2386191860831969086305017,0.6612093864662645136613996,0.9324695142031520278123016],
			[0,0.4058451513773971669066064,0.7415311855993944398638648,0.9491079123427585245261897],
			[  0.1834346424956498049394761,0.5255324099163289858177390,0.7966664774136267395915539,0.9602898564975362316835609],
			[0,0.3242534234038089290385380,0.6133714327005903973087020,0.8360311073266357942994298,0.9681602395076260898355762],
			[  0.1488743389816312108848260,0.4333953941292471907992659,0.6794095682990244062343274,0.8650633666889845107320967,0.9739065285171717200779640],
			[0,0.2695431559523449723315320,0.5190961292068118159257257,0.7301520055740493240934163,0.8870625997680952990751578,0.9782286581460569928039380],
			[  0.1252334085114689154724414,0.3678314989981801937526915,0.5873179542866174472967024,0.7699026741943046870368938,0.9041172563704748566784659,0.9815606342467192506905491],
			[0,0.2304583159551347940655281,0.4484927510364468528779129,0.6423493394403402206439846,0.8015780907333099127942065,0.9175983992229779652065478,0.9841830547185881494728294],
			[  0.1080549487073436620662447,0.3191123689278897604356718,0.5152486363581540919652907,0.6872929048116854701480198,0.8272013150697649931897947,0.9284348836635735173363911,0.9862838086968123388415973],
			[0,0.2011940939974345223006283,0.3941513470775633698972074,0.5709721726085388475372267,0.7244177313601700474161861,0.8482065834104272162006483,0.9372733924007059043077589,0.9879925180204854284895657],
			[  0.0950125098376374401853193,0.2816035507792589132304605,0.4580167776572273863424194,0.6178762444026437484466718,0.7554044083550030338951012,0.8656312023878317438804679,0.9445750230732325760779884,0.9894009349916499325961542]
		];
	
		var weights = [
			[1],
			[0.8888888888888888888888889,0.5555555555555555555555556],
			[0.6521451548625461426269361,0.3478548451374538573730639],
			[0.5688888888888888888888889,0.4786286704993664680412915,0.2369268850561890875142640],
			[0.4679139345726910473898703,0.3607615730481386075698335,0.1713244923791703450402961],
			[0.4179591836734693877551020,0.3818300505051189449503698,0.2797053914892766679014678,0.1294849661688696932706114],
			[0.3626837833783619829651504,0.3137066458778872873379622,0.2223810344533744705443560,0.1012285362903762591525314],
			[0.3302393550012597631645251,0.3123470770400028400686304,0.2606106964029354623187429,0.1806481606948574040584720,0.0812743883615744119718922],
			[0.2955242247147528701738930,0.2692667193099963550912269,0.2190863625159820439955349,0.1494513491505805931457763,0.0666713443086881375935688],
			[0.2729250867779006307144835,0.2628045445102466621806889,0.2331937645919904799185237,0.1862902109277342514260976,0.1255803694649046246346943,0.0556685671161736664827537],
			[0.2491470458134027850005624,0.2334925365383548087608499,0.2031674267230659217490645,0.1600783285433462263346525,0.1069393259953184309602547,0.0471753363865118271946160],
			[0.2325515532308739101945895,0.2262831802628972384120902,0.2078160475368885023125232,0.1781459807619457382800467,0.1388735102197872384636018,0.0921214998377284479144218,0.0404840047653158795200216],
			[0.2152638534631577901958764,0.2051984637212956039659241,0.1855383974779378137417166,0.1572031671581935345696019,0.1215185706879031846894148,0.0801580871597602098056333,0.0351194603317518630318329],
			[0.2025782419255612728806202,0.1984314853271115764561183,0.1861610000155622110268006,0.1662692058169939335532009,0.1395706779261543144478048,0.1071592204671719350118695,0.0703660474881081247092674,0.0307532419961172683546284],
			[0.1894506104550684962853967,0.1826034150449235888667637,0.1691565193950025381893121,0.1495959888165767320815017,0.1246289712555338720524763,0.0951585116824927848099251,0.0622535239386478928628438,0.0271524594117540948517806]
		];
	
		var abs = Math.abs,
			sqrt = Math.sqrt,
			pow = Math.pow,
			TOLERANCE = 1e-6,
			EPSILON = 1e-12,
			MACHINE_EPSILON = 1.12e-16;
	
		return {
			TOLERANCE: TOLERANCE,
			EPSILON: EPSILON,
			MACHINE_EPSILON: MACHINE_EPSILON,
			KAPPA: 4 * (sqrt(2) - 1) / 3,
	
			isZero: function(val) {
				return abs(val) <= EPSILON;
			},
	
			integrate: function(f, a, b, n) {
				var x = abscissas[n - 2],
					w = weights[n - 2],
					A = (b - a) * 0.5,
					B = A + a,
					i = 0,
					m = (n + 1) >> 1,
					sum = n & 1 ? w[i++] * f(B) : 0;
				while (i < m) {
					var Ax = A * x[i];
					sum += w[i++] * (f(B + Ax) + f(B - Ax));
				}
				return A * sum;
			},
	
			findRoot: function(f, df, x, a, b, n, tolerance) {
				for (var i = 0; i < n; i++) {
					var fx = f(x),
						dx = fx / df(x),
						nx = x - dx;
					if (abs(dx) < tolerance)
						return nx;
					if (fx > 0) {
						b = x;
						x = nx <= a ? (a + b) * 0.5 : nx;
					} else {
						a = x;
						x = nx >= b ? (a + b) * 0.5 : nx;
					}
				}
				return x;
			},
	
			solveQuadratic: function(a, b, c, roots, min, max) {
				var count = 0,
					x1, x2 = Infinity,
					B = b,
					D;
				b /= 2;
				D = b * b - a * c;
				if (D !== 0 && abs(D) < MACHINE_EPSILON) {
					var gmC = pow(abs(a * b * c), 1 / 3);
					if (gmC < 1e-8) {
						var mult = pow(10, abs(
							Math.floor(Math.log(gmC) * Math.LOG10E)));
						if (!isFinite(mult))
							mult = 0;
						a *= mult;
						b *= mult;
						c *= mult;
						D = b * b - a * c;
					}
				}
				if (abs(a) < EPSILON) {
					if (abs(B) < EPSILON)
						return abs(c) < EPSILON ? -1 : 0;
					x1 = -c / B;
				} else {
					if (D >= -MACHINE_EPSILON) {
						D = D < 0 ? 0 : D;
						var R = sqrt(D);
						if (b >= MACHINE_EPSILON && b <= MACHINE_EPSILON) {
							x1 = abs(a) >= abs(c) ? R / a : -c / R;
							x2 = -x1;
						} else {
							var q = -(b + (b < 0 ? -1 : 1) * R);
							x1 = q / a;
							x2 = c / q;
						}
					}
				}
				if (isFinite(x1) && (min == null || x1 >= min && x1 <= max))
					roots[count++] = x1;
				if (x2 !== x1
						&& isFinite(x2) && (min == null || x2 >= min && x2 <= max))
					roots[count++] = x2;
				return count;
			},
	
			solveCubic: function(a, b, c, d, roots, min, max) {
				var count = 0,
					x, b1, c2;
				if (abs(a) < EPSILON) {
					a = b;
					b1 = c;
					c2 = d;
					x = Infinity;
				} else if (abs(d) < EPSILON) {
					b1 = b;
					c2 = c;
					x = 0;
				} else {
					var ec = 1 + MACHINE_EPSILON,
						x0, q, qd, t, r, s, tmp;
					x = -(b / a) / 3;
					tmp = a * x,
					b1 = tmp + b,
					c2 = b1 * x + c,
					qd = (tmp + b1) * x + c2,
					q = c2 * x + d;
					t = q /a;
					r = pow(abs(t), 1/3);
					s = t < 0 ? -1 : 1;
					t = -qd / a;
					r = t > 0 ? 1.3247179572 * Math.max(r, sqrt(t)) : r;
					x0 = x - s * r;
					if (x0 !== x) {
						do {
							x = x0;
							tmp = a * x,
							b1 = tmp + b,
							c2 = b1 * x + c,
							qd = (tmp + b1) * x + c2,
							q = c2 * x + d;
							x0 = qd === 0 ? x : x - q / qd / ec;
							if (x0 === x) {
								x = x0;
								break;
							}
						} while (s * x0 > s * x);
						if (abs(a) * x * x > abs(d / x)) {
							c2 = -d / x;
							b1 = (c2 - c) / x;
						}
					}
				}
				var count = Numerical.solveQuadratic(a, b1, c2, roots, min, max);
				if (isFinite(x) && (count === 0 || x !== roots[count - 1])
						&& (min == null || x >= min && x <= max))
					roots[count++] = x;
				return count;
			}
		};
	};
	
	var UID = {
		_id: 1,
		_pools: {},
	
		get: function(ctor) {
			if (ctor) {
				var name = ctor._class,
					pool = this._pools[name];
				if (!pool)
					pool = this._pools[name] = { _id: 1 };
				return pool._id++;
			} else {
				return this._id++;
			}
		}
	};
	
	var Point = Base.extend({
		_class: 'Point',
		_readIndex: true,
	
		initialize: function Point(arg0, arg1) {
			var type = typeof arg0;
			if (type === 'number') {
				var hasY = typeof arg1 === 'number';
				this.x = arg0;
				this.y = hasY ? arg1 : arg0;
				if (this.__read)
					this.__read = hasY ? 2 : 1;
			} else if (type === 'undefined' || arg0 === null) {
				this.x = this.y = 0;
				if (this.__read)
					this.__read = arg0 === null ? 1 : 0;
			} else {
				if (Array.isArray(arg0)) {
					this.x = arg0[0];
					this.y = arg0.length > 1 ? arg0[1] : arg0[0];
				} else if (arg0.x != null) {
					this.x = arg0.x;
					this.y = arg0.y;
				} else if (arg0.width != null) {
					this.x = arg0.width;
					this.y = arg0.height;
				} else if (arg0.angle != null) {
					this.x = arg0.length;
					this.y = 0;
					this.setAngle(arg0.angle);
				} else {
					this.x = this.y = 0;
					if (this.__read)
						this.__read = 0;
				}
				if (this.__read)
					this.__read = 1;
			}
		},
	
		set: function(x, y) {
			this.x = x;
			this.y = y;
			return this;
		},
	
		equals: function(point) {
			return this === point || point
					&& (this.x === point.x && this.y === point.y
						|| Array.isArray(point)
							&& this.x === point[0] && this.y === point[1])
					|| false;
		},
	
		clone: function() {
			return new Point(this.x, this.y);
		},
	
		toString: function() {
			var f = Formatter.instance;
			return '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';
		},
	
		_serialize: function(options) {
			var f = options.formatter;
			return [f.number(this.x), f.number(this.y)];
		},
	
		getLength: function() {
			return Math.sqrt(this.x * this.x + this.y * this.y);
		},
	
		setLength: function(length) {
			if (this.isZero()) {
				var angle = this._angle || 0;
				this.set(
					Math.cos(angle) * length,
					Math.sin(angle) * length
				);
			} else {
				var scale = length / this.getLength();
				if (Numerical.isZero(scale))
					this.getAngle();
				this.set(
					this.x * scale,
					this.y * scale
				);
			}
		},
		getAngle: function() {
			return this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;
		},
	
		setAngle: function(angle) {
			this.setAngleInRadians.call(this, angle * Math.PI / 180);
		},
	
		getAngleInDegrees: '#getAngle',
		setAngleInDegrees: '#setAngle',
	
		getAngleInRadians: function() {
			if (!arguments.length) {
				return this.isZero()
						? this._angle || 0
						: this._angle = Math.atan2(this.y, this.x);
			} else {
				var point = Point.read(arguments),
					div = this.getLength() * point.getLength();
				if (Numerical.isZero(div)) {
					return NaN;
				} else {
					var a = this.dot(point) / div;
					return Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);
				}
			}
		},
	
		setAngleInRadians: function(angle) {
			this._angle = angle;
			if (!this.isZero()) {
				var length = this.getLength();
				this.set(
					Math.cos(angle) * length,
					Math.sin(angle) * length
				);
			}
		},
	
		getQuadrant: function() {
			return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;
		}
	}, {
		beans: false,
	
		getDirectedAngle: function() {
			var point = Point.read(arguments);
			return Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;
		},
	
		getDistance: function() {
			var point = Point.read(arguments),
				x = point.x - this.x,
				y = point.y - this.y,
				d = x * x + y * y,
				squared = Base.read(arguments);
			return squared ? d : Math.sqrt(d);
		},
	
		normalize: function(length) {
			if (length === undefined)
				length = 1;
			var current = this.getLength(),
				scale = current !== 0 ? length / current : 0,
				point = new Point(this.x * scale, this.y * scale);
			if (scale >= 0)
				point._angle = this._angle;
			return point;
		},
	
		rotate: function(angle, center) {
			if (angle === 0)
				return this.clone();
			angle = angle * Math.PI / 180;
			var point = center ? this.subtract(center) : this,
				s = Math.sin(angle),
				c = Math.cos(angle);
			point = new Point(
				point.x * c - point.y * s,
				point.x * s + point.y * c
			);
			return center ? point.add(center) : point;
		},
	
		transform: function(matrix) {
			return matrix ? matrix._transformPoint(this) : this;
		},
	
		add: function() {
			var point = Point.read(arguments);
			return new Point(this.x + point.x, this.y + point.y);
		},
	
		subtract: function() {
			var point = Point.read(arguments);
			return new Point(this.x - point.x, this.y - point.y);
		},
	
		multiply: function() {
			var point = Point.read(arguments);
			return new Point(this.x * point.x, this.y * point.y);
		},
	
		divide: function() {
			var point = Point.read(arguments);
			return new Point(this.x / point.x, this.y / point.y);
		},
	
		modulo: function() {
			var point = Point.read(arguments);
			return new Point(this.x % point.x, this.y % point.y);
		},
	
		negate: function() {
			return new Point(-this.x, -this.y);
		},
	
		isInside: function() {
			return Rectangle.read(arguments).contains(this);
		},
	
		isClose: function(point, tolerance) {
			return this.getDistance(point) < tolerance;
		},
	
		isCollinear: function(point) {
			return Math.abs(this.cross(point)) < 0.000001;
		},
	
		isColinear: '#isCollinear',
	
		isOrthogonal: function(point) {
			return Math.abs(this.dot(point)) < 0.000001;
		},
	
		isZero: function() {
			return Numerical.isZero(this.x) && Numerical.isZero(this.y);
		},
	
		isNaN: function() {
			return isNaN(this.x) || isNaN(this.y);
		},
	
		dot: function() {
			var point = Point.read(arguments);
			return this.x * point.x + this.y * point.y;
		},
	
		cross: function() {
			var point = Point.read(arguments);
			return this.x * point.y - this.y * point.x;
		},
	
		project: function() {
			var point = Point.read(arguments);
			if (point.isZero()) {
				return new Point(0, 0);
			} else {
				var scale = this.dot(point) / point.dot(point);
				return new Point(
					point.x * scale,
					point.y * scale
				);
			}
		},
	
		statics: {
			min: function() {
				var point1 = Point.read(arguments),
					point2 = Point.read(arguments);
				return new Point(
					Math.min(point1.x, point2.x),
					Math.min(point1.y, point2.y)
				);
			},
	
			max: function() {
				var point1 = Point.read(arguments),
					point2 = Point.read(arguments);
				return new Point(
					Math.max(point1.x, point2.x),
					Math.max(point1.y, point2.y)
				);
			},
	
			random: function() {
				return new Point(Math.random(), Math.random());
			}
		}
	}, Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {
		var op = Math[name];
		this[name] = function() {
			return new Point(op(this.x), op(this.y));
		};
	}, {}));
	
	var LinkedPoint = Point.extend({
		initialize: function Point(x, y, owner, setter) {
			this._x = x;
			this._y = y;
			this._owner = owner;
			this._setter = setter;
		},
	
		set: function(x, y, _dontNotify) {
			this._x = x;
			this._y = y;
			if (!_dontNotify)
				this._owner[this._setter](this);
			return this;
		},
	
		getX: function() {
			return this._x;
		},
	
		setX: function(x) {
			this._x = x;
			this._owner[this._setter](this);
		},
	
		getY: function() {
			return this._y;
		},
	
		setY: function(y) {
			this._y = y;
			this._owner[this._setter](this);
		}
	});
	
	var Size = Base.extend({
		_class: 'Size',
		_readIndex: true,
	
		initialize: function Size(arg0, arg1) {
			var type = typeof arg0;
			if (type === 'number') {
				var hasHeight = typeof arg1 === 'number';
				this.width = arg0;
				this.height = hasHeight ? arg1 : arg0;
				if (this.__read)
					this.__read = hasHeight ? 2 : 1;
			} else if (type === 'undefined' || arg0 === null) {
				this.width = this.height = 0;
				if (this.__read)
					this.__read = arg0 === null ? 1 : 0;
			} else {
				if (Array.isArray(arg0)) {
					this.width = arg0[0];
					this.height = arg0.length > 1 ? arg0[1] : arg0[0];
				} else if (arg0.width != null) {
					this.width = arg0.width;
					this.height = arg0.height;
				} else if (arg0.x != null) {
					this.width = arg0.x;
					this.height = arg0.y;
				} else {
					this.width = this.height = 0;
					if (this.__read)
						this.__read = 0;
				}
				if (this.__read)
					this.__read = 1;
			}
		},
	
		set: function(width, height) {
			this.width = width;
			this.height = height;
			return this;
		},
	
		equals: function(size) {
			return size === this || size && (this.width === size.width
					&& this.height === size.height
					|| Array.isArray(size) && this.width === size[0]
						&& this.height === size[1]) || false;
		},
	
		clone: function() {
			return new Size(this.width, this.height);
		},
	
		toString: function() {
			var f = Formatter.instance;
			return '{ width: ' + f.number(this.width)
					+ ', height: ' + f.number(this.height) + ' }';
		},
	
		_serialize: function(options) {
			var f = options.formatter;
			return [f.number(this.width),
					f.number(this.height)];
		},
	
		add: function() {
			var size = Size.read(arguments);
			return new Size(this.width + size.width, this.height + size.height);
		},
	
		subtract: function() {
			var size = Size.read(arguments);
			return new Size(this.width - size.width, this.height - size.height);
		},
	
		multiply: function() {
			var size = Size.read(arguments);
			return new Size(this.width * size.width, this.height * size.height);
		},
	
		divide: function() {
			var size = Size.read(arguments);
			return new Size(this.width / size.width, this.height / size.height);
		},
	
		modulo: function() {
			var size = Size.read(arguments);
			return new Size(this.width % size.width, this.height % size.height);
		},
	
		negate: function() {
			return new Size(-this.width, -this.height);
		},
	
		isZero: function() {
			return Numerical.isZero(this.width) && Numerical.isZero(this.height);
		},
	
		isNaN: function() {
			return isNaN(this.width) || isNaN(this.height);
		},
	
		statics: {
			min: function(size1, size2) {
				return new Size(
					Math.min(size1.width, size2.width),
					Math.min(size1.height, size2.height));
			},
	
			max: function(size1, size2) {
				return new Size(
					Math.max(size1.width, size2.width),
					Math.max(size1.height, size2.height));
			},
	
			random: function() {
				return new Size(Math.random(), Math.random());
			}
		}
	}, Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {
		var op = Math[name];
		this[name] = function() {
			return new Size(op(this.width), op(this.height));
		};
	}, {}));
	
	var LinkedSize = Size.extend({
		initialize: function Size(width, height, owner, setter) {
			this._width = width;
			this._height = height;
			this._owner = owner;
			this._setter = setter;
		},
	
		set: function(width, height, _dontNotify) {
			this._width = width;
			this._height = height;
			if (!_dontNotify)
				this._owner[this._setter](this);
			return this;
		},
	
		getWidth: function() {
			return this._width;
		},
	
		setWidth: function(width) {
			this._width = width;
			this._owner[this._setter](this);
		},
	
		getHeight: function() {
			return this._height;
		},
	
		setHeight: function(height) {
			this._height = height;
			this._owner[this._setter](this);
		}
	});
	
	var Rectangle = Base.extend({
		_class: 'Rectangle',
		_readIndex: true,
		beans: true,
	
		initialize: function Rectangle(arg0, arg1, arg2, arg3) {
			var type = typeof arg0,
				read = 0;
			if (type === 'number') {
				this.x = arg0;
				this.y = arg1;
				this.width = arg2;
				this.height = arg3;
				read = 4;
			} else if (type === 'undefined' || arg0 === null) {
				this.x = this.y = this.width = this.height = 0;
				read = arg0 === null ? 1 : 0;
			} else if (arguments.length === 1) {
				if (Array.isArray(arg0)) {
					this.x = arg0[0];
					this.y = arg0[1];
					this.width = arg0[2];
					this.height = arg0[3];
					read = 1;
				} else if (arg0.x !== undefined || arg0.width !== undefined) {
					this.x = arg0.x || 0;
					this.y = arg0.y || 0;
					this.width = arg0.width || 0;
					this.height = arg0.height || 0;
					read = 1;
				} else if (arg0.from === undefined && arg0.to === undefined) {
					this.x = this.y = this.width = this.height = 0;
					this._set(arg0);
					read = 1;
				}
			}
			if (!read) {
				var point = Point.readNamed(arguments, 'from'),
					next = Base.peek(arguments);
				this.x = point.x;
				this.y = point.y;
				if (next && next.x !== undefined || Base.hasNamed(arguments, 'to')) {
					var to = Point.readNamed(arguments, 'to');
					this.width = to.x - point.x;
					this.height = to.y - point.y;
					if (this.width < 0) {
						this.x = to.x;
						this.width = -this.width;
					}
					if (this.height < 0) {
						this.y = to.y;
						this.height = -this.height;
					}
				} else {
					var size = Size.read(arguments);
					this.width = size.width;
					this.height = size.height;
				}
				read = arguments.__index;
			}
			if (this.__read)
				this.__read = read;
		},
	
		set: function(x, y, width, height) {
			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;
			return this;
		},
	
		clone: function() {
			return new Rectangle(this.x, this.y, this.width, this.height);
		},
	
		equals: function(rect) {
			var rt = Base.isPlainValue(rect)
					? Rectangle.read(arguments)
					: rect;
			return rt === this
					|| rt && this.x === rt.x && this.y === rt.y
						&& this.width === rt.width && this.height === rt.height
					|| false;
		},
	
		toString: function() {
			var f = Formatter.instance;
			return '{ x: ' + f.number(this.x)
					+ ', y: ' + f.number(this.y)
					+ ', width: ' + f.number(this.width)
					+ ', height: ' + f.number(this.height)
					+ ' }';
		},
	
		_serialize: function(options) {
			var f = options.formatter;
			return [f.number(this.x),
					f.number(this.y),
					f.number(this.width),
					f.number(this.height)];
		},
	
		getPoint: function(_dontLink) {
			var ctor = _dontLink ? Point : LinkedPoint;
			return new ctor(this.x, this.y, this, 'setPoint');
		},
	
		setPoint: function() {
			var point = Point.read(arguments);
			this.x = point.x;
			this.y = point.y;
		},
	
		getSize: function(_dontLink) {
			var ctor = _dontLink ? Size : LinkedSize;
			return new ctor(this.width, this.height, this, 'setSize');
		},
	
		setSize: function() {
			var size = Size.read(arguments);
			if (this._fixX)
				this.x += (this.width - size.width) * this._fixX;
			if (this._fixY)
				this.y += (this.height - size.height) * this._fixY;
			this.width = size.width;
			this.height = size.height;
			this._fixW = 1;
			this._fixH = 1;
		},
	
		getLeft: function() {
			return this.x;
		},
	
		setLeft: function(left) {
			if (!this._fixW)
				this.width -= left - this.x;
			this.x = left;
			this._fixX = 0;
		},
	
		getTop: function() {
			return this.y;
		},
	
		setTop: function(top) {
			if (!this._fixH)
				this.height -= top - this.y;
			this.y = top;
			this._fixY = 0;
		},
	
		getRight: function() {
			return this.x + this.width;
		},
	
		setRight: function(right) {
			if (this._fixX !== undefined && this._fixX !== 1)
				this._fixW = 0;
			if (this._fixW)
				this.x = right - this.width;
			else
				this.width = right - this.x;
			this._fixX = 1;
		},
	
		getBottom: function() {
			return this.y + this.height;
		},
	
		setBottom: function(bottom) {
			if (this._fixY !== undefined && this._fixY !== 1)
				this._fixH = 0;
			if (this._fixH)
				this.y = bottom - this.height;
			else
				this.height = bottom - this.y;
			this._fixY = 1;
		},
	
		getCenterX: function() {
			return this.x + this.width * 0.5;
		},
	
		setCenterX: function(x) {
			this.x = x - this.width * 0.5;
			this._fixX = 0.5;
		},
	
		getCenterY: function() {
			return this.y + this.height * 0.5;
		},
	
		setCenterY: function(y) {
			this.y = y - this.height * 0.5;
			this._fixY = 0.5;
		},
	
		getCenter: function(_dontLink) {
			var ctor = _dontLink ? Point : LinkedPoint;
			return new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');
		},
	
		setCenter: function() {
			var point = Point.read(arguments);
			this.setCenterX(point.x);
			this.setCenterY(point.y);
			return this;
		},
	
		getArea: function() {
			return this.width * this.height;
		},
	
		isEmpty: function() {
			return this.width === 0 || this.height === 0;
		},
	
		contains: function(arg) {
			return arg && arg.width !== undefined
					|| (Array.isArray(arg) ? arg : arguments).length == 4
					? this._containsRectangle(Rectangle.read(arguments))
					: this._containsPoint(Point.read(arguments));
		},
	
		_containsPoint: function(point) {
			var x = point.x,
				y = point.y;
			return x >= this.x && y >= this.y
					&& x <= this.x + this.width
					&& y <= this.y + this.height;
		},
	
		_containsRectangle: function(rect) {
			var x = rect.x,
				y = rect.y;
			return x >= this.x && y >= this.y
					&& x + rect.width <= this.x + this.width
					&& y + rect.height <= this.y + this.height;
		},
	
		intersects: function() {
			var rect = Rectangle.read(arguments);
			return rect.x + rect.width > this.x
					&& rect.y + rect.height > this.y
					&& rect.x < this.x + this.width
					&& rect.y < this.y + this.height;
		},
	
		touches: function() {
			var rect = Rectangle.read(arguments);
			return rect.x + rect.width >= this.x
					&& rect.y + rect.height >= this.y
					&& rect.x <= this.x + this.width
					&& rect.y <= this.y + this.height;
		},
	
		intersect: function() {
			var rect = Rectangle.read(arguments),
				x1 = Math.max(this.x, rect.x),
				y1 = Math.max(this.y, rect.y),
				x2 = Math.min(this.x + this.width, rect.x + rect.width),
				y2 = Math.min(this.y + this.height, rect.y + rect.height);
			return new Rectangle(x1, y1, x2 - x1, y2 - y1);
		},
	
		unite: function() {
			var rect = Rectangle.read(arguments),
				x1 = Math.min(this.x, rect.x),
				y1 = Math.min(this.y, rect.y),
				x2 = Math.max(this.x + this.width, rect.x + rect.width),
				y2 = Math.max(this.y + this.height, rect.y + rect.height);
			return new Rectangle(x1, y1, x2 - x1, y2 - y1);
		},
	
		include: function() {
			var point = Point.read(arguments);
			var x1 = Math.min(this.x, point.x),
				y1 = Math.min(this.y, point.y),
				x2 = Math.max(this.x + this.width, point.x),
				y2 = Math.max(this.y + this.height, point.y);
			return new Rectangle(x1, y1, x2 - x1, y2 - y1);
		},
	
		expand: function() {
			var amount = Size.read(arguments),
				hor = amount.width,
				ver = amount.height;
			return new Rectangle(this.x - hor / 2, this.y - ver / 2,
					this.width + hor, this.height + ver);
		},
	
		scale: function(hor, ver) {
			return this.expand(this.width * hor - this.width,
					this.height * (ver === undefined ? hor : ver) - this.height);
		}
	}, Base.each([
			['Top', 'Left'], ['Top', 'Right'],
			['Bottom', 'Left'], ['Bottom', 'Right'],
			['Left', 'Center'], ['Top', 'Center'],
			['Right', 'Center'], ['Bottom', 'Center']
		],
		function(parts, index) {
			var part = parts.join('');
			var xFirst = /^[RL]/.test(part);
			if (index >= 4)
				parts[1] += xFirst ? 'Y' : 'X';
			var x = parts[xFirst ? 0 : 1],
				y = parts[xFirst ? 1 : 0],
				getX = 'get' + x,
				getY = 'get' + y,
				setX = 'set' + x,
				setY = 'set' + y,
				get = 'get' + part,
				set = 'set' + part;
			this[get] = function(_dontLink) {
				var ctor = _dontLink ? Point : LinkedPoint;
				return new ctor(this[getX](), this[getY](), this, set);
			};
			this[set] = function() {
				var point = Point.read(arguments);
				this[setX](point.x);
				this[setY](point.y);
			};
		}, {
			beans: true
		}
	));
	
	var LinkedRectangle = Rectangle.extend({
		initialize: function Rectangle(x, y, width, height, owner, setter) {
			this.set(x, y, width, height, true);
			this._owner = owner;
			this._setter = setter;
		},
	
		set: function(x, y, width, height, _dontNotify) {
			this._x = x;
			this._y = y;
			this._width = width;
			this._height = height;
			if (!_dontNotify)
				this._owner[this._setter](this);
			return this;
		}
	}, new function() {
		var proto = Rectangle.prototype;
	
		return Base.each(['x', 'y', 'width', 'height'], function(key) {
			var part = Base.capitalize(key);
			var internal = '_' + key;
			this['get' + part] = function() {
				return this[internal];
			};
	
			this['set' + part] = function(value) {
				this[internal] = value;
				if (!this._dontNotify)
					this._owner[this._setter](this);
			};
		}, Base.each(['Point', 'Size', 'Center',
				'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY',
				'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
				'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'],
			function(key) {
				var name = 'set' + key;
				this[name] = function() {
					this._dontNotify = true;
					proto[name].apply(this, arguments);
					this._dontNotify = false;
					this._owner[this._setter](this);
				};
			}, {
				isSelected: function() {
					return this._owner._boundsSelected;
				},
	
				setSelected: function(selected) {
					var owner = this._owner;
					if (owner.setSelected) {
						owner._boundsSelected = selected;
						owner.setSelected(selected || owner._selectedSegmentState > 0);
					}
				}
			})
		);
	});
	
	var Matrix = Base.extend({
		_class: 'Matrix',
	
		initialize: function Matrix(arg) {
			var count = arguments.length,
				ok = true;
			if (count === 6) {
				this.set.apply(this, arguments);
			} else if (count === 1) {
				if (arg instanceof Matrix) {
					this.set(arg._a, arg._c, arg._b, arg._d, arg._tx, arg._ty);
				} else if (Array.isArray(arg)) {
					this.set.apply(this, arg);
				} else {
					ok = false;
				}
			} else if (count === 0) {
				this.reset();
			} else {
				ok = false;
			}
			if (!ok)
				throw new Error('Unsupported matrix parameters');
		},
	
		set: function(a, c, b, d, tx, ty, _dontNotify) {
			this._a = a;
			this._c = c;
			this._b = b;
			this._d = d;
			this._tx = tx;
			this._ty = ty;
			if (!_dontNotify)
				this._changed();
			return this;
		},
	
		_serialize: function(options) {
			return Base.serialize(this.getValues(), options);
		},
	
		_changed: function() {
			var owner = this._owner;
			if (owner) {
				if (owner._applyMatrix) {
					owner.transform(null, true);
				} else {
					owner._changed(9);
				}
			}
		},
	
		clone: function() {
			return new Matrix(this._a, this._c, this._b, this._d,
					this._tx, this._ty);
		},
	
		equals: function(mx) {
			return mx === this || mx && this._a === mx._a && this._b === mx._b
					&& this._c === mx._c && this._d === mx._d
					&& this._tx === mx._tx && this._ty === mx._ty
					|| false;
		},
	
		toString: function() {
			var f = Formatter.instance;
			return '[[' + [f.number(this._a), f.number(this._b),
						f.number(this._tx)].join(', ') + '], ['
					+ [f.number(this._c), f.number(this._d),
						f.number(this._ty)].join(', ') + ']]';
		},
	
		reset: function(_dontNotify) {
			this._a = this._d = 1;
			this._c = this._b = this._tx = this._ty = 0;
			if (!_dontNotify)
				this._changed();
			return this;
		},
	
		apply: function(recursively, _setApplyMatrix) {
			var owner = this._owner;
			if (owner) {
				owner.transform(null, true, Base.pick(recursively, true),
						_setApplyMatrix);
				return this.isIdentity();
			}
			return false;
		},
	
		translate: function() {
			var point = Point.read(arguments),
				x = point.x,
				y = point.y;
			this._tx += x * this._a + y * this._b;
			this._ty += x * this._c + y * this._d;
			this._changed();
			return this;
		},
	
		scale: function() {
			var scale = Point.read(arguments),
				center = Point.read(arguments, 0, { readNull: true });
			if (center)
				this.translate(center);
			this._a *= scale.x;
			this._c *= scale.x;
			this._b *= scale.y;
			this._d *= scale.y;
			if (center)
				this.translate(center.negate());
			this._changed();
			return this;
		},
	
		rotate: function(angle ) {
			angle *= Math.PI / 180;
			var center = Point.read(arguments, 1),
				x = center.x,
				y = center.y,
				cos = Math.cos(angle),
				sin = Math.sin(angle),
				tx = x - x * cos + y * sin,
				ty = y - x * sin - y * cos,
				a = this._a,
				b = this._b,
				c = this._c,
				d = this._d;
			this._a = cos * a + sin * b;
			this._b = -sin * a + cos * b;
			this._c = cos * c + sin * d;
			this._d = -sin * c + cos * d;
			this._tx += tx * a + ty * b;
			this._ty += tx * c + ty * d;
			this._changed();
			return this;
		},
	
		shear: function() {
			var shear = Point.read(arguments),
				center = Point.read(arguments, 0, { readNull: true });
			if (center)
				this.translate(center);
			var a = this._a,
				c = this._c;
			this._a += shear.y * this._b;
			this._c += shear.y * this._d;
			this._b += shear.x * a;
			this._d += shear.x * c;
			if (center)
				this.translate(center.negate());
			this._changed();
			return this;
		},
	
		skew: function() {
			var skew = Point.read(arguments),
				center = Point.read(arguments, 0, { readNull: true }),
				toRadians = Math.PI / 180,
				shear = new Point(Math.tan(skew.x * toRadians),
					Math.tan(skew.y * toRadians));
			return this.shear(shear, center);
		},
	
		concatenate: function(mx) {
			var a1 = this._a,
				b1 = this._b,
				c1 = this._c,
				d1 = this._d,
				a2 = mx._a,
				b2 = mx._b,
				c2 = mx._c,
				d2 = mx._d,
				tx2 = mx._tx,
				ty2 = mx._ty;
			this._a = a2 * a1 + c2 * b1;
			this._b = b2 * a1 + d2 * b1;
			this._c = a2 * c1 + c2 * d1;
			this._d = b2 * c1 + d2 * d1;
			this._tx += tx2 * a1 + ty2 * b1;
			this._ty += tx2 * c1 + ty2 * d1;
			this._changed();
			return this;
		},
	
		preConcatenate: function(mx) {
			var a1 = this._a,
				b1 = this._b,
				c1 = this._c,
				d1 = this._d,
				tx1 = this._tx,
				ty1 = this._ty,
				a2 = mx._a,
				b2 = mx._b,
				c2 = mx._c,
				d2 = mx._d,
				tx2 = mx._tx,
				ty2 = mx._ty;
			this._a = a2 * a1 + b2 * c1;
			this._b = a2 * b1 + b2 * d1;
			this._c = c2 * a1 + d2 * c1;
			this._d = c2 * b1 + d2 * d1;
			this._tx = a2 * tx1 + b2 * ty1 + tx2;
			this._ty = c2 * tx1 + d2 * ty1 + ty2;
			this._changed();
			return this;
		},
	
		chain: function(mx) {
			var a1 = this._a,
				b1 = this._b,
				c1 = this._c,
				d1 = this._d,
				tx1 = this._tx,
				ty1 = this._ty,
				a2 = mx._a,
				b2 = mx._b,
				c2 = mx._c,
				d2 = mx._d,
				tx2 = mx._tx,
				ty2 = mx._ty;
			return new Matrix(
					a2 * a1 + c2 * b1,
					a2 * c1 + c2 * d1,
					b2 * a1 + d2 * b1,
					b2 * c1 + d2 * d1,
					tx1 + tx2 * a1 + ty2 * b1,
					ty1 + tx2 * c1 + ty2 * d1);
		},
	
		isIdentity: function() {
			return this._a === 1 && this._c === 0 && this._b === 0 && this._d === 1
					&& this._tx === 0 && this._ty === 0;
		},
	
		orNullIfIdentity: function() {
			return this.isIdentity() ? null : this;
		},
	
		isInvertible: function() {
			return !!this._getDeterminant();
		},
	
		isSingular: function() {
			return !this._getDeterminant();
		},
	
		transform: function( src, dst, count) {
			return arguments.length < 3
				? this._transformPoint(Point.read(arguments))
				: this._transformCoordinates(src, dst, count);
		},
	
		_transformPoint: function(point, dest, _dontNotify) {
			var x = point.x,
				y = point.y;
			if (!dest)
				dest = new Point();
			return dest.set(
				x * this._a + y * this._b + this._tx,
				x * this._c + y * this._d + this._ty,
				_dontNotify
			);
		},
	
		_transformCoordinates: function(src, dst, count) {
			var i = 0,
				j = 0,
				max = 2 * count;
			while (i < max) {
				var x = src[i++],
					y = src[i++];
				dst[j++] = x * this._a + y * this._b + this._tx;
				dst[j++] = x * this._c + y * this._d + this._ty;
			}
			return dst;
		},
	
		_transformCorners: function(rect) {
			var x1 = rect.x,
				y1 = rect.y,
				x2 = x1 + rect.width,
				y2 = y1 + rect.height,
				coords = [ x1, y1, x2, y1, x2, y2, x1, y2 ];
			return this._transformCoordinates(coords, coords, 4);
		},
	
		_transformBounds: function(bounds, dest, _dontNotify) {
			var coords = this._transformCorners(bounds),
				min = coords.slice(0, 2),
				max = coords.slice();
			for (var i = 2; i < 8; i++) {
				var val = coords[i],
					j = i & 1;
				if (val < min[j])
					min[j] = val;
				else if (val > max[j])
					max[j] = val;
			}
			if (!dest)
				dest = new Rectangle();
			return dest.set(min[0], min[1], max[0] - min[0], max[1] - min[1],
					_dontNotify);
		},
	
		inverseTransform: function() {
			return this._inverseTransform(Point.read(arguments));
		},
	
		_getDeterminant: function() {
			var det = this._a * this._d - this._b * this._c;
			return isFinite(det) && !Numerical.isZero(det)
					&& isFinite(this._tx) && isFinite(this._ty)
					? det : null;
		},
	
		_inverseTransform: function(point, dest, _dontNotify) {
			var det = this._getDeterminant();
			if (!det)
				return null;
			var x = point.x - this._tx,
				y = point.y - this._ty;
			if (!dest)
				dest = new Point();
			return dest.set(
				(x * this._d - y * this._b) / det,
				(y * this._a - x * this._c) / det,
				_dontNotify
			);
		},
	
		decompose: function() {
			var a = this._a, b = this._b, c = this._c, d = this._d;
			if (Numerical.isZero(a * d - b * c))
				return null;
	
			var scaleX = Math.sqrt(a * a + b * b);
			a /= scaleX;
			b /= scaleX;
	
			var shear = a * c + b * d;
			c -= a * shear;
			d -= b * shear;
	
			var scaleY = Math.sqrt(c * c + d * d);
			c /= scaleY;
			d /= scaleY;
			shear /= scaleY;
	
			if (a * d < b * c) {
				a = -a;
				b = -b;
				shear = -shear;
				scaleX = -scaleX;
			}
	
			return {
				scaling: new Point(scaleX, scaleY),
				rotation: -Math.atan2(b, a) * 180 / Math.PI,
				shearing: shear
			};
		},
	
		getValues: function() {
			return [ this._a, this._c, this._b, this._d, this._tx, this._ty ];
		},
	
		getTranslation: function() {
			return new Point(this._tx, this._ty);
		},
	
		getScaling: function() {
			return (this.decompose() || {}).scaling;
		},
	
		getRotation: function() {
			return (this.decompose() || {}).rotation;
		},
	
		inverted: function() {
			var det = this._getDeterminant();
			return det && new Matrix(
					this._d / det,
					-this._c / det,
					-this._b / det,
					this._a / det,
					(this._b * this._ty - this._d * this._tx) / det,
					(this._c * this._tx - this._a * this._ty) / det);
		},
	
		shiftless: function() {
			return new Matrix(this._a, this._c, this._b, this._d, 0, 0);
		},
	
		applyToContext: function(ctx) {
			ctx.transform(this._a, this._c, this._b, this._d, this._tx, this._ty);
		}
	}, Base.each(['a', 'c', 'b', 'd', 'tx', 'ty'], function(name) {
		var part = Base.capitalize(name),
			prop = '_' + name;
		this['get' + part] = function() {
			return this[prop];
		};
		this['set' + part] = function(value) {
			this[prop] = value;
			this._changed();
		};
	}, {}));
	
	var Line = Base.extend({
		_class: 'Line',
	
		initialize: function Line(arg0, arg1, arg2, arg3, arg4) {
			var asVector = false;
			if (arguments.length >= 4) {
				this._px = arg0;
				this._py = arg1;
				this._vx = arg2;
				this._vy = arg3;
				asVector = arg4;
			} else {
				this._px = arg0.x;
				this._py = arg0.y;
				this._vx = arg1.x;
				this._vy = arg1.y;
				asVector = arg2;
			}
			if (!asVector) {
				this._vx -= this._px;
				this._vy -= this._py;
			}
		},
	
		getPoint: function() {
			return new Point(this._px, this._py);
		},
	
		getVector: function() {
			return new Point(this._vx, this._vy);
		},
	
		getLength: function() {
			return this.getVector().getLength();
		},
	
		intersect: function(line, isInfinite) {
			return Line.intersect(
					this._px, this._py, this._vx, this._vy,
					line._px, line._py, line._vx, line._vy,
					true, isInfinite);
		},
	
		getSide: function(point) {
			return Line.getSide(
					this._px, this._py, this._vx, this._vy,
					point.x, point.y, true);
		},
	
		getDistance: function(point) {
			return Math.abs(Line.getSignedDistance(
					this._px, this._py, this._vx, this._vy,
					point.x, point.y, true));
		},
	
		statics: {
			intersect: function(apx, apy, avx, avy, bpx, bpy, bvx, bvy, asVector,
					isInfinite) {
				if (!asVector) {
					avx -= apx;
					avy -= apy;
					bvx -= bpx;
					bvy -= bpy;
				}
				var cross = avx * bvy - avy * bvx;
				if (!Numerical.isZero(cross)) {
					var dx = apx - bpx,
						dy = apy - bpy,
						ta = (bvx * dy - bvy * dx) / cross,
						tb = (avx * dy - avy * dx) / cross;
					if (isInfinite || 0 <= ta && ta <= 1 && 0 <= tb && tb <= 1)
						return new Point(
									apx + ta * avx,
									apy + ta * avy);
				}
			},
	
			getSide: function(px, py, vx, vy, x, y, asVector) {
				if (!asVector) {
					vx -= px;
					vy -= py;
				}
				var v2x = x - px,
					v2y = y - py,
					ccw = v2x * vy - v2y * vx;
				if (ccw === 0) {
					ccw = v2x * vx + v2y * vy;
					if (ccw > 0) {
						v2x -= vx;
						v2y -= vy;
						ccw = v2x * vx + v2y * vy;
						if (ccw < 0)
							ccw = 0;
					}
				}
				return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;
			},
	
			getSignedDistance: function(px, py, vx, vy, x, y, asVector) {
				if (!asVector) {
					vx -= px;
					vy -= py;
				}
				return Numerical.isZero(vx)
						? vy >= 0 ? px - x : x - px
						: Numerical.isZero(vy)
							? vx >= 0 ? y - py : py - y
							: (vx * (y - py) - vy * (x - px)) / Math.sqrt(vx * vx + vy * vy);
			}
		}
	});
	
	var Project = PaperScopeItem.extend({
		_class: 'Project',
		_list: 'projects',
		_reference: 'project',
	
		initialize: function Project(element) {
			PaperScopeItem.call(this, true);
			this.layers = [];
			this._activeLayer = null;
			this.symbols = [];
			this._currentStyle = new Style(null, null, this);
			this._view = View.create(this,
					element || CanvasProvider.getCanvas(1, 1));
			this._selectedItems = {};
			this._selectedItemCount = 0;
			this._updateVersion = 0;
		},
	
		_serialize: function(options, dictionary) {
			return Base.serialize(this.layers, options, true, dictionary);
		},
	
		clear: function() {
			for (var i = this.layers.length - 1; i >= 0; i--)
				this.layers[i].remove();
			this.symbols = [];
		},
	
		isEmpty: function() {
			return this.layers.length === 0;
		},
	
		remove: function remove() {
			if (!remove.base.call(this))
				return false;
			if (this._view)
				this._view.remove();
			return true;
		},
	
		getView: function() {
			return this._view;
		},
	
		getCurrentStyle: function() {
			return this._currentStyle;
		},
	
		setCurrentStyle: function(style) {
			this._currentStyle.initialize(style);
		},
	
		getIndex: function() {
			return this._index;
		},
	
		getOptions: function() {
			return this._scope.settings;
		},
	
		getActiveLayer: function() {
			return this._activeLayer || new Layer({ project: this });
		},
	
		getSelectedItems: function() {
			var items = [];
			for (var id in this._selectedItems) {
				var item = this._selectedItems[id];
				if (item.isInserted())
					items.push(item);
			}
			return items;
		},
	
		insertChild: function(index, item, _preserve) {
			if (item instanceof Layer) {
				item._remove(false, true);
				Base.splice(this.layers, [item], index, 0);
				item._setProject(this, true);
				if (this._changes)
					item._changed(5);
				if (!this._activeLayer)
					this._activeLayer = item;
			} else if (item instanceof Item) {
				(this._activeLayer
					|| this.insertChild(index, new Layer(Item.NO_INSERT)))
						.insertChild(index, item, _preserve);
			} else {
				item = null;
			}
			return item;
		},
	
		addChild: function(item, _preserve) {
			return this.insertChild(undefined, item, _preserve);
		},
	
		_updateSelection: function(item) {
			var id = item._id,
				selectedItems = this._selectedItems;
			if (item._selected) {
				if (selectedItems[id] !== item) {
					this._selectedItemCount++;
					selectedItems[id] = item;
				}
			} else if (selectedItems[id] === item) {
				this._selectedItemCount--;
				delete selectedItems[id];
			}
		},
	
		selectAll: function() {
			var layers = this.layers;
			for (var i = 0, l = layers.length; i < l; i++)
				layers[i].setFullySelected(true);
		},
	
		deselectAll: function() {
			var selectedItems = this._selectedItems;
			for (var i in selectedItems)
				selectedItems[i].setFullySelected(false);
		},
	
		hitTest: function() {
			var point = Point.read(arguments),
				options = HitResult.getOptions(Base.read(arguments));
			for (var i = this.layers.length - 1; i >= 0; i--) {
				var res = this.layers[i]._hitTest(point, options);
				if (res) return res;
			}
			return null;
		},
	
		getItems: function(match) {
			return Item._getItems(this.layers, match);
		},
	
		getItem: function(match) {
			return Item._getItems(this.layers, match, null, null, true)[0] || null;
		},
	
		importJSON: function(json) {
			this.activate();
			var layer = this._activeLayer;
			return Base.importJSON(json, layer && layer.isEmpty() && layer);
		},
	
		draw: function(ctx, matrix, pixelRatio) {
			this._updateVersion++;
			ctx.save();
			matrix.applyToContext(ctx);
			var param = new Base({
				offset: new Point(0, 0),
				pixelRatio: pixelRatio,
				viewMatrix: matrix.isIdentity() ? null : matrix,
				matrices: [new Matrix()],
				updateMatrix: true
			});
			for (var i = 0, layers = this.layers, l = layers.length; i < l; i++)
				layers[i].draw(ctx, param);
			ctx.restore();
	
			if (this._selectedItemCount > 0) {
				ctx.save();
				ctx.strokeWidth = 1;
				var items = this._selectedItems,
					size = this._scope.settings.handleSize,
					version = this._updateVersion;
				for (var id in items)
					items[id]._drawSelection(ctx, matrix, size, items, version);
				ctx.restore();
			}
		}
	});
	
	var Symbol = Base.extend({
		_class: 'Symbol',
	
		initialize: function Symbol(item, dontCenter) {
			this._id = UID.get();
			this.project = paper.project;
			this.project.symbols.push(this);
			if (item)
				this.setDefinition(item, dontCenter);
		},
	
		_serialize: function(options, dictionary) {
			return dictionary.add(this, function() {
				return Base.serialize([this._class, this._definition],
						options, false, dictionary);
			});
		},
	
		_changed: function(flags) {
			if (flags & 8) {
				Item._clearBoundsCache(this);
			}
			if (flags & 1) {
				this.project._needsUpdate = true;
			}
		},
	
		getDefinition: function() {
			return this._definition;
		},
	
		setDefinition: function(item, _dontCenter) {
			if (item._parentSymbol)
				item = item.clone();
			if (this._definition)
				this._definition._parentSymbol = null;
			this._definition = item;
			item.remove();
			item.setSelected(false);
			if (!_dontCenter)
				item.setPosition(new Point());
			item._parentSymbol = this;
			this._changed(9);
		},
	
		place: function(position) {
			return new PlacedSymbol(this, position);
		},
	
		clone: function() {
			return new Symbol(this._definition.clone(false));
		},
	
		equals: function(symbol) {
			return symbol === this
					|| symbol && this.definition.equals(symbol.definition)
					|| false;
		}
	});
	
	var Item = Base.extend(Emitter, {
		statics: {
			extend: function extend(src) {
				if (src._serializeFields)
					src._serializeFields = new Base(
							this.prototype._serializeFields, src._serializeFields);
				return extend.base.apply(this, arguments);
			},
	
			NO_INSERT: { insert: false }
		},
	
		_class: 'Item',
		_applyMatrix: true,
		_canApplyMatrix: true,
		_boundsSelected: false,
		_selectChildren: false,
		_serializeFields: {
			name: null,
			applyMatrix: null,
			matrix: new Matrix(),
			pivot: null,
			locked: false,
			visible: true,
			blendMode: 'normal',
			opacity: 1,
			guide: false,
			selected: false,
			clipMask: false,
			data: {}
		},
	
		initialize: function Item() {
		},
	
		_initialize: function(props, point) {
			var hasProps = props && Base.isPlainObject(props),
				internal = hasProps && props.internal === true,
				matrix = this._matrix = new Matrix(),
				project = hasProps && props.project || paper.project;
			if (!internal)
				this._id = UID.get();
			this._applyMatrix = this._canApplyMatrix && paper.settings.applyMatrix;
			if (point)
				matrix.translate(point);
			matrix._owner = this;
			this._style = new Style(project._currentStyle, this, project);
			if (!this._project) {
				if (internal || hasProps && props.insert === false) {
					this._setProject(project);
				} else if (hasProps && props.parent) {
					this.setParent(props.parent);
				} else {
					(project._activeLayer || new Layer()).addChild(this);
				}
			}
			if (hasProps && props !== Item.NO_INSERT)
				this._set(props, { insert: true, project: true, parent: true },
						true);
			return hasProps;
		},
	
		_events: new function() {
	
			var mouseFlags = {
				mousedown: {
					mousedown: 1,
					mousedrag: 1,
					click: 1,
					doubleclick: 1
				},
				mouseup: {
					mouseup: 1,
					mousedrag: 1,
					click: 1,
					doubleclick: 1
				},
				mousemove: {
					mousedrag: 1,
					mousemove: 1,
					mouseenter: 1,
					mouseleave: 1
				}
			};
	
			var mouseEvent = {
				install: function(type) {
					var counters = this.getView()._eventCounters;
					if (counters) {
						for (var key in mouseFlags) {
							counters[key] = (counters[key] || 0)
									+ (mouseFlags[key][type] || 0);
						}
					}
				},
				uninstall: function(type) {
					var counters = this.getView()._eventCounters;
					if (counters) {
						for (var key in mouseFlags)
							counters[key] -= mouseFlags[key][type] || 0;
					}
				}
			};
	
			return Base.each(['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick',
				'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'],
				function(name) {
					this[name] = mouseEvent;
				}, {
					onFrame: {
						install: function() {
							this._animateItem(true);
						},
						uninstall: function() {
							this._animateItem(false);
						}
					},
	
					onLoad: {}
				}
			);
		},
	
		_animateItem: function(animate) {
			this.getView()._animateItem(this, animate);
		},
	
		_serialize: function(options, dictionary) {
			var props = {},
				that = this;
	
			function serialize(fields) {
				for (var key in fields) {
					var value = that[key];
					if (!Base.equals(value, key === 'leading'
							? fields.fontSize * 1.2 : fields[key])) {
						props[key] = Base.serialize(value, options,
								key !== 'data', dictionary);
					}
				}
			}
	
			serialize(this._serializeFields);
			if (!(this instanceof Group))
				serialize(this._style._defaults);
			return [ this._class, props ];
		},
	
		_changed: function(flags) {
			var symbol = this._parentSymbol,
				cacheParent = this._parent || symbol,
				project = this._project;
			if (flags & 8) {
				this._bounds = this._position = this._decomposed =
						this._globalMatrix = this._currentPath = undefined;
			}
			if (cacheParent
					&& (flags & 40)) {
				Item._clearBoundsCache(cacheParent);
			}
			if (flags & 2) {
				Item._clearBoundsCache(this);
			}
			if (project) {
				if (flags & 1) {
					project._needsUpdate = true;
				}
				if (project._changes) {
					var entry = project._changesById[this._id];
					if (entry) {
						entry.flags |= flags;
					} else {
						entry = { item: this, flags: flags };
						project._changesById[this._id] = entry;
						project._changes.push(entry);
					}
				}
			}
			if (symbol)
				symbol._changed(flags);
		},
	
		set: function(props) {
			if (props)
				this._set(props);
			return this;
		},
	
		getId: function() {
			return this._id;
		},
	
		getName: function() {
			return this._name;
		},
	
		setName: function(name, unique) {
	
			if (this._name)
				this._removeNamed();
			if (name === (+name) + '')
				throw new Error(
						'Names consisting only of numbers are not supported.');
			var parent = this._parent;
			if (name && parent) {
				var children = parent._children,
					namedChildren = parent._namedChildren,
					orig = name,
					i = 1;
				while (unique && children[name])
					name = orig + ' ' + (i++);
				(namedChildren[name] = namedChildren[name] || []).push(this);
				children[name] = this;
			}
			this._name = name || undefined;
			this._changed(128);
		},
	
		getStyle: function() {
			return this._style;
		},
	
		setStyle: function(style) {
			this.getStyle().set(style);
		}
	}, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'],
		function(name) {
			var part = Base.capitalize(name),
				name = '_' + name;
			this['get' + part] = function() {
				return this[name];
			};
			this['set' + part] = function(value) {
				if (value != this[name]) {
					this[name] = value;
					this._changed(name === '_locked'
							? 128 : 129);
				}
			};
		},
	{}), {
		beans: true,
	
		_locked: false,
	
		_visible: true,
	
		_blendMode: 'normal',
	
		_opacity: 1,
	
		_guide: false,
	
		isSelected: function() {
			if (this._selectChildren) {
				var children = this._children;
				for (var i = 0, l = children.length; i < l; i++)
					if (children[i].isSelected())
						return true;
			}
			return this._selected;
		},
	
		setSelected: function(selected, noChildren) {
			if (!noChildren && this._selectChildren) {
				var children = this._children;
				for (var i = 0, l = children.length; i < l; i++)
					children[i].setSelected(selected);
			}
			if ((selected = !!selected) ^ this._selected) {
				this._selected = selected;
				this._project._updateSelection(this);
				this._changed(129);
			}
		},
	
		_selected: false,
	
		isFullySelected: function() {
			var children = this._children;
			if (children && this._selected) {
				for (var i = 0, l = children.length; i < l; i++)
					if (!children[i].isFullySelected())
						return false;
				return true;
			}
			return this._selected;
		},
	
		setFullySelected: function(selected) {
			var children = this._children;
			if (children) {
				for (var i = 0, l = children.length; i < l; i++)
					children[i].setFullySelected(selected);
			}
			this.setSelected(selected, true);
		},
	
		isClipMask: function() {
			return this._clipMask;
		},
	
		setClipMask: function(clipMask) {
			if (this._clipMask != (clipMask = !!clipMask)) {
				this._clipMask = clipMask;
				if (clipMask) {
					this.setFillColor(null);
					this.setStrokeColor(null);
				}
				this._changed(129);
				if (this._parent)
					this._parent._changed(1024);
			}
		},
	
		_clipMask: false,
	
		getData: function() {
			if (!this._data)
				this._data = {};
			return this._data;
		},
	
		setData: function(data) {
			this._data = data;
		},
	
		getPosition: function(_dontLink) {
			var position = this._position,
				ctor = _dontLink ? Point : LinkedPoint;
			if (!position) {
				var pivot = this._pivot;
				position = this._position = pivot
						? this._matrix._transformPoint(pivot)
						: this.getBounds().getCenter(true);
			}
			return new ctor(position.x, position.y, this, 'setPosition');
		},
	
		setPosition: function() {
			this.translate(Point.read(arguments).subtract(this.getPosition(true)));
		},
	
		getPivot: function(_dontLink) {
			var pivot = this._pivot;
			if (pivot) {
				var ctor = _dontLink ? Point : LinkedPoint;
				pivot = new ctor(pivot.x, pivot.y, this, 'setPivot');
			}
			return pivot;
		},
	
		setPivot: function() {
			this._pivot = Point.read(arguments, 0, { clone: true, readNull: true });
			this._position = undefined;
		},
	
		_pivot: null,
	}, Base.each(['bounds', 'strokeBounds', 'handleBounds', 'roughBounds',
			'internalBounds', 'internalRoughBounds'],
		function(key) {
			var getter = 'get' + Base.capitalize(key),
				match = key.match(/^internal(.*)$/),
				internalGetter = match ? 'get' + match[1] : null;
			this[getter] = function(_matrix) {
				var boundsGetter = this._boundsGetter,
					name = !internalGetter && (typeof boundsGetter === 'string'
							? boundsGetter : boundsGetter && boundsGetter[getter])
							|| getter,
					bounds = this._getCachedBounds(name, _matrix, this,
							internalGetter);
				return key === 'bounds'
						? new LinkedRectangle(bounds.x, bounds.y, bounds.width,
								bounds.height, this, 'setBounds')
						: bounds;
			};
		},
	{
		beans: true,
	
		_getBounds: function(getter, matrix, cacheItem) {
			var children = this._children;
			if (!children || children.length == 0)
				return new Rectangle();
			Item._updateBoundsCache(this, cacheItem);
			var x1 = Infinity,
				x2 = -x1,
				y1 = x1,
				y2 = x2;
			for (var i = 0, l = children.length; i < l; i++) {
				var child = children[i];
				if (child._visible && !child.isEmpty()) {
					var rect = child._getCachedBounds(getter,
							matrix && matrix.chain(child._matrix), cacheItem);
					x1 = Math.min(rect.x, x1);
					y1 = Math.min(rect.y, y1);
					x2 = Math.max(rect.x + rect.width, x2);
					y2 = Math.max(rect.y + rect.height, y2);
				}
			}
			return isFinite(x1)
					? new Rectangle(x1, y1, x2 - x1, y2 - y1)
					: new Rectangle();
		},
	
		setBounds: function() {
			var rect = Rectangle.read(arguments),
				bounds = this.getBounds(),
				matrix = new Matrix(),
				center = rect.getCenter();
			matrix.translate(center);
			if (rect.width != bounds.width || rect.height != bounds.height) {
				matrix.scale(
						bounds.width != 0 ? rect.width / bounds.width : 1,
						bounds.height != 0 ? rect.height / bounds.height : 1);
			}
			center = bounds.getCenter();
			matrix.translate(-center.x, -center.y);
			this.transform(matrix);
		},
	
		_getCachedBounds: function(getter, matrix, cacheItem, internalGetter) {
			matrix = matrix && matrix.orNullIfIdentity();
			var _matrix = internalGetter ? null : this._matrix.orNullIfIdentity(),
				cache = (!matrix || matrix.equals(_matrix)) && getter;
			Item._updateBoundsCache(this._parent || this._parentSymbol, cacheItem);
			if (cache && this._bounds && this._bounds[cache])
				return this._bounds[cache].clone();
			var bounds = this._getBounds(internalGetter || getter,
					matrix || _matrix, cacheItem);
			if (cache) {
				if (!this._bounds)
					this._bounds = {};
				var cached = this._bounds[cache] = bounds.clone();
				cached._internal = !!internalGetter;
			}
			return bounds;
		},
	
		statics: {
			_updateBoundsCache: function(parent, item) {
				if (parent) {
					var id = item._id,
						ref = parent._boundsCache = parent._boundsCache || {
							ids: {},
							list: []
						};
					if (!ref.ids[id]) {
						ref.list.push(item);
						ref.ids[id] = item;
					}
				}
			},
	
			_clearBoundsCache: function(item) {
				var cache = item._boundsCache;
				if (cache) {
					item._bounds = item._position = item._boundsCache = undefined;
					for (var i = 0, list = cache.list, l = list.length; i < l; i++){
						var other = list[i];
						if (other !== item) {
							other._bounds = other._position = undefined;
							if (other._boundsCache)
								Item._clearBoundsCache(other);
						}
					}
				}
			}
		}
	
	}), {
		beans: true,
	
		_decompose: function() {
			return this._decomposed = this._matrix.decompose();
		},
	
		getRotation: function() {
			var decomposed = this._decomposed || this._decompose();
			return decomposed && decomposed.rotation;
		},
	
		setRotation: function(rotation) {
			var current = this.getRotation();
			if (current != null && rotation != null) {
				var decomposed = this._decomposed;
				this.rotate(rotation - current);
				decomposed.rotation = rotation;
				this._decomposed = decomposed;
			}
		},
	
		getScaling: function(_dontLink) {
			var decomposed = this._decomposed || this._decompose(),
				scaling = decomposed && decomposed.scaling,
				ctor = _dontLink ? Point : LinkedPoint;
			return scaling && new ctor(scaling.x, scaling.y, this, 'setScaling');
		},
	
		setScaling: function() {
			var current = this.getScaling();
			if (current) {
				var scaling = Point.read(arguments, 0, { clone: true }),
					decomposed = this._decomposed;
				this.scale(scaling.x / current.x, scaling.y / current.y);
				decomposed.scaling = scaling;
				this._decomposed = decomposed;
			}
		},
	
		getMatrix: function() {
			return this._matrix;
		},
	
		setMatrix: function() {
			var matrix = this._matrix;
			matrix.initialize.apply(matrix, arguments);
			if (this._applyMatrix) {
				this.transform(null, true);
			} else {
				this._changed(9);
			}
		},
	
		getGlobalMatrix: function(_dontClone) {
			var matrix = this._globalMatrix,
				updateVersion = this._project._updateVersion;
			if (matrix && matrix._updateVersion !== updateVersion)
				matrix = null;
			if (!matrix) {
				matrix = this._globalMatrix = this._matrix.clone();
				var parent = this._parent;
				if (parent)
					matrix.preConcatenate(parent.getGlobalMatrix(true));
				matrix._updateVersion = updateVersion;
			}
			return _dontClone ? matrix : matrix.clone();
		},
	
		getApplyMatrix: function() {
			return this._applyMatrix;
		},
	
		setApplyMatrix: function(apply) {
			if (this._applyMatrix = this._canApplyMatrix && !!apply)
				this.transform(null, true);
		},
	
		getTransformContent: '#getApplyMatrix',
		setTransformContent: '#setApplyMatrix',
	}, {
		getProject: function() {
			return this._project;
		},
	
		_setProject: function(project, installEvents) {
			if (this._project !== project) {
				if (this._project)
					this._installEvents(false);
				this._project = project;
				var children = this._children;
				for (var i = 0, l = children && children.length; i < l; i++)
					children[i]._setProject(project);
				installEvents = true;
			}
			if (installEvents)
				this._installEvents(true);
		},
	
		getView: function() {
			return this._project.getView();
		},
	
		_installEvents: function _installEvents(install) {
			_installEvents.base.call(this, install);
			var children = this._children;
			for (var i = 0, l = children && children.length; i < l; i++)
				children[i]._installEvents(install);
		},
	
		getLayer: function() {
			var parent = this;
			while (parent = parent._parent) {
				if (parent instanceof Layer)
					return parent;
			}
			return null;
		},
	
		getParent: function() {
			return this._parent;
		},
	
		setParent: function(item) {
			return item.addChild(this);
		},
	
		getChildren: function() {
			return this._children;
		},
	
		setChildren: function(items) {
			this.removeChildren();
			this.addChildren(items);
		},
	
		getFirstChild: function() {
			return this._children && this._children[0] || null;
		},
	
		getLastChild: function() {
			return this._children && this._children[this._children.length - 1]
					|| null;
		},
	
		getNextSibling: function() {
			return this._parent && this._parent._children[this._index + 1] || null;
		},
	
		getPreviousSibling: function() {
			return this._parent && this._parent._children[this._index - 1] || null;
		},
	
		getIndex: function() {
			return this._index;
		},
	
		equals: function(item) {
			return item === this || item && this._class === item._class
					&& this._style.equals(item._style)
					&& this._matrix.equals(item._matrix)
					&& this._locked === item._locked
					&& this._visible === item._visible
					&& this._blendMode === item._blendMode
					&& this._opacity === item._opacity
					&& this._clipMask === item._clipMask
					&& this._guide === item._guide
					&& this._equals(item)
					|| false;
		},
	
		_equals: function(item) {
			return Base.equals(this._children, item._children);
		},
	
		clone: function(insert) {
			return this._clone(new this.constructor(Item.NO_INSERT), insert);
		},
	
		_clone: function(copy, insert, includeMatrix) {
			var keys = ['_locked', '_visible', '_blendMode', '_opacity',
					'_clipMask', '_guide'],
				children = this._children;
			copy.setStyle(this._style);
			for (var i = 0, l = children && children.length; i < l; i++) {
				copy.addChild(children[i].clone(false), true);
			}
			for (var i = 0, l = keys.length; i < l; i++) {
				var key = keys[i];
				if (this.hasOwnProperty(key))
					copy[key] = this[key];
			}
			if (includeMatrix !== false)
				copy._matrix.initialize(this._matrix);
			copy.setApplyMatrix(this._applyMatrix);
			copy.setPivot(this._pivot);
			copy.setSelected(this._selected);
			copy._data = this._data ? Base.clone(this._data) : null;
			if (insert || insert === undefined)
				copy.insertAbove(this);
			if (this._name)
				copy.setName(this._name, true);
			return copy;
		},
	
		copyTo: function(itemOrProject) {
			return itemOrProject.addChild(this.clone(false));
		},
	
		rasterize: function(resolution) {
			var bounds = this.getStrokeBounds(),
				scale = (resolution || this.getView().getResolution()) / 72,
				topLeft = bounds.getTopLeft().floor(),
				bottomRight = bounds.getBottomRight().ceil(),
				size = new Size(bottomRight.subtract(topLeft)),
				canvas = CanvasProvider.getCanvas(size.multiply(scale)),
				ctx = canvas.getContext('2d'),
				matrix = new Matrix().scale(scale).translate(topLeft.negate());
			ctx.save();
			matrix.applyToContext(ctx);
			this.draw(ctx, new Base({ matrices: [matrix] }));
			ctx.restore();
			var raster = new Raster(Item.NO_INSERT);
			raster.setCanvas(canvas);
			raster.transform(new Matrix().translate(topLeft.add(size.divide(2)))
					.scale(1 / scale));
			raster.insertAbove(this);
			return raster;
		},
	
		contains: function() {
			return !!this._contains(
					this._matrix._inverseTransform(Point.read(arguments)));
		},
	
		_contains: function(point) {
			if (this._children) {
				for (var i = this._children.length - 1; i >= 0; i--) {
					if (this._children[i].contains(point))
						return true;
				}
				return false;
			}
			return point.isInside(this.getInternalBounds());
		},
	
		isInside: function() {
			return Rectangle.read(arguments).contains(this.getBounds());
		},
	
		_asPathItem: function() {
			return new Path.Rectangle({
				rectangle: this.getInternalBounds(),
				matrix: this._matrix,
				insert: false,
			});
		},
	
		intersects: function(item, _matrix) {
			if (!(item instanceof Item))
				return false;
			return this._asPathItem().getIntersections(item._asPathItem(),
					_matrix || item._matrix).length > 0;
		},
	
		hitTest: function() {
			return this._hitTest(
					Point.read(arguments),
					HitResult.getOptions(Base.read(arguments)));
		},
	
		_hitTest: function(point, options) {
			if (this._locked || !this._visible || this._guide && !options.guides
					|| this.isEmpty())
				return null;
	
			var matrix = this._matrix,
				parentTotalMatrix = options._totalMatrix,
				view = this.getView(),
				totalMatrix = options._totalMatrix = parentTotalMatrix
						? parentTotalMatrix.chain(matrix)
						: this.getGlobalMatrix().preConcatenate(view._matrix),
				tolerancePadding = options._tolerancePadding = new Size(
							Path._getPenPadding(1, totalMatrix.inverted())
						).multiply(
							Math.max(options.tolerance, 0.000001)
						);
			point = matrix._inverseTransform(point);
	
			if (!this._children && !this.getInternalRoughBounds()
					.expand(tolerancePadding.multiply(2))._containsPoint(point))
				return null;
			var checkSelf = !(options.guides && !this._guide
					|| options.selected && !this._selected
					|| options.type && options.type !== Base.hyphenate(this._class)
					|| options.class && !(this instanceof options.class)),
				that = this,
				res;
	
			function checkBounds(type, part) {
				var pt = bounds['get' + part]();
				if (point.subtract(pt).divide(tolerancePadding).length <= 1)
					return new HitResult(type, that,
							{ name: Base.hyphenate(part), point: pt });
			}
	
			if (checkSelf && (options.center || options.bounds) && this._parent) {
				var bounds = this.getInternalBounds();
				if (options.center)
					res = checkBounds('center', 'Center');
				if (!res && options.bounds) {
					var points = [
						'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
						'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'
					];
					for (var i = 0; i < 8 && !res; i++)
						res = checkBounds('bounds', points[i]);
				}
			}
	
			var children = !res && this._children;
			if (children) {
				var opts = this._getChildHitTestOptions(options);
				for (var i = children.length - 1; i >= 0 && !res; i--)
					res = children[i]._hitTest(point, opts);
			}
			if (!res && checkSelf)
				res = this._hitTestSelf(point, options);
			if (res && res.point)
				res.point = matrix.transform(res.point);
			options._totalMatrix = parentTotalMatrix;
			return res;
		},
	
		_getChildHitTestOptions: function(options) {
			return options;
		},
	
		_hitTestSelf: function(point, options) {
			if (options.fill && this.hasFill() && this._contains(point))
				return new HitResult('fill', this);
		},
	
		matches: function(name, compare) {
			function matchObject(obj1, obj2) {
				for (var i in obj1) {
					if (obj1.hasOwnProperty(i)) {
						var val1 = obj1[i],
							val2 = obj2[i];
						if (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {
							if (!matchObject(val1, val2))
								return false;
						} else if (!Base.equals(val1, val2)) {
							return false;
						}
					}
				}
				return true;
			}
			var type = typeof name;
			if (type === 'object') {
				for (var key in name) {
					if (name.hasOwnProperty(key) && !this.matches(key, name[key]))
						return false;
				}
			} else if (type === 'function') {
				return name(this);
			} else {
				var value = /^(empty|editable)$/.test(name)
						? this['is' + Base.capitalize(name)]()
						: name === 'type'
							? Base.hyphenate(this._class)
							: this[name];
				if (/^(constructor|class)$/.test(name)) {
					if (!(this instanceof compare))
						return false;
				} else if (compare instanceof RegExp) {
					if (!compare.test(value))
						return false;
				} else if (typeof compare === 'function') {
					if (!compare(value))
						return false;
				} else if (Base.isPlainObject(compare)) {
					if (!matchObject(compare, value))
						return false;
				} else if (!Base.equals(value, compare)) {
					return false;
				}
			}
			return true;
		},
	
		getItems: function(match) {
			return Item._getItems(this._children, match, this._matrix);
		},
	
		getItem: function(match) {
			return Item._getItems(this._children, match, this._matrix, null, true)
					[0] || null;
		},
	
		statics: {
			_getItems: function _getItems(children, match, matrix, param,
					firstOnly) {
				if (!param && typeof match === 'object') {
					var overlapping = match.overlapping,
						inside = match.inside,
						bounds = overlapping || inside,
						rect =	bounds && Rectangle.read([bounds]);
					param = {
						items: [],
						inside: !!inside,
						overlapping: !!overlapping,
						rect: rect,
						path: overlapping && new Path.Rectangle({
							rectangle: rect,
							insert: false
						})
					};
					if (bounds)
						match = Base.set({}, match,
								{ inside: true, overlapping: true });
				}
				var items = param && param.items,
					rect = param && param.rect;
				matrix = rect && (matrix || new Matrix());
				for (var i = 0, l = children && children.length; i < l; i++) {
					var child = children[i],
						childMatrix = matrix && matrix.chain(child._matrix),
						add = true;
					if (rect) {
						var bounds = child.getBounds(childMatrix);
						if (!rect.intersects(bounds))
							continue;
						if (!(param.inside && rect.contains(bounds))
								&& !(param.overlapping && (bounds.contains(rect)
									|| param.path.intersects(child, childMatrix))))
							add = false;
					}
					if (add && child.matches(match)) {
						items.push(child);
						if (firstOnly)
							break;
					}
					_getItems(child._children, match,
							childMatrix, param,
							firstOnly);
					if (firstOnly && items.length > 0)
						break;
				}
				return items;
			}
		}
	}, {
	
		importJSON: function(json) {
			var res = Base.importJSON(json, this);
			return res !== this
					? this.addChild(res)
					: res;
		},
	
		addChild: function(item, _preserve) {
			return this.insertChild(undefined, item, _preserve);
		},
	
		insertChild: function(index, item, _preserve) {
			var res = item ? this.insertChildren(index, [item], _preserve) : null;
			return res && res[0];
		},
	
		addChildren: function(items, _preserve) {
			return this.insertChildren(this._children.length, items, _preserve);
		},
	
		insertChildren: function(index, items, _preserve, _proto) {
			var children = this._children;
			if (children && items && items.length > 0) {
				items = Array.prototype.slice.apply(items);
				for (var i = items.length - 1; i >= 0; i--) {
					var item = items[i];
					if (_proto && !(item instanceof _proto)) {
						items.splice(i, 1);
					} else {
						var shift = item._parent === this && item._index < index;
						if (item._remove(false, true) && shift)
							index--;
					}
				}
				Base.splice(children, items, index, 0);
				var project = this._project,
					notifySelf = project && project._changes;
				for (var i = 0, l = items.length; i < l; i++) {
					var item = items[i];
					item._parent = this;
					item._setProject(this._project, true);
					if (item._name)
						item.setName(item._name);
					if (notifySelf)
						this._changed(5);
				}
				this._changed(11);
			} else {
				items = null;
			}
			return items;
		},
	
		_insertSibling: function(index, item, _preserve) {
			return this._parent
					? this._parent.insertChild(index, item, _preserve)
					: null;
		},
	
		insertAbove: function(item, _preserve) {
			return item._insertSibling(item._index + 1, this, _preserve);
		},
	
		insertBelow: function(item, _preserve) {
			return item._insertSibling(item._index, this, _preserve);
		},
	
		sendToBack: function() {
			return (this._parent || this instanceof Layer && this._project)
					.insertChild(0, this);
		},
	
		bringToFront: function() {
			return (this._parent || this instanceof Layer && this._project)
					.addChild(this);
		},
	
		appendTop: '#addChild',
	
		appendBottom: function(item) {
			return this.insertChild(0, item);
		},
	
		moveAbove: '#insertAbove',
	
		moveBelow: '#insertBelow',
	
		reduce: function() {
			if (this._children && this._children.length === 1) {
				var child = this._children[0].reduce();
				child.insertAbove(this);
				child.setStyle(this._style);
				this.remove();
				return child;
			}
			return this;
		},
	
		_removeNamed: function() {
			var parent = this._parent;
			if (parent) {
				var children = parent._children,
					namedChildren = parent._namedChildren,
					name = this._name,
					namedArray = namedChildren[name],
					index = namedArray ? namedArray.indexOf(this) : -1;
				if (index !== -1) {
					if (children[name] == this)
						delete children[name];
					namedArray.splice(index, 1);
					if (namedArray.length) {
						children[name] = namedArray[namedArray.length - 1];
					} else {
						delete namedChildren[name];
					}
				}
			}
		},
	
		_remove: function(notifySelf, notifyParent) {
			var parent = this._parent;
			if (parent) {
				if (this._name)
					this._removeNamed();
				if (this._index != null)
					Base.splice(parent._children, null, this._index, 1);
				this._installEvents(false);
				if (notifySelf) {
					var project = this._project;
					if (project && project._changes)
						this._changed(5);
				}
				if (notifyParent)
					parent._changed(11);
				this._parent = null;
				return true;
			}
			return false;
		},
	
		remove: function() {
			return this._remove(true, true);
		},
	
		replaceWith: function(item) {
			var ok = item && item.insertBelow(this);
			if (ok)
				this.remove();
			return ok;
		},
	
		removeChildren: function(from, to) {
			if (!this._children)
				return null;
			from = from || 0;
			to = Base.pick(to, this._children.length);
			var removed = Base.splice(this._children, null, from, to - from);
			for (var i = removed.length - 1; i >= 0; i--) {
				removed[i]._remove(true, false);
			}
			if (removed.length > 0)
				this._changed(11);
			return removed;
		},
	
		clear: '#removeChildren',
	
		reverseChildren: function() {
			if (this._children) {
				this._children.reverse();
				for (var i = 0, l = this._children.length; i < l; i++)
					this._children[i]._index = i;
				this._changed(11);
			}
		},
	
		isEmpty: function() {
			return !this._children || this._children.length === 0;
		},
	
		isEditable: function() {
			var item = this;
			while (item) {
				if (!item._visible || item._locked)
					return false;
				item = item._parent;
			}
			return true;
		},
	
		hasFill: function() {
			return this.getStyle().hasFill();
		},
	
		hasStroke: function() {
			return this.getStyle().hasStroke();
		},
	
		hasShadow: function() {
			return this.getStyle().hasShadow();
		},
	
		_getOrder: function(item) {
			function getList(item) {
				var list = [];
				do {
					list.unshift(item);
				} while (item = item._parent);
				return list;
			}
			var list1 = getList(this),
				list2 = getList(item);
			for (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {
				if (list1[i] != list2[i]) {
					return list1[i]._index < list2[i]._index ? 1 : -1;
				}
			}
			return 0;
		},
	
		hasChildren: function() {
			return this._children && this._children.length > 0;
		},
	
		isInserted: function() {
			return this._parent ? this._parent.isInserted() : false;
		},
	
		isAbove: function(item) {
			return this._getOrder(item) === -1;
		},
	
		isBelow: function(item) {
			return this._getOrder(item) === 1;
		},
	
		isParent: function(item) {
			return this._parent === item;
		},
	
		isChild: function(item) {
			return item && item._parent === this;
		},
	
		isDescendant: function(item) {
			var parent = this;
			while (parent = parent._parent) {
				if (parent == item)
					return true;
			}
			return false;
		},
	
		isAncestor: function(item) {
			return item ? item.isDescendant(this) : false;
		},
	
		isGroupedWith: function(item) {
			var parent = this._parent;
			while (parent) {
				if (parent._parent
					&& /^(Group|Layer|CompoundPath)$/.test(parent._class)
					&& item.isDescendant(parent))
						return true;
				parent = parent._parent;
			}
			return false;
		},
	
		translate: function() {
			var mx = new Matrix();
			return this.transform(mx.translate.apply(mx, arguments));
		},
	
		rotate: function(angle ) {
			return this.transform(new Matrix().rotate(angle,
					Point.read(arguments, 1, { readNull: true })
						|| this.getPosition(true)));
		}
	}, Base.each(['scale', 'shear', 'skew'], function(name) {
		this[name] = function() {
			var point = Point.read(arguments),
				center = Point.read(arguments, 0, { readNull: true });
			return this.transform(new Matrix()[name](point,
					center || this.getPosition(true)));
		};
	}, {
	
	}), {
		transform: function(matrix, _applyMatrix, _applyRecursively,
				_setApplyMatrix) {
			if (matrix && matrix.isIdentity())
				matrix = null;
			var _matrix = this._matrix,
				applyMatrix = (_applyMatrix || this._applyMatrix)
						&& ((!_matrix.isIdentity() || matrix)
							|| _applyMatrix && _applyRecursively && this._children);
			if (!matrix && !applyMatrix)
				return this;
			if (matrix)
				_matrix.preConcatenate(matrix);
			if (applyMatrix = applyMatrix && this._transformContent(_matrix,
						_applyRecursively, _setApplyMatrix)) {
				var pivot = this._pivot,
					style = this._style,
					fillColor = style.getFillColor(true),
					strokeColor = style.getStrokeColor(true);
				if (pivot)
					_matrix._transformPoint(pivot, pivot, true);
				if (fillColor)
					fillColor.transform(_matrix);
				if (strokeColor)
					strokeColor.transform(_matrix);
				_matrix.reset(true);
				if (_setApplyMatrix && this._canApplyMatrix)
					this._applyMatrix = true;
			}
			var bounds = this._bounds,
				position = this._position;
			this._changed(9);
			var decomp = bounds && matrix && matrix.decompose();
			if (decomp && !decomp.shearing && decomp.rotation % 90 === 0) {
				for (var key in bounds) {
					var rect = bounds[key];
					if (applyMatrix || !rect._internal)
						matrix._transformBounds(rect, rect);
				}
				var getter = this._boundsGetter,
					rect = bounds[getter && getter.getBounds || getter || 'getBounds'];
				if (rect)
					this._position = rect.getCenter(true);
				this._bounds = bounds;
			} else if (matrix && position) {
				this._position = matrix._transformPoint(position, position);
			}
			return this;
		},
	
		_transformContent: function(matrix, applyRecursively, setApplyMatrix) {
			var children = this._children;
			if (children) {
				for (var i = 0, l = children.length; i < l; i++)
					children[i].transform(matrix, true, applyRecursively,
							setApplyMatrix);
				return true;
			}
		},
	
		globalToLocal: function() {
			return this.getGlobalMatrix(true)._inverseTransform(
					Point.read(arguments));
		},
	
		localToGlobal: function() {
			return this.getGlobalMatrix(true)._transformPoint(
					Point.read(arguments));
		},
	
		parentToLocal: function() {
			return this._matrix._inverseTransform(Point.read(arguments));
		},
	
		localToParent: function() {
			return this._matrix._transformPoint(Point.read(arguments));
		},
	
		fitBounds: function(rectangle, fill) {
			rectangle = Rectangle.read(arguments);
			var bounds = this.getBounds(),
				itemRatio = bounds.height / bounds.width,
				rectRatio = rectangle.height / rectangle.width,
				scale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio)
						? rectangle.width / bounds.width
						: rectangle.height / bounds.height,
				newBounds = new Rectangle(new Point(),
						new Size(bounds.width * scale, bounds.height * scale));
			newBounds.setCenter(rectangle.getCenter());
			this.setBounds(newBounds);
		},
	
		_setStyles: function(ctx) {
			var style = this._style,
				fillColor = style.getFillColor(),
				strokeColor = style.getStrokeColor(),
				shadowColor = style.getShadowColor();
			if (fillColor)
				ctx.fillStyle = fillColor.toCanvasStyle(ctx);
			if (strokeColor) {
				var strokeWidth = style.getStrokeWidth();
				if (strokeWidth > 0) {
					ctx.strokeStyle = strokeColor.toCanvasStyle(ctx);
					ctx.lineWidth = strokeWidth;
					var strokeJoin = style.getStrokeJoin(),
						strokeCap = style.getStrokeCap(),
						miterLimit = style.getMiterLimit();
					if (strokeJoin)
						ctx.lineJoin = strokeJoin;
					if (strokeCap)
						ctx.lineCap = strokeCap;
					if (miterLimit)
						ctx.miterLimit = miterLimit;
					if (paper.support.nativeDash) {
						var dashArray = style.getDashArray(),
							dashOffset = style.getDashOffset();
						if (dashArray && dashArray.length) {
							if ('setLineDash' in ctx) {
								ctx.setLineDash(dashArray);
								ctx.lineDashOffset = dashOffset;
							} else {
								ctx.mozDash = dashArray;
								ctx.mozDashOffset = dashOffset;
							}
						}
					}
				}
			}
			if (shadowColor) {
				var shadowBlur = style.getShadowBlur();
				if (shadowBlur > 0) {
					ctx.shadowColor = shadowColor.toCanvasStyle(ctx);
					ctx.shadowBlur = shadowBlur;
					var offset = this.getShadowOffset();
					ctx.shadowOffsetX = offset.x;
					ctx.shadowOffsetY = offset.y;
				}
			}
		},
	
		draw: function(ctx, param, parentStrokeMatrix) {
			var updateVersion = this._updateVersion = this._project._updateVersion;
			if (!this._visible || this._opacity === 0)
				return;
			var matrices = param.matrices,
				viewMatrix = param.viewMatrix,
				matrix = this._matrix,
				globalMatrix = matrices[matrices.length - 1].chain(matrix);
			if (!globalMatrix.isInvertible())
				return;
	
			function getViewMatrix(matrix) {
				return viewMatrix ? viewMatrix.chain(matrix) : matrix;
			}
	
			matrices.push(globalMatrix);
			if (param.updateMatrix) {
				globalMatrix._updateVersion = updateVersion;
				this._globalMatrix = globalMatrix;
			}
	
			var blendMode = this._blendMode,
				opacity = this._opacity,
				normalBlend = blendMode === 'normal',
				nativeBlend = BlendMode.nativeModes[blendMode],
				direct = normalBlend && opacity === 1
						|| param.dontStart
						|| param.clip
						|| (nativeBlend || normalBlend && opacity < 1)
							&& this._canComposite(),
				pixelRatio = param.pixelRatio || 1,
				mainCtx, itemOffset, prevOffset;
			if (!direct) {
				var bounds = this.getStrokeBounds(getViewMatrix(globalMatrix));
				if (!bounds.width || !bounds.height)
					return;
				prevOffset = param.offset;
				itemOffset = param.offset = bounds.getTopLeft().floor();
				mainCtx = ctx;
				ctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1)
						.multiply(pixelRatio));
				if (pixelRatio !== 1)
					ctx.scale(pixelRatio, pixelRatio);
			}
			ctx.save();
			var strokeMatrix = parentStrokeMatrix
					? parentStrokeMatrix.chain(matrix)
					: !this.getStrokeScaling(true) && getViewMatrix(globalMatrix),
				clip = !direct && param.clipItem,
				transform = !strokeMatrix || clip;
			if (direct) {
				ctx.globalAlpha = opacity;
				if (nativeBlend)
					ctx.globalCompositeOperation = blendMode;
			} else if (transform) {
				ctx.translate(-itemOffset.x, -itemOffset.y);
			}
			if (transform)
				(direct ? matrix : getViewMatrix(globalMatrix)).applyToContext(ctx);
			if (clip)
				param.clipItem.draw(ctx, param.extend({ clip: true }));
			if (strokeMatrix) {
				ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
				var offset = param.offset;
				if (offset)
					ctx.translate(-offset.x, -offset.y);
			}
			this._draw(ctx, param, strokeMatrix);
			ctx.restore();
			matrices.pop();
			if (param.clip && !param.dontFinish)
				ctx.clip();
			if (!direct) {
				BlendMode.process(blendMode, ctx, mainCtx, opacity,
						itemOffset.subtract(prevOffset).multiply(pixelRatio));
				CanvasProvider.release(ctx);
				param.offset = prevOffset;
			}
		},
	
		_isUpdated: function(updateVersion) {
			var parent = this._parent;
			if (parent instanceof CompoundPath)
				return parent._isUpdated(updateVersion);
			var updated = this._updateVersion === updateVersion;
			if (!updated && parent && parent._visible
					&& parent._isUpdated(updateVersion)) {
				this._updateVersion = updateVersion;
				updated = true;
			}
			return updated;
		},
	
		_drawSelection: function(ctx, matrix, size, selectedItems, updateVersion) {
			if ((this._drawSelected || this._boundsSelected)
					&& this._isUpdated(updateVersion)) {
				var color = this.getSelectedColor(true)
						|| this.getLayer().getSelectedColor(true),
					mx = matrix.chain(this.getGlobalMatrix(true));
				ctx.strokeStyle = ctx.fillStyle = color
						? color.toCanvasStyle(ctx) : '#009dec';
				if (this._drawSelected)
					this._drawSelected(ctx, mx, selectedItems);
				if (this._boundsSelected) {
					var half = size / 2;
						coords = mx._transformCorners(this.getInternalBounds());
					ctx.beginPath();
					for (var i = 0; i < 8; i++)
						ctx[i === 0 ? 'moveTo' : 'lineTo'](coords[i], coords[++i]);
					ctx.closePath();
					ctx.stroke();
					for (var i = 0; i < 8; i++)
						ctx.fillRect(coords[i] - half, coords[++i] - half,
								size, size);
				}
			}
		},
	
		_canComposite: function() {
			return false;
		}
	}, Base.each(['down', 'drag', 'up', 'move'], function(name) {
		this['removeOn' + Base.capitalize(name)] = function() {
			var hash = {};
			hash[name] = true;
			return this.removeOn(hash);
		};
	}, {
	
		removeOn: function(obj) {
			for (var name in obj) {
				if (obj[name]) {
					var key = 'mouse' + name,
						project = this._project,
						sets = project._removeSets = project._removeSets || {};
					sets[key] = sets[key] || {};
					sets[key][this._id] = this;
				}
			}
			return this;
		}
	}));
	
	var Group = Item.extend({
		_class: 'Group',
		_selectChildren: true,
		_serializeFields: {
			children: []
		},
	
		initialize: function Group(arg) {
			this._children = [];
			this._namedChildren = {};
			if (!this._initialize(arg))
				this.addChildren(Array.isArray(arg) ? arg : arguments);
		},
	
		_changed: function _changed(flags) {
			_changed.base.call(this, flags);
			if (flags & 1026) {
				this._clipItem = undefined;
			}
		},
	
		_getClipItem: function() {
			var clipItem = this._clipItem;
			if (clipItem === undefined) {
				clipItem = null;
				for (var i = 0, l = this._children.length; i < l; i++) {
					var child = this._children[i];
					if (child._clipMask) {
						clipItem = child;
						break;
					}
				}
				this._clipItem = clipItem;
			}
			return clipItem;
		},
	
		isClipped: function() {
			return !!this._getClipItem();
		},
	
		setClipped: function(clipped) {
			var child = this.getFirstChild();
			if (child)
				child.setClipMask(clipped);
		},
	
		_draw: function(ctx, param) {
			var clip = param.clip,
				clipItem = !clip && this._getClipItem(),
				draw = true;
			param = param.extend({ clipItem: clipItem, clip: false });
			if (clip) {
				if (this._currentPath) {
					ctx.currentPath = this._currentPath;
					draw = false;
				} else {
					ctx.beginPath();
					param.dontStart = param.dontFinish = true;
				}
			} else if (clipItem) {
				clipItem.draw(ctx, param.extend({ clip: true }));
			}
			if (draw) {
				for (var i = 0, l = this._children.length; i < l; i++) {
					var item = this._children[i];
					if (item !== clipItem)
						item.draw(ctx, param);
				}
			}
			if (clip) {
				this._currentPath = ctx.currentPath;
			}
		}
	});
	
	var Layer = Group.extend({
		_class: 'Layer',
	
		initialize: function Layer(arg) {
			var props = Base.isPlainObject(arg)
					? new Base(arg)
					: { children: Array.isArray(arg) ? arg : arguments },
				insert = props.insert;
			props.insert = false;
			Group.call(this, props);
			if (insert || insert === undefined) {
				this._project.addChild(this);
				this.activate();
			}
		},
	
		_remove: function _remove(notifySelf, notifyParent) {
			if (this._parent)
				return _remove.base.call(this, notifySelf, notifyParent);
			if (this._index != null) {
				var project = this._project;
				if (project._activeLayer === this)
					project._activeLayer = this.getNextSibling()
							|| this.getPreviousSibling();
				Base.splice(project.layers, null, this._index, 1);
				this._installEvents(false);
				if (notifySelf && project._changes)
					this._changed(5);
				if (notifyParent) {
					project._needsUpdate = true;
				}
				return true;
			}
			return false;
		},
	
		getNextSibling: function getNextSibling() {
			return this._parent ? getNextSibling.base.call(this)
					: this._project.layers[this._index + 1] || null;
		},
	
		getPreviousSibling: function getPreviousSibling() {
			return this._parent ? getPreviousSibling.base.call(this)
					: this._project.layers[this._index - 1] || null;
		},
	
		isInserted: function isInserted() {
			return this._parent ? isInserted.base.call(this) : this._index != null;
		},
	
		activate: function() {
			this._project._activeLayer = this;
		},
	
		_insertSibling: function _insertSibling(index, item, _preserve) {
			return !this._parent
					? this._project.insertChild(index, item, _preserve)
					: _insertSibling.base.call(this, index, item, _preserve);
		}
	});
	
	var Shape = Item.extend({
		_class: 'Shape',
		_applyMatrix: false,
		_canApplyMatrix: false,
		_boundsSelected: true,
		_serializeFields: {
			type: null,
			size: null,
			radius: null
		},
	
		initialize: function Shape(props) {
			this._initialize(props);
		},
	
		_equals: function(item) {
			return this._type === item._type
				&& this._size.equals(item._size)
				&& Base.equals(this._radius, item._radius);
		},
	
		clone: function(insert) {
			var copy = new Shape(Item.NO_INSERT);
			copy.setType(this._type);
			copy.setSize(this._size);
			copy.setRadius(this._radius);
			return this._clone(copy, insert);
		},
	
		getType: function() {
			return this._type;
		},
	
		setType: function(type) {
			this._type = type;
		},
	
		getShape: '#getType',
		setShape: '#setType',
	
		getSize: function() {
			var size = this._size;
			return new LinkedSize(size.width, size.height, this, 'setSize');
		},
	
		setSize: function() {
			var size = Size.read(arguments);
			if (!this._size) {
				this._size = size.clone();
			} else if (!this._size.equals(size)) {
				var type = this._type,
					width = size.width,
					height = size.height;
				if (type === 'rectangle') {
					var radius = Size.min(this._radius, size.divide(2));
					this._radius.set(radius.width, radius.height);
				} else if (type === 'circle') {
					width = height = (width + height) / 2;
					this._radius = width / 2;
				} else if (type === 'ellipse') {
					this._radius.set(width / 2, height / 2);
				}
				this._size.set(width, height);
				this._changed(9);
			}
		},
	
		getRadius: function() {
			var rad = this._radius;
			return this._type === 'circle'
					? rad
					: new LinkedSize(rad.width, rad.height, this, 'setRadius');
		},
	
		setRadius: function(radius) {
			var type = this._type;
			if (type === 'circle') {
				if (radius === this._radius)
					return;
				var size = radius * 2;
				this._radius = radius;
				this._size.set(size, size);
			} else {
				radius = Size.read(arguments);
				if (!this._radius) {
					this._radius = radius.clone();
				} else {
					if (this._radius.equals(radius))
						return;
					this._radius.set(radius.width, radius.height);
					if (type === 'rectangle') {
						var size = Size.max(this._size, radius.multiply(2));
						this._size.set(size.width, size.height);
					} else if (type === 'ellipse') {
						this._size.set(radius.width * 2, radius.height * 2);
					}
				}
			}
			this._changed(9);
		},
	
		isEmpty: function() {
			return false;
		},
	
		toPath: function(insert) {
			var path = this._clone(new Path[Base.capitalize(this._type)]({
				center: new Point(),
				size: this._size,
				radius: this._radius,
				insert: false
			}), insert);
			if (paper.settings.applyMatrix)
				path.setApplyMatrix(true);
			return path;
		},
	
		_draw: function(ctx, param, strokeMatrix) {
			var style = this._style,
				hasFill = style.hasFill(),
				hasStroke = style.hasStroke(),
				dontPaint = param.dontFinish || param.clip,
				untransformed = !strokeMatrix;
			if (hasFill || hasStroke || dontPaint) {
				var type = this._type,
					radius = this._radius,
					isCircle = type === 'circle';
				if (!param.dontStart)
					ctx.beginPath();
				if (untransformed && isCircle) {
					ctx.arc(0, 0, radius, 0, Math.PI * 2, true);
				} else {
					var rx = isCircle ? radius : radius.width,
						ry = isCircle ? radius : radius.height,
						size = this._size,
						width = size.width,
						height = size.height;
					if (untransformed && type === 'rectangle' && rx === 0 && ry === 0) {
						ctx.rect(-width / 2, -height / 2, width, height);
					} else {
						var x = width / 2,
							y = height / 2,
							kappa = 1 - 0.5522847498307936,
							cx = rx * kappa,
							cy = ry * kappa,
							c = [
								-x, -y + ry,
								-x, -y + cy,
								-x + cx, -y,
								-x + rx, -y,
								x - rx, -y,
								x - cx, -y,
								x, -y + cy,
								x, -y + ry,
								x, y - ry,
								x, y - cy,
								x - cx, y,
								x - rx, y,
								-x + rx, y,
								-x + cx, y,
								-x, y - cy,
								-x, y - ry
							];
						if (strokeMatrix)
							strokeMatrix.transform(c, c, 32);
						ctx.moveTo(c[0], c[1]);
						ctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);
						if (x !== rx)
							ctx.lineTo(c[8], c[9]);
						ctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);
						if (y !== ry)
							ctx.lineTo(c[16], c[17]);
						ctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);
						if (x !== rx)
							ctx.lineTo(c[24], c[25]);
						ctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);
					}
				}
				ctx.closePath();
			}
			if (!dontPaint && (hasFill || hasStroke)) {
				this._setStyles(ctx);
				if (hasFill) {
					ctx.fill(style.getWindingRule());
					ctx.shadowColor = 'rgba(0,0,0,0)';
				}
				if (hasStroke)
					ctx.stroke();
			}
		},
	
		_canComposite: function() {
			return !(this.hasFill() && this.hasStroke());
		},
	
		_getBounds: function(getter, matrix) {
			var rect = new Rectangle(this._size).setCenter(0, 0);
			if (getter !== 'getBounds' && this.hasStroke())
				rect = rect.expand(this.getStrokeWidth());
			return matrix ? matrix._transformBounds(rect) : rect;
		}
	},
	new function() {
	
		function getCornerCenter(that, point, expand) {
			var radius = that._radius;
			if (!radius.isZero()) {
				var halfSize = that._size.divide(2);
				for (var i = 0; i < 4; i++) {
					var dir = new Point(i & 1 ? 1 : -1, i > 1 ? 1 : -1),
						corner = dir.multiply(halfSize),
						center = corner.subtract(dir.multiply(radius)),
						rect = new Rectangle(corner, center);
					if ((expand ? rect.expand(expand) : rect).contains(point))
						return center;
				}
			}
		}
	
		function getEllipseRadius(point, radius) {
			var angle = point.getAngleInRadians(),
				width = radius.width * 2,
				height = radius.height * 2,
				x = width * Math.sin(angle),
				y = height * Math.cos(angle);
			return width * height / (2 * Math.sqrt(x * x + y * y));
		}
	
		return {
			_contains: function _contains(point) {
				if (this._type === 'rectangle') {
					var center = getCornerCenter(this, point);
					return center
							? point.subtract(center).divide(this._radius)
								.getLength() <= 1
							: _contains.base.call(this, point);
				} else {
					return point.divide(this.size).getLength() <= 0.5;
				}
			},
	
			_hitTestSelf: function _hitTestSelf(point, options) {
				var hit = false;
				if (this.hasStroke()) {
					var type = this._type,
						radius = this._radius,
						strokeWidth = this.getStrokeWidth() + 2 * options.tolerance;
					if (type === 'rectangle') {
						var center = getCornerCenter(this, point, strokeWidth);
						if (center) {
							var pt = point.subtract(center);
							hit = 2 * Math.abs(pt.getLength()
									- getEllipseRadius(pt, radius)) <= strokeWidth;
						} else {
							var rect = new Rectangle(this._size).setCenter(0, 0),
								outer = rect.expand(strokeWidth),
								inner = rect.expand(-strokeWidth);
							hit = outer._containsPoint(point)
									&& !inner._containsPoint(point);
						}
					} else {
						if (type === 'ellipse')
							radius = getEllipseRadius(point, radius);
						hit = 2 * Math.abs(point.getLength() - radius)
								<= strokeWidth;
					}
				}
				return hit
						? new HitResult('stroke', this)
						: _hitTestSelf.base.apply(this, arguments);
			}
		};
	}, {
	
	statics: new function() {
		function createShape(type, point, size, radius, args) {
			var item = new Shape(Base.getNamed(args));
			item._type = type;
			item._size = size;
			item._radius = radius;
			return item.translate(point);
		}
	
		return {
			Circle: function() {
				var center = Point.readNamed(arguments, 'center'),
					radius = Base.readNamed(arguments, 'radius');
				return createShape('circle', center, new Size(radius * 2), radius,
						arguments);
			},
	
			Rectangle: function() {
				var rect = Rectangle.readNamed(arguments, 'rectangle'),
					radius = Size.min(Size.readNamed(arguments, 'radius'),
							rect.getSize(true).divide(2));
				return createShape('rectangle', rect.getCenter(true),
						rect.getSize(true), radius, arguments);
			},
	
			Ellipse: function() {
				var ellipse = Shape._readEllipse(arguments),
					radius = ellipse.radius;
				return createShape('ellipse', ellipse.center, radius.multiply(2),
						radius, arguments);
			},
	
			_readEllipse: function(args) {
				var center,
					radius;
				if (Base.hasNamed(args, 'radius')) {
					center = Point.readNamed(args, 'center');
					radius = Size.readNamed(args, 'radius');
				} else {
					var rect = Rectangle.readNamed(args, 'rectangle');
					center = rect.getCenter(true);
					radius = rect.getSize(true).divide(2);
				}
				return { center: center, radius: radius };
			}
		};
	}});
	
	var Raster = Item.extend({
		_class: 'Raster',
		_applyMatrix: false,
		_canApplyMatrix: false,
		_boundsGetter: 'getBounds',
		_boundsSelected: true,
		_serializeFields: {
			crossOrigin: null,
			source: null
		},
	
		initialize: function Raster(object, position) {
			if (!this._initialize(object,
					position !== undefined && Point.read(arguments, 1))) {
				if (typeof object === 'string') {
					this.setSource(object);
				} else {
					this.setImage(object);
				}
			}
			if (!this._size) {
				this._size = new Size();
				this._loaded = false;
			}
		},
	
		_equals: function(item) {
			return this.getSource() === item.getSource();
		},
	
		clone: function(insert) {
			var copy = new Raster(Item.NO_INSERT),
				image = this._image,
				canvas = this._canvas;
			if (image) {
				copy.setImage(image);
			} else if (canvas) {
				var copyCanvas = CanvasProvider.getCanvas(this._size);
				copyCanvas.getContext('2d').drawImage(canvas, 0, 0);
				copy.setImage(copyCanvas);
			}
			copy._crossOrigin = this._crossOrigin;
			return this._clone(copy, insert);
		},
	
		getSize: function() {
			var size = this._size;
			return new LinkedSize(size ? size.width : 0, size ? size.height : 0,
					this, 'setSize');
		},
	
		setSize: function() {
			var size = Size.read(arguments);
			if (!size.equals(this._size)) {
				if (size.width > 0 && size.height > 0) {
					var element = this.getElement();
					this.setImage(CanvasProvider.getCanvas(size));
					if (element)
						this.getContext(true).drawImage(element, 0, 0,
								size.width, size.height);
				} else {
					if (this._canvas)
						CanvasProvider.release(this._canvas);
					this._size = size.clone();
				}
			}
		},
	
		getWidth: function() {
			return this._size ? this._size.width : 0;
		},
	
		setWidth: function(width) {
			this.setSize(width, this.getHeight());
		},
	
		getHeight: function() {
			return this._size ? this._size.height : 0;
		},
	
		setHeight: function(height) {
			this.setSize(this.getWidth(), height);
		},
	
		isEmpty: function() {
			var size = this._size;
			return !size || size.width === 0 && size.height === 0;
		},
	
		getResolution: function() {
			var matrix = this._matrix,
				orig = new Point(0, 0).transform(matrix),
				u = new Point(1, 0).transform(matrix).subtract(orig),
				v = new Point(0, 1).transform(matrix).subtract(orig);
			return new Size(
				72 / u.getLength(),
				72 / v.getLength()
			);
		},
	
		getPpi: '#getResolution',
	
		getImage: function() {
			return this._image;
		},
	
		setImage: function(image) {
			if (this._canvas)
				CanvasProvider.release(this._canvas);
			if (image && image.getContext) {
				this._image = null;
				this._canvas = image;
				this._loaded = true;
			} else {
				this._image = image;
				this._canvas = null;
				this._loaded = image && image.complete;
			}
			this._size = new Size(
					image ? image.naturalWidth || image.width : 0,
					image ? image.naturalHeight || image.height : 0);
			this._context = null;
			this._changed(521);
		},
	
		getCanvas: function() {
			if (!this._canvas) {
				var ctx = CanvasProvider.getContext(this._size);
				try {
					if (this._image)
						ctx.drawImage(this._image, 0, 0);
					this._canvas = ctx.canvas;
				} catch (e) {
					CanvasProvider.release(ctx);
				}
			}
			return this._canvas;
		},
	
		setCanvas: '#setImage',
	
		getContext: function(modify) {
			if (!this._context)
				this._context = this.getCanvas().getContext('2d');
			if (modify) {
				this._image = null;
				this._changed(513);
			}
			return this._context;
		},
	
		setContext: function(context) {
			this._context = context;
		},
	
		getSource: function() {
			return this._image && this._image.src || this.toDataURL();
		},
	
		setSource: function(src) {
			var that = this,
				crossOrigin = this._crossOrigin,
				image;
	
			function loaded() {
				var view = that.getView();
				if (view) {
					paper = view._scope;
					that.setImage(image);
					that.emit('load');
					view.update();
				}
			}
	
			image = document.getElementById(src) || new Image();
			if (crossOrigin)
				image.crossOrigin = crossOrigin;
			if (image.naturalWidth && image.naturalHeight) {
				setTimeout(loaded, 0);
			} else {
				DomEvent.add(image, { load: loaded });
				if (!image.src)
					image.src = src;
			}
			this.setImage(image);
		},
	
		getCrossOrigin: function() {
			return this._image && this._image.crossOrigin || this._crossOrigin || '';
		},
	
		setCrossOrigin: function(crossOrigin) {
			this._crossOrigin = crossOrigin;
			if (this._image)
				this._image.crossOrigin = crossOrigin;
		},
	
		getElement: function() {
			return this._canvas || this._loaded && this._image;
		}
	}, {
		beans: false,
	
		getSubCanvas: function() {
			var rect = Rectangle.read(arguments),
				ctx = CanvasProvider.getContext(rect.getSize());
			ctx.drawImage(this.getCanvas(), rect.x, rect.y,
					rect.width, rect.height, 0, 0, rect.width, rect.height);
			return ctx.canvas;
		},
	
		getSubRaster: function() {
			var rect = Rectangle.read(arguments),
				raster = new Raster(Item.NO_INSERT);
			raster.setImage(this.getSubCanvas(rect));
			raster.translate(rect.getCenter().subtract(this.getSize().divide(2)));
			raster._matrix.preConcatenate(this._matrix);
			raster.insertAbove(this);
			return raster;
		},
	
		toDataURL: function() {
			var src = this._image && this._image.src;
			if (/^data:/.test(src))
				return src;
			var canvas = this.getCanvas();
			return canvas ? canvas.toDataURL() : null;
		},
	
		drawImage: function(image ) {
			var point = Point.read(arguments, 1);
			this.getContext(true).drawImage(image, point.x, point.y);
		},
	
		getAverageColor: function(object) {
			var bounds, path;
			if (!object) {
				bounds = this.getBounds();
			} else if (object instanceof PathItem) {
				path = object;
				bounds = object.getBounds();
			} else if (object.width) {
				bounds = new Rectangle(object);
			} else if (object.x) {
				bounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);
			}
			var sampleSize = 32,
				width = Math.min(bounds.width, sampleSize),
				height = Math.min(bounds.height, sampleSize);
			var ctx = Raster._sampleContext;
			if (!ctx) {
				ctx = Raster._sampleContext = CanvasProvider.getContext(
						new Size(sampleSize));
			} else {
				ctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);
			}
			ctx.save();
			var matrix = new Matrix()
					.scale(width / bounds.width, height / bounds.height)
					.translate(-bounds.x, -bounds.y);
			matrix.applyToContext(ctx);
			if (path)
				path.draw(ctx, new Base({ clip: true, matrices: [matrix] }));
			this._matrix.applyToContext(ctx);
			var element = this.getElement(),
				size = this._size;
			if (element)
				ctx.drawImage(element, -size.width / 2, -size.height / 2);
			ctx.restore();
			var pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width),
					Math.ceil(height)).data,
				channels = [0, 0, 0],
				total = 0;
			for (var i = 0, l = pixels.length; i < l; i += 4) {
				var alpha = pixels[i + 3];
				total += alpha;
				alpha /= 255;
				channels[0] += pixels[i] * alpha;
				channels[1] += pixels[i + 1] * alpha;
				channels[2] += pixels[i + 2] * alpha;
			}
			for (var i = 0; i < 3; i++)
				channels[i] /= total;
			return total ? Color.read(channels) : null;
		},
	
		getPixel: function() {
			var point = Point.read(arguments);
			var data = this.getContext().getImageData(point.x, point.y, 1, 1).data;
			return new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255],
					data[3] / 255);
		},
	
		setPixel: function() {
			var point = Point.read(arguments),
				color = Color.read(arguments),
				components = color._convert('rgb'),
				alpha = color._alpha,
				ctx = this.getContext(true),
				imageData = ctx.createImageData(1, 1),
				data = imageData.data;
			data[0] = components[0] * 255;
			data[1] = components[1] * 255;
			data[2] = components[2] * 255;
			data[3] = alpha != null ? alpha * 255 : 255;
			ctx.putImageData(imageData, point.x, point.y);
		},
	
		createImageData: function() {
			var size = Size.read(arguments);
			return this.getContext().createImageData(size.width, size.height);
		},
	
		getImageData: function() {
			var rect = Rectangle.read(arguments);
			if (rect.isEmpty())
				rect = new Rectangle(this._size);
			return this.getContext().getImageData(rect.x, rect.y,
					rect.width, rect.height);
		},
	
		setImageData: function(data ) {
			var point = Point.read(arguments, 1);
			this.getContext(true).putImageData(data, point.x, point.y);
		},
	
		_getBounds: function(getter, matrix) {
			var rect = new Rectangle(this._size).setCenter(0, 0);
			return matrix ? matrix._transformBounds(rect) : rect;
		},
	
		_hitTestSelf: function(point) {
			if (this._contains(point)) {
				var that = this;
				return new HitResult('pixel', that, {
					offset: point.add(that._size.divide(2)).round(),
					color: {
						get: function() {
							return that.getPixel(this.offset);
						}
					}
				});
			}
		},
	
		_draw: function(ctx) {
			var element = this.getElement();
			if (element) {
				ctx.globalAlpha = this._opacity;
				ctx.drawImage(element,
						-this._size.width / 2, -this._size.height / 2);
			}
		},
	
		_canComposite: function() {
			return true;
		}
	});
	
	var PlacedSymbol = Item.extend({
		_class: 'PlacedSymbol',
		_applyMatrix: false,
		_canApplyMatrix: false,
		_boundsGetter: { getBounds: 'getStrokeBounds' },
		_boundsSelected: true,
		_serializeFields: {
			symbol: null
		},
	
		initialize: function PlacedSymbol(arg0, arg1) {
			if (!this._initialize(arg0,
					arg1 !== undefined && Point.read(arguments, 1)))
				this.setSymbol(arg0 instanceof Symbol ? arg0 : new Symbol(arg0));
		},
	
		_equals: function(item) {
			return this._symbol === item._symbol;
		},
	
		getSymbol: function() {
			return this._symbol;
		},
	
		setSymbol: function(symbol) {
			this._symbol = symbol;
			this._changed(9);
		},
	
		clone: function(insert) {
			var copy = new PlacedSymbol(Item.NO_INSERT);
			copy.setSymbol(this._symbol);
			return this._clone(copy, insert);
		},
	
		isEmpty: function() {
			return this._symbol._definition.isEmpty();
		},
	
		_getBounds: function(getter, matrix, cacheItem) {
			var definition = this.symbol._definition;
			return definition._getCachedBounds(getter,
					matrix && matrix.chain(definition._matrix), cacheItem);
		},
	
		_hitTestSelf: function(point, options) {
			var res = this._symbol._definition._hitTest(point, options);
			if (res)
				res.item = this;
			return res;
		},
	
		_draw: function(ctx, param) {
			this.symbol._definition.draw(ctx, param);
		}
	
	});
	
	var HitResult = Base.extend({
		_class: 'HitResult',
	
		initialize: function HitResult(type, item, values) {
			this.type = type;
			this.item = item;
			if (values) {
				values.enumerable = true;
				this.inject(values);
			}
		},
	
		statics: {
			getOptions: function(options) {
				return new Base({
					type: null,
					tolerance: paper.settings.hitTolerance,
					fill: !options,
					stroke: !options,
					segments: !options,
					handles: false,
					ends: false,
					center: false,
					bounds: false,
					guides: false,
					selected: false
				}, options);
			}
		}
	});
	
	var Segment = Base.extend({
		_class: 'Segment',
		beans: true,
	
		initialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {
			var count = arguments.length,
				point, handleIn, handleOut;
			if (count === 0) {
			} else if (count === 1) {
				if (arg0.point) {
					point = arg0.point;
					handleIn = arg0.handleIn;
					handleOut = arg0.handleOut;
				} else {
					point = arg0;
				}
			} else if (count === 2 && typeof arg0 === 'number') {
				point = arguments;
			} else if (count <= 3) {
				point = arg0;
				handleIn = arg1;
				handleOut = arg2;
			} else {
				point = arg0 !== undefined ? [ arg0, arg1 ] : null;
				handleIn = arg2 !== undefined ? [ arg2, arg3 ] : null;
				handleOut = arg4 !== undefined ? [ arg4, arg5 ] : null;
			}
			new SegmentPoint(point, this, '_point');
			new SegmentPoint(handleIn, this, '_handleIn');
			new SegmentPoint(handleOut, this, '_handleOut');
		},
	
		_serialize: function(options) {
			return Base.serialize(this.isStraight() ? this._point
					: [this._point, this._handleIn, this._handleOut],
					options, true);
		},
	
		_changed: function(point) {
			var path = this._path;
			if (!path)
				return;
			var curves = path._curves,
				index = this._index,
				curve;
			if (curves) {
				if ((!point || point === this._point || point === this._handleIn)
						&& (curve = index > 0 ? curves[index - 1] : path._closed
							? curves[curves.length - 1] : null))
					curve._changed();
				if ((!point || point === this._point || point === this._handleOut)
						&& (curve = curves[index]))
					curve._changed();
			}
			path._changed(25);
		},
	
		getPoint: function() {
			return this._point;
		},
	
		setPoint: function() {
			var point = Point.read(arguments);
			this._point.set(point.x, point.y);
		},
	
		getHandleIn: function() {
			return this._handleIn;
		},
	
		setHandleIn: function() {
			var point = Point.read(arguments);
			this._handleIn.set(point.x, point.y);
		},
	
		getHandleOut: function() {
			return this._handleOut;
		},
	
		setHandleOut: function() {
			var point = Point.read(arguments);
			this._handleOut.set(point.x, point.y);
		},
	
		hasHandles: function() {
			return !this.isStraight();
		},
	
		isStraight: function() {
			return this._handleIn.isZero() && this._handleOut.isZero();
		},
	
		isLinear: function() {
			return Segment.isLinear(this, this.getNext());
		},
	
		isCollinear: function(segment) {
			return Segment.isCollinear(this, this.getNext(),
					segment, segment.getNext());
		},
	
		isColinear: '#isCollinear',
	
		isOrthogonal: function() {
			return Segment.isOrthogonal(this.getPrevious(), this, this.getNext());
		},
	
		isOrthogonalArc: function() {
			return Segment.isOrthogonalArc(this, this.getNext());
		},
	
		isArc: '#isOrthogonalArc',
	
		_selectionState: 0,
	
		isSelected: function(_point) {
			var state = this._selectionState;
			return !_point ? !!(state & 7)
				: _point === this._point ? !!(state & 4)
				: _point === this._handleIn ? !!(state & 1)
				: _point === this._handleOut ? !!(state & 2)
				: false;
		},
	
		setSelected: function(selected, _point) {
			var path = this._path,
				selected = !!selected,
				state = this._selectionState,
				oldState = state,
				flag = !_point ? 7
						: _point === this._point ? 4
						: _point === this._handleIn ? 1
						: _point === this._handleOut ? 2
						: 0;
			if (selected) {
				state |= flag;
			} else {
				state &= ~flag;
			}
			this._selectionState = state;
			if (path && state !== oldState) {
				path._updateSelection(this, oldState, state);
				path._changed(129);
			}
		},
	
		getIndex: function() {
			return this._index !== undefined ? this._index : null;
		},
	
		getPath: function() {
			return this._path || null;
		},
	
		getCurve: function() {
			var path = this._path,
				index = this._index;
			if (path) {
				if (index > 0 && !path._closed
						&& index === path._segments.length - 1)
					index--;
				return path.getCurves()[index] || null;
			}
			return null;
		},
	
		getLocation: function() {
			var curve = this.getCurve();
			return curve
					? new CurveLocation(curve, this === curve._segment1 ? 0 : 1)
					: null;
		},
	
		getNext: function() {
			var segments = this._path && this._path._segments;
			return segments && (segments[this._index + 1]
					|| this._path._closed && segments[0]) || null;
		},
	
		getPrevious: function() {
			var segments = this._path && this._path._segments;
			return segments && (segments[this._index - 1]
					|| this._path._closed && segments[segments.length - 1]) || null;
		},
	
		reverse: function() {
			return new Segment(this._point, this._handleOut, this._handleIn);
		},
	
		remove: function() {
			return this._path ? !!this._path.removeSegment(this._index) : false;
		},
	
		clone: function() {
			return new Segment(this._point, this._handleIn, this._handleOut);
		},
	
		equals: function(segment) {
			return segment === this || segment && this._class === segment._class
					&& this._point.equals(segment._point)
					&& this._handleIn.equals(segment._handleIn)
					&& this._handleOut.equals(segment._handleOut)
					|| false;
		},
	
		toString: function() {
			var parts = [ 'point: ' + this._point ];
			if (!this._handleIn.isZero())
				parts.push('handleIn: ' + this._handleIn);
			if (!this._handleOut.isZero())
				parts.push('handleOut: ' + this._handleOut);
			return '{ ' + parts.join(', ') + ' }';
		},
	
		transform: function(matrix) {
			this._transformCoordinates(matrix, new Array(6), true);
			this._changed();
		},
	
		_transformCoordinates: function(matrix, coords, change) {
			var point = this._point,
				handleIn = !change || !this._handleIn.isZero()
						? this._handleIn : null,
				handleOut = !change || !this._handleOut.isZero()
						? this._handleOut : null,
				x = point._x,
				y = point._y,
				i = 2;
			coords[0] = x;
			coords[1] = y;
			if (handleIn) {
				coords[i++] = handleIn._x + x;
				coords[i++] = handleIn._y + y;
			}
			if (handleOut) {
				coords[i++] = handleOut._x + x;
				coords[i++] = handleOut._y + y;
			}
			if (matrix) {
				matrix._transformCoordinates(coords, coords, i / 2);
				x = coords[0];
				y = coords[1];
				if (change) {
					point._x = x;
					point._y = y;
					i  = 2;
					if (handleIn) {
						handleIn._x = coords[i++] - x;
						handleIn._y = coords[i++] - y;
					}
					if (handleOut) {
						handleOut._x = coords[i++] - x;
						handleOut._y = coords[i++] - y;
					}
				} else {
					if (!handleIn) {
						coords[i++] = x;
						coords[i++] = y;
					}
					if (!handleOut) {
						coords[i++] = x;
						coords[i++] = y;
					}
				}
			}
			return coords;
		},
	
	   statics: {
	
			isLinear: function(seg1, seg2) {
				var l = seg2._point.subtract(seg1._point);
				return l.isCollinear(seg1._handleOut)
						&& l.isCollinear(seg2._handleIn);
			},
	
			isCollinear: function(seg1, seg2, seg3, seg4) {
				return seg1._handleOut.isZero() && seg2._handleIn.isZero()
						&& seg3._handleOut.isZero() && seg4._handleIn.isZero()
						&& seg2._point.subtract(seg1._point).isCollinear(
							seg4._point.subtract(seg3._point));
			},
	
			isOrthogonal: function(seg1, seg2, seg3) {
				return seg1._handleOut.isZero() && seg2._handleIn.isZero()
					&& seg2._handleOut.isZero() && seg3._handleIn.isZero()
					&& seg2._point.subtract(seg1._point).isOrthogonal(
							seg3._point.subtract(seg2._point));
			},
	
			isOrthogonalArc: function(seg1, seg2) {
				var handle1 = seg1._handleOut,
					handle2 = seg2._handleIn,
					kappa = 0.5522847498307936;
				if (handle1.isOrthogonal(handle2)) {
					var pt1 = seg1._point,
						pt2 = seg2._point,
						corner = new Line(pt1, handle1, true).intersect(
								new Line(pt2, handle2, true), true);
					return corner && Numerical.isZero(handle1.getLength() /
							corner.subtract(pt1).getLength() - kappa)
						&& Numerical.isZero(handle2.getLength() /
							corner.subtract(pt2).getLength() - kappa);
				}
				return false;
			},
		}
	});
	
	var SegmentPoint = Point.extend({
		initialize: function SegmentPoint(point, owner, key) {
			var x, y, selected;
			if (!point) {
				x = y = 0;
			} else if ((x = point[0]) !== undefined) {
				y = point[1];
			} else {
				var pt = point;
				if ((x = pt.x) === undefined) {
					pt = Point.read(arguments);
					x = pt.x;
				}
				y = pt.y;
				selected = pt.selected;
			}
			this._x = x;
			this._y = y;
			this._owner = owner;
			owner[key] = this;
			if (selected)
				this.setSelected(true);
		},
	
		set: function(x, y) {
			this._x = x;
			this._y = y;
			this._owner._changed(this);
			return this;
		},
	
		_serialize: function(options) {
			var f = options.formatter,
				x = f.number(this._x),
				y = f.number(this._y);
			return this.isSelected()
					? { x: x, y: y, selected: true }
					: [x, y];
		},
	
		getX: function() {
			return this._x;
		},
	
		setX: function(x) {
			this._x = x;
			this._owner._changed(this);
		},
	
		getY: function() {
			return this._y;
		},
	
		setY: function(y) {
			this._y = y;
			this._owner._changed(this);
		},
	
		isZero: function() {
			return Numerical.isZero(this._x) && Numerical.isZero(this._y);
		},
	
		setSelected: function(selected) {
			this._owner.setSelected(selected, this);
		},
	
		isSelected: function() {
			return this._owner.isSelected(this);
		}
	});
	
	var Curve = Base.extend({
		_class: 'Curve',
	
		initialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
			var count = arguments.length;
			if (count === 3) {
				this._path = arg0;
				this._segment1 = arg1;
				this._segment2 = arg2;
			} else if (count === 0) {
				this._segment1 = new Segment();
				this._segment2 = new Segment();
			} else if (count === 1) {
				this._segment1 = new Segment(arg0.segment1);
				this._segment2 = new Segment(arg0.segment2);
			} else if (count === 2) {
				this._segment1 = new Segment(arg0);
				this._segment2 = new Segment(arg1);
			} else {
				var point1, handle1, handle2, point2;
				if (count === 4) {
					point1 = arg0;
					handle1 = arg1;
					handle2 = arg2;
					point2 = arg3;
				} else if (count === 8) {
					point1 = [arg0, arg1];
					point2 = [arg6, arg7];
					handle1 = [arg2 - arg0, arg3 - arg1];
					handle2 = [arg4 - arg6, arg5 - arg7];
				}
				this._segment1 = new Segment(point1, null, handle1);
				this._segment2 = new Segment(point2, handle2, null);
			}
		},
	
		_changed: function() {
			this._length = this._bounds = undefined;
		},
	
		getPoint1: function() {
			return this._segment1._point;
		},
	
		setPoint1: function() {
			var point = Point.read(arguments);
			this._segment1._point.set(point.x, point.y);
		},
	
		getPoint2: function() {
			return this._segment2._point;
		},
	
		setPoint2: function() {
			var point = Point.read(arguments);
			this._segment2._point.set(point.x, point.y);
		},
	
		getHandle1: function() {
			return this._segment1._handleOut;
		},
	
		setHandle1: function() {
			var point = Point.read(arguments);
			this._segment1._handleOut.set(point.x, point.y);
		},
	
		getHandle2: function() {
			return this._segment2._handleIn;
		},
	
		setHandle2: function() {
			var point = Point.read(arguments);
			this._segment2._handleIn.set(point.x, point.y);
		},
	
		getSegment1: function() {
			return this._segment1;
		},
	
		getSegment2: function() {
			return this._segment2;
		},
	
		getPath: function() {
			return this._path;
		},
	
		getIndex: function() {
			return this._segment1._index;
		},
	
		getNext: function() {
			var curves = this._path && this._path._curves;
			return curves && (curves[this._segment1._index + 1]
					|| this._path._closed && curves[0]) || null;
		},
	
		getPrevious: function() {
			var curves = this._path && this._path._curves;
			return curves && (curves[this._segment1._index - 1]
					|| this._path._closed && curves[curves.length - 1]) || null;
		},
	
		isSelected: function() {
			return this.getPoint1().isSelected()
					&& this.getHandle2().isSelected()
					&& this.getHandle2().isSelected()
					&& this.getPoint2().isSelected();
		},
	
		setSelected: function(selected) {
			this.getPoint1().setSelected(selected);
			this.getHandle1().setSelected(selected);
			this.getHandle2().setSelected(selected);
			this.getPoint2().setSelected(selected);
		},
	
		getValues: function(matrix) {
			return Curve.getValues(this._segment1, this._segment2, matrix);
		},
	
		getPoints: function() {
			var coords = this.getValues(),
				points = [];
			for (var i = 0; i < 8; i += 2)
				points.push(new Point(coords[i], coords[i + 1]));
			return points;
		},
	
		getLength: function() {
			if (this._length == null) {
				this._length = this.isLinear()
					? this._segment2._point.getDistance(this._segment1._point)
					: Curve.getLength(this.getValues(), 0, 1);
			}
			return this._length;
		},
	
		getArea: function() {
			return Curve.getArea(this.getValues());
		},
	
		getPart: function(from, to) {
			return new Curve(Curve.getPart(this.getValues(), from, to));
		},
	
		getPartLength: function(from, to) {
			return Curve.getLength(this.getValues(), from, to);
		},
	
		hasHandles: function() {
			return !this._segment1._handleOut.isZero()
					|| !this._segment2._handleIn.isZero();
		},
	
		isLinear: function() {
			return Segment.isLinear(this._segment1, this._segment2);
		},
	
		isCollinear: function(curve) {
			return Ssegment.isCollinear(this._segment1, this._segment2,
					curve._segment1, curve._segment2);
		},
	
		isOrthogonalArc: function() {
			return Segment.isOrthogonalArc(this._segment1, this._segment2);
		},
	
		getIntersections: function(curve) {
			return Curve.filterIntersections(Curve.getIntersections(
					this.getValues(), curve.getValues(), this, curve, []));
		},
	
		_getParameter: function(offset, isParameter) {
			return isParameter
					? offset
					: offset && offset.curve === this
						? offset.parameter
						: offset === undefined && isParameter === undefined
							? 0.5
							: this.getParameterAt(offset, 0);
		},
	
		divide: function(offset, isParameter, ignoreLinear) {
			var parameter = this._getParameter(offset, isParameter),
				tolerance = 0.000001,
				res = null;
			if (parameter > tolerance && parameter < 1 - tolerance) {
				var parts = Curve.subdivide(this.getValues(), parameter),
					isLinear = ignoreLinear ? false : this.isLinear(),
					left = parts[0],
					right = parts[1];
	
				if (!isLinear) {
					this._segment1._handleOut.set(left[2] - left[0],
							left[3] - left[1]);
					this._segment2._handleIn.set(right[4] - right[6],
							right[5] - right[7]);
				}
	
				var x = left[6], y = left[7],
					segment = new Segment(new Point(x, y),
							!isLinear && new Point(left[4] - x, left[5] - y),
							!isLinear && new Point(right[2] - x, right[3] - y));
	
				if (this._path) {
					if (this._segment1._index > 0 && this._segment2._index === 0) {
						this._path.add(segment);
					} else {
						this._path.insert(this._segment2._index, segment);
					}
					res = this;
				} else {
					var end = this._segment2;
					this._segment2 = segment;
					res = new Curve(segment, end);
				}
			}
			return res;
		},
	
		split: function(offset, isParameter) {
			return this._path
				? this._path.split(this._segment1._index,
						this._getParameter(offset, isParameter))
				: null;
		},
	
		reverse: function() {
			return new Curve(this._segment2.reverse(), this._segment1.reverse());
		},
	
		remove: function() {
			var removed = false;
			if (this._path) {
				var segment2 = this._segment2,
					handleOut = segment2._handleOut;
				removed = segment2.remove();
				if (removed)
					this._segment1._handleOut.set(handleOut.x, handleOut.y);
			}
			return removed;
		},
	
		clone: function() {
			return new Curve(this._segment1, this._segment2);
		},
	
		toString: function() {
			var parts = [ 'point1: ' + this._segment1._point ];
			if (!this._segment1._handleOut.isZero())
				parts.push('handle1: ' + this._segment1._handleOut);
			if (!this._segment2._handleIn.isZero())
				parts.push('handle2: ' + this._segment2._handleIn);
			parts.push('point2: ' + this._segment2._point);
			return '{ ' + parts.join(', ') + ' }';
		},
	
	statics: {
		getValues: function(segment1, segment2, matrix) {
			var p1 = segment1._point,
				h1 = segment1._handleOut,
				h2 = segment2._handleIn,
				p2 = segment2._point,
				values = [
					p1._x, p1._y,
					p1._x + h1._x, p1._y + h1._y,
					p2._x + h2._x, p2._y + h2._y,
					p2._x, p2._y
				];
			if (matrix)
				matrix._transformCoordinates(values, values, 4);
			return values;
		},
	
		subdivide: function(v, t) {
			var p1x = v[0], p1y = v[1],
				c1x = v[2], c1y = v[3],
				c2x = v[4], c2y = v[5],
				p2x = v[6], p2y = v[7];
			if (t === undefined)
				t = 0.5;
			var u = 1 - t,
				p3x = u * p1x + t * c1x, p3y = u * p1y + t * c1y,
				p4x = u * c1x + t * c2x, p4y = u * c1y + t * c2y,
				p5x = u * c2x + t * p2x, p5y = u * c2y + t * p2y,
				p6x = u * p3x + t * p4x, p6y = u * p3y + t * p4y,
				p7x = u * p4x + t * p5x, p7y = u * p4y + t * p5y,
				p8x = u * p6x + t * p7x, p8y = u * p6y + t * p7y;
			return [
				[p1x, p1y, p3x, p3y, p6x, p6y, p8x, p8y],
				[p8x, p8y, p7x, p7y, p5x, p5y, p2x, p2y]
			];
		},
	
		solveCubic: function (v, coord, val, roots, min, max) {
			var p1 = v[coord],
				c1 = v[coord + 2],
				c2 = v[coord + 4],
				p2 = v[coord + 6],
				c = 3 * (c1 - p1),
				b = 3 * (c2 - c1) - c,
				a = p2 - p1 - c - b;
			return Numerical.solveCubic(a, b, c, p1 - val, roots, min, max);
		},
	
		getParameterOf: function(v, x, y) {
			var tolerance = 0.000001;
			if (Math.abs(v[0] - x) < tolerance && Math.abs(v[1] - y) < tolerance)
				return 0;
			if (Math.abs(v[6] - x) < tolerance && Math.abs(v[7] - y) < tolerance)
				return 1;
			var txs = [],
				tys = [],
				sx = Curve.solveCubic(v, 0, x, txs, 0, 1),
				sy = Curve.solveCubic(v, 1, y, tys, 0, 1),
				tx, ty;
			for (var cx = 0;  sx === -1 || cx < sx;) {
				if (sx === -1 || (tx = txs[cx++]) > 0 && tx < 1) {
					for (var cy = 0; sy === -1 || cy < sy;) {
						if (sy === -1 || (ty = tys[cy++]) > 0 && ty < 1) {
							if (sx === -1) {
								tx = ty;
							} else if (sy === -1) {
								ty = tx;
							}
							if (Math.abs(tx - ty) < tolerance)
								return (tx + ty) * 0.5;
						}
					}
					if (sx === -1)
						break;
				}
			}
			return null;
		},
	
		getPart: function(v, from, to) {
			if (from > 0)
				v = Curve.subdivide(v, from)[1];
			if (to < 1)
				v = Curve.subdivide(v, (to - from) / (1 - from))[0];
			return v;
		},
	
		hasHandles: function(v) {
			var isZero = Numerical.isZero;
			return !(isZero(v[0] - v[2]) && isZero(v[1] - v[3])
					&& isZero(v[4] - v[6]) && isZero(v[5] - v[7]));
		},
	
		isLinear: function(v) {
			var p1x = v[0], p1y = v[1],
				p2x = v[6], p2y = v[7],
				l = new Point(p2x - p1x, p2y - p1y);
			return l.isCollinear(new Point(v[2] - p1x, v[3] - p1y))
					&& l.isCollinear(new Point(v[4] - p2x, v[5] - p2y));
		},
	
		isFlatEnough: function(v, tolerance) {
			var p1x = v[0], p1y = v[1],
				c1x = v[2], c1y = v[3],
				c2x = v[4], c2y = v[5],
				p2x = v[6], p2y = v[7],
				ux = 3 * c1x - 2 * p1x - p2x,
				uy = 3 * c1y - 2 * p1y - p2y,
				vx = 3 * c2x - 2 * p2x - p1x,
				vy = 3 * c2y - 2 * p2y - p1y;
			return Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy)
					< 10 * tolerance * tolerance;
		},
	
		getArea: function(v) {
			var p1x = v[0], p1y = v[1],
				c1x = v[2], c1y = v[3],
				c2x = v[4], c2y = v[5],
				p2x = v[6], p2y = v[7];
			return (  3.0 * c1y * p1x - 1.5 * c1y * c2x
					- 1.5 * c1y * p2x - 3.0 * p1y * c1x
					- 1.5 * p1y * c2x - 0.5 * p1y * p2x
					+ 1.5 * c2y * p1x + 1.5 * c2y * c1x
					- 3.0 * c2y * p2x + 0.5 * p2y * p1x
					+ 1.5 * p2y * c1x + 3.0 * p2y * c2x) / 10;
		},
	
		getEdgeSum: function(v) {
			return	  (v[0] - v[2]) * (v[3] + v[1])
					+ (v[2] - v[4]) * (v[5] + v[3])
					+ (v[4] - v[6]) * (v[7] + v[5]);
		},
	
		getBounds: function(v) {
			var min = v.slice(0, 2),
				max = min.slice(),
				roots = [0, 0];
			for (var i = 0; i < 2; i++)
				Curve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6],
						i, 0, min, max, roots);
			return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
		},
	
		_addBounds: function(v0, v1, v2, v3, coord, padding, min, max, roots) {
			function add(value, padding) {
				var left = value - padding,
					right = value + padding;
				if (left < min[coord])
					min[coord] = left;
				if (right > max[coord])
					max[coord] = right;
			}
			var a = 3 * (v1 - v2) - v0 + v3,
				b = 2 * (v0 + v2) - 4 * v1,
				c = v1 - v0,
				count = Numerical.solveQuadratic(a, b, c, roots),
				tMin = 0.000001,
				tMax = 1 - tMin;
			add(v3, 0);
			for (var i = 0; i < count; i++) {
				var t = roots[i],
					u = 1 - t;
				if (tMin < t && t < tMax)
					add(u * u * u * v0
						+ 3 * u * u * t * v1
						+ 3 * u * t * t * v2
						+ t * t * t * v3,
						padding);
			}
		}
	}}, Base.each(
		['getBounds', 'getStrokeBounds', 'getHandleBounds', 'getRoughBounds'],
		function(name) {
			this[name] = function() {
				if (!this._bounds)
					this._bounds = {};
				var bounds = this._bounds[name];
				if (!bounds) {
					bounds = this._bounds[name] = Path[name]([this._segment1,
							this._segment2], false, this._path.getStyle());
				}
				return bounds.clone();
			};
		},
	{
	
	}), {
		beans: false,
	
		getParameterAt: function(offset, start) {
			return Curve.getParameterAt(this.getValues(), offset, start);
		},
	
		getParameterOf: function() {
			var point = Point.read(arguments);
			return Curve.getParameterOf(this.getValues(), point.x, point.y);
		},
	
		getLocationAt: function(offset, isParameter) {
			var t = isParameter ? offset : this.getParameterAt(offset);
			return t != null && t >= 0 && t <= 1
					? new CurveLocation(this, t)
					: null;
		},
	
		getLocationOf: function() {
			return this.getLocationAt(this.getParameterOf(Point.read(arguments)),
					true);
		},
	
		getOffsetOf: function() {
			var loc = this.getLocationOf.apply(this, arguments);
			return loc ? loc.getOffset() : null;
		},
	
		getNearestLocation: function() {
			var point = Point.read(arguments),
				values = this.getValues(),
				count = 100,
				minDist = Infinity,
				minT = 0;
	
			function refine(t) {
				if (t >= 0 && t <= 1) {
					var dist = point.getDistance(Curve.getPoint(values, t), true);
					if (dist < minDist) {
						minDist = dist;
						minT = t;
						return true;
					}
				}
			}
	
			for (var i = 0; i <= count; i++)
				refine(i / count);
	
			var step = 1 / (count * 2);
			while (step > 0.000001) {
				if (!refine(minT - step) && !refine(minT + step))
					step /= 2;
			}
			var pt = Curve.getPoint(values, minT);
			return new CurveLocation(this, minT, pt, null, null, null,
					point.getDistance(pt));
		},
	
		getNearestPoint: function() {
			return this.getNearestLocation.apply(this, arguments).getPoint();
		}
	
	},
	new function() {
		var methods = ['getPoint', 'getTangent', 'getNormal', 'getWeightedTangent',
			'getWeightedNormal', 'getCurvature'];
		return Base.each(methods,
		function(name) {
			this[name + 'At'] = function(offset, isParameter) {
				var values = this.getValues();
				return Curve[name](values, isParameter ? offset
						: Curve.getParameterAt(values, offset, 0));
			};
		}, {
			statics: {
				evaluateMethods: methods
			}
		})
	},
	new function() {
	
		function getLengthIntegrand(v) {
			var p1x = v[0], p1y = v[1],
				c1x = v[2], c1y = v[3],
				c2x = v[4], c2y = v[5],
				p2x = v[6], p2y = v[7],
	
				ax = 9 * (c1x - c2x) + 3 * (p2x - p1x),
				bx = 6 * (p1x + c2x) - 12 * c1x,
				cx = 3 * (c1x - p1x),
	
				ay = 9 * (c1y - c2y) + 3 * (p2y - p1y),
				by = 6 * (p1y + c2y) - 12 * c1y,
				cy = 3 * (c1y - p1y);
	
			return function(t) {
				var dx = (ax * t + bx) * t + cx,
					dy = (ay * t + by) * t + cy;
				return Math.sqrt(dx * dx + dy * dy);
			};
		}
	
		function getIterations(a, b) {
			return Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));
		}
	
		function evaluate(v, t, type, normalized) {
			if (t == null || t < 0 || t > 1)
				return null;
			var p1x = v[0], p1y = v[1],
				c1x = v[2], c1y = v[3],
				c2x = v[4], c2y = v[5],
				p2x = v[6], p2y = v[7],
				tolerance = 0.000001,
				x, y;
	
			if (type === 0 && (t < tolerance || t > 1 - tolerance)) {
				var isZero = t < tolerance;
				x = isZero ? p1x : p2x;
				y = isZero ? p1y : p2y;
			} else {
				var cx = 3 * (c1x - p1x),
					bx = 3 * (c2x - c1x) - cx,
					ax = p2x - p1x - cx - bx,
	
					cy = 3 * (c1y - p1y),
					by = 3 * (c2y - c1y) - cy,
					ay = p2y - p1y - cy - by;
				if (type === 0) {
					x = ((ax * t + bx) * t + cx) * t + p1x;
					y = ((ay * t + by) * t + cy) * t + p1y;
				} else {
					if (t < tolerance) {
						x = cx;
						y = cy;
					} else if (t > 1 - tolerance) {
						x = 3 * (p2x - c2x);
						y = 3 * (p2y - c2y);
					} else {
						x = (3 * ax * t + 2 * bx) * t + cx;
						y = (3 * ay * t + 2 * by) * t + cy;
					}
					if (normalized) {
						if (x === 0 && y === 0
								&& (t < tolerance || t > 1 - tolerance)) {
							x = c2x - c1x;
							y = c2y - c1y;
						}
						var len = Math.sqrt(x * x + y * y);
						x /= len;
						y /= len;
					}
					if (type === 3) {
						var x2 = 6 * ax * t + 2 * bx,
							y2 = 6 * ay * t + 2 * by,
							d = Math.pow(x * x + y * y, 3 / 2);
						x = d !== 0 ? (x * y2 - y * x2) / d : 0;
						y = 0;
					}
				}
			}
			return type === 2 ? new Point(y, -x) : new Point(x, y);
		}
	
		return {
			statics: true,
	
			getLength: function(v, a, b) {
				if (a === undefined)
					a = 0;
				if (b === undefined)
					b = 1;
				var isZero = Numerical.isZero;
				if (a === 0 && b === 1
						&& isZero(v[0] - v[2]) && isZero(v[1] - v[3])
						&& isZero(v[6] - v[4]) && isZero(v[7] - v[5])) {
					var dx = v[6] - v[0],
						dy = v[7] - v[1];
					return Math.sqrt(dx * dx + dy * dy);
				}
				var ds = getLengthIntegrand(v);
				return Numerical.integrate(ds, a, b, getIterations(a, b));
			},
	
			getParameterAt: function(v, offset, start) {
				if (start === undefined)
					start = offset < 0 ? 1 : 0
				if (offset === 0)
					return start;
				var tolerance = 0.000001,
					abs = Math.abs,
					forward = offset > 0,
					a = forward ? start : 0,
					b = forward ? 1 : start,
					ds = getLengthIntegrand(v),
					rangeLength = Numerical.integrate(ds, a, b,
							getIterations(a, b));
				if (abs(offset - rangeLength) < tolerance) {
					return forward ? b : a;
				} else if (abs(offset) > rangeLength) {
					return null;
				}
				var guess = offset / rangeLength,
					length = 0;
				function f(t) {
					length += Numerical.integrate(ds, start, t,
							getIterations(start, t));
					start = t;
					return length - offset;
				}
				return Numerical.findRoot(f, ds, start + guess, a, b, 16,
						tolerance);
			},
	
			getPoint: function(v, t) {
				return evaluate(v, t, 0, false);
			},
	
			getTangent: function(v, t) {
				return evaluate(v, t, 1, true);
			},
	
			getWeightedTangent: function(v, t) {
				return evaluate(v, t, 1, false);
			},
	
			getNormal: function(v, t) {
				return evaluate(v, t, 2, true);
			},
	
			getWeightedNormal: function(v, t) {
				return evaluate(v, t, 2, false);
			},
	
			getCurvature: function(v, t) {
				return evaluate(v, t, 3, false).x;
			}
		};
	}, new function() {
		function addLocation(locations, include, curve1, t1, point1, curve2, t2,
				point2) {
			var loc = new CurveLocation(curve1, t1, point1, curve2, t2, point2);
			if (!include || include(loc))
				locations.push(loc);
		}
	
		function addCurveIntersections(v1, v2, curve1, curve2, locations, include,
				tMin, tMax, uMin, uMax, oldTDiff, reverse, recursion) {
			if (recursion > 32)
				return;
			var q0x = v2[0], q0y = v2[1], q3x = v2[6], q3y = v2[7],
				tolerance = 0.000001,
				getSignedDistance = Line.getSignedDistance,
				d1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]) || 0,
				d2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]) || 0,
				factor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,
				dMin = factor * Math.min(0, d1, d2),
				dMax = factor * Math.max(0, d1, d2),
				dp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),
				dp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),
				dp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),
				dp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),
				tMinNew, tMaxNew, tDiff;
			if (q0x === q3x && uMax - uMin < tolerance && recursion > 3) {
				tMaxNew = tMinNew = (tMax + tMin) / 2;
				tDiff = 0;
			} else {
				var hull = getConvexHull(dp0, dp1, dp2, dp3),
					top = hull[0],
					bottom = hull[1],
					tMinClip, tMaxClip;
				tMinClip = clipConvexHull(top, bottom, dMin, dMax);
				top.reverse();
				bottom.reverse();
				tMaxClip = clipConvexHull(top, bottom, dMin, dMax);
				if (tMinClip == null || tMaxClip == null)
					return;
				v1 = Curve.getPart(v1, tMinClip, tMaxClip);
				tDiff = tMaxClip - tMinClip;
				tMinNew = tMax * tMinClip + tMin * (1 - tMinClip);
				tMaxNew = tMax * tMaxClip + tMin * (1 - tMaxClip);
			}
			if (oldTDiff > 0.5 && tDiff > 0.5) {
				if (tMaxNew - tMinNew > uMax - uMin) {
					var parts = Curve.subdivide(v1, 0.5),
						t = tMinNew + (tMaxNew - tMinNew) / 2;
					addCurveIntersections(
						v2, parts[0], curve2, curve1, locations, include,
						uMin, uMax, tMinNew, t, tDiff, !reverse, ++recursion);
					addCurveIntersections(
						v2, parts[1], curve2, curve1, locations, include,
						uMin, uMax, t, tMaxNew, tDiff, !reverse, recursion);
				} else {
					var parts = Curve.subdivide(v2, 0.5),
						t = uMin + (uMax - uMin) / 2;
					addCurveIntersections(
						parts[0], v1, curve2, curve1, locations, include,
						uMin, t, tMinNew, tMaxNew, tDiff, !reverse, ++recursion);
					addCurveIntersections(
						parts[1], v1, curve2, curve1, locations, include,
						t, uMax, tMinNew, tMaxNew, tDiff, !reverse, recursion);
				}
			} else if (Math.max(uMax - uMin, tMaxNew - tMinNew) < tolerance) {
				var t1 = tMinNew + (tMaxNew - tMinNew) / 2,
					t2 = uMin + (uMax - uMin) / 2;
				if (reverse) {
					addLocation(locations, include,
							curve2, t2, Curve.getPoint(v2, t2),
							curve1, t1, Curve.getPoint(v1, t1));
				} else {
					addLocation(locations, include,
							curve1, t1, Curve.getPoint(v1, t1),
							curve2, t2, Curve.getPoint(v2, t2));
				}
			} else if (tDiff > 0) {
				addCurveIntersections(v2, v1, curve2, curve1, locations, include,
						uMin, uMax, tMinNew, tMaxNew, tDiff, !reverse, ++recursion);
			}
		}
	
		function getConvexHull(dq0, dq1, dq2, dq3) {
			var p0 = [ 0, dq0 ],
				p1 = [ 1 / 3, dq1 ],
				p2 = [ 2 / 3, dq2 ],
				p3 = [ 1, dq3 ],
				getSignedDistance = Line.getSignedDistance,
				dist1 = getSignedDistance(0, dq0, 1, dq3, 1 / 3, dq1),
				dist2 = getSignedDistance(0, dq0, 1, dq3, 2 / 3, dq2),
				flip = false,
				hull;
			if (dist1 * dist2 < 0) {
				hull = [[p0, p1, p3], [p0, p2, p3]];
				flip = dist1 < 0;
			} else {
				var pmax, cross = 0,
					distZero = dist1 === 0 || dist2 === 0;
				if (Math.abs(dist1) > Math.abs(dist2)) {
					pmax = p1;
					cross = (dq3 - dq2 - (dq3 - dq0) / 3)
							* (2 * (dq3 - dq2) - dq3 + dq1) / 3;
				} else {
					pmax = p2;
					cross = (dq1 - dq0 + (dq0 - dq3) / 3)
							* (-2 * (dq0 - dq1) + dq0 - dq2) / 3;
				}
				hull = cross < 0 || distZero
						? [[p0, pmax, p3], [p0, p3]]
						: [[p0, p1, p2, p3], [p0, p3]];
				flip = dist1 ? dist1 < 0 : dist2 < 0;
			}
			return flip ? hull.reverse() : hull;
		}
	
		function clipConvexHull(hullTop, hullBottom, dMin, dMax) {
			if (hullTop[0][1] < dMin) {
				return clipConvexHullPart(hullTop, true, dMin);
			} else if (hullBottom[0][1] > dMax) {
				return clipConvexHullPart(hullBottom, false, dMax);
			} else {
				return hullTop[0][0];
			}
		}
	
		function clipConvexHullPart(part, top, threshold) {
			var px = part[0][0],
				py = part[0][1];
			for (var i = 1, l = part.length; i < l; i++) {
				var qx = part[i][0],
					qy = part[i][1];
				if (top ? qy >= threshold : qy <= threshold)
					return px + (threshold - py) * (qx - px) / (qy - py);
				px = qx;
				py = qy;
			}
			return null;
		}
	
		function addCurveLineIntersections(v1, v2, curve1, curve2, locations,
				include) {
			var flip = Curve.isLinear(v1),
				vc = flip ? v2 : v1,
				vl = flip ? v1 : v2,
				lx1 = vl[0], ly1 = vl[1],
				lx2 = vl[6], ly2 = vl[7],
				ldx = lx2 - lx1,
				ldy = ly2 - ly1,
				angle = Math.atan2(-ldy, ldx),
				sin = Math.sin(angle),
				cos = Math.cos(angle),
				rlx2 = ldx * cos - ldy * sin,
				rvl = [0, 0, 0, 0, rlx2, 0, rlx2, 0],
				rvc = [];
			for(var i = 0; i < 8; i += 2) {
				var x = vc[i] - lx1,
					y = vc[i + 1] - ly1;
				rvc.push(
					x * cos - y * sin,
					y * cos + x * sin);
			}
			var roots = [],
				count = Curve.solveCubic(rvc, 1, 0, roots, 0, 1);
			for (var i = 0; i < count; i++) {
				var tc = roots[i],
					x = Curve.getPoint(rvc, tc).x;
				if (x >= 0 && x <= rlx2) {
					var tl = Curve.getParameterOf(rvl, x, 0),
						t1 = flip ? tl : tc,
						t2 = flip ? tc : tl;
					addLocation(locations, include,
							curve1, t1, Curve.getPoint(v1, t1),
							curve2, t2, Curve.getPoint(v2, t2));
				}
			}
		}
	
		function addLineIntersection(v1, v2, curve1, curve2, locations, include) {
			var point = Line.intersect(
					v1[0], v1[1], v1[6], v1[7],
					v2[0], v2[1], v2[6], v2[7]);
			if (point) {
				var x = point.x,
					y = point.y;
				addLocation(locations, include,
						curve1, Curve.getParameterOf(v1, x, y), point,
						curve2, Curve.getParameterOf(v2, x, y), point);
			}
		}
	
		return { statics: {
			getIntersections: function(v1, v2, c1, c2, locations, include) {
				var linear1 = Curve.isLinear(v1),
					linear2 = Curve.isLinear(v2),
					c1p1 = c1.getPoint1(),
					c1p2 = c1.getPoint2(),
					c2p1 = c2.getPoint1(),
					c2p2 = c2.getPoint2(),
					tolerance = 0.000001;
				if (c1p1.isClose(c2p1, tolerance))
					addLocation(locations, include, c1, 0, c1p1, c2, 0, c1p1);
				if (c1p1.isClose(c2p2, tolerance))
					addLocation(locations, include, c1, 0, c1p1, c2, 1, c1p1);
				(linear1 && linear2
					? addLineIntersection
					: linear1 || linear2
						? addCurveLineIntersections
						: addCurveIntersections)(
							v1, v2, c1, c2, locations, include,
							0, 1, 0, 1, 0, false, 0);
				if (c1p2.isClose(c2p1, tolerance))
					addLocation(locations, include, c1, 1, c1p2, c2, 0, c1p2);
				if (c1p2.isClose(c2p2, tolerance))
					addLocation(locations, include, c1, 1, c1p2, c2, 1, c1p2);
				return locations;
			},
	
			filterIntersections: function(locations, _expand) {
				var last = locations.length - 1,
					tMax = 1 - 0.000001;
				for (var i = last; i >= 0; i--) {
					var loc = locations[i],
						next = loc._curve.getNext(),
						next2 = loc._curve2.getNext();
					if (next && loc._parameter >= tMax) {
						loc._parameter = 0;
						loc._curve = next;
					}
					if (next2 && loc._parameter2 >= tMax) {
						loc._parameter2 = 0;
						loc._curve2 = next2;
					}
				}
	
				function compare(loc1, loc2) {
					var path1 = loc1.getPath(),
						path2 = loc2.getPath();
					return path1 === path2
							? (loc1.getIndex() + loc1.getParameter())
									- (loc2.getIndex() + loc2.getParameter())
							: path1._id - path2._id;
				}
	
				if (last > 0) {
					locations.sort(compare);
					for (var i = last; i > 0; i--) {
						if (locations[i].equals(locations[i - 1])) {
							locations.splice(i, 1);
							last--;
						}
					}
				}
				if (_expand) {
					for (var i = last; i >= 0; i--)
						locations.push(locations[i].getIntersection());
					locations.sort(compare);
				}
				return locations;
			}
		}};
	});
	
	var CurveLocation = Base.extend({
		_class: 'CurveLocation',
		beans: true,
	
		initialize: function CurveLocation(curve, parameter, point, _curve2,
				_parameter2, _point2, _distance) {
			this._id = UID.get(CurveLocation);
			var path = curve._path;
			this._version = path ? path._version : 0;
			this._curve = curve;
			this._parameter = parameter;
			this._point = point || curve.getPointAt(parameter, true);
			this._curve2 = _curve2;
			this._parameter2 = _parameter2;
			this._point2 = _point2;
			this._distance = _distance;
			this._segment1 = curve._segment1;
			this._segment2 = curve._segment2;
		},
	
		getSegment: function(_preferFirst) {
			if (!this._segment) {
				var curve = this.getCurve(),
					parameter = this.getParameter();
				if (parameter === 1) {
					this._segment = curve._segment2;
				} else if (parameter === 0 || _preferFirst) {
					this._segment = curve._segment1;
				} else if (parameter == null) {
					return null;
				} else {
					this._segment = curve.getPartLength(0, parameter)
						< curve.getPartLength(parameter, 1)
							? curve._segment1
							: curve._segment2;
				}
			}
			return this._segment;
		},
	
		getCurve: function() {
			var curve = this._curve,
				path = curve && curve._path;
			if (path && path._version !== this._version) {
				curve = null;
				this._parameter = null;
			}
			if (!curve) {
				curve = this._segment1.getCurve();
				if (curve.getParameterOf(this._point) == null)
					curve = this._segment2.getPrevious().getCurve();
				this._curve = curve;
				path = curve._path;
				this._version = path ? path._version : 0;
			}
			return curve;
		},
	
		getPath: function() {
			var curve = this.getCurve();
			return curve && curve._path;
		},
	
		getIndex: function() {
			var curve = this.getCurve();
			return curve && curve.getIndex();
		},
	
		getParameter: function() {
			var curve = this.getCurve(),
				parameter = this._parameter;
			return curve && parameter == null
				? this._parameter = curve.getParameterOf(this._point)
				: parameter;
		},
	
		getPoint: function() {
			return this._point;
		},
	
		getOffset: function() {
			var path = this.getPath();
			return path ? path._getOffset(this) : this.getCurveOffset();
		},
	
		getCurveOffset: function() {
			var curve = this.getCurve(),
				parameter = this.getParameter();
			return parameter != null && curve && curve.getPartLength(0, parameter);
		},
	
		getIntersection: function() {
			var intersection = this._intersection;
			if (!intersection && this._curve2) {
				this._intersection = intersection = new CurveLocation(this._curve2,
						this._parameter2, this._point2 || this._point, this);
				intersection._intersection = this;
			}
			return intersection;
		},
	
		getDistance: function() {
			return this._distance;
		},
	
		divide: function() {
			var curve = this.getCurve();
			return curve && curve.divide(this.getParameter(), true);
		},
	
		split: function() {
			var curve = this.getCurve();
			return curve && curve.split(this.getParameter(), true);
		},
	
		equals: function(loc) {
			var abs = Math.abs,
				tolerance = 0.000001;
			return this === loc
					|| loc instanceof CurveLocation
						&& this.getCurve() === loc.getCurve()
						&& abs(this.getParameter() - loc.getParameter()) < tolerance
						&& this._curve2 === loc._curve2
						&& abs(this._parameter2 - loc._parameter2) < tolerance
					|| false;
		},
	
		toString: function() {
			var parts = [],
				point = this.getPoint(),
				f = Formatter.instance;
			if (point)
				parts.push('point: ' + point);
			var index = this.getIndex();
			if (index != null)
				parts.push('index: ' + index);
			var parameter = this.getParameter();
			if (parameter != null)
				parts.push('parameter: ' + f.number(parameter));
			if (this._distance != null)
				parts.push('distance: ' + f.number(this._distance));
			return '{ ' + parts.join(', ') + ' }';
		}
	}, Base.each(Curve.evaluateMethods, function(name) {
		if (name !== 'getPoint') {
			var get = name + 'At';
			this[name] = function() {
				var parameter = this.getParameter(),
					curve = this.getCurve();
				return parameter != null && curve && curve[get](parameter, true);
			};
		}
	}, {}));
	
	var PathItem = Item.extend({
		_class: 'PathItem',
	
		initialize: function PathItem() {
		},
	
		getIntersections: function(path, _matrix, _expand) {
			if (this === path)
				path = null;
			var locations = [],
				curves1 = this.getCurves(),
				curves2 = path ? path.getCurves() : curves1,
				matrix1 = this._matrix.orNullIfIdentity(),
				matrix2 = path ? (_matrix || path._matrix).orNullIfIdentity()
					: matrix1,
				length1 = curves1.length,
				length2 = path ? curves2.length : length1,
				values2 = [],
				tMin = 0.000001,
				tMax = 1 - tMin;
			if (path && !this.getBounds(matrix1).touches(path.getBounds(matrix2)))
				return [];
			for (var i = 0; i < length2; i++)
				values2[i] = curves2[i].getValues(matrix2);
			for (var i = 0; i < length1; i++) {
				var curve1 = curves1[i],
					values1 = path ? curve1.getValues(matrix1) : values2[i];
				if (!path) {
					var seg1 = curve1.getSegment1(),
						seg2 = curve1.getSegment2(),
						h1 = seg1._handleOut,
						h2 = seg2._handleIn;
					if (new Line(seg1._point.subtract(h1), h1.multiply(2), true)
							.intersect(new Line(seg2._point.subtract(h2),
							h2.multiply(2), true), false)) {
						var parts = Curve.subdivide(values1);
						Curve.getIntersections(
							parts[0], parts[1], curve1, curve1, locations,
							function(loc) {
								if (loc._parameter <= tMax) {
									loc._parameter /= 2;
									loc._parameter2 = 0.5 + loc._parameter2 / 2;
									return true;
								}
							}
						);
					}
				}
				for (var j = path ? 0 : i + 1; j < length2; j++) {
					Curve.getIntersections(
						values1, values2[j], curve1, curves2[j], locations,
						!path && (j === i + 1 || j === length2 - 1 && i === 0)
							&& function(loc) {
								var t = loc._parameter;
								return t >= tMin && t <= tMax;
							}
					);
				}
			}
			return Curve.filterIntersections(locations, _expand);
		},
	
		_asPathItem: function() {
			return this;
		},
	
		setPathData: function(data) {
	
			var parts = data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),
				coords,
				relative = false,
				previous,
				control,
				current = new Point(),
				start = new Point();
	
			function getCoord(index, coord) {
				var val = +coords[index];
				if (relative)
					val += current[coord];
				return val;
			}
	
			function getPoint(index) {
				return new Point(
					getCoord(index, 'x'),
					getCoord(index + 1, 'y')
				);
			}
	
			this.clear();
	
			for (var i = 0, l = parts && parts.length; i < l; i++) {
				var part = parts[i],
					command = part[0],
					lower = command.toLowerCase();
				coords = part.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
				var length = coords && coords.length;
				relative = command === lower;
				if (previous === 'z' && !/[mz]/.test(lower))
					this.moveTo(current = start);
				switch (lower) {
				case 'm':
				case 'l':
					var move = lower === 'm';
					for (var j = 0; j < length; j += 2)
						this[j === 0 && move ? 'moveTo' : 'lineTo'](
								current = getPoint(j));
					control = current;
					if (move)
						start = current;
					break;
				case 'h':
				case 'v':
					var coord = lower === 'h' ? 'x' : 'y';
					for (var j = 0; j < length; j++) {
						current[coord] = getCoord(j, coord);
						this.lineTo(current);
					}
					control = current;
					break;
				case 'c':
					for (var j = 0; j < length; j += 6) {
						this.cubicCurveTo(
								getPoint(j),
								control = getPoint(j + 2),
								current = getPoint(j + 4));
					}
					break;
				case 's':
					for (var j = 0; j < length; j += 4) {
						this.cubicCurveTo(
								/[cs]/.test(previous)
										? current.multiply(2).subtract(control)
										: current,
								control = getPoint(j),
								current = getPoint(j + 2));
						previous = lower;
					}
					break;
				case 'q':
					for (var j = 0; j < length; j += 4) {
						this.quadraticCurveTo(
								control = getPoint(j),
								current = getPoint(j + 2));
					}
					break;
				case 't':
					for (var j = 0; j < length; j += 2) {
						this.quadraticCurveTo(
								control = (/[qt]/.test(previous)
										? current.multiply(2).subtract(control)
										: current),
								current = getPoint(j));
						previous = lower;
					}
					break;
				case 'a':
					for (var j = 0; j < length; j += 7) {
						this.arcTo(current = getPoint(j + 5),
								new Size(+coords[j], +coords[j + 1]),
								+coords[j + 2], +coords[j + 4], +coords[j + 3]);
					}
					break;
				case 'z':
					this.closePath(true);
					break;
				}
				previous = lower;
			}
		},
	
		_canComposite: function() {
			return !(this.hasFill() && this.hasStroke());
		},
	
		_contains: function(point) {
			var winding = this._getWinding(point, false, true);
			return !!(this.getWindingRule() === 'evenodd' ? winding & 1 : winding);
		}
	
	});
	
	var Path = PathItem.extend({
		_class: 'Path',
		_serializeFields: {
			segments: [],
			closed: false
		},
	
		initialize: function Path(arg) {
			this._closed = false;
			this._segments = [];
			this._version = 0;
			var segments = Array.isArray(arg)
				? typeof arg[0] === 'object'
					? arg
					: arguments
				: arg && (arg.size === undefined && (arg.x !== undefined
						|| arg.point !== undefined))
					? arguments
					: null;
			if (segments && segments.length > 0) {
				this.setSegments(segments);
			} else {
				this._curves = undefined;
				this._selectedSegmentState = 0;
				if (!segments && typeof arg === 'string') {
					this.setPathData(arg);
					arg = null;
				}
			}
			this._initialize(!segments && arg);
		},
	
		_equals: function(item) {
			return this._closed === item._closed
					&& Base.equals(this._segments, item._segments);
		},
	
		clone: function(insert) {
			var copy = new Path(Item.NO_INSERT);
			copy.setSegments(this._segments);
			copy._closed = this._closed;
			if (this._clockwise !== undefined)
				copy._clockwise = this._clockwise;
			return this._clone(copy, insert);
		},
	
		_changed: function _changed(flags) {
			_changed.base.call(this, flags);
			if (flags & 8) {
				var parent = this._parent;
				if (parent)
					parent._currentPath = undefined;
				this._length = this._clockwise = undefined;
				if (flags & 16) {
					this._version++;
				} else if (this._curves) {
				   for (var i = 0, l = this._curves.length; i < l; i++)
						this._curves[i]._changed();
				}
				this._monoCurves = undefined;
			} else if (flags & 32) {
				this._bounds = undefined;
			}
		},
	
		getStyle: function() {
			var parent = this._parent;
			return (parent instanceof CompoundPath ? parent : this)._style;
		},
	
		getSegments: function() {
			return this._segments;
		},
	
		setSegments: function(segments) {
			var fullySelected = this.isFullySelected();
			this._segments.length = 0;
			this._selectedSegmentState = 0;
			this._curves = undefined;
			if (segments && segments.length > 0)
				this._add(Segment.readAll(segments));
			if (fullySelected)
				this.setFullySelected(true);
		},
	
		getFirstSegment: function() {
			return this._segments[0];
		},
	
		getLastSegment: function() {
			return this._segments[this._segments.length - 1];
		},
	
		getCurves: function() {
			var curves = this._curves,
				segments = this._segments;
			if (!curves) {
				var length = this._countCurves();
				curves = this._curves = new Array(length);
				for (var i = 0; i < length; i++)
					curves[i] = new Curve(this, segments[i],
						segments[i + 1] || segments[0]);
			}
			return curves;
		},
	
		getFirstCurve: function() {
			return this.getCurves()[0];
		},
	
		getLastCurve: function() {
			var curves = this.getCurves();
			return curves[curves.length - 1];
		},
	
		isClosed: function() {
			return this._closed;
		},
	
		setClosed: function(closed) {
			if (this._closed != (closed = !!closed)) {
				this._closed = closed;
				if (this._curves) {
					var length = this._curves.length = this._countCurves();
					if (closed)
						this._curves[length - 1] = new Curve(this,
							this._segments[length - 1], this._segments[0]);
				}
				this._changed(25);
			}
		}
	}, {
		beans: true,
	
		getPathData: function(_matrix, _precision) {
			var segments = this._segments,
				length = segments.length,
				f = new Formatter(_precision),
				coords = new Array(6),
				first = true,
				curX, curY,
				prevX, prevY,
				inX, inY,
				outX, outY,
				parts = [];
	
			function addSegment(segment, skipLine) {
				segment._transformCoordinates(_matrix, coords, false);
				curX = coords[0];
				curY = coords[1];
				if (first) {
					parts.push('M' + f.pair(curX, curY));
					first = false;
				} else {
					inX = coords[2];
					inY = coords[3];
					if (inX === curX && inY === curY
							&& outX === prevX && outY === prevY) {
						if (!skipLine)
							parts.push('l' + f.pair(curX - prevX, curY - prevY));
					} else {
						parts.push('c' + f.pair(outX - prevX, outY - prevY)
								+ ' ' + f.pair(inX - prevX, inY - prevY)
								+ ' ' + f.pair(curX - prevX, curY - prevY));
					}
				}
				prevX = curX;
				prevY = curY;
				outX = coords[4];
				outY = coords[5];
			}
	
			if (length === 0)
				return '';
	
			for (var i = 0; i < length; i++)
				addSegment(segments[i]);
			if (this._closed && length > 0) {
				addSegment(segments[0], true);
				parts.push('z');
			}
			return parts.join('');
		}
	}, {
	
		isEmpty: function() {
			return this._segments.length === 0;
		},
	
		isLinear: function() {
			var segments = this._segments;
			for (var i = 0, l = segments.length; i < l; i++) {
				if (!segments[i].isLinear())
					return false;
			}
			return true;
		},
	
		hasHandles: function() {
			var segments = this._segments;
			for (var i = 0, l = segments.length; i < l; i++) {
				if (segments[i].hasHandles())
					return true;
			}
			return false;
		},
	
		_transformContent: function(matrix) {
			var coords = new Array(6);
			for (var i = 0, l = this._segments.length; i < l; i++)
				this._segments[i]._transformCoordinates(matrix, coords, true);
			return true;
		},
	
		_add: function(segs, index) {
			var segments = this._segments,
				curves = this._curves,
				amount = segs.length,
				append = index == null,
				index = append ? segments.length : index;
			for (var i = 0; i < amount; i++) {
				var segment = segs[i];
				if (segment._path)
					segment = segs[i] = segment.clone();
				segment._path = this;
				segment._index = index + i;
				if (segment._selectionState)
					this._updateSelection(segment, 0, segment._selectionState);
			}
			if (append) {
				segments.push.apply(segments, segs);
			} else {
				segments.splice.apply(segments, [index, 0].concat(segs));
				for (var i = index + amount, l = segments.length; i < l; i++)
					segments[i]._index = i;
			}
			if (curves || segs._curves) {
				if (!curves)
					curves = this._curves = [];
				var from = index > 0 ? index - 1 : index,
					start = from,
					to = Math.min(from + amount, this._countCurves());
				if (segs._curves) {
					curves.splice.apply(curves, [from, 0].concat(segs._curves));
					start += segs._curves.length;
				}
				for (var i = start; i < to; i++)
					curves.splice(i, 0, new Curve(this, null, null));
				this._adjustCurves(from, to);
			}
			this._changed(25);
			return segs;
		},
	
		_adjustCurves: function(from, to) {
			var segments = this._segments,
				curves = this._curves,
				curve;
			for (var i = from; i < to; i++) {
				curve = curves[i];
				curve._path = this;
				curve._segment1 = segments[i];
				curve._segment2 = segments[i + 1] || segments[0];
				curve._changed();
			}
			if (curve = curves[this._closed && from === 0 ? segments.length - 1
					: from - 1]) {
				curve._segment2 = segments[from] || segments[0];
				curve._changed();
			}
			if (curve = curves[to]) {
				curve._segment1 = segments[to];
				curve._changed();
			}
		},
	
		_countCurves: function() {
			var length = this._segments.length;
			return !this._closed && length > 0 ? length - 1 : length;
		},
	
		add: function(segment1 ) {
			return arguments.length > 1 && typeof segment1 !== 'number'
				? this._add(Segment.readAll(arguments))
				: this._add([ Segment.read(arguments) ])[0];
		},
	
		insert: function(index, segment1 ) {
			return arguments.length > 2 && typeof segment1 !== 'number'
				? this._add(Segment.readAll(arguments, 1), index)
				: this._add([ Segment.read(arguments, 1) ], index)[0];
		},
	
		addSegment: function() {
			return this._add([ Segment.read(arguments) ])[0];
		},
	
		insertSegment: function(index ) {
			return this._add([ Segment.read(arguments, 1) ], index)[0];
		},
	
		addSegments: function(segments) {
			return this._add(Segment.readAll(segments));
		},
	
		insertSegments: function(index, segments) {
			return this._add(Segment.readAll(segments), index);
		},
	
		removeSegment: function(index) {
			return this.removeSegments(index, index + 1)[0] || null;
		},
	
		removeSegments: function(from, to, _includeCurves) {
			from = from || 0;
			to = Base.pick(to, this._segments.length);
			var segments = this._segments,
				curves = this._curves,
				count = segments.length,
				removed = segments.splice(from, to - from),
				amount = removed.length;
			if (!amount)
				return removed;
			for (var i = 0; i < amount; i++) {
				var segment = removed[i];
				if (segment._selectionState)
					this._updateSelection(segment, segment._selectionState, 0);
				segment._index = segment._path = null;
			}
			for (var i = from, l = segments.length; i < l; i++)
				segments[i]._index = i;
			if (curves) {
				var index = from > 0 && to === count + (this._closed ? 1 : 0)
						? from - 1
						: from,
					curves = curves.splice(index, amount);
				if (_includeCurves)
					removed._curves = curves.slice(1);
				this._adjustCurves(index, index);
			}
			this._changed(25);
			return removed;
		},
	
		clear: '#removeSegments',
	
		getLength: function() {
			if (this._length == null) {
				var curves = this.getCurves();
				this._length = 0;
				for (var i = 0, l = curves.length; i < l; i++)
					this._length += curves[i].getLength();
			}
			return this._length;
		},
	
		getArea: function() {
			var curves = this.getCurves();
			var area = 0;
			for (var i = 0, l = curves.length; i < l; i++)
				area += curves[i].getArea();
			return area;
		},
	
		isFullySelected: function() {
			var length = this._segments.length;
			return this._selected && length > 0 && this._selectedSegmentState
					=== length * 7;
		},
	
		setFullySelected: function(selected) {
			if (selected)
				this._selectSegments(true);
			this.setSelected(selected);
		},
	
		setSelected: function setSelected(selected) {
			if (!selected)
				this._selectSegments(false);
			setSelected.base.call(this, selected);
		},
	
		_selectSegments: function(selected) {
			var length = this._segments.length;
			this._selectedSegmentState = selected
					? length * 7 : 0;
			for (var i = 0; i < length; i++)
				this._segments[i]._selectionState = selected
						? 7 : 0;
		},
	
		_updateSelection: function(segment, oldState, newState) {
			segment._selectionState = newState;
			var total = this._selectedSegmentState += newState - oldState;
			if (total > 0)
				this.setSelected(true);
		},
	
		flatten: function(maxDistance) {
			var iterator = new PathIterator(this, 64, 0.1),
				pos = 0,
				step = iterator.length / Math.ceil(iterator.length / maxDistance),
				end = iterator.length + (this._closed ? -step : step) / 2;
			var segments = [];
			while (pos <= end) {
				segments.push(new Segment(iterator.getPointAt(pos)));
				pos += step;
			}
			this.setSegments(segments);
		},
	
		reduce: function() {
			var curves = this.getCurves();
			for (var i = curves.length - 1; i >= 0; i--) {
				var curve = curves[i];
				if (curve.isLinear() && curve.getLength() === 0)
					curve.remove();
			}
			return this;
		},
	
		simplify: function(tolerance) {
			if (this._segments.length > 2) {
				var fitter = new PathFitter(this, tolerance || 2.5);
				this.setSegments(fitter.fit());
			}
		},
	
		split: function(index, parameter) {
			if (parameter === null)
				return null;
			if (arguments.length === 1) {
				var arg = index;
				if (typeof arg === 'number')
					arg = this.getLocationAt(arg);
				if (!arg)
					return null
				index = arg.index;
				parameter = arg.parameter;
			}
			var tolerance = 0.000001;
			if (parameter >= 1 - tolerance) {
				index++;
				parameter--;
			}
			var curves = this.getCurves();
			if (index >= 0 && index < curves.length) {
				if (parameter > tolerance) {
					curves[index++].divide(parameter, true);
				}
				var segs = this.removeSegments(index, this._segments.length, true),
					path;
				if (this._closed) {
					this.setClosed(false);
					path = this;
				} else {
					path = this._clone(new Path().insertAbove(this, true));
				}
				path._add(segs, 0);
				this.addSegment(segs[0]);
				return path;
			}
			return null;
		},
	
		isClockwise: function() {
			if (this._clockwise !== undefined)
				return this._clockwise;
			return Path.isClockwise(this._segments);
		},
	
		setClockwise: function(clockwise) {
			if (this.isClockwise() != (clockwise = !!clockwise))
				this.reverse();
			this._clockwise = clockwise;
		},
	
		reverse: function() {
			this._segments.reverse();
			for (var i = 0, l = this._segments.length; i < l; i++) {
				var segment = this._segments[i];
				var handleIn = segment._handleIn;
				segment._handleIn = segment._handleOut;
				segment._handleOut = handleIn;
				segment._index = i;
			}
			this._curves = null;
			if (this._clockwise !== undefined)
				this._clockwise = !this._clockwise;
			this._changed(9);
		},
	
		join: function(path) {
			if (path) {
				var segments = path._segments,
					last1 = this.getLastSegment(),
					last2 = path.getLastSegment();
				if (!last2)
					return this;
				if (last1 && last1._point.equals(last2._point))
					path.reverse();
				var first2 = path.getFirstSegment();
				if (last1 && last1._point.equals(first2._point)) {
					last1.setHandleOut(first2._handleOut);
					this._add(segments.slice(1));
				} else {
					var first1 = this.getFirstSegment();
					if (first1 && first1._point.equals(first2._point))
						path.reverse();
					last2 = path.getLastSegment();
					if (first1 && first1._point.equals(last2._point)) {
						first1.setHandleIn(last2._handleIn);
						this._add(segments.slice(0, segments.length - 1), 0);
					} else {
						this._add(segments.slice());
					}
				}
				if (path.closed)
					this._add([segments[0]]);
				path.remove();
			}
			var first = this.getFirstSegment(),
				last = this.getLastSegment();
			if (first !== last && first._point.equals(last._point)) {
				first.setHandleIn(last._handleIn);
				last.remove();
				this.setClosed(true);
			}
			return this;
		},
	
		toShape: function(insert) {
			if (!this._closed)
				return null;
	
			var segments = this._segments,
				type,
				size,
				radius,
				topCenter;
	
			function isCollinear(i, j) {
				return segments[i].isCollinear(segments[j]);
			}
	
			function isOrthogonal(i) {
				return segments[i].isOrthogonal();
			}
	
			function isArc(i) {
				return segments[i].isOrthogonalArc();
			}
	
			function getDistance(i, j) {
				return segments[i]._point.getDistance(segments[j]._point);
			}
	
			if (!this.hasHandles() && segments.length === 4
					&& isCollinear(0, 2) && isCollinear(1, 3) && isOrthogonal(1)) {
				type = Shape.Rectangle;
				size = new Size(getDistance(0, 3), getDistance(0, 1));
				topCenter = segments[1]._point.add(segments[2]._point).divide(2);
			} else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4)
					&& isArc(6) && isCollinear(1, 5) && isCollinear(3, 7)) {
				type = Shape.Rectangle;
				size = new Size(getDistance(1, 6), getDistance(0, 3));
				radius = size.subtract(new Size(getDistance(0, 7),
						getDistance(1, 2))).divide(2);
				topCenter = segments[3]._point.add(segments[4]._point).divide(2);
			} else if (segments.length === 4
					&& isArc(0) && isArc(1) && isArc(2) && isArc(3)) {
				if (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {
					type = Shape.Circle;
					radius = getDistance(0, 2) / 2;
				} else {
					type = Shape.Ellipse;
					radius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);
				}
				topCenter = segments[1]._point;
			}
	
			if (type) {
				var center = this.getPosition(true),
					shape = this._clone(new type({
						center: center,
						size: size,
						radius: radius,
						insert: false
					}), insert, false);
				shape.rotate(topCenter.subtract(center).getAngle() + 90);
				return shape;
			}
			return null;
		},
	
		_hitTestSelf: function(point, options) {
			var that = this,
				style = this.getStyle(),
				segments = this._segments,
				numSegments = segments.length,
				closed = this._closed,
				tolerancePadding = options._tolerancePadding,
				strokePadding = tolerancePadding,
				join, cap, miterLimit,
				area, loc, res,
				hitStroke = options.stroke && style.hasStroke(),
				hitFill = options.fill && style.hasFill(),
				hitCurves = options.curves,
				radius = hitStroke
						? style.getStrokeWidth() / 2
						: hitFill && options.tolerance > 0 || hitCurves
							? 0 : null;
			if (radius !== null) {
				if (radius > 0) {
					join = style.getStrokeJoin();
					cap = style.getStrokeCap();
					miterLimit = radius * style.getMiterLimit();
					strokePadding = tolerancePadding.add(new Point(radius, radius));
				} else {
					join = cap = 'round';
				}
			}
	
			function isCloseEnough(pt, padding) {
				return point.subtract(pt).divide(padding).length <= 1;
			}
	
			function checkSegmentPoint(seg, pt, name) {
				if (!options.selected || pt.isSelected()) {
					var anchor = seg._point;
					if (pt !== anchor)
						pt = pt.add(anchor);
					if (isCloseEnough(pt, strokePadding)) {
						return new HitResult(name, that, {
							segment: seg,
							point: pt
						});
					}
				}
			}
	
			function checkSegmentPoints(seg, ends) {
				return (ends || options.segments)
					&& checkSegmentPoint(seg, seg._point, 'segment')
					|| (!ends && options.handles) && (
						checkSegmentPoint(seg, seg._handleIn, 'handle-in') ||
						checkSegmentPoint(seg, seg._handleOut, 'handle-out'));
			}
	
			function addToArea(point) {
				area.add(point);
			}
	
			function checkSegmentStroke(segment) {
				if (join !== 'round' || cap !== 'round') {
					area = new Path({ internal: true, closed: true });
					if (closed || segment._index > 0
							&& segment._index < numSegments - 1) {
						if (join !== 'round' && (segment._handleIn.isZero()
								|| segment._handleOut.isZero()))
							Path._addBevelJoin(segment, join, radius, miterLimit,
									addToArea, true);
					} else if (cap !== 'round') {
						Path._addSquareCap(segment, cap, radius, addToArea, true);
					}
					if (!area.isEmpty()) {
						var loc;
						return area.contains(point)
							|| (loc = area.getNearestLocation(point))
								&& isCloseEnough(loc.getPoint(), tolerancePadding);
					}
				}
				return isCloseEnough(segment._point, strokePadding);
			}
	
			if (options.ends && !options.segments && !closed) {
				if (res = checkSegmentPoints(segments[0], true)
						|| checkSegmentPoints(segments[numSegments - 1], true))
					return res;
			} else if (options.segments || options.handles) {
				for (var i = 0; i < numSegments; i++)
					if (res = checkSegmentPoints(segments[i]))
						return res;
			}
			if (radius !== null) {
				loc = this.getNearestLocation(point);
				if (loc) {
					var parameter = loc.getParameter();
					if (parameter === 0 || parameter === 1 && numSegments > 1) {
						if (!checkSegmentStroke(loc.getSegment()))
							loc = null;
					} else if (!isCloseEnough(loc.getPoint(), strokePadding)) {
						loc = null;
					}
				}
				if (!loc && join === 'miter' && numSegments > 1) {
					for (var i = 0; i < numSegments; i++) {
						var segment = segments[i];
						if (point.getDistance(segment._point) <= miterLimit
								&& checkSegmentStroke(segment)) {
							loc = segment.getLocation();
							break;
						}
					}
				}
			}
			return !loc && hitFill && this._contains(point)
					|| loc && !hitStroke && !hitCurves
						? new HitResult('fill', this)
						: loc
							? new HitResult(hitStroke ? 'stroke' : 'curve', this, {
								location: loc,
								point: loc.getPoint()
							})
							: null;
		}
	
	}, Base.each(Curve.evaluateMethods,
		function(name) {
			this[name + 'At'] = function(offset, isParameter) {
				var loc = this.getLocationAt(offset, isParameter);
				return loc && loc[name]();
			};
		},
	{
		beans: false,
	
		_getOffset: function(location) {
			var index = location && location.getIndex();
			if (index != null) {
				var curves = this.getCurves(),
					offset = 0;
				for (var i = 0; i < index; i++)
					offset += curves[i].getLength();
				var curve = curves[index],
					parameter = location.getParameter();
				if (parameter > 0)
					offset += curve.getPartLength(0, parameter);
				return offset;
			}
			return null;
		},
	
		getLocationOf: function() {
			var point = Point.read(arguments),
				curves = this.getCurves();
			for (var i = 0, l = curves.length; i < l; i++) {
				var loc = curves[i].getLocationOf(point);
				if (loc)
					return loc;
			}
			return null;
		},
	
		getOffsetOf: function() {
			var loc = this.getLocationOf.apply(this, arguments);
			return loc ? loc.getOffset() : null;
		},
	
		getLocationAt: function(offset, isParameter) {
			var curves = this.getCurves(),
				length = 0;
			if (isParameter) {
				var index = ~~offset,
					curve = curves[index];
				return curve ? curve.getLocationAt(offset - index, true) : null;
			}
			for (var i = 0, l = curves.length; i < l; i++) {
				var start = length,
					curve = curves[i];
				length += curve.getLength();
				if (length > offset) {
					return curve.getLocationAt(offset - start);
				}
			}
			if (offset <= this.getLength())
				return new CurveLocation(curves[curves.length - 1], 1);
			return null;
		},
	
		getNearestLocation: function() {
			var point = Point.read(arguments),
				curves = this.getCurves(),
				minDist = Infinity,
				minLoc = null;
			for (var i = 0, l = curves.length; i < l; i++) {
				var loc = curves[i].getNearestLocation(point);
				if (loc._distance < minDist) {
					minDist = loc._distance;
					minLoc = loc;
				}
			}
			return minLoc;
		},
	
		getNearestPoint: function() {
			return this.getNearestLocation.apply(this, arguments).getPoint();
		}
	}), new function() {
	
		function drawHandles(ctx, segments, matrix, size) {
			var half = size / 2;
	
			function drawHandle(index) {
				var hX = coords[index],
					hY = coords[index + 1];
				if (pX != hX || pY != hY) {
					ctx.beginPath();
					ctx.moveTo(pX, pY);
					ctx.lineTo(hX, hY);
					ctx.stroke();
					ctx.beginPath();
					ctx.arc(hX, hY, half, 0, Math.PI * 2, true);
					ctx.fill();
				}
			}
	
			var coords = new Array(6);
			for (var i = 0, l = segments.length; i < l; i++) {
				var segment = segments[i];
				segment._transformCoordinates(matrix, coords, false);
				var state = segment._selectionState,
					pX = coords[0],
					pY = coords[1];
				if (state & 1)
					drawHandle(2);
				if (state & 2)
					drawHandle(4);
				ctx.fillRect(pX - half, pY - half, size, size);
				if (!(state & 4)) {
					var fillStyle = ctx.fillStyle;
					ctx.fillStyle = '#ffffff';
					ctx.fillRect(pX - half + 1, pY - half + 1, size - 2, size - 2);
					ctx.fillStyle = fillStyle;
				}
			}
		}
	
		function drawSegments(ctx, path, matrix) {
			var segments = path._segments,
				length = segments.length,
				coords = new Array(6),
				first = true,
				curX, curY,
				prevX, prevY,
				inX, inY,
				outX, outY;
	
			function drawSegment(segment) {
				if (matrix) {
					segment._transformCoordinates(matrix, coords, false);
					curX = coords[0];
					curY = coords[1];
				} else {
					var point = segment._point;
					curX = point._x;
					curY = point._y;
				}
				if (first) {
					ctx.moveTo(curX, curY);
					first = false;
				} else {
					if (matrix) {
						inX = coords[2];
						inY = coords[3];
					} else {
						var handle = segment._handleIn;
						inX = curX + handle._x;
						inY = curY + handle._y;
					}
					if (inX === curX && inY === curY
							&& outX === prevX && outY === prevY) {
						ctx.lineTo(curX, curY);
					} else {
						ctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);
					}
				}
				prevX = curX;
				prevY = curY;
				if (matrix) {
					outX = coords[4];
					outY = coords[5];
				} else {
					var handle = segment._handleOut;
					outX = prevX + handle._x;
					outY = prevY + handle._y;
				}
			}
	
			for (var i = 0; i < length; i++)
				drawSegment(segments[i]);
			if (path._closed && length > 0)
				drawSegment(segments[0]);
		}
	
		return {
			_draw: function(ctx, param, strokeMatrix) {
				var dontStart = param.dontStart,
					dontPaint = param.dontFinish || param.clip,
					style = this.getStyle(),
					hasFill = style.hasFill(),
					hasStroke = style.hasStroke(),
					dashArray = style.getDashArray(),
					dashLength = !paper.support.nativeDash && hasStroke
							&& dashArray && dashArray.length;
	
				if (!dontStart)
					ctx.beginPath();
	
				if (!dontStart && this._currentPath) {
					ctx.currentPath = this._currentPath;
				} else if (hasFill || hasStroke && !dashLength || dontPaint) {
					drawSegments(ctx, this, strokeMatrix);
					if (this._closed)
						ctx.closePath();
					if (!dontStart)
						this._currentPath = ctx.currentPath;
				}
	
				function getOffset(i) {
					return dashArray[((i % dashLength) + dashLength) % dashLength];
				}
	
				if (!dontPaint && (hasFill || hasStroke)) {
					this._setStyles(ctx);
					if (hasFill) {
						ctx.fill(style.getWindingRule());
						ctx.shadowColor = 'rgba(0,0,0,0)';
					}
					if (hasStroke) {
						if (dashLength) {
							if (!dontStart)
								ctx.beginPath();
							var iterator = new PathIterator(this, 32, 0.25,
									strokeMatrix),
								length = iterator.length,
								from = -style.getDashOffset(), to,
								i = 0;
							from = from % length;
							while (from > 0) {
								from -= getOffset(i--) + getOffset(i--);
							}
							while (from < length) {
								to = from + getOffset(i++);
								if (from > 0 || to > 0)
									iterator.drawPart(ctx,
											Math.max(from, 0), Math.max(to, 0));
								from = to + getOffset(i++);
							}
						}
						ctx.stroke();
					}
				}
			},
	
			_drawSelected: function(ctx, matrix) {
				ctx.beginPath();
				drawSegments(ctx, this, matrix);
				ctx.stroke();
				drawHandles(ctx, this._segments, matrix, paper.settings.handleSize);
			}
		};
	}, new function() {
	
		function getFirstControlPoints(rhs) {
			var n = rhs.length,
				x = [],
				tmp = [],
				b = 2;
			x[0] = rhs[0] / b;
			for (var i = 1; i < n; i++) {
				tmp[i] = 1 / b;
				b = (i < n - 1 ? 4 : 2) - tmp[i];
				x[i] = (rhs[i] - x[i - 1]) / b;
			}
			for (var i = 1; i < n; i++) {
				x[n - i - 1] -= tmp[n - i] * x[n - i];
			}
			return x;
		}
	
		return {
			smooth: function() {
				var segments = this._segments,
					size = segments.length,
					closed = this._closed,
					n = size,
					overlap = 0;
				if (size <= 2)
					return;
				if (closed) {
					overlap = Math.min(size, 4);
					n += Math.min(size, overlap) * 2;
				}
				var knots = [];
				for (var i = 0; i < size; i++)
					knots[i + overlap] = segments[i]._point;
				if (closed) {
					for (var i = 0; i < overlap; i++) {
						knots[i] = segments[i + size - overlap]._point;
						knots[i + size + overlap] = segments[i]._point;
					}
				} else {
					n--;
				}
				var rhs = [];
	
				for (var i = 1; i < n - 1; i++)
					rhs[i] = 4 * knots[i]._x + 2 * knots[i + 1]._x;
				rhs[0] = knots[0]._x + 2 * knots[1]._x;
				rhs[n - 1] = 3 * knots[n - 1]._x;
				var x = getFirstControlPoints(rhs);
	
				for (var i = 1; i < n - 1; i++)
					rhs[i] = 4 * knots[i]._y + 2 * knots[i + 1]._y;
				rhs[0] = knots[0]._y + 2 * knots[1]._y;
				rhs[n - 1] = 3 * knots[n - 1]._y;
				var y = getFirstControlPoints(rhs);
	
				if (closed) {
					for (var i = 0, j = size; i < overlap; i++, j++) {
						var f1 = i / overlap,
							f2 = 1 - f1,
							ie = i + overlap,
							je = j + overlap;
						x[j] = x[i] * f1 + x[j] * f2;
						y[j] = y[i] * f1 + y[j] * f2;
						x[je] = x[ie] * f2 + x[je] * f1;
						y[je] = y[ie] * f2 + y[je] * f1;
					}
					n--;
				}
				var handleIn = null;
				for (var i = overlap; i <= n - overlap; i++) {
					var segment = segments[i - overlap];
					if (handleIn)
						segment.setHandleIn(handleIn.subtract(segment._point));
					if (i < n) {
						segment.setHandleOut(
								new Point(x[i], y[i]).subtract(segment._point));
						handleIn = i < n - 1
								? new Point(
									2 * knots[i + 1]._x - x[i + 1],
									2 * knots[i + 1]._y - y[i + 1])
								: new Point(
									(knots[n]._x + x[n - 1]) / 2,
									(knots[n]._y + y[n - 1]) / 2);
					}
				}
				if (closed && handleIn) {
					var segment = this._segments[0];
					segment.setHandleIn(handleIn.subtract(segment._point));
				}
			}
		};
	}, new function() {
		function getCurrentSegment(that) {
			var segments = that._segments;
			if (segments.length === 0)
				throw new Error('Use a moveTo() command first');
			return segments[segments.length - 1];
		}
	
		return {
			moveTo: function() {
				var segments = this._segments;
				if (segments.length === 1)
					this.removeSegment(0);
				if (!segments.length)
					this._add([ new Segment(Point.read(arguments)) ]);
			},
	
			moveBy: function() {
				throw new Error('moveBy() is unsupported on Path items.');
			},
	
			lineTo: function() {
				this._add([ new Segment(Point.read(arguments)) ]);
			},
	
			cubicCurveTo: function() {
				var handle1 = Point.read(arguments),
					handle2 = Point.read(arguments),
					to = Point.read(arguments),
					current = getCurrentSegment(this);
				current.setHandleOut(handle1.subtract(current._point));
				this._add([ new Segment(to, handle2.subtract(to)) ]);
			},
	
			quadraticCurveTo: function() {
				var handle = Point.read(arguments),
					to = Point.read(arguments),
					current = getCurrentSegment(this)._point;
				this.cubicCurveTo(
					handle.add(current.subtract(handle).multiply(1 / 3)),
					handle.add(to.subtract(handle).multiply(1 / 3)),
					to
				);
			},
	
			curveTo: function() {
				var through = Point.read(arguments),
					to = Point.read(arguments),
					t = Base.pick(Base.read(arguments), 0.5),
					t1 = 1 - t,
					current = getCurrentSegment(this)._point,
					handle = through.subtract(current.multiply(t1 * t1))
						.subtract(to.multiply(t * t)).divide(2 * t * t1);
				if (handle.isNaN())
					throw new Error(
						'Cannot put a curve through points with parameter = ' + t);
				this.quadraticCurveTo(handle, to);
			},
	
			arcTo: function() {
				var current = getCurrentSegment(this),
					from = current._point,
					to = Point.read(arguments),
					through,
					peek = Base.peek(arguments),
					clockwise = Base.pick(peek, true),
					center, extent, vector, matrix;
				if (typeof clockwise === 'boolean') {
					var middle = from.add(to).divide(2),
					through = middle.add(middle.subtract(from).rotate(
							clockwise ? -90 : 90));
				} else if (Base.remain(arguments) <= 2) {
					through = to;
					to = Point.read(arguments);
				} else {
					var radius = Size.read(arguments);
					if (radius.isZero())
						return this.lineTo(to);
					var rotation = Base.read(arguments),
						clockwise = !!Base.read(arguments),
						large = !!Base.read(arguments),
						middle = from.add(to).divide(2),
						pt = from.subtract(middle).rotate(-rotation),
						x = pt.x,
						y = pt.y,
						abs = Math.abs,
						epsilon = 1e-12,
						rx = abs(radius.width),
						ry = abs(radius.height),
						rxSq = rx * rx,
						rySq = ry * ry,
						xSq =  x * x,
						ySq =  y * y;
					var factor = Math.sqrt(xSq / rxSq + ySq / rySq);
					if (factor > 1) {
						rx *= factor;
						ry *= factor;
						rxSq = rx * rx;
						rySq = ry * ry;
					}
					factor = (rxSq * rySq - rxSq * ySq - rySq * xSq) /
							(rxSq * ySq + rySq * xSq);
					if (abs(factor) < epsilon)
						factor = 0;
					if (factor < 0)
						throw new Error(
								'Cannot create an arc with the given arguments');
					center = new Point(rx * y / ry, -ry * x / rx)
							.multiply((large === clockwise ? -1 : 1)
								* Math.sqrt(factor))
							.rotate(rotation).add(middle);
					matrix = new Matrix().translate(center).rotate(rotation)
							.scale(rx, ry);
					vector = matrix._inverseTransform(from);
					extent = vector.getDirectedAngle(matrix._inverseTransform(to));
					if (!clockwise && extent > 0)
						extent -= 360;
					else if (clockwise && extent < 0)
						extent += 360;
				}
				if (through) {
					var l1 = new Line(from.add(through).divide(2),
								through.subtract(from).rotate(90), true),
						l2 = new Line(through.add(to).divide(2),
								to.subtract(through).rotate(90), true),
						line = new Line(from, to),
						throughSide = line.getSide(through);
					center = l1.intersect(l2, true);
					if (!center) {
						if (!throughSide)
							return this.lineTo(to);
						throw new Error(
								'Cannot create an arc with the given arguments');
					}
					vector = from.subtract(center);
					extent = vector.getDirectedAngle(to.subtract(center));
					var centerSide = line.getSide(center);
					if (centerSide === 0) {
						extent = throughSide * Math.abs(extent);
					} else if (throughSide === centerSide) {
						extent += extent < 0 ? 360 : -360;
					}
				}
				var ext = Math.abs(extent),
					count = ext >= 360 ? 4 : Math.ceil(ext / 90),
					inc = extent / count,
					half = inc * Math.PI / 360,
					z = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),
					segments = [];
				for (var i = 0; i <= count; i++) {
					var pt = to,
						out = null;
					if (i < count) {
						out = vector.rotate(90).multiply(z);
						if (matrix) {
							pt = matrix._transformPoint(vector);
							out = matrix._transformPoint(vector.add(out))
									.subtract(pt);
						} else {
							pt = center.add(vector);
						}
					}
					if (i === 0) {
						current.setHandleOut(out);
					} else {
						var _in = vector.rotate(-90).multiply(z);
						if (matrix) {
							_in = matrix._transformPoint(vector.add(_in))
									.subtract(pt);
						}
						segments.push(new Segment(pt, _in, out));
					}
					vector = vector.rotate(inc);
				}
				this._add(segments);
			},
	
			lineBy: function() {
				var to = Point.read(arguments),
					current = getCurrentSegment(this)._point;
				this.lineTo(current.add(to));
			},
	
			curveBy: function() {
				var through = Point.read(arguments),
					to = Point.read(arguments),
					parameter = Base.read(arguments),
					current = getCurrentSegment(this)._point;
				this.curveTo(current.add(through), current.add(to), parameter);
			},
	
			cubicCurveBy: function() {
				var handle1 = Point.read(arguments),
					handle2 = Point.read(arguments),
					to = Point.read(arguments),
					current = getCurrentSegment(this)._point;
				this.cubicCurveTo(current.add(handle1), current.add(handle2),
						current.add(to));
			},
	
			quadraticCurveBy: function() {
				var handle = Point.read(arguments),
					to = Point.read(arguments),
					current = getCurrentSegment(this)._point;
				this.quadraticCurveTo(current.add(handle), current.add(to));
			},
	
			arcBy: function() {
				var current = getCurrentSegment(this)._point,
					point = current.add(Point.read(arguments)),
					clockwise = Base.pick(Base.peek(arguments), true);
				if (typeof clockwise === 'boolean') {
					this.arcTo(point, clockwise);
				} else {
					this.arcTo(point, current.add(Point.read(arguments)));
				}
			},
	
			closePath: function(join) {
				this.setClosed(true);
				if (join)
					this.join();
			}
		};
	}, {
	
		_getBounds: function(getter, matrix) {
			return Path[getter](this._segments, this._closed, this.getStyle(),
					matrix);
		},
	
	statics: {
		isClockwise: function(segments) {
			var sum = 0;
			for (var i = 0, l = segments.length; i < l; i++)
				sum += Curve.getEdgeSum(Curve.getValues(
						segments[i], segments[i + 1 < l ? i + 1 : 0]));
			return sum > 0;
		},
	
		getBounds: function(segments, closed, style, matrix, strokePadding) {
			var first = segments[0];
			if (!first)
				return new Rectangle();
			var coords = new Array(6),
				prevCoords = first._transformCoordinates(matrix, new Array(6), false),
				min = prevCoords.slice(0, 2),
				max = min.slice(),
				roots = new Array(2);
	
			function processSegment(segment) {
				segment._transformCoordinates(matrix, coords, false);
				for (var i = 0; i < 2; i++) {
					Curve._addBounds(
						prevCoords[i],
						prevCoords[i + 4],
						coords[i + 2],
						coords[i],
						i, strokePadding ? strokePadding[i] : 0, min, max, roots);
				}
				var tmp = prevCoords;
				prevCoords = coords;
				coords = tmp;
			}
	
			for (var i = 1, l = segments.length; i < l; i++)
				processSegment(segments[i]);
			if (closed)
				processSegment(first);
			return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
		},
	
		getStrokeBounds: function(segments, closed, style, matrix) {
			if (!style.hasStroke())
				return Path.getBounds(segments, closed, style, matrix);
			var length = segments.length - (closed ? 0 : 1),
				radius = style.getStrokeWidth() / 2,
				padding = Path._getPenPadding(radius, matrix),
				bounds = Path.getBounds(segments, closed, style, matrix, padding),
				join = style.getStrokeJoin(),
				cap = style.getStrokeCap(),
				miterLimit = radius * style.getMiterLimit();
			var joinBounds = new Rectangle(new Size(padding).multiply(2));
	
			function add(point) {
				bounds = bounds.include(matrix
					? matrix._transformPoint(point, point) : point);
			}
	
			function addRound(segment) {
				bounds = bounds.unite(joinBounds.setCenter(matrix
					? matrix._transformPoint(segment._point) : segment._point));
			}
	
			function addJoin(segment, join) {
				var handleIn = segment._handleIn,
					handleOut = segment._handleOut;
				if (join === 'round' || !handleIn.isZero() && !handleOut.isZero()
						&& handleIn.isCollinear(handleOut)) {
					addRound(segment);
				} else {
					Path._addBevelJoin(segment, join, radius, miterLimit, add);
				}
			}
	
			function addCap(segment, cap) {
				if (cap === 'round') {
					addRound(segment);
				} else {
					Path._addSquareCap(segment, cap, radius, add);
				}
			}
	
			for (var i = 1; i < length; i++)
				addJoin(segments[i], join);
			if (closed) {
				addJoin(segments[0], join);
			} else if (length > 0) {
				addCap(segments[0], cap);
				addCap(segments[segments.length - 1], cap);
			}
			return bounds;
		},
	
		_getPenPadding: function(radius, matrix) {
			if (!matrix)
				return [radius, radius];
			var mx = matrix.shiftless(),
				hor = mx.transform(new Point(radius, 0)),
				ver = mx.transform(new Point(0, radius)),
				phi = hor.getAngleInRadians(),
				a = hor.getLength(),
				b = ver.getLength();
			var sin = Math.sin(phi),
				cos = Math.cos(phi),
				tan = Math.tan(phi),
				tx = -Math.atan(b * tan / a),
				ty = Math.atan(b / (tan * a));
			return [Math.abs(a * Math.cos(tx) * cos - b * Math.sin(tx) * sin),
					Math.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];
		},
	
		_addBevelJoin: function(segment, join, radius, miterLimit, addPoint, area) {
			var curve2 = segment.getCurve(),
				curve1 = curve2.getPrevious(),
				point = curve2.getPointAt(0, true),
				normal1 = curve1.getNormalAt(1, true),
				normal2 = curve2.getNormalAt(0, true),
				step = normal1.getDirectedAngle(normal2) < 0 ? -radius : radius;
			normal1.setLength(step);
			normal2.setLength(step);
			if (area) {
				addPoint(point);
				addPoint(point.add(normal1));
			}
			if (join === 'miter') {
				var corner = new Line(
						point.add(normal1),
						new Point(-normal1.y, normal1.x), true
					).intersect(new Line(
						point.add(normal2),
						new Point(-normal2.y, normal2.x), true
					), true);
				if (corner && point.getDistance(corner) <= miterLimit) {
					addPoint(corner);
					if (!area)
						return;
				}
			}
			if (!area)
				addPoint(point.add(normal1));
			addPoint(point.add(normal2));
		},
	
		_addSquareCap: function(segment, cap, radius, addPoint, area) {
			var point = segment._point,
				loc = segment.getLocation(),
				normal = loc.getNormal().multiply(radius);
			if (area) {
				addPoint(point.subtract(normal));
				addPoint(point.add(normal));
			}
			if (cap === 'square')
				point = point.add(normal.rotate(loc.getParameter() === 0 ? -90 : 90));
			addPoint(point.add(normal));
			addPoint(point.subtract(normal));
		},
	
		getHandleBounds: function(segments, closed, style, matrix, strokePadding,
				joinPadding) {
			var coords = new Array(6),
				x1 = Infinity,
				x2 = -x1,
				y1 = x1,
				y2 = x2;
			for (var i = 0, l = segments.length; i < l; i++) {
				var segment = segments[i];
				segment._transformCoordinates(matrix, coords, false);
				for (var j = 0; j < 6; j += 2) {
					var padding = j === 0 ? joinPadding : strokePadding,
						paddingX = padding ? padding[0] : 0,
						paddingY = padding ? padding[1] : 0,
						x = coords[j],
						y = coords[j + 1],
						xn = x - paddingX,
						xx = x + paddingX,
						yn = y - paddingY,
						yx = y + paddingY;
					if (xn < x1) x1 = xn;
					if (xx > x2) x2 = xx;
					if (yn < y1) y1 = yn;
					if (yx > y2) y2 = yx;
				}
			}
			return new Rectangle(x1, y1, x2 - x1, y2 - y1);
		},
	
		getRoughBounds: function(segments, closed, style, matrix) {
			var strokeRadius = style.hasStroke() ? style.getStrokeWidth() / 2 : 0,
				joinRadius = strokeRadius;
			if (strokeRadius > 0) {
				if (style.getStrokeJoin() === 'miter')
					joinRadius = strokeRadius * style.getMiterLimit();
				if (style.getStrokeCap() === 'square')
					joinRadius = Math.max(joinRadius, strokeRadius * Math.sqrt(2));
			}
			return Path.getHandleBounds(segments, closed, style, matrix,
					Path._getPenPadding(strokeRadius, matrix),
					Path._getPenPadding(joinRadius, matrix));
		}
	}});
	
	Path.inject({ statics: new function() {
	
		var kappa = 0.5522847498307936,
			ellipseSegments = [
				new Segment([-1, 0], [0, kappa ], [0, -kappa]),
				new Segment([0, -1], [-kappa, 0], [kappa, 0 ]),
				new Segment([1, 0], [0, -kappa], [0, kappa ]),
				new Segment([0, 1], [kappa, 0 ], [-kappa, 0])
			];
	
		function createPath(segments, closed, args) {
			var props = Base.getNamed(args),
				path = new Path(props && props.insert === false && Item.NO_INSERT);
			path._add(segments);
			path._closed = closed;
			return path.set(props);
		}
	
		function createEllipse(center, radius, args) {
			var segments = new Array(4);
			for (var i = 0; i < 4; i++) {
				var segment = ellipseSegments[i];
				segments[i] = new Segment(
					segment._point.multiply(radius).add(center),
					segment._handleIn.multiply(radius),
					segment._handleOut.multiply(radius)
				);
			}
			return createPath(segments, true, args);
		}
	
		return {
			Line: function() {
				return createPath([
					new Segment(Point.readNamed(arguments, 'from')),
					new Segment(Point.readNamed(arguments, 'to'))
				], false, arguments);
			},
	
			Circle: function() {
				var center = Point.readNamed(arguments, 'center'),
					radius = Base.readNamed(arguments, 'radius');
				return createEllipse(center, new Size(radius), arguments);
			},
	
			Rectangle: function() {
				var rect = Rectangle.readNamed(arguments, 'rectangle'),
					radius = Size.readNamed(arguments, 'radius', 0,
							{ readNull: true }),
					bl = rect.getBottomLeft(true),
					tl = rect.getTopLeft(true),
					tr = rect.getTopRight(true),
					br = rect.getBottomRight(true),
					segments;
				if (!radius || radius.isZero()) {
					segments = [
						new Segment(bl),
						new Segment(tl),
						new Segment(tr),
						new Segment(br)
					];
				} else {
					radius = Size.min(radius, rect.getSize(true).divide(2));
					var rx = radius.width,
						ry = radius.height,
						hx = rx * kappa,
						hy = ry * kappa;
					segments = [
						new Segment(bl.add(rx, 0), null, [-hx, 0]),
						new Segment(bl.subtract(0, ry), [0, hy]),
						new Segment(tl.add(0, ry), null, [0, -hy]),
						new Segment(tl.add(rx, 0), [-hx, 0], null),
						new Segment(tr.subtract(rx, 0), null, [hx, 0]),
						new Segment(tr.add(0, ry), [0, -hy], null),
						new Segment(br.subtract(0, ry), null, [0, hy]),
						new Segment(br.subtract(rx, 0), [hx, 0])
					];
				}
				return createPath(segments, true, arguments);
			},
	
			RoundRectangle: '#Rectangle',
	
			Ellipse: function() {
				var ellipse = Shape._readEllipse(arguments);
				return createEllipse(ellipse.center, ellipse.radius, arguments);
			},
	
			Oval: '#Ellipse',
	
			Arc: function() {
				var from = Point.readNamed(arguments, 'from'),
					through = Point.readNamed(arguments, 'through'),
					to = Point.readNamed(arguments, 'to'),
					props = Base.getNamed(arguments),
					path = new Path(props && props.insert === false
							&& Item.NO_INSERT);
				path.moveTo(from);
				path.arcTo(through, to);
				return path.set(props);
			},
	
			RegularPolygon: function() {
				var center = Point.readNamed(arguments, 'center'),
					sides = Base.readNamed(arguments, 'sides'),
					radius = Base.readNamed(arguments, 'radius'),
					step = 360 / sides,
					three = !(sides % 3),
					vector = new Point(0, three ? -radius : radius),
					offset = three ? -1 : 0.5,
					segments = new Array(sides);
				for (var i = 0; i < sides; i++)
					segments[i] = new Segment(center.add(
						vector.rotate((i + offset) * step)));
				return createPath(segments, true, arguments);
			},
	
			Star: function() {
				var center = Point.readNamed(arguments, 'center'),
					points = Base.readNamed(arguments, 'points') * 2,
					radius1 = Base.readNamed(arguments, 'radius1'),
					radius2 = Base.readNamed(arguments, 'radius2'),
					step = 360 / points,
					vector = new Point(0, -1),
					segments = new Array(points);
				for (var i = 0; i < points; i++)
					segments[i] = new Segment(center.add(vector.rotate(step * i)
							.multiply(i % 2 ? radius2 : radius1)));
				return createPath(segments, true, arguments);
			}
		};
	}});
	
	var CompoundPath = PathItem.extend({
		_class: 'CompoundPath',
		_serializeFields: {
			children: []
		},
	
		initialize: function CompoundPath(arg) {
			this._children = [];
			this._namedChildren = {};
			if (!this._initialize(arg)) {
				if (typeof arg === 'string') {
					this.setPathData(arg);
				} else {
					this.addChildren(Array.isArray(arg) ? arg : arguments);
				}
			}
		},
	
		insertChildren: function insertChildren(index, items, _preserve) {
			items = insertChildren.base.call(this, index, items, _preserve, Path);
			for (var i = 0, l = !_preserve && items && items.length; i < l; i++) {
				var item = items[i];
				if (item._clockwise === undefined)
					item.setClockwise(item._index === 0);
			}
			return items;
		},
	
		reverse: function() {
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++)
				children[i].reverse();
		},
	
		smooth: function() {
			for (var i = 0, l = this._children.length; i < l; i++)
				this._children[i].smooth();
		},
	
		reduce: function reduce() {
			if (this._children.length === 0) {
				var path = new Path(Item.NO_INSERT);
				path.insertAbove(this);
				path.setStyle(this._style);
				this.remove();
				return path;
			} else {
				return reduce.base.call(this);
			}
		},
	
		isClockwise: function() {
			var child = this.getFirstChild();
			return child && child.isClockwise();
		},
	
		setClockwise: function(clockwise) {
			if (this.isClockwise() !== !!clockwise)
				this.reverse();
		},
	
		getFirstSegment: function() {
			var first = this.getFirstChild();
			return first && first.getFirstSegment();
		},
	
		getLastSegment: function() {
			var last = this.getLastChild();
			return last && last.getLastSegment();
		},
	
		getCurves: function() {
			var children = this._children,
				curves = [];
			for (var i = 0, l = children.length; i < l; i++)
				curves.push.apply(curves, children[i].getCurves());
			return curves;
		},
	
		getFirstCurve: function() {
			var first = this.getFirstChild();
			return first && first.getFirstCurve();
		},
	
		getLastCurve: function() {
			var last = this.getLastChild();
			return last && last.getFirstCurve();
		},
	
		getArea: function() {
			var children = this._children,
				area = 0;
			for (var i = 0, l = children.length; i < l; i++)
				area += children[i].getArea();
			return area;
		}
	}, {
		beans: true,
	
		getPathData: function(_matrix, _precision) {
			var children = this._children,
				paths = [];
			for (var i = 0, l = children.length; i < l; i++) {
				var child = children[i],
					mx = child._matrix;
				paths.push(child.getPathData(_matrix && !mx.isIdentity()
						? _matrix.chain(mx) : mx, _precision));
			}
			return paths.join(' ');
		}
	}, {
		_getChildHitTestOptions: function(options) {
			return options.class === Path || options.type === 'path'
					? options
					: new Base(options, { fill: false });
		},
	
		_draw: function(ctx, param, strokeMatrix) {
			var children = this._children;
			if (children.length === 0)
				return;
	
			if (this._currentPath) {
				ctx.currentPath = this._currentPath;
			} else {
				param = param.extend({ dontStart: true, dontFinish: true });
				ctx.beginPath();
				for (var i = 0, l = children.length; i < l; i++)
					children[i].draw(ctx, param, strokeMatrix);
				this._currentPath = ctx.currentPath;
			}
	
			if (!param.clip) {
				this._setStyles(ctx);
				var style = this._style;
				if (style.hasFill()) {
					ctx.fill(style.getWindingRule());
					ctx.shadowColor = 'rgba(0,0,0,0)';
				}
				if (style.hasStroke())
					ctx.stroke();
			}
		},
	
		_drawSelected: function(ctx, matrix, selectedItems) {
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++) {
				var child = children[i],
					mx = child._matrix;
				if (!selectedItems[child._id])
					child._drawSelected(ctx, mx.isIdentity() ? matrix
							: matrix.chain(mx));
			}
		}
	}, new function() {
		function getCurrentPath(that, check) {
			var children = that._children;
			if (check && children.length === 0)
				throw new Error('Use a moveTo() command first');
			return children[children.length - 1];
		}
	
		var fields = {
			moveTo: function() {
				var current = getCurrentPath(this),
					path = current && current.isEmpty() ? current : new Path();
				if (path !== current)
					this.addChild(path);
				path.moveTo.apply(path, arguments);
			},
	
			moveBy: function() {
				var current = getCurrentPath(this, true),
					last = current && current.getLastSegment(),
					point = Point.read(arguments);
				this.moveTo(last ? point.add(last._point) : point);
			},
	
			closePath: function(join) {
				getCurrentPath(this, true).closePath(join);
			}
		};
	
		Base.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo', 'arcTo',
				'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy', 'arcBy'],
				function(key) {
					fields[key] = function() {
						var path = getCurrentPath(this, true);
						path[key].apply(path, arguments);
					};
				}
		);
	
		return fields;
	});
	
	PathItem.inject(new function() {
		var operators = {
			unite: function(w) {
				return w === 1 || w === 0;
			},
	
			intersect: function(w) {
				return w === 2;
			},
	
			subtract: function(w) {
				return w === 1;
			},
	
			exclude: function(w) {
				return w === 1;
			}
		};
	
		function computeBoolean(path1, path2, operation) {
			var operator = operators[operation];
			function preparePath(path) {
				return path.clone(false).reduce().reorient().transform(null, true,
						true);
			}
	
			var _path1 = preparePath(path1),
				_path2 = path2 && path1 !== path2 && preparePath(path2);
			if (_path2 && /^(subtract|exclude)$/.test(operation)
					^ (_path2.isClockwise() !== _path1.isClockwise()))
				_path2.reverse();
			splitPath(_path1.getIntersections(_path2, null, true));
	
			var chain = [],
				segments = [],
				monoCurves = [],
				tolerance = 0.000001;
	
			function collect(paths) {
				for (var i = 0, l = paths.length; i < l; i++) {
					var path = paths[i];
					segments.push.apply(segments, path._segments);
					monoCurves.push.apply(monoCurves, path._getMonoCurves());
				}
			}
	
			collect(_path1._children || [_path1]);
			if (_path2)
				collect(_path2._children || [_path2]);
			segments.sort(function(a, b) {
				var _a = a._intersection,
					_b = b._intersection;
				return !_a && !_b || _a && _b ? 0 : _a ? -1 : 1;
			});
			for (var i = 0, l = segments.length; i < l; i++) {
				var segment = segments[i];
				if (segment._winding != null)
					continue;
				chain.length = 0;
				var startSeg = segment,
					totalLength = 0,
					windingSum = 0;
				do {
					var length = segment.getCurve().getLength();
					chain.push({ segment: segment, length: length });
					totalLength += length;
					segment = segment.getNext();
				} while (segment && !segment._intersection && segment !== startSeg);
				for (var j = 0; j < 3; j++) {
					var length = totalLength * (j + 1) / 4;
					for (var k = 0, m = chain.length; k < m; k++) {
						var node = chain[k],
							curveLength = node.length;
						if (length <= curveLength) {
							if (length < tolerance
									|| curveLength - length < tolerance)
								length = curveLength / 2;
							var curve = node.segment.getCurve(),
								pt = curve.getPointAt(length),
								hor = curve.isLinear() && Math.abs(curve
										.getTangentAt(0.5, true).y) < tolerance,
								path = curve._path;
							if (path._parent instanceof CompoundPath)
								path = path._parent;
							windingSum += operation === 'subtract' && _path2
								&& (path === _path1 && _path2._getWinding(pt, hor)
								|| path === _path2 && !_path1._getWinding(pt, hor))
								? 0
								: getWinding(pt, monoCurves, hor);
							break;
						}
						length -= curveLength;
					}
				}
				var winding = Math.round(windingSum / 3);
				for (var j = chain.length - 1; j >= 0; j--)
					chain[j].segment._winding = winding;
			}
			var result = new CompoundPath(Item.NO_INSERT);
			result.insertAbove(path1);
			result.addChildren(tracePaths(segments, operator), true);
			result = result.reduce();
			result.setStyle(path1._style);
			return result;
		}
	
		function splitPath(intersections) {
			var tMin = 0.000001,
				tMax = 1 - tMin,
				linearHandles;
	
			function resetLinear() {
				for (var i = 0, l = linearHandles.length; i < l; i++)
					linearHandles[i].set(0, 0);
			}
	
			for (var i = intersections.length - 1, curve, prev; i >= 0; i--) {
				var loc = intersections[i],
					t = loc._parameter;
				if (prev && prev._curve === loc._curve && prev._parameter > 0) {
					t /= prev._parameter;
				} else {
					curve = loc._curve;
					if (linearHandles)
						resetLinear();
					linearHandles = curve.isLinear() ? [
							curve._segment1._handleOut,
							curve._segment2._handleIn
						] : null;
				}
				var newCurve,
					segment;
				if (newCurve = curve.divide(t, true, true)) {
					segment = newCurve._segment1;
					curve = newCurve.getPrevious();
					if (linearHandles)
						linearHandles.push(segment._handleOut, segment._handleIn);
				} else {
					segment = t < tMin
						? curve._segment1
						: t > tMax
							? curve._segment2
							: curve.getPartLength(0, t) < curve.getPartLength(t, 1)
								? curve._segment1
								: curve._segment2;
				}
				segment._intersection = loc.getIntersection();
				loc._segment = segment;
				prev = loc;
			}
			if (linearHandles)
				resetLinear();
		}
	
		function getWinding(point, curves, horizontal, testContains) {
			var tolerance = 0.000001,
				tMin = tolerance,
				tMax = 1 - tMin,
				px = point.x,
				py = point.y,
				windLeft = 0,
				windRight = 0,
				roots = [],
				abs = Math.abs;
			if (horizontal) {
				var yTop = -Infinity,
					yBottom = Infinity,
					yBefore = py - tolerance,
					yAfter = py + tolerance;
				for (var i = 0, l = curves.length; i < l; i++) {
					var values = curves[i].values;
					if (Curve.solveCubic(values, 0, px, roots, 0, 1) > 0) {
						for (var j = roots.length - 1; j >= 0; j--) {
							var y = Curve.getPoint(values, roots[j]).y;
							if (y < yBefore && y > yTop) {
								yTop = y;
							} else if (y > yAfter && y < yBottom) {
								yBottom = y;
							}
						}
					}
				}
				yTop = (yTop + py) / 2;
				yBottom = (yBottom + py) / 2;
				if (yTop > -Infinity)
					windLeft = getWinding(new Point(px, yTop), curves);
				if (yBottom < Infinity)
					windRight = getWinding(new Point(px, yBottom), curves);
			} else {
				var xBefore = px - tolerance,
					xAfter = px + tolerance;
				var startCounted = false,
					prevCurve,
					prevT;
				for (var i = 0, l = curves.length; i < l; i++) {
					var curve = curves[i],
						values = curve.values,
						winding = curve.winding;
					if (winding && (winding === 1
							&& py >= values[1] && py <= values[7]
							|| py >= values[7] && py <= values[1])
						&& Curve.solveCubic(values, 1, py, roots, 0, 1) === 1) {
						var t = roots[0];
						if (!(
							t > tMax && startCounted && curve.next !== curves[i + 1]
							|| t < tMin && prevT > tMax
								&& curve.previous === prevCurve)) {
							var x = Curve.getPoint(values, t).x,
								slope = Curve.getTangent(values, t).y,
								counted = false;
							if (Numerical.isZero(slope) && !Curve.isLinear(values)
									|| t < tMin && slope * Curve.getTangent(
										curve.previous.values, 1).y < 0
									|| t > tMax && slope * Curve.getTangent(
										curve.next.values, 0).y < 0) {
								if (testContains && x >= xBefore && x <= xAfter) {
									++windLeft;
									++windRight;
									counted = true;
								}
							} else if (x <= xBefore) {
								windLeft += winding;
								counted = true;
							} else if (x >= xAfter) {
								windRight += winding;
								counted = true;
							}
							if (curve.previous !== curves[i - 1])
								startCounted = t < tMin && counted;
						}
						prevCurve = curve;
						prevT = t;
					}
				}
			}
			return Math.max(abs(windLeft), abs(windRight));
		}
	
		function tracePaths(segments, operator, selfOp) {
			var paths = [],
				tMin = 0.000001,
				tMax = 1 - tMin;
			for (var i = 0, seg, startSeg, l = segments.length; i < l; i++) {
				seg = startSeg = segments[i];
				if (seg._visited || !operator(seg._winding))
					continue;
				var path = new Path(Item.NO_INSERT),
					inter = seg._intersection,
					startInterSeg = inter && inter._segment,
					added = false,
					dir = 1;
				do {
					var handleIn = dir > 0 ? seg._handleIn : seg._handleOut,
						handleOut = dir > 0 ? seg._handleOut : seg._handleIn,
						interSeg;
					if (added && (!operator(seg._winding) || selfOp)
							&& (inter = seg._intersection)
							&& (interSeg = inter._segment)
							&& interSeg !== startSeg) {
						if (selfOp) {
							seg._visited = interSeg._visited;
							seg = interSeg;
							dir = 1;
						} else {
							var c1 = seg.getCurve();
							if (dir > 0)
								c1 = c1.getPrevious();
							var t1 = c1.getTangentAt(dir < 1 ? tMin : tMax, true),
								c4 = interSeg.getCurve(),
								c3 = c4.getPrevious(),
								t3 = c3.getTangentAt(tMax, true),
								t4 = c4.getTangentAt(tMin, true),
								w3 = t1.cross(t3),
								w4 = t1.cross(t4);
							if (w3 * w4 !== 0) {
								var curve = w3 < w4 ? c3 : c4,
									nextCurve = operator(curve._segment1._winding)
										? curve
										: w3 < w4 ? c4 : c3,
									nextSeg = nextCurve._segment1;
								dir = nextCurve === c3 ? -1 : 1;
								if (nextSeg._visited && seg._path !== nextSeg._path
											|| !operator(nextSeg._winding)) {
									dir = 1;
								} else {
									seg._visited = interSeg._visited;
									seg = interSeg;
									if (nextSeg._visited)
										dir = 1;
								}
							} else {
								dir = 1;
							}
						}
						handleOut = dir > 0 ? seg._handleOut : seg._handleIn;
					}
					path.add(new Segment(seg._point, added && handleIn, handleOut));
					added = true;
					seg._visited = true;
					seg = dir > 0 ? seg.getNext() : seg. getPrevious();
				} while (seg && !seg._visited
						&& seg !== startSeg && seg !== startInterSeg
						&& (seg._intersection || operator(seg._winding)));
				if (seg && (seg === startSeg || seg === startInterSeg)) {
					path.firstSegment.setHandleIn((seg === startInterSeg
							? startInterSeg : seg)._handleIn);
					path.setClosed(true);
				} else {
					path.lastSegment._handleOut.set(0, 0);
				}
				if (path._segments.length >
						(path._closed ? path.isLinear() ? 2 : 0 : 1))
					paths.push(path);
			}
			return paths;
		}
	
		return {
			_getWinding: function(point, horizontal, testContains) {
				return getWinding(point, this._getMonoCurves(),
						horizontal, testContains);
			},
	
			unite: function(path) {
				return computeBoolean(this, path, 'unite');
			},
	
			intersect: function(path) {
				return computeBoolean(this, path, 'intersect');
			},
	
			subtract: function(path) {
				return computeBoolean(this, path, 'subtract');
			},
	
			exclude: function(path) {
				return computeBoolean(this, path, 'exclude');
			},
	
			divide: function(path) {
				return new Group([this.subtract(path), this.intersect(path)]);
			}
		};
	});
	
	Path.inject({
		_getMonoCurves: function() {
			var monoCurves = this._monoCurves,
				prevCurve;
	
			function insertCurve(v) {
				var y0 = v[1],
					y1 = v[7],
					curve = {
						values: v,
						winding: y0 === y1
							? 0
							: y0 > y1
								? -1
								: 1,
						previous: prevCurve,
						next: null
					};
				if (prevCurve)
					prevCurve.next = curve;
				monoCurves.push(curve);
				prevCurve = curve;
			}
	
			function handleCurve(v) {
				if (Curve.getLength(v) === 0)
					return;
				var y0 = v[1],
					y1 = v[3],
					y2 = v[5],
					y3 = v[7];
				if (Curve.isLinear(v)) {
					insertCurve(v);
				} else {
					var a = 3 * (y1 - y2) - y0 + y3,
						b = 2 * (y0 + y2) - 4 * y1,
						c = y1 - y0,
						tolerance = 0.000001,
						roots = [];
					var count = Numerical.solveQuadratic(a, b, c, roots, tolerance,
							1 - tolerance);
					if (count === 0) {
						insertCurve(v);
					} else {
						roots.sort();
						var t = roots[0],
							parts = Curve.subdivide(v, t);
						insertCurve(parts[0]);
						if (count > 1) {
							t = (roots[1] - t) / (1 - t);
							parts = Curve.subdivide(parts[1], t);
							insertCurve(parts[0]);
						}
						insertCurve(parts[1]);
					}
				}
			}
	
			if (!monoCurves) {
				monoCurves = this._monoCurves = [];
				var curves = this.getCurves(),
					segments = this._segments;
				for (var i = 0, l = curves.length; i < l; i++)
					handleCurve(curves[i].getValues());
				if (!this._closed && segments.length > 1) {
					var p1 = segments[segments.length - 1]._point,
						p2 = segments[0]._point,
						p1x = p1._x, p1y = p1._y,
						p2x = p2._x, p2y = p2._y;
					handleCurve([p1x, p1y, p1x, p1y, p2x, p2y, p2x, p2y]);
				}
				if (monoCurves.length > 0) {
					var first = monoCurves[0],
						last = monoCurves[monoCurves.length - 1];
					first.previous = last;
					last.next = first;
				}
			}
			return monoCurves;
		},
	
		getInteriorPoint: function() {
			var bounds = this.getBounds(),
				point = bounds.getCenter(true);
			if (!this.contains(point)) {
				var curves = this._getMonoCurves(),
					roots = [],
					y = point.y,
					xIntercepts = [];
				for (var i = 0, l = curves.length; i < l; i++) {
					var values = curves[i].values;
					if ((curves[i].winding === 1
							&& y >= values[1] && y <= values[7]
							|| y >= values[7] && y <= values[1])
							&& Curve.solveCubic(values, 1, y, roots, 0, 1) > 0) {
						for (var j = roots.length - 1; j >= 0; j--)
							xIntercepts.push(Curve.getPoint(values, roots[j]).x);
					}
					if (xIntercepts.length > 1)
						break;
				}
				point.x = (xIntercepts[0] + xIntercepts[1]) / 2;
			}
			return point;
		},
	
		reorient: function() {
			this.setClockwise(true);
			return this;
		}
	});
	
	CompoundPath.inject({
		_getMonoCurves: function() {
			var children = this._children,
				monoCurves = [];
			for (var i = 0, l = children.length; i < l; i++)
				monoCurves.push.apply(monoCurves, children[i]._getMonoCurves());
			return monoCurves;
		},
	
		reorient: function() {
			var children = this.removeChildren().sort(function(a, b) {
				return b.getBounds().getArea() - a.getBounds().getArea();
			});
			if (children.length > 0) {
				this.addChildren(children);
				var clockwise = children[0].isClockwise();
				for (var i = 1, l = children.length; i < l; i++) {
					var point = children[i].getInteriorPoint(),
						counters = 0;
					for (var j = i - 1; j >= 0; j--) {
						if (children[j].contains(point))
							counters++;
					}
					children[i].setClockwise(counters % 2 === 0 && clockwise);
				}
			}
			return this;
		}
	});
	
	var PathIterator = Base.extend({
		_class: 'PathIterator',
	
		initialize: function(path, maxRecursion, tolerance, matrix) {
			var curves = [],
				parts = [],
				length = 0,
				minDifference = 1 / (maxRecursion || 32),
				segments = path._segments,
				segment1 = segments[0],
				segment2;
	
			function addCurve(segment1, segment2) {
				var curve = Curve.getValues(segment1, segment2, matrix);
				curves.push(curve);
				computeParts(curve, segment1._index, 0, 1);
			}
	
			function computeParts(curve, index, minT, maxT) {
				if ((maxT - minT) > minDifference
						&& !Curve.isFlatEnough(curve, tolerance || 0.25)) {
					var split = Curve.subdivide(curve),
						halfT = (minT + maxT) / 2;
					computeParts(split[0], index, minT, halfT);
					computeParts(split[1], index, halfT, maxT);
				} else {
					var x = curve[6] - curve[0],
						y = curve[7] - curve[1],
						dist = Math.sqrt(x * x + y * y);
					if (dist > 0.000001) {
						length += dist;
						parts.push({
							offset: length,
							value: maxT,
							index: index
						});
					}
				}
			}
	
			for (var i = 1, l = segments.length; i < l; i++) {
				segment2 = segments[i];
				addCurve(segment1, segment2);
				segment1 = segment2;
			}
			if (path._closed)
				addCurve(segment2, segments[0]);
	
			this.curves = curves;
			this.parts = parts;
			this.length = length;
			this.index = 0;
		},
	
		getParameterAt: function(offset) {
			var i, j = this.index;
			for (;;) {
				i = j;
				if (j == 0 || this.parts[--j].offset < offset)
					break;
			}
			for (var l = this.parts.length; i < l; i++) {
				var part = this.parts[i];
				if (part.offset >= offset) {
					this.index = i;
					var prev = this.parts[i - 1];
					var prevVal = prev && prev.index == part.index ? prev.value : 0,
						prevLen = prev ? prev.offset : 0;
					return {
						value: prevVal + (part.value - prevVal)
							* (offset - prevLen) / (part.offset - prevLen),
						index: part.index
					};
				}
			}
			var part = this.parts[this.parts.length - 1];
			return {
				value: 1,
				index: part.index
			};
		},
	
		drawPart: function(ctx, from, to) {
			from = this.getParameterAt(from);
			to = this.getParameterAt(to);
			for (var i = from.index; i <= to.index; i++) {
				var curve = Curve.getPart(this.curves[i],
						i == from.index ? from.value : 0,
						i == to.index ? to.value : 1);
				if (i == from.index)
					ctx.moveTo(curve[0], curve[1]);
				ctx.bezierCurveTo.apply(ctx, curve.slice(2));
			}
		}
	}, Base.each(Curve.evaluateMethods,
		function(name) {
			this[name + 'At'] = function(offset, weighted) {
				var param = this.getParameterAt(offset);
				return Curve[name](this.curves[param.index], param.value, weighted);
			};
		}, {})
	);
	
	var PathFitter = Base.extend({
		initialize: function(path, error) {
			var points = this.points = [],
				segments = path._segments,
				prev;
			for (var i = 0, l = segments.length; i < l; i++) {
				var point = segments[i].point.clone();
				if (!prev || !prev.equals(point)) {
					points.push(point);
					prev = point;
				}
			}
	
			if (path._closed) {
				this.closed = true;
				points.unshift(points[points.length - 1]);
				points.push(points[1]);
			}
	
			this.error = error;
		},
	
		fit: function() {
			var points = this.points,
				length = points.length,
				segments = this.segments = length > 0
						? [new Segment(points[0])] : [];
			if (length > 1)
				this.fitCubic(0, length - 1,
					points[1].subtract(points[0]).normalize(),
					points[length - 2].subtract(points[length - 1]).normalize());
	
			if (this.closed) {
				segments.shift();
				segments.pop();
			}
	
			return segments;
		},
	
		fitCubic: function(first, last, tan1, tan2) {
			if (last - first == 1) {
				var pt1 = this.points[first],
					pt2 = this.points[last],
					dist = pt1.getDistance(pt2) / 3;
				this.addCurve([pt1, pt1.add(tan1.normalize(dist)),
						pt2.add(tan2.normalize(dist)), pt2]);
				return;
			}
			var uPrime = this.chordLengthParameterize(first, last),
				maxError = Math.max(this.error, this.error * this.error),
				split,
				parametersInOrder = true;
			for (var i = 0; i <= 4; i++) {
				var curve = this.generateBezier(first, last, uPrime, tan1, tan2);
				var max = this.findMaxError(first, last, curve, uPrime);
				if (max.error < this.error && parametersInOrder) {
					this.addCurve(curve);
					return;
				}
				split = max.index;
				if (max.error >= maxError)
					break;
				parametersInOrder = this.reparameterize(first, last, uPrime, curve);
				maxError = max.error;
			}
			var V1 = this.points[split - 1].subtract(this.points[split]),
				V2 = this.points[split].subtract(this.points[split + 1]),
				tanCenter = V1.add(V2).divide(2).normalize();
			this.fitCubic(first, split, tan1, tanCenter);
			this.fitCubic(split, last, tanCenter.negate(), tan2);
		},
	
		addCurve: function(curve) {
			var prev = this.segments[this.segments.length - 1];
			prev.setHandleOut(curve[1].subtract(curve[0]));
			this.segments.push(
					new Segment(curve[3], curve[2].subtract(curve[3])));
		},
	
		generateBezier: function(first, last, uPrime, tan1, tan2) {
			var epsilon = 1e-12,
				pt1 = this.points[first],
				pt2 = this.points[last],
				C = [[0, 0], [0, 0]],
				X = [0, 0];
	
			for (var i = 0, l = last - first + 1; i < l; i++) {
				var u = uPrime[i],
					t = 1 - u,
					b = 3 * u * t,
					b0 = t * t * t,
					b1 = b * t,
					b2 = b * u,
					b3 = u * u * u,
					a1 = tan1.normalize(b1),
					a2 = tan2.normalize(b2),
					tmp = this.points[first + i]
						.subtract(pt1.multiply(b0 + b1))
						.subtract(pt2.multiply(b2 + b3));
				C[0][0] += a1.dot(a1);
				C[0][1] += a1.dot(a2);
				C[1][0] = C[0][1];
				C[1][1] += a2.dot(a2);
				X[0] += a1.dot(tmp);
				X[1] += a2.dot(tmp);
			}
	
			var detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],
				alpha1, alpha2;
			if (Math.abs(detC0C1) > epsilon) {
				var detC0X	= C[0][0] * X[1]	- C[1][0] * X[0],
					detXC1	= X[0]	  * C[1][1] - X[1]	  * C[0][1];
				alpha1 = detXC1 / detC0C1;
				alpha2 = detC0X / detC0C1;
			} else {
				var c0 = C[0][0] + C[0][1],
					c1 = C[1][0] + C[1][1];
				if (Math.abs(c0) > epsilon) {
					alpha1 = alpha2 = X[0] / c0;
				} else if (Math.abs(c1) > epsilon) {
					alpha1 = alpha2 = X[1] / c1;
				} else {
					alpha1 = alpha2 = 0;
				}
			}
	
			var segLength = pt2.getDistance(pt1),
				eps = epsilon * segLength,
				handle1,
				handle2;
			if (alpha1 < eps || alpha2 < eps) {
				alpha1 = alpha2 = segLength / 3;
			} else {
				var line = pt2.subtract(pt1);
				handle1 = tan1.normalize(alpha1);
				handle2 = tan2.normalize(alpha2);
				if (handle1.dot(line) - handle2.dot(line) > segLength * segLength) {
					alpha1 = alpha2 = segLength / 3;
					handle1 = handle2 = null;
				}
			}
	
			return [pt1, pt1.add(handle1 || tan1.normalize(alpha1)),
					pt2.add(handle2 || tan2.normalize(alpha2)), pt2];
		},
	
		reparameterize: function(first, last, u, curve) {
			for (var i = first; i <= last; i++) {
				u[i - first] = this.findRoot(curve, this.points[i], u[i - first]);
			}
			for (var i = 1, l = u.length; i < l; i++) {
				if (u[i] <= u[i - 1])
					return false;
			}
			return true;
		},
	
		findRoot: function(curve, point, u) {
			var curve1 = [],
				curve2 = [];
			for (var i = 0; i <= 2; i++) {
				curve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);
			}
			for (var i = 0; i <= 1; i++) {
				curve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);
			}
			var pt = this.evaluate(3, curve, u),
				pt1 = this.evaluate(2, curve1, u),
				pt2 = this.evaluate(1, curve2, u),
				diff = pt.subtract(point),
				df = pt1.dot(pt1) + diff.dot(pt2);
			if (Math.abs(df) < 0.000001)
				return u;
			return u - diff.dot(pt1) / df;
		},
	
		evaluate: function(degree, curve, t) {
			var tmp = curve.slice();
			for (var i = 1; i <= degree; i++) {
				for (var j = 0; j <= degree - i; j++) {
					tmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));
				}
			}
			return tmp[0];
		},
	
		chordLengthParameterize: function(first, last) {
			var u = [0];
			for (var i = first + 1; i <= last; i++) {
				u[i - first] = u[i - first - 1]
						+ this.points[i].getDistance(this.points[i - 1]);
			}
			for (var i = 1, m = last - first; i <= m; i++) {
				u[i] /= u[m];
			}
			return u;
		},
	
		findMaxError: function(first, last, curve, u) {
			var index = Math.floor((last - first + 1) / 2),
				maxDist = 0;
			for (var i = first + 1; i < last; i++) {
				var P = this.evaluate(3, curve, u[i - first]);
				var v = P.subtract(this.points[i]);
				var dist = v.x * v.x + v.y * v.y;
				if (dist >= maxDist) {
					maxDist = dist;
					index = i;
				}
			}
			return {
				error: maxDist,
				index: index
			};
		}
	});
	
	var TextItem = Item.extend({
		_class: 'TextItem',
		_boundsSelected: true,
		_applyMatrix: false,
		_canApplyMatrix: false,
		_serializeFields: {
			content: null
		},
		_boundsGetter: 'getBounds',
	
		initialize: function TextItem(arg) {
			this._content = '';
			this._lines = [];
			var hasProps = arg && Base.isPlainObject(arg)
					&& arg.x === undefined && arg.y === undefined;
			this._initialize(hasProps && arg, !hasProps && Point.read(arguments));
		},
	
		_equals: function(item) {
			return this._content === item._content;
		},
	
		_clone: function _clone(copy, insert, includeMatrix) {
			copy.setContent(this._content);
			return _clone.base.call(this, copy, insert, includeMatrix);
		},
	
		getContent: function() {
			return this._content;
		},
	
		setContent: function(content) {
			this._content = '' + content;
			this._lines = this._content.split(/\r\n|\n|\r/mg);
			this._changed(265);
		},
	
		isEmpty: function() {
			return !this._content;
		},
	
		getCharacterStyle: '#getStyle',
		setCharacterStyle: '#setStyle',
	
		getParagraphStyle: '#getStyle',
		setParagraphStyle: '#setStyle'
	});
	
	var PointText = TextItem.extend({
		_class: 'PointText',
	
		initialize: function PointText() {
			TextItem.apply(this, arguments);
		},
	
		clone: function(insert) {
			return this._clone(new PointText(Item.NO_INSERT), insert);
		},
	
		getPoint: function() {
			var point = this._matrix.getTranslation();
			return new LinkedPoint(point.x, point.y, this, 'setPoint');
		},
	
		setPoint: function() {
			var point = Point.read(arguments);
			this.translate(point.subtract(this._matrix.getTranslation()));
		},
	
		_draw: function(ctx) {
			if (!this._content)
				return;
			this._setStyles(ctx);
			var style = this._style,
				lines = this._lines,
				leading = style.getLeading(),
				shadowColor = ctx.shadowColor;
			ctx.font = style.getFontStyle();
			ctx.textAlign = style.getJustification();
			for (var i = 0, l = lines.length; i < l; i++) {
				ctx.shadowColor = shadowColor;
				var line = lines[i];
				if (style.hasFill()) {
					ctx.fillText(line, 0, 0);
					ctx.shadowColor = 'rgba(0,0,0,0)';
				}
				if (style.hasStroke())
					ctx.strokeText(line, 0, 0);
				ctx.translate(0, leading);
			}
		},
	
		_getBounds: function(getter, matrix) {
			var style = this._style,
				lines = this._lines,
				numLines = lines.length,
				justification = style.getJustification(),
				leading = style.getLeading(),
				width = this.getView().getTextWidth(style.getFontStyle(), lines),
				x = 0;
			if (justification !== 'left')
				x -= width / (justification === 'center' ? 2: 1);
			var bounds = new Rectangle(x,
						numLines ? - 0.75 * leading : 0,
						width, numLines * leading);
			return matrix ? matrix._transformBounds(bounds, bounds) : bounds;
		}
	});
	
	var Color = Base.extend(new function() {
		var types = {
			gray: ['gray'],
			rgb: ['red', 'green', 'blue'],
			hsb: ['hue', 'saturation', 'brightness'],
			hsl: ['hue', 'saturation', 'lightness'],
			gradient: ['gradient', 'origin', 'destination', 'highlight']
		};
	
		var componentParsers = {},
			colorCache = {},
			colorCtx;
	
		function fromCSS(string) {
			var match = string.match(/^#(\w{1,2})(\w{1,2})(\w{1,2})$/),
				components;
			if (match) {
				components = [0, 0, 0];
				for (var i = 0; i < 3; i++) {
					var value = match[i + 1];
					components[i] = parseInt(value.length == 1
							? value + value : value, 16) / 255;
				}
			} else if (match = string.match(/^rgba?\((.*)\)$/)) {
				components = match[1].split(',');
				for (var i = 0, l = components.length; i < l; i++) {
					var value = +components[i];
					components[i] = i < 3 ? value / 255 : value;
				}
			} else {
				var cached = colorCache[string];
				if (!cached) {
					if (!colorCtx) {
						colorCtx = CanvasProvider.getContext(1, 1);
						colorCtx.globalCompositeOperation = 'copy';
					}
					colorCtx.fillStyle = 'rgba(0,0,0,0)';
					colorCtx.fillStyle = string;
					colorCtx.fillRect(0, 0, 1, 1);
					var data = colorCtx.getImageData(0, 0, 1, 1).data;
					cached = colorCache[string] = [
						data[0] / 255,
						data[1] / 255,
						data[2] / 255
					];
				}
				components = cached.slice();
			}
			return components;
		}
	
		var hsbIndices = [
			[0, 3, 1],
			[2, 0, 1],
			[1, 0, 3],
			[1, 2, 0],
			[3, 1, 0],
			[0, 1, 2]
		];
	
		var converters = {
			'rgb-hsb': function(r, g, b) {
				var max = Math.max(r, g, b),
					min = Math.min(r, g, b),
					delta = max - min,
					h = delta === 0 ? 0
						:	( max == r ? (g - b) / delta + (g < b ? 6 : 0)
							: max == g ? (b - r) / delta + 2
							:			 (r - g) / delta + 4) * 60;
				return [h, max === 0 ? 0 : delta / max, max];
			},
	
			'hsb-rgb': function(h, s, b) {
				h = (((h / 60) % 6) + 6) % 6;
				var i = Math.floor(h),
					f = h - i,
					i = hsbIndices[i],
					v = [
						b,
						b * (1 - s),
						b * (1 - s * f),
						b * (1 - s * (1 - f))
					];
				return [v[i[0]], v[i[1]], v[i[2]]];
			},
	
			'rgb-hsl': function(r, g, b) {
				var max = Math.max(r, g, b),
					min = Math.min(r, g, b),
					delta = max - min,
					achromatic = delta === 0,
					h = achromatic ? 0
						:	( max == r ? (g - b) / delta + (g < b ? 6 : 0)
							: max == g ? (b - r) / delta + 2
							:			 (r - g) / delta + 4) * 60,
					l = (max + min) / 2,
					s = achromatic ? 0 : l < 0.5
							? delta / (max + min)
							: delta / (2 - max - min);
				return [h, s, l];
			},
	
			'hsl-rgb': function(h, s, l) {
				h = (((h / 360) % 1) + 1) % 1;
				if (s === 0)
					return [l, l, l];
				var t3s = [ h + 1 / 3, h, h - 1 / 3 ],
					t2 = l < 0.5 ? l * (1 + s) : l + s - l * s,
					t1 = 2 * l - t2,
					c = [];
				for (var i = 0; i < 3; i++) {
					var t3 = t3s[i];
					if (t3 < 0) t3 += 1;
					if (t3 > 1) t3 -= 1;
					c[i] = 6 * t3 < 1
						? t1 + (t2 - t1) * 6 * t3
						: 2 * t3 < 1
							? t2
							: 3 * t3 < 2
								? t1 + (t2 - t1) * ((2 / 3) - t3) * 6
								: t1;
				}
				return c;
			},
	
			'rgb-gray': function(r, g, b) {
				return [r * 0.2989 + g * 0.587 + b * 0.114];
			},
	
			'gray-rgb': function(g) {
				return [g, g, g];
			},
	
			'gray-hsb': function(g) {
				return [0, 0, g];
			},
	
			'gray-hsl': function(g) {
				return [0, 0, g];
			},
	
			'gradient-rgb': function() {
				return [];
			},
	
			'rgb-gradient': function() {
				return [];
			}
	
		};
	
		return Base.each(types, function(properties, type) {
			componentParsers[type] = [];
			Base.each(properties, function(name, index) {
				var part = Base.capitalize(name),
					hasOverlap = /^(hue|saturation)$/.test(name),
					parser = componentParsers[type][index] = name === 'gradient'
						? function(value) {
							var current = this._components[0];
							value = Gradient.read(Array.isArray(value) ? value
									: arguments, 0, { readNull: true });
							if (current !== value) {
								if (current)
									current._removeOwner(this);
								if (value)
									value._addOwner(this);
							}
							return value;
						}
						: type === 'gradient'
							? function() {
								return Point.read(arguments, 0, {
										readNull: name === 'highlight',
										clone: true
								});
							}
							: function(value) {
								return value == null || isNaN(value) ? 0 : value;
							};
	
				this['get' + part] = function() {
					return this._type === type
						|| hasOverlap && /^hs[bl]$/.test(this._type)
							? this._components[index]
							: this._convert(type)[index];
				};
	
				this['set' + part] = function(value) {
					if (this._type !== type
							&& !(hasOverlap && /^hs[bl]$/.test(this._type))) {
						this._components = this._convert(type);
						this._properties = types[type];
						this._type = type;
					}
					this._components[index] = parser.call(this, value);
					this._changed();
				};
			}, this);
		}, {
			_class: 'Color',
			_readIndex: true,
	
			initialize: function Color(arg) {
				var slice = Array.prototype.slice,
					args = arguments,
					read = 0,
					type,
					components,
					alpha,
					values;
				if (Array.isArray(arg)) {
					args = arg;
					arg = args[0];
				}
				var argType = arg != null && typeof arg;
				if (argType === 'string' && arg in types) {
					type = arg;
					arg = args[1];
					if (Array.isArray(arg)) {
						components = arg;
						alpha = args[2];
					} else {
						if (this.__read)
							read = 1;
						args = slice.call(args, 1);
						argType = typeof arg;
					}
				}
				if (!components) {
					values = argType === 'number'
							? args
							: argType === 'object' && arg.length != null
								? arg
								: null;
					if (values) {
						if (!type)
							type = values.length >= 3
									? 'rgb'
									: 'gray';
						var length = types[type].length;
						alpha = values[length];
						if (this.__read)
							read += values === arguments
								? length + (alpha != null ? 1 : 0)
								: 1;
						if (values.length > length)
							values = slice.call(values, 0, length);
					} else if (argType === 'string') {
						type = 'rgb';
						components = fromCSS(arg);
						if (components.length === 4) {
							alpha = components[3];
							components.length--;
						}
					} else if (argType === 'object') {
						if (arg.constructor === Color) {
							type = arg._type;
							components = arg._components.slice();
							alpha = arg._alpha;
							if (type === 'gradient') {
								for (var i = 1, l = components.length; i < l; i++) {
									var point = components[i];
									if (point)
										components[i] = point.clone();
								}
							}
						} else if (arg.constructor === Gradient) {
							type = 'gradient';
							values = args;
						} else {
							type = 'hue' in arg
								? 'lightness' in arg
									? 'hsl'
									: 'hsb'
								: 'gradient' in arg || 'stops' in arg
										|| 'radial' in arg
									? 'gradient'
									: 'gray' in arg
										? 'gray'
										: 'rgb';
							var properties = types[type];
								parsers = componentParsers[type];
							this._components = components = [];
							for (var i = 0, l = properties.length; i < l; i++) {
								var value = arg[properties[i]];
								if (value == null && i === 0 && type === 'gradient'
										&& 'stops' in arg) {
									value = {
										stops: arg.stops,
										radial: arg.radial
									};
								}
								value = parsers[i].call(this, value);
								if (value != null)
									components[i] = value;
							}
							alpha = arg.alpha;
						}
					}
					if (this.__read && type)
						read = 1;
				}
				this._type = type || 'rgb';
				this._id = UID.get(Color);
				if (!components) {
					this._components = components = [];
					var parsers = componentParsers[this._type];
					for (var i = 0, l = parsers.length; i < l; i++) {
						var value = parsers[i].call(this, values && values[i]);
						if (value != null)
							components[i] = value;
					}
				}
				this._components = components;
				this._properties = types[this._type];
				this._alpha = alpha;
				if (this.__read)
					this.__read = read;
			},
	
			_serialize: function(options, dictionary) {
				var components = this.getComponents();
				return Base.serialize(
						/^(gray|rgb)$/.test(this._type)
							? components
							: [this._type].concat(components),
						options, true, dictionary);
			},
	
			_changed: function() {
				this._canvasStyle = null;
				if (this._owner)
					this._owner._changed(65);
			},
	
			_convert: function(type) {
				var converter;
				return this._type === type
						? this._components.slice()
						: (converter = converters[this._type + '-' + type])
							? converter.apply(this, this._components)
							: converters['rgb-' + type].apply(this,
								converters[this._type + '-rgb'].apply(this,
									this._components));
			},
	
			convert: function(type) {
				return new Color(type, this._convert(type), this._alpha);
			},
	
			getType: function() {
				return this._type;
			},
	
			setType: function(type) {
				this._components = this._convert(type);
				this._properties = types[type];
				this._type = type;
			},
	
			getComponents: function() {
				var components = this._components.slice();
				if (this._alpha != null)
					components.push(this._alpha);
				return components;
			},
	
			getAlpha: function() {
				return this._alpha != null ? this._alpha : 1;
			},
	
			setAlpha: function(alpha) {
				this._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);
				this._changed();
			},
	
			hasAlpha: function() {
				return this._alpha != null;
			},
	
			equals: function(color) {
				var col = Base.isPlainValue(color, true)
						? Color.read(arguments)
						: color;
				return col === this || col && this._class === col._class
						&& this._type === col._type
						&& this._alpha === col._alpha
						&& Base.equals(this._components, col._components)
						|| false;
			},
	
			toString: function() {
				var properties = this._properties,
					parts = [],
					isGradient = this._type === 'gradient',
					f = Formatter.instance;
				for (var i = 0, l = properties.length; i < l; i++) {
					var value = this._components[i];
					if (value != null)
						parts.push(properties[i] + ': '
								+ (isGradient ? value : f.number(value)));
				}
				if (this._alpha != null)
					parts.push('alpha: ' + f.number(this._alpha));
				return '{ ' + parts.join(', ') + ' }';
			},
	
			toCSS: function(hex) {
				var components = this._convert('rgb'),
					alpha = hex || this._alpha == null ? 1 : this._alpha;
				function convert(val) {
					return Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);
				}
				components = [
					convert(components[0]),
					convert(components[1]),
					convert(components[2])
				];
				if (alpha < 1)
					components.push(alpha < 0 ? 0 : alpha);
				return hex
						? '#' + ((1 << 24) + (components[0] << 16)
							+ (components[1] << 8)
							+ components[2]).toString(16).slice(1)
						: (components.length == 4 ? 'rgba(' : 'rgb(')
							+ components.join(',') + ')';
			},
	
			toCanvasStyle: function(ctx) {
				if (this._canvasStyle)
					return this._canvasStyle;
				if (this._type !== 'gradient')
					return this._canvasStyle = this.toCSS();
				var components = this._components,
					gradient = components[0],
					stops = gradient._stops,
					origin = components[1],
					destination = components[2],
					canvasGradient;
				if (gradient._radial) {
					var radius = destination.getDistance(origin),
						highlight = components[3];
					if (highlight) {
						var vector = highlight.subtract(origin);
						if (vector.getLength() > radius)
							highlight = origin.add(vector.normalize(radius - 0.1));
					}
					var start = highlight || origin;
					canvasGradient = ctx.createRadialGradient(start.x, start.y,
							0, origin.x, origin.y, radius);
				} else {
					canvasGradient = ctx.createLinearGradient(origin.x, origin.y,
							destination.x, destination.y);
				}
				for (var i = 0, l = stops.length; i < l; i++) {
					var stop = stops[i];
					canvasGradient.addColorStop(stop._rampPoint,
							stop._color.toCanvasStyle());
				}
				return this._canvasStyle = canvasGradient;
			},
	
			transform: function(matrix) {
				if (this._type === 'gradient') {
					var components = this._components;
					for (var i = 1, l = components.length; i < l; i++) {
						var point = components[i];
						matrix._transformPoint(point, point, true);
					}
					this._changed();
				}
			},
	
			statics: {
				_types: types,
	
				random: function() {
					var random = Math.random;
					return new Color(random(), random(), random());
				}
			}
		});
	}, new function() {
		var operators = {
			add: function(a, b) {
				return a + b;
			},
	
			subtract: function(a, b) {
				return a - b;
			},
	
			multiply: function(a, b) {
				return a * b;
			},
	
			divide: function(a, b) {
				return a / b;
			}
		};
	
		return Base.each(operators, function(operator, name) {
			this[name] = function(color) {
				color = Color.read(arguments);
				var type = this._type,
					components1 = this._components,
					components2 = color._convert(type);
				for (var i = 0, l = components1.length; i < l; i++)
					components2[i] = operator(components1[i], components2[i]);
				return new Color(type, components2,
						this._alpha != null
								? operator(this._alpha, color.getAlpha())
								: null);
			};
		}, {
		});
	});
	
	Base.each(Color._types, function(properties, type) {
		var ctor = this[Base.capitalize(type) + 'Color'] = function(arg) {
				var argType = arg != null && typeof arg,
					components = argType === 'object' && arg.length != null
						? arg
						: argType === 'string'
							? null
							: arguments;
				return components
						? new Color(type, components)
						: new Color(arg);
			};
		if (type.length == 3) {
			var acronym = type.toUpperCase();
			Color[acronym] = this[acronym + 'Color'] = ctor;
		}
	}, Base.exports);
	
	var Gradient = Base.extend({
		_class: 'Gradient',
	
		initialize: function Gradient(stops, radial) {
			this._id = UID.get();
			if (stops && this._set(stops))
				stops = radial = null;
			if (!this._stops)
				this.setStops(stops || ['white', 'black']);
			if (this._radial == null)
				this.setRadial(typeof radial === 'string' && radial === 'radial'
						|| radial || false);
		},
	
		_serialize: function(options, dictionary) {
			return dictionary.add(this, function() {
				return Base.serialize([this._stops, this._radial],
						options, true, dictionary);
			});
		},
	
		_changed: function() {
			for (var i = 0, l = this._owners && this._owners.length; i < l; i++)
				this._owners[i]._changed();
		},
	
		_addOwner: function(color) {
			if (!this._owners)
				this._owners = [];
			this._owners.push(color);
		},
	
		_removeOwner: function(color) {
			var index = this._owners ? this._owners.indexOf(color) : -1;
			if (index != -1) {
				this._owners.splice(index, 1);
				if (this._owners.length === 0)
					this._owners = undefined;
			}
		},
	
		clone: function() {
			var stops = [];
			for (var i = 0, l = this._stops.length; i < l; i++)
				stops[i] = this._stops[i].clone();
			return new Gradient(stops, this._radial);
		},
	
		getStops: function() {
			return this._stops;
		},
	
		setStops: function(stops) {
			if (this.stops) {
				for (var i = 0, l = this._stops.length; i < l; i++)
					this._stops[i]._owner = undefined;
			}
			if (stops.length < 2)
				throw new Error(
						'Gradient stop list needs to contain at least two stops.');
			this._stops = GradientStop.readAll(stops, 0, { clone: true });
			for (var i = 0, l = this._stops.length; i < l; i++) {
				var stop = this._stops[i];
				stop._owner = this;
				if (stop._defaultRamp)
					stop.setRampPoint(i / (l - 1));
			}
			this._changed();
		},
	
		getRadial: function() {
			return this._radial;
		},
	
		setRadial: function(radial) {
			this._radial = radial;
			this._changed();
		},
	
		equals: function(gradient) {
			if (gradient === this)
				return true;
			if (gradient && this._class === gradient._class
					&& this._stops.length === gradient._stops.length) {
				for (var i = 0, l = this._stops.length; i < l; i++) {
					if (!this._stops[i].equals(gradient._stops[i]))
						return false;
				}
				return true;
			}
			return false;
		}
	});
	
	var GradientStop = Base.extend({
		_class: 'GradientStop',
	
		initialize: function GradientStop(arg0, arg1) {
			if (arg0) {
				var color, rampPoint;
				if (arg1 === undefined && Array.isArray(arg0)) {
					color = arg0[0];
					rampPoint = arg0[1];
				} else if (arg0.color) {
					color = arg0.color;
					rampPoint = arg0.rampPoint;
				} else {
					color = arg0;
					rampPoint = arg1;
				}
				this.setColor(color);
				this.setRampPoint(rampPoint);
			}
		},
	
		clone: function() {
			return new GradientStop(this._color.clone(), this._rampPoint);
		},
	
		_serialize: function(options, dictionary) {
			return Base.serialize([this._color, this._rampPoint], options, true,
					dictionary);
		},
	
		_changed: function() {
			if (this._owner)
				this._owner._changed(65);
		},
	
		getRampPoint: function() {
			return this._rampPoint;
		},
	
		setRampPoint: function(rampPoint) {
			this._defaultRamp = rampPoint == null;
			this._rampPoint = rampPoint || 0;
			this._changed();
		},
	
		getColor: function() {
			return this._color;
		},
	
		setColor: function(color) {
			this._color = Color.read(arguments);
			if (this._color === color)
				this._color = color.clone();
			this._color._owner = this;
			this._changed();
		},
	
		equals: function(stop) {
			return stop === this || stop && this._class === stop._class
					&& this._color.equals(stop._color)
					&& this._rampPoint == stop._rampPoint
					|| false;
		}
	});
	
	var Style = Base.extend(new function() {
		var defaults = {
			fillColor: undefined,
			strokeColor: undefined,
			strokeWidth: 1,
			strokeCap: 'butt',
			strokeJoin: 'miter',
			strokeScaling: true,
			miterLimit: 10,
			dashOffset: 0,
			dashArray: [],
			windingRule: 'nonzero',
			shadowColor: undefined,
			shadowBlur: 0,
			shadowOffset: new Point(),
			selectedColor: undefined,
			fontFamily: 'sans-serif',
			fontWeight: 'normal',
			fontSize: 12,
			font: 'sans-serif',
			leading: null,
			justification: 'left'
		};
	
		var flags = {
			strokeWidth: 97,
			strokeCap: 97,
			strokeJoin: 97,
			strokeScaling: 105,
			miterLimit: 97,
			fontFamily: 9,
			fontWeight: 9,
			fontSize: 9,
			font: 9,
			leading: 9,
			justification: 9
		};
	
		var item = { beans: true },
			fields = {
				_defaults: defaults,
				_textDefaults: new Base(defaults, {
					fillColor: new Color()
				}),
				beans: true
			};
	
		Base.each(defaults, function(value, key) {
			var isColor = /Color$/.test(key),
				isPoint = key === 'shadowOffset',
				part = Base.capitalize(key),
				flag = flags[key],
				set = 'set' + part,
				get = 'get' + part;
	
			fields[set] = function(value) {
				var owner = this._owner,
					children = owner && owner._children;
				if (children && children.length > 0
						&& !(owner instanceof CompoundPath)) {
					for (var i = 0, l = children.length; i < l; i++)
						children[i]._style[set](value);
				} else {
					var old = this._values[key];
					if (old !== value) {
						if (isColor) {
							if (old)
								old._owner = undefined;
							if (value && value.constructor === Color) {
								if (value._owner)
									value = value.clone();
								value._owner = owner;
							}
						}
						this._values[key] = value;
						if (owner)
							owner._changed(flag || 65);
					}
				}
			};
	
			fields[get] = function(_dontMerge) {
				var owner = this._owner,
					children = owner && owner._children,
					value;
				if (!children || children.length === 0 || _dontMerge
						|| owner instanceof CompoundPath) {
					var value = this._values[key];
					if (value === undefined) {
						value = this._defaults[key];
						if (value && value.clone)
							value = value.clone();
					} else {
						var ctor = isColor ? Color : isPoint ? Point : null;
						if (ctor && !(value && value.constructor === ctor)) {
							this._values[key] = value = ctor.read([value], 0,
									{ readNull: true, clone: true });
							if (value && isColor)
								value._owner = owner;
						}
					}
					return value;
				}
				for (var i = 0, l = children.length; i < l; i++) {
					var childValue = children[i]._style[get]();
					if (i === 0) {
						value = childValue;
					} else if (!Base.equals(value, childValue)) {
						return undefined;
					}
				}
				return value;
			};
	
			item[get] = function(_dontMerge) {
				return this._style[get](_dontMerge);
			};
	
			item[set] = function(value) {
				this._style[set](value);
			};
		});
	
		Item.inject(item);
		return fields;
	}, {
		_class: 'Style',
	
		initialize: function Style(style, _owner, _project) {
			this._values = {};
			this._owner = _owner;
			this._project = _owner && _owner._project || _project || paper.project;
			if (_owner instanceof TextItem)
				this._defaults = this._textDefaults;
			if (style)
				this.set(style);
		},
	
		set: function(style) {
			var isStyle = style instanceof Style,
				values = isStyle ? style._values : style;
			if (values) {
				for (var key in values) {
					if (key in this._defaults) {
						var value = values[key];
						this[key] = value && isStyle && value.clone
								? value.clone() : value;
					}
				}
			}
		},
	
		equals: function(style) {
			return style === this || style && this._class === style._class
					&& Base.equals(this._values, style._values)
					|| false;
		},
	
		hasFill: function() {
			return !!this.getFillColor();
		},
	
		hasStroke: function() {
			return !!this.getStrokeColor() && this.getStrokeWidth() > 0;
		},
	
		hasShadow: function() {
			return !!this.getShadowColor() && this.getShadowBlur() > 0;
		},
	
		getView: function() {
			return this._project.getView();
		},
	
		getFontStyle: function() {
			var fontSize = this.getFontSize();
			return this.getFontWeight()
					+ ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ')
					+ this.getFontFamily();
		},
	
		getFont: '#getFontFamily',
		setFont: '#setFontFamily',
	
		getLeading: function getLeading() {
			var leading = getLeading.base.call(this),
				fontSize = this.getFontSize();
			if (/pt|em|%|px/.test(fontSize))
				fontSize = this.getView().getPixelSize(fontSize);
			return leading != null ? leading : fontSize * 1.2;
		}
	
	});
	
	var DomElement = new function() {
		function handlePrefix(el, name, set, value) {
			var prefixes = ['', 'webkit', 'moz', 'Moz', 'ms', 'o'],
				suffix = name[0].toUpperCase() + name.substring(1);
			for (var i = 0; i < 6; i++) {
				var prefix = prefixes[i],
					key = prefix ? prefix + suffix : name;
				if (key in el) {
					if (set) {
						el[key] = value;
					} else {
						return el[key];
					}
					break;
				}
			}
		}
	
		return {
			getStyles: function(el) {
				var doc = el && el.nodeType !== 9 ? el.ownerDocument : el,
					view = doc && doc.defaultView;
				return view && view.getComputedStyle(el, '');
			},
	
			getBounds: function(el, viewport) {
				var doc = el.ownerDocument,
					body = doc.body,
					html = doc.documentElement,
					rect;
				try {
					rect = el.getBoundingClientRect();
				} catch (e) {
					rect = { left: 0, top: 0, width: 0, height: 0 };
				}
				var x = rect.left - (html.clientLeft || body.clientLeft || 0),
					y = rect.top - (html.clientTop || body.clientTop || 0);
				if (!viewport) {
					var view = doc.defaultView;
					x += view.pageXOffset || html.scrollLeft || body.scrollLeft;
					y += view.pageYOffset || html.scrollTop || body.scrollTop;
				}
				return new Rectangle(x, y, rect.width, rect.height);
			},
	
			getViewportBounds: function(el) {
				var doc = el.ownerDocument,
					view = doc.defaultView,
					html = doc.documentElement;
				return new Rectangle(0, 0,
					view.innerWidth || html.clientWidth,
					view.innerHeight || html.clientHeight
				);
			},
	
			getOffset: function(el, viewport) {
				return DomElement.getBounds(el, viewport).getPoint();
			},
	
			getSize: function(el) {
				return DomElement.getBounds(el, true).getSize();
			},
	
			isInvisible: function(el) {
				return DomElement.getSize(el).equals(new Size(0, 0));
			},
	
			isInView: function(el) {
				return !DomElement.isInvisible(el)
						&& DomElement.getViewportBounds(el).intersects(
							DomElement.getBounds(el, true));
			},
	
			getPrefixed: function(el, name) {
				return handlePrefix(el, name);
			},
	
			setPrefixed: function(el, name, value) {
				if (typeof name === 'object') {
					for (var key in name)
						handlePrefix(el, key, true, name[key]);
				} else {
					handlePrefix(el, name, true, value);
				}
			}
		};
	};
	
	var DomEvent = {
		add: function(el, events) {
			for (var type in events) {
				var func = events[type],
					parts = type.split(/[\s,]+/g);
				for (var i = 0, l = parts.length; i < l; i++)
					el.addEventListener(parts[i], func, false);
			}
		},
	
		remove: function(el, events) {
			for (var type in events) {
				var func = events[type],
					parts = type.split(/[\s,]+/g);
				for (var i = 0, l = parts.length; i < l; i++)
					el.removeEventListener(parts[i], func, false);
			}
		},
	
		getPoint: function(event) {
			var pos = event.targetTouches
					? event.targetTouches.length
						? event.targetTouches[0]
						: event.changedTouches[0]
					: event;
			return new Point(
				pos.pageX || pos.clientX + document.documentElement.scrollLeft,
				pos.pageY || pos.clientY + document.documentElement.scrollTop
			);
		},
	
		getTarget: function(event) {
			return event.target || event.srcElement;
		},
	
		getRelatedTarget: function(event) {
			return event.relatedTarget || event.toElement;
		},
	
		getOffset: function(event, target) {
			return DomEvent.getPoint(event).subtract(DomElement.getOffset(
					target || DomEvent.getTarget(event)));
		},
	
		stop: function(event) {
			event.stopPropagation();
			event.preventDefault();
		}
	};
	
	DomEvent.requestAnimationFrame = new function() {
		var nativeRequest = DomElement.getPrefixed(window, 'requestAnimationFrame'),
			requested = false,
			callbacks = [],
			focused = true,
			timer;
	
		DomEvent.add(window, {
			focus: function() {
				focused = true;
			},
			blur: function() {
				focused = false;
			}
		});
	
		function handleCallbacks() {
			for (var i = callbacks.length - 1; i >= 0; i--) {
				var entry = callbacks[i],
					func = entry[0],
					el = entry[1];
				if (!el || (PaperScope.getAttribute(el, 'keepalive') == 'true'
						|| focused) && DomElement.isInView(el)) {
					callbacks.splice(i, 1);
					func();
				}
			}
			if (nativeRequest) {
				if (callbacks.length) {
					nativeRequest(handleCallbacks);
				} else {
					requested = false;
				}
			}
		}
	
		return function(callback, element) {
			callbacks.push([callback, element]);
			if (nativeRequest) {
				if (!requested) {
					nativeRequest(handleCallbacks);
					requested = true;
				}
			} else if (!timer) {
				timer = setInterval(handleCallbacks, 1000 / 60);
			}
		};
	};
	
	var View = Base.extend(Emitter, {
		_class: 'View',
	
		initialize: function View(project, element) {
			this._project = project;
			this._scope = project._scope;
			this._element = element;
			var size;
			if (!this._pixelRatio)
				this._pixelRatio = window.devicePixelRatio || 1;
			this._id = element.getAttribute('id');
			if (this._id == null)
				element.setAttribute('id', this._id = 'view-' + View._id++);
			DomEvent.add(element, this._viewEvents);
			var none = 'none';
			DomElement.setPrefixed(element.style, {
				userSelect: none,
				touchAction: none,
				touchCallout: none,
				contentZooming: none,
				userDrag: none,
				tapHighlightColor: 'rgba(0,0,0,0)'
			});
	
			function getSize(name) {
				return element[name] || parseInt(element.getAttribute(name), 10);
			};
	
			function getCanvasSize() {
				var size = DomElement.getSize(element);
				return size.isNaN() || size.isZero()
						? new Size(getSize('width'), getSize('height'))
						: size;
			};
	
			if (PaperScope.hasAttribute(element, 'resize')) {
				var that = this;
				DomEvent.add(window, this._windowEvents = {
					resize: function() {
						that.setViewSize(getCanvasSize());
					}
				});
			}
			this._setViewSize(size = getCanvasSize());
			if (PaperScope.hasAttribute(element, 'stats')
					&& typeof Stats !== 'undefined') {
				this._stats = new Stats();
				var stats = this._stats.domElement,
					style = stats.style,
					offset = DomElement.getOffset(element);
				style.position = 'absolute';
				style.left = offset.x + 'px';
				style.top = offset.y + 'px';
				document.body.appendChild(stats);
			}
			View._views.push(this);
			View._viewsById[this._id] = this;
			this._viewSize = size;
			(this._matrix = new Matrix())._owner = this;
			this._zoom = 1;
			if (!View._focused)
				View._focused = this;
			this._frameItems = {};
			this._frameItemCount = 0;
		},
	
		remove: function() {
			if (!this._project)
				return false;
			if (View._focused === this)
				View._focused = null;
			View._views.splice(View._views.indexOf(this), 1);
			delete View._viewsById[this._id];
			if (this._project._view === this)
				this._project._view = null;
			DomEvent.remove(this._element, this._viewEvents);
			DomEvent.remove(window, this._windowEvents);
			this._element = this._project = null;
			this.off('frame');
			this._animate = false;
			this._frameItems = {};
			return true;
		},
	
		_events: {
			onFrame: {
				install: function() {
					this.play();
				},
	
				uninstall: function() {
					this.pause();
				}
			},
	
			onResize: {}
		},
	
		_animate: false,
		_time: 0,
		_count: 0,
	
		_requestFrame: function() {
			var that = this;
			DomEvent.requestAnimationFrame(function() {
				that._requested = false;
				if (!that._animate)
					return;
				that._requestFrame();
				that._handleFrame();
			}, this._element);
			this._requested = true;
		},
	
		_handleFrame: function() {
			paper = this._scope;
			var now = Date.now() / 1000,
				delta = this._before ? now - this._before : 0;
			this._before = now;
			this._handlingFrame = true;
			this.emit('frame', new Base({
				delta: delta,
				time: this._time += delta,
				count: this._count++
			}));
			if (this._stats)
				this._stats.update();
			this._handlingFrame = false;
			this.update();
		},
	
		_animateItem: function(item, animate) {
			var items = this._frameItems;
			if (animate) {
				items[item._id] = {
					item: item,
					time: 0,
					count: 0
				};
				if (++this._frameItemCount === 1)
					this.on('frame', this._handleFrameItems);
			} else {
				delete items[item._id];
				if (--this._frameItemCount === 0) {
					this.off('frame', this._handleFrameItems);
				}
			}
		},
	
		_handleFrameItems: function(event) {
			for (var i in this._frameItems) {
				var entry = this._frameItems[i];
				entry.item.emit('frame', new Base(event, {
					time: entry.time += event.delta,
					count: entry.count++
				}));
			}
		},
	
		_update: function() {
			this._project._needsUpdate = true;
			if (this._handlingFrame)
				return;
			if (this._animate) {
				this._handleFrame();
			} else {
				this.update();
			}
		},
	
		_changed: function(flags) {
			if (flags & 1)
				this._project._needsUpdate = true;
		},
	
		_transform: function(matrix) {
			this._matrix.concatenate(matrix);
			this._bounds = null;
			this._update();
		},
	
		getElement: function() {
			return this._element;
		},
	
		getPixelRatio: function() {
			return this._pixelRatio;
		},
	
		getResolution: function() {
			return this._pixelRatio * 72;
		},
	
		getViewSize: function() {
			var size = this._viewSize;
			return new LinkedSize(size.width, size.height, this, 'setViewSize');
		},
	
		setViewSize: function() {
			var size = Size.read(arguments),
				delta = size.subtract(this._viewSize);
			if (delta.isZero())
				return;
			this._viewSize.set(size.width, size.height);
			this._setViewSize(size);
			this._bounds = null;
			this.emit('resize', {
				size: size,
				delta: delta
			});
			this._update();
		},
	
		_setViewSize: function(size) {
			var element = this._element;
			element.width = size.width;
			element.height = size.height;
		},
	
		getBounds: function() {
			if (!this._bounds)
				this._bounds = this._matrix.inverted()._transformBounds(
						new Rectangle(new Point(), this._viewSize));
			return this._bounds;
		},
	
		getSize: function() {
			return this.getBounds().getSize();
		},
	
		getCenter: function() {
			return this.getBounds().getCenter();
		},
	
		setCenter: function() {
			var center = Point.read(arguments);
			this.scrollBy(center.subtract(this.getCenter()));
		},
	
		getZoom: function() {
			return this._zoom;
		},
	
		setZoom: function(zoom) {
			this._transform(new Matrix().scale(zoom / this._zoom,
				this.getCenter()));
			this._zoom = zoom;
		},
	
		isVisible: function() {
			return DomElement.isInView(this._element);
		},
	
		scrollBy: function() {
			this._transform(new Matrix().translate(Point.read(arguments).negate()));
		},
	
		play: function() {
			this._animate = true;
			if (!this._requested)
				this._requestFrame();
		},
	
		pause: function() {
			this._animate = false;
		},
	
		draw: function() {
			this.update();
		},
	
		projectToView: function() {
			return this._matrix._transformPoint(Point.read(arguments));
		},
	
		viewToProject: function() {
			return this._matrix._inverseTransform(Point.read(arguments));
		}
	
	}, {
		statics: {
			_views: [],
			_viewsById: {},
			_id: 0,
	
			create: function(project, element) {
				if (typeof element === 'string')
					element = document.getElementById(element);
				return new CanvasView(project, element);
			}
		}
	}, new function() {
		var tool,
			prevFocus,
			tempFocus,
			dragging = false;
	
		function getView(event) {
			var target = DomEvent.getTarget(event);
			return target.getAttribute && View._viewsById[target.getAttribute('id')];
		}
	
		function viewToProject(view, event) {
			return view.viewToProject(DomEvent.getOffset(event, view._element));
		}
	
		function updateFocus() {
			if (!View._focused || !View._focused.isVisible()) {
				for (var i = 0, l = View._views.length; i < l; i++) {
					var view = View._views[i];
					if (view && view.isVisible()) {
						View._focused = tempFocus = view;
						break;
					}
				}
			}
		}
	
		function handleMouseMove(view, point, event) {
			view._handleEvent('mousemove', point, event);
			var tool = view._scope.tool;
			if (tool) {
				tool._handleEvent(dragging && tool.responds('mousedrag')
						? 'mousedrag' : 'mousemove', point, event);
			}
			view.update();
			return tool;
		}
	
		var navigator = window.navigator,
			mousedown, mousemove, mouseup;
		if (navigator.pointerEnabled || navigator.msPointerEnabled) {
			mousedown = 'pointerdown MSPointerDown';
			mousemove = 'pointermove MSPointerMove';
			mouseup = 'pointerup pointercancel MSPointerUp MSPointerCancel';
		} else {
			mousedown = 'touchstart';
			mousemove = 'touchmove';
			mouseup = 'touchend touchcancel';
			if (!('ontouchstart' in window && navigator.userAgent.match(
					/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {
				mousedown += ' mousedown';
				mousemove += ' mousemove';
				mouseup += ' mouseup';
			}
		}
	
		var viewEvents = {
			'selectstart dragstart': function(event) {
				if (dragging)
					event.preventDefault();
			}
		};
	
		var docEvents = {
			mouseout: function(event) {
				var view = View._focused,
					target = DomEvent.getRelatedTarget(event);
				if (view && (!target || target.nodeName === 'HTML'))
					handleMouseMove(view, viewToProject(view, event), event);
			},
	
			scroll: updateFocus
		};
	
		viewEvents[mousedown] = function(event) {
			var view = View._focused = getView(event),
				point = viewToProject(view, event);
			dragging = true;
			view._handleEvent('mousedown', point, event);
			if (tool = view._scope.tool)
				tool._handleEvent('mousedown', point, event);
			view.update();
		};
	
		docEvents[mousemove] = function(event) {
			var view = View._focused;
			if (!dragging) {
				var target = getView(event);
				if (target) {
					if (view !== target)
						handleMouseMove(view, viewToProject(view, event), event);
					prevFocus = view;
					view = View._focused = tempFocus = target;
				} else if (tempFocus && tempFocus === view) {
					view = View._focused = prevFocus;
					updateFocus();
				}
			}
			if (view) {
				var point = viewToProject(view, event);
				if (dragging || view.getBounds().contains(point))
					tool = handleMouseMove(view, point, event);
			}
		};
	
		docEvents[mouseup] = function(event) {
			var view = View._focused;
			if (!view || !dragging)
				return;
			var point = viewToProject(view, event);
			dragging = false;
			view._handleEvent('mouseup', point, event);
			if (tool)
				tool._handleEvent('mouseup', point, event);
			view.update();
		};
	
		DomEvent.add(document, docEvents);
	
		DomEvent.add(window, {
			load: updateFocus
		});
	
		return {
			_viewEvents: viewEvents,
	
			_handleEvent: function() {},
	
			statics: {
				updateFocus: updateFocus
			}
		};
	});
	
	var CanvasView = View.extend({
		_class: 'CanvasView',
	
		initialize: function CanvasView(project, canvas) {
			if (!(canvas instanceof HTMLCanvasElement)) {
				var size = Size.read(arguments, 1);
				if (size.isZero())
					throw new Error(
							'Cannot create CanvasView with the provided argument: '
							+ [].slice.call(arguments, 1));
				canvas = CanvasProvider.getCanvas(size);
			}
			this._context = canvas.getContext('2d');
			this._eventCounters = {};
			this._pixelRatio = 1;
			if (!/^off|false$/.test(PaperScope.getAttribute(canvas, 'hidpi'))) {
				var deviceRatio = window.devicePixelRatio || 1,
					backingStoreRatio = DomElement.getPrefixed(this._context,
							'backingStorePixelRatio') || 1;
				this._pixelRatio = deviceRatio / backingStoreRatio;
			}
			View.call(this, project, canvas);
		},
	
		_setViewSize: function(size) {
			var element = this._element,
				pixelRatio = this._pixelRatio,
				width = size.width,
				height = size.height;
			element.width = width * pixelRatio;
			element.height = height * pixelRatio;
			if (pixelRatio !== 1) {
				if (!PaperScope.hasAttribute(element, 'resize')) {
					var style = element.style;
					style.width = width + 'px';
					style.height = height + 'px';
				}
				this._context.scale(pixelRatio, pixelRatio);
			}
		},
	
		getPixelSize: function(size) {
			var browser = paper.browser,
				pixels;
			if (browser && browser.firefox) {
				var parent = this._element.parentNode,
					temp = document.createElement('div');
				temp.style.fontSize = size;
				parent.appendChild(temp);
				pixels = parseFloat(DomElement.getStyles(temp).fontSize);
				parent.removeChild(temp);
			} else {
				var ctx = this._context,
					prevFont = ctx.font;
				ctx.font = size + ' serif';
				pixels = parseFloat(ctx.font);
				ctx.font = prevFont;
			}
			return pixels;
		},
	
		getTextWidth: function(font, lines) {
			var ctx = this._context,
				prevFont = ctx.font,
				width = 0;
			ctx.font = font;
			for (var i = 0, l = lines.length; i < l; i++)
				width = Math.max(width, ctx.measureText(lines[i]).width);
			ctx.font = prevFont;
			return width;
		},
	
		update: function(force) {
			var project = this._project;
			if (!project || !force && !project._needsUpdate)
				return false;
			var ctx = this._context,
				size = this._viewSize;
			ctx.clearRect(0, 0, size.width + 1, size.height + 1);
			project.draw(ctx, this._matrix, this._pixelRatio);
			project._needsUpdate = false;
			return true;
		}
	}, new function() {
	
		var downPoint,
			lastPoint,
			overPoint,
			downItem,
			lastItem,
			overItem,
			dragItem,
			dblClick,
			clickTime;
	
		function callEvent(view, type, event, point, target, lastPoint) {
			var item = target,
				mouseEvent;
	
			function call(obj) {
				if (obj.responds(type)) {
					if (!mouseEvent) {
						mouseEvent = new MouseEvent(type, event, point, target,
								lastPoint ? point.subtract(lastPoint) : null);
					}
					if (obj.emit(type, mouseEvent) && mouseEvent.isStopped) {
						event.preventDefault();
						return true;
					}
				}
			}
	
			while (item) {
				if (call(item))
					return true;
				item = item.getParent();
			}
			if (call(view))
				return true;
			return false;
		}
	
		return {
			_handleEvent: function(type, point, event) {
				if (!this._eventCounters[type])
					return;
				var project = this._project,
					hit = project.hitTest(point, {
						tolerance: 0,
						fill: true,
						stroke: true
					}),
					item = hit && hit.item,
					stopped = false;
				switch (type) {
				case 'mousedown':
					stopped = callEvent(this, type, event, point, item);
					dblClick = lastItem == item && (Date.now() - clickTime < 300);
					downItem = lastItem = item;
					downPoint = lastPoint = overPoint = point;
					dragItem = !stopped && item;
					while (dragItem && !dragItem.responds('mousedrag'))
						dragItem = dragItem._parent;
					break;
				case 'mouseup':
					stopped = callEvent(this, type, event, point, item, downPoint);
					if (dragItem) {
						if (lastPoint && !lastPoint.equals(point))
							callEvent(this, 'mousedrag', event, point, dragItem,
									lastPoint);
						if (item !== dragItem) {
							overPoint = point;
							callEvent(this, 'mousemove', event, point, item,
									overPoint);
						}
					}
					if (!stopped && item && item === downItem) {
						clickTime = Date.now();
						callEvent(this, dblClick && downItem.responds('doubleclick')
								? 'doubleclick' : 'click', event, downPoint, item);
						dblClick = false;
					}
					downItem = dragItem = null;
					break;
				case 'mousemove':
					if (dragItem)
						stopped = callEvent(this, 'mousedrag', event, point,
								dragItem, lastPoint);
					if (!stopped) {
						if (item !== overItem)
							overPoint = point;
						stopped = callEvent(this, type, event, point, item,
								overPoint);
					}
					lastPoint = overPoint = point;
					if (item !== overItem) {
						callEvent(this, 'mouseleave', event, point, overItem);
						overItem = item;
						callEvent(this, 'mouseenter', event, point, item);
					}
					break;
				}
				return stopped;
			}
		};
	});
	
	var Event = Base.extend({
		_class: 'Event',
	
		initialize: function Event(event) {
			this.event = event;
		},
	
		isPrevented: false,
		isStopped: false,
	
		preventDefault: function() {
			this.isPrevented = true;
			this.event.preventDefault();
		},
	
		stopPropagation: function() {
			this.isStopped = true;
			this.event.stopPropagation();
		},
	
		stop: function() {
			this.stopPropagation();
			this.preventDefault();
		},
	
		getModifiers: function() {
			return Key.modifiers;
		}
	});
	
	var KeyEvent = Event.extend({
		_class: 'KeyEvent',
	
		initialize: function KeyEvent(down, key, character, event) {
			Event.call(this, event);
			this.type = down ? 'keydown' : 'keyup';
			this.key = key;
			this.character = character;
		},
	
		toString: function() {
			return "{ type: '" + this.type
					+ "', key: '" + this.key
					+ "', character: '" + this.character
					+ "', modifiers: " + this.getModifiers()
					+ " }";
		}
	});
	
	var Key = new function() {
	
		var specialKeys = {
			8: 'backspace',
			9: 'tab',
			13: 'enter',
			16: 'shift',
			17: 'control',
			18: 'option',
			19: 'pause',
			20: 'caps-lock',
			27: 'escape',
			32: 'space',
			35: 'end',
			36: 'home',
			37: 'left',
			38: 'up',
			39: 'right',
			40: 'down',
			46: 'delete',
			91: 'command',
			93: 'command',
			224: 'command'
		},
	
		specialChars = {
			9: true,
			13: true,
			32: true
		},
	
		modifiers = new Base({
			shift: false,
			control: false,
			option: false,
			command: false,
			capsLock: false,
			space: false
		}),
	
		charCodeMap = {},
		keyMap = {},
		commandFixMap,
		downCode;
	
		function handleKey(down, keyCode, charCode, event) {
			var character = charCode ? String.fromCharCode(charCode) : '',
				specialKey = specialKeys[keyCode],
				key = specialKey || character.toLowerCase(),
				type = down ? 'keydown' : 'keyup',
				view = View._focused,
				scope = view && view.isVisible() && view._scope,
				tool = scope && scope.tool,
				name;
			keyMap[key] = down;
			if (down) {
				charCodeMap[keyCode] = charCode;
			} else {
				delete charCodeMap[keyCode];
			}
			if (specialKey && (name = Base.camelize(specialKey)) in modifiers) {
				modifiers[name] = down;
				var browser = paper.browser;
				if (name === 'command' && browser && browser.mac) {
					if (down) {
						commandFixMap = {};
					} else {
						for (var code in commandFixMap) {
							if (code in charCodeMap)
								handleKey(false, code, commandFixMap[code], event);
						}
						commandFixMap = null;
					}
				}
			} else if (down && commandFixMap) {
				commandFixMap[keyCode] = charCode;
			}
			if (tool && tool.responds(type)) {
				paper = scope;
				tool.emit(type, new KeyEvent(down, key, character, event));
				if (view)
					view.update();
			}
		}
	
		DomEvent.add(document, {
			keydown: function(event) {
				var code = event.which || event.keyCode;
				if (code in specialKeys || modifiers.command) {
					handleKey(true, code,
							code in specialChars || modifiers.command ? code : 0,
							event);
				} else {
					downCode = code;
				}
			},
	
			keypress: function(event) {
				if (downCode != null) {
					handleKey(true, downCode, event.which || event.keyCode, event);
					downCode = null;
				}
			},
	
			keyup: function(event) {
				var code = event.which || event.keyCode;
				if (code in charCodeMap)
					handleKey(false, code, charCodeMap[code], event);
			}
		});
	
		DomEvent.add(window, {
			blur: function(event) {
				for (var code in charCodeMap)
					handleKey(false, code, charCodeMap[code], event);
			}
		});
	
		return {
			modifiers: modifiers,
	
			isDown: function(key) {
				return !!keyMap[key];
			}
		};
	};
	
	var MouseEvent = Event.extend({
		_class: 'MouseEvent',
	
		initialize: function MouseEvent(type, event, point, target, delta) {
			Event.call(this, event);
			this.type = type;
			this.point = point;
			this.target = target;
			this.delta = delta;
		},
	
		toString: function() {
			return "{ type: '" + this.type
					+ "', point: " + this.point
					+ ', target: ' + this.target
					+ (this.delta ? ', delta: ' + this.delta : '')
					+ ', modifiers: ' + this.getModifiers()
					+ ' }';
		}
	});
	
	var ToolEvent = Event.extend({
		_class: 'ToolEvent',
		_item: null,
	
		initialize: function ToolEvent(tool, type, event) {
			this.tool = tool;
			this.type = type;
			this.event = event;
		},
	
		_choosePoint: function(point, toolPoint) {
			return point ? point : toolPoint ? toolPoint.clone() : null;
		},
	
		getPoint: function() {
			return this._choosePoint(this._point, this.tool._point);
		},
	
		setPoint: function(point) {
			this._point = point;
		},
	
		getLastPoint: function() {
			return this._choosePoint(this._lastPoint, this.tool._lastPoint);
		},
	
		setLastPoint: function(lastPoint) {
			this._lastPoint = lastPoint;
		},
	
		getDownPoint: function() {
			return this._choosePoint(this._downPoint, this.tool._downPoint);
		},
	
		setDownPoint: function(downPoint) {
			this._downPoint = downPoint;
		},
	
		getMiddlePoint: function() {
			if (!this._middlePoint && this.tool._lastPoint) {
				return this.tool._point.add(this.tool._lastPoint).divide(2);
			}
			return this._middlePoint;
		},
	
		setMiddlePoint: function(middlePoint) {
			this._middlePoint = middlePoint;
		},
	
		getDelta: function() {
			return !this._delta && this.tool._lastPoint
					? this.tool._point.subtract(this.tool._lastPoint)
					: this._delta;
		},
	
		setDelta: function(delta) {
			this._delta = delta;
		},
	
		getCount: function() {
			return /^mouse(down|up)$/.test(this.type)
					? this.tool._downCount
					: this.tool._count;
		},
	
		setCount: function(count) {
			this.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count']
				= count;
		},
	
		getItem: function() {
			if (!this._item) {
				var result = this.tool._scope.project.hitTest(this.getPoint());
				if (result) {
					var item = result.item,
						parent = item._parent;
					while (/^(Group|CompoundPath)$/.test(parent._class)) {
						item = parent;
						parent = parent._parent;
					}
					this._item = item;
				}
			}
			return this._item;
		},
	
		setItem: function(item) {
			this._item = item;
		},
	
		toString: function() {
			return '{ type: ' + this.type
					+ ', point: ' + this.getPoint()
					+ ', count: ' + this.getCount()
					+ ', modifiers: ' + this.getModifiers()
					+ ' }';
		}
	});
	
	var Tool = PaperScopeItem.extend({
		_class: 'Tool',
		_list: 'tools',
		_reference: 'tool',
		_events: [ 'onActivate', 'onDeactivate', 'onEditOptions',
				'onMouseDown', 'onMouseUp', 'onMouseDrag', 'onMouseMove',
				'onKeyDown', 'onKeyUp' ],
	
		initialize: function Tool(props) {
			PaperScopeItem.call(this);
			this._firstMove = true;
			this._count = 0;
			this._downCount = 0;
			this._set(props);
		},
	
		getMinDistance: function() {
			return this._minDistance;
		},
	
		setMinDistance: function(minDistance) {
			this._minDistance = minDistance;
			if (minDistance != null && this._maxDistance != null
					&& minDistance > this._maxDistance) {
				this._maxDistance = minDistance;
			}
		},
	
		getMaxDistance: function() {
			return this._maxDistance;
		},
	
		setMaxDistance: function(maxDistance) {
			this._maxDistance = maxDistance;
			if (this._minDistance != null && maxDistance != null
					&& maxDistance < this._minDistance) {
				this._minDistance = maxDistance;
			}
		},
	
		getFixedDistance: function() {
			return this._minDistance == this._maxDistance
				? this._minDistance : null;
		},
	
		setFixedDistance: function(distance) {
			this._minDistance = distance;
			this._maxDistance = distance;
		},
	
		_updateEvent: function(type, point, minDistance, maxDistance, start,
				needsChange, matchMaxDistance) {
			if (!start) {
				if (minDistance != null || maxDistance != null) {
					var minDist = minDistance != null ? minDistance : 0,
						vector = point.subtract(this._point),
						distance = vector.getLength();
					if (distance < minDist)
						return false;
					if (maxDistance != null && maxDistance != 0) {
						if (distance > maxDistance) {
							point = this._point.add(vector.normalize(maxDistance));
						} else if (matchMaxDistance) {
							return false;
						}
					}
				}
				if (needsChange && point.equals(this._point))
					return false;
			}
			this._lastPoint = start && type == 'mousemove' ? point : this._point;
			this._point = point;
			switch (type) {
			case 'mousedown':
				this._lastPoint = this._downPoint;
				this._downPoint = this._point;
				this._downCount++;
				break;
			case 'mouseup':
				this._lastPoint = this._downPoint;
				break;
			}
			this._count = start ? 0 : this._count + 1;
			return true;
		},
	
		_fireEvent: function(type, event) {
			var sets = paper.project._removeSets;
			if (sets) {
				if (type === 'mouseup')
					sets.mousedrag = null;
				var set = sets[type];
				if (set) {
					for (var id in set) {
						var item = set[id];
						for (var key in sets) {
							var other = sets[key];
							if (other && other != set)
								delete other[item._id];
						}
						item.remove();
					}
					sets[type] = null;
				}
			}
			return this.responds(type)
					&& this.emit(type, new ToolEvent(this, type, event));
		},
	
		_handleEvent: function(type, point, event) {
			paper = this._scope;
			var called = false;
			switch (type) {
			case 'mousedown':
				this._updateEvent(type, point, null, null, true, false, false);
				called = this._fireEvent(type, event);
				break;
			case 'mousedrag':
				var needsChange = false,
					matchMaxDistance = false;
				while (this._updateEvent(type, point, this.minDistance,
						this.maxDistance, false, needsChange, matchMaxDistance)) {
					called = this._fireEvent(type, event) || called;
					needsChange = true;
					matchMaxDistance = true;
				}
				break;
			case 'mouseup':
				if (!point.equals(this._point)
						&& this._updateEvent('mousedrag', point, this.minDistance,
								this.maxDistance, false, false, false)) {
					called = this._fireEvent('mousedrag', event);
				}
				this._updateEvent(type, point, null, this.maxDistance, false,
						false, false);
				called = this._fireEvent(type, event) || called;
				this._updateEvent(type, point, null, null, true, false, false);
				this._firstMove = true;
				break;
			case 'mousemove':
				while (this._updateEvent(type, point, this.minDistance,
						this.maxDistance, this._firstMove, true, false)) {
					called = this._fireEvent(type, event) || called;
					this._firstMove = false;
				}
				break;
			}
			if (called)
				event.preventDefault();
			return called;
		}
	
	});
	
	var Http = {
		request: function(method, url, callback, async) {
			async = (async === undefined) ? true : async;
			var xhr = new (window.ActiveXObject || XMLHttpRequest)(
						'Microsoft.XMLHTTP');
			xhr.open(method.toUpperCase(), url, async);
			if ('overrideMimeType' in xhr)
				xhr.overrideMimeType('text/plain');
			xhr.onreadystatechange = function() {
				if (xhr.readyState === 4) {
					var status = xhr.status;
					if (status === 0 || status === 200) {
						callback.call(xhr, xhr.responseText);
					} else {
						throw new Error('Could not load ' + url + ' (Error '
								+ status + ')');
					}
				}
			};
			return xhr.send(null);
		}
	};
	
	var CanvasProvider = {
		canvases: [],
	
		getCanvas: function(width, height) {
			var canvas,
				clear = true;
			if (typeof width === 'object') {
				height = width.height;
				width = width.width;
			}
			if (this.canvases.length) {
				canvas = this.canvases.pop();
			} else {
				canvas = document.createElement('canvas');
			}
			var ctx = canvas.getContext('2d');
			if (canvas.width === width && canvas.height === height) {
				if (clear)
					ctx.clearRect(0, 0, width + 1, height + 1);
			} else {
				canvas.width = width;
				canvas.height = height;
			}
			ctx.save();
			return canvas;
		},
	
		getContext: function(width, height) {
			return this.getCanvas(width, height).getContext('2d');
		},
	
		release: function(obj) {
			var canvas = obj.canvas ? obj.canvas : obj;
			canvas.getContext('2d').restore();
			this.canvases.push(canvas);
		}
	};
	
	var BlendMode = new function() {
		var min = Math.min,
			max = Math.max,
			abs = Math.abs,
			sr, sg, sb, sa,
			br, bg, bb, ba,
			dr, dg, db;
	
		function getLum(r, g, b) {
			return 0.2989 * r + 0.587 * g + 0.114 * b;
		}
	
		function setLum(r, g, b, l) {
			var d = l - getLum(r, g, b);
			dr = r + d;
			dg = g + d;
			db = b + d;
			var l = getLum(dr, dg, db),
				mn = min(dr, dg, db),
				mx = max(dr, dg, db);
			if (mn < 0) {
				var lmn = l - mn;
				dr = l + (dr - l) * l / lmn;
				dg = l + (dg - l) * l / lmn;
				db = l + (db - l) * l / lmn;
			}
			if (mx > 255) {
				var ln = 255 - l,
					mxl = mx - l;
				dr = l + (dr - l) * ln / mxl;
				dg = l + (dg - l) * ln / mxl;
				db = l + (db - l) * ln / mxl;
			}
		}
	
		function getSat(r, g, b) {
			return max(r, g, b) - min(r, g, b);
		}
	
		function setSat(r, g, b, s) {
			var col = [r, g, b],
				mx = max(r, g, b),
				mn = min(r, g, b),
				md;
			mn = mn === r ? 0 : mn === g ? 1 : 2;
			mx = mx === r ? 0 : mx === g ? 1 : 2;
			md = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;
			if (col[mx] > col[mn]) {
				col[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);
				col[mx] = s;
			} else {
				col[md] = col[mx] = 0;
			}
			col[mn] = 0;
			dr = col[0];
			dg = col[1];
			db = col[2];
		}
	
		var modes = {
			multiply: function() {
				dr = br * sr / 255;
				dg = bg * sg / 255;
				db = bb * sb / 255;
			},
	
			screen: function() {
				dr = br + sr - (br * sr / 255);
				dg = bg + sg - (bg * sg / 255);
				db = bb + sb - (bb * sb / 255);
			},
	
			overlay: function() {
				dr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;
				dg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;
				db = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;
			},
	
			'soft-light': function() {
				var t = sr * br / 255;
				dr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;
				t = sg * bg / 255;
				dg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;
				t = sb * bb / 255;
				db = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;
			},
	
			'hard-light': function() {
				dr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;
				dg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;
				db = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;
			},
	
			'color-dodge': function() {
				dr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));
				dg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));
				db = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));
			},
	
			'color-burn': function() {
				dr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);
				dg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);
				db = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);
			},
	
			darken: function() {
				dr = br < sr ? br : sr;
				dg = bg < sg ? bg : sg;
				db = bb < sb ? bb : sb;
			},
	
			lighten: function() {
				dr = br > sr ? br : sr;
				dg = bg > sg ? bg : sg;
				db = bb > sb ? bb : sb;
			},
	
			difference: function() {
				dr = br - sr;
				if (dr < 0)
					dr = -dr;
				dg = bg - sg;
				if (dg < 0)
					dg = -dg;
				db = bb - sb;
				if (db < 0)
					db = -db;
			},
	
			exclusion: function() {
				dr = br + sr * (255 - br - br) / 255;
				dg = bg + sg * (255 - bg - bg) / 255;
				db = bb + sb * (255 - bb - bb) / 255;
			},
	
			hue: function() {
				setSat(sr, sg, sb, getSat(br, bg, bb));
				setLum(dr, dg, db, getLum(br, bg, bb));
			},
	
			saturation: function() {
				setSat(br, bg, bb, getSat(sr, sg, sb));
				setLum(dr, dg, db, getLum(br, bg, bb));
			},
	
			luminosity: function() {
				setLum(br, bg, bb, getLum(sr, sg, sb));
			},
	
			color: function() {
				setLum(sr, sg, sb, getLum(br, bg, bb));
			},
	
			add: function() {
				dr = min(br + sr, 255);
				dg = min(bg + sg, 255);
				db = min(bb + sb, 255);
			},
	
			subtract: function() {
				dr = max(br - sr, 0);
				dg = max(bg - sg, 0);
				db = max(bb - sb, 0);
			},
	
			average: function() {
				dr = (br + sr) / 2;
				dg = (bg + sg) / 2;
				db = (bb + sb) / 2;
			},
	
			negation: function() {
				dr = 255 - abs(255 - sr - br);
				dg = 255 - abs(255 - sg - bg);
				db = 255 - abs(255 - sb - bb);
			}
		};
	
		var nativeModes = this.nativeModes = Base.each([
			'source-over', 'source-in', 'source-out', 'source-atop',
			'destination-over', 'destination-in', 'destination-out',
			'destination-atop', 'lighter', 'darker', 'copy', 'xor'
		], function(mode) {
			this[mode] = true;
		}, {});
	
		var ctx = CanvasProvider.getContext(1, 1);
		Base.each(modes, function(func, mode) {
			var darken = mode === 'darken',
				ok = false;
			ctx.save();
			try {
				ctx.fillStyle = darken ? '#300' : '#a00';
				ctx.fillRect(0, 0, 1, 1);
				ctx.globalCompositeOperation = mode;
				if (ctx.globalCompositeOperation === mode) {
					ctx.fillStyle = darken ? '#a00' : '#300';
					ctx.fillRect(0, 0, 1, 1);
					ok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken ? 170 : 51;
				}
			} catch (e) {}
			ctx.restore();
			nativeModes[mode] = ok;
		});
		CanvasProvider.release(ctx);
	
		this.process = function(mode, srcContext, dstContext, alpha, offset) {
			var srcCanvas = srcContext.canvas,
				normal = mode === 'normal';
			if (normal || nativeModes[mode]) {
				dstContext.save();
				dstContext.setTransform(1, 0, 0, 1, 0, 0);
				dstContext.globalAlpha = alpha;
				if (!normal)
					dstContext.globalCompositeOperation = mode;
				dstContext.drawImage(srcCanvas, offset.x, offset.y);
				dstContext.restore();
			} else {
				var process = modes[mode];
				if (!process)
					return;
				var dstData = dstContext.getImageData(offset.x, offset.y,
						srcCanvas.width, srcCanvas.height),
					dst = dstData.data,
					src = srcContext.getImageData(0, 0,
						srcCanvas.width, srcCanvas.height).data;
				for (var i = 0, l = dst.length; i < l; i += 4) {
					sr = src[i];
					br = dst[i];
					sg = src[i + 1];
					bg = dst[i + 1];
					sb = src[i + 2];
					bb = dst[i + 2];
					sa = src[i + 3];
					ba = dst[i + 3];
					process();
					var a1 = sa * alpha / 255,
						a2 = 1 - a1;
					dst[i] = a1 * dr + a2 * br;
					dst[i + 1] = a1 * dg + a2 * bg;
					dst[i + 2] = a1 * db + a2 * bb;
					dst[i + 3] = sa * alpha + a2 * ba;
				}
				dstContext.putImageData(dstData, offset.x, offset.y);
			}
		};
	};
	
	var SVGStyles = Base.each({
		fillColor: ['fill', 'color'],
		strokeColor: ['stroke', 'color'],
		strokeWidth: ['stroke-width', 'number'],
		strokeCap: ['stroke-linecap', 'string'],
		strokeJoin: ['stroke-linejoin', 'string'],
		strokeScaling: ['vector-effect', 'lookup', {
			true: 'none',
			false: 'non-scaling-stroke'
		}, function(item, value) {
			return !value
					&& (item instanceof PathItem
						|| item instanceof Shape
						|| item instanceof TextItem);
		}],
		miterLimit: ['stroke-miterlimit', 'number'],
		dashArray: ['stroke-dasharray', 'array'],
		dashOffset: ['stroke-dashoffset', 'number'],
		fontFamily: ['font-family', 'string'],
		fontWeight: ['font-weight', 'string'],
		fontSize: ['font-size', 'number'],
		justification: ['text-anchor', 'lookup', {
			left: 'start',
			center: 'middle',
			right: 'end'
		}],
		opacity: ['opacity', 'number'],
		blendMode: ['mix-blend-mode', 'string']
	}, function(entry, key) {
		var part = Base.capitalize(key),
			lookup = entry[2];
		this[key] = {
			type: entry[1],
			property: key,
			attribute: entry[0],
			toSVG: lookup,
			fromSVG: lookup && Base.each(lookup, function(value, name) {
				this[value] = name;
			}, {}),
			exportFilter: entry[3],
			get: 'get' + part,
			set: 'set' + part
		};
	}, {});
	
	var SVGNamespaces = {
		href: 'http://www.w3.org/1999/xlink',
		xlink: 'http://www.w3.org/2000/xmlns'
	};
	
	new function() {
		var formatter;
	
		function setAttributes(node, attrs) {
			for (var key in attrs) {
				var val = attrs[key],
					namespace = SVGNamespaces[key];
				if (typeof val === 'number')
					val = formatter.number(val);
				if (namespace) {
					node.setAttributeNS(namespace, key, val);
				} else {
					node.setAttribute(key, val);
				}
			}
			return node;
		}
	
		function createElement(tag, attrs) {
			return setAttributes(
				document.createElementNS('http://www.w3.org/2000/svg', tag), attrs);
		}
	
		function getTransform(matrix, coordinates, center) {
			var attrs = new Base(),
				trans = matrix.getTranslation();
			if (coordinates) {
				matrix = matrix.shiftless();
				var point = matrix._inverseTransform(trans);
				attrs[center ? 'cx' : 'x'] = point.x;
				attrs[center ? 'cy' : 'y'] = point.y;
				trans = null;
			}
			if (!matrix.isIdentity()) {
				var decomposed = matrix.decompose();
				if (decomposed && !decomposed.shearing) {
					var parts = [],
						angle = decomposed.rotation,
						scale = decomposed.scaling;
					if (trans && !trans.isZero())
						parts.push('translate(' + formatter.point(trans) + ')');
					if (!Numerical.isZero(scale.x - 1)
							|| !Numerical.isZero(scale.y - 1))
						parts.push('scale(' + formatter.point(scale) +')');
					if (angle)
						parts.push('rotate(' + formatter.number(angle) + ')');
					attrs.transform = parts.join(' ');
				} else {
					attrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';
				}
			}
			return attrs;
		}
	
		function exportGroup(item, options) {
			var attrs = getTransform(item._matrix),
				children = item._children;
			var node = createElement('g', attrs);
			for (var i = 0, l = children.length; i < l; i++) {
				var child = children[i];
				var childNode = exportSVG(child, options);
				if (childNode) {
					if (child.isClipMask()) {
						var clip = createElement('clipPath');
						clip.appendChild(childNode);
						setDefinition(child, clip, 'clip');
						setAttributes(node, {
							'clip-path': 'url(#' + clip.id + ')'
						});
					} else {
						node.appendChild(childNode);
					}
				}
			}
			return node;
		}
	
		function exportRaster(item, options) {
			var attrs = getTransform(item._matrix, true),
				size = item.getSize(),
				image = item.getImage();
			attrs.x -= size.width / 2;
			attrs.y -= size.height / 2;
			attrs.width = size.width;
			attrs.height = size.height;
			attrs.href = options.embedImages === false && image && image.src
					|| item.toDataURL();
			return createElement('image', attrs);
		}
	
		function exportPath(item, options) {
			var matchShapes = options.matchShapes;
			if (matchShapes) {
				var shape = item.toShape(false);
				if (shape)
					return exportShape(shape, options);
			}
			var segments = item._segments,
				type,
				attrs = getTransform(item._matrix);
			if (segments.length === 0)
				return null;
			if (matchShapes && !item.hasHandles()) {
				if (segments.length >= 3) {
					type = item._closed ? 'polygon' : 'polyline';
					var parts = [];
					for(var i = 0, l = segments.length; i < l; i++)
						parts.push(formatter.point(segments[i]._point));
					attrs.points = parts.join(' ');
				} else {
					type = 'line';
					var first = segments[0]._point,
						last = segments[segments.length - 1]._point;
					attrs.set({
						x1: first.x,
						y1: first.y,
						x2: last.x,
						y2: last.y
					});
				}
			} else {
				type = 'path';
				attrs.d = item.getPathData(null, options.precision);
			}
			return createElement(type, attrs);
		}
	
		function exportShape(item) {
			var type = item._type,
				radius = item._radius,
				attrs = getTransform(item._matrix, true, type !== 'rectangle');
			if (type === 'rectangle') {
				type = 'rect';
				var size = item._size,
					width = size.width,
					height = size.height;
				attrs.x -= width / 2;
				attrs.y -= height / 2;
				attrs.width = width;
				attrs.height = height;
				if (radius.isZero())
					radius = null;
			}
			if (radius) {
				if (type === 'circle') {
					attrs.r = radius;
				} else {
					attrs.rx = radius.width;
					attrs.ry = radius.height;
				}
			}
			return createElement(type, attrs);
		}
	
		function exportCompoundPath(item, options) {
			var attrs = getTransform(item._matrix);
			var data = item.getPathData(null, options.precision);
			if (data)
				attrs.d = data;
			return createElement('path', attrs);
		}
	
		function exportPlacedSymbol(item, options) {
			var attrs = getTransform(item._matrix, true),
				symbol = item.getSymbol(),
				symbolNode = getDefinition(symbol, 'symbol'),
				definition = symbol.getDefinition(),
				bounds = definition.getBounds();
			if (!symbolNode) {
				symbolNode = createElement('symbol', {
					viewBox: formatter.rectangle(bounds)
				});
				symbolNode.appendChild(exportSVG(definition, options));
				setDefinition(symbol, symbolNode, 'symbol');
			}
			attrs.href = '#' + symbolNode.id;
			attrs.x += bounds.x;
			attrs.y += bounds.y;
			attrs.width = formatter.number(bounds.width);
			attrs.height = formatter.number(bounds.height);
			attrs.overflow = 'visible';
			return createElement('use', attrs);
		}
	
		function exportGradient(color) {
			var gradientNode = getDefinition(color, 'color');
			if (!gradientNode) {
				var gradient = color.getGradient(),
					radial = gradient._radial,
					origin = color.getOrigin().transform(),
					destination = color.getDestination().transform(),
					attrs;
				if (radial) {
					attrs = {
						cx: origin.x,
						cy: origin.y,
						r: origin.getDistance(destination)
					};
					var highlight = color.getHighlight();
					if (highlight) {
						highlight = highlight.transform();
						attrs.fx = highlight.x;
						attrs.fy = highlight.y;
					}
				} else {
					attrs = {
						x1: origin.x,
						y1: origin.y,
						x2: destination.x,
						y2: destination.y
					};
				}
				attrs.gradientUnits = 'userSpaceOnUse';
				gradientNode = createElement(
						(radial ? 'radial' : 'linear') + 'Gradient', attrs);
				var stops = gradient._stops;
				for (var i = 0, l = stops.length; i < l; i++) {
					var stop = stops[i],
						stopColor = stop._color,
						alpha = stopColor.getAlpha();
					attrs = {
						offset: stop._rampPoint,
						'stop-color': stopColor.toCSS(true)
					};
					if (alpha < 1)
						attrs['stop-opacity'] = alpha;
					gradientNode.appendChild(createElement('stop', attrs));
				}
				setDefinition(color, gradientNode, 'color');
			}
			return 'url(#' + gradientNode.id + ')';
		}
	
		function exportText(item) {
			var node = createElement('text', getTransform(item._matrix, true));
			node.textContent = item._content;
			return node;
		}
	
		var exporters = {
			Group: exportGroup,
			Layer: exportGroup,
			Raster: exportRaster,
			Path: exportPath,
			Shape: exportShape,
			CompoundPath: exportCompoundPath,
			PlacedSymbol: exportPlacedSymbol,
			PointText: exportText
		};
	
		function applyStyle(item, node, isRoot) {
			var attrs = {},
				parent = !isRoot && item.getParent();
	
			if (item._name != null)
				attrs.id = item._name;
	
			Base.each(SVGStyles, function(entry) {
				var get = entry.get,
					type = entry.type,
					value = item[get]();
				if (entry.exportFilter
						? entry.exportFilter(item, value)
						: !parent || !Base.equals(parent[get](), value)) {
					if (type === 'color' && value != null) {
						var alpha = value.getAlpha();
						if (alpha < 1)
							attrs[entry.attribute + '-opacity'] = alpha;
					}
					attrs[entry.attribute] = value == null
						? 'none'
						: type === 'number'
							? formatter.number(value)
							: type === 'color'
								? value.gradient
									? exportGradient(value, item)
									: value.toCSS(true)
								: type === 'array'
									? value.join(',')
									: type === 'lookup'
										? entry.toSVG[value]
										: value;
				}
			});
	
			if (attrs.opacity === 1)
				delete attrs.opacity;
	
			if (!item._visible)
				attrs.visibility = 'hidden';
	
			return setAttributes(node, attrs);
		}
	
		var definitions;
		function getDefinition(item, type) {
			if (!definitions)
				definitions = { ids: {}, svgs: {} };
			return item && definitions.svgs[type + '-' + item._id];
		}
	
		function setDefinition(item, node, type) {
			if (!definitions)
				getDefinition();
			var id = definitions.ids[type] = (definitions.ids[type] || 0) + 1;
			node.id = type + '-' + id;
			definitions.svgs[type + '-' + item._id] = node;
		}
	
		function exportDefinitions(node, options) {
			var svg = node,
				defs = null;
			if (definitions) {
				svg = node.nodeName.toLowerCase() === 'svg' && node;
				for (var i in definitions.svgs) {
					if (!defs) {
						if (!svg) {
							svg = createElement('svg');
							svg.appendChild(node);
						}
						defs = svg.insertBefore(createElement('defs'),
								svg.firstChild);
					}
					defs.appendChild(definitions.svgs[i]);
				}
				definitions = null;
			}
			return options.asString
					? new XMLSerializer().serializeToString(svg)
					: svg;
		}
	
		function exportSVG(item, options, isRoot) {
			var exporter = exporters[item._class],
				node = exporter && exporter(item, options);
			if (node) {
				var onExport = options.onExport;
				if (onExport)
					node = onExport(item, node, options) || node;
				var data = JSON.stringify(item._data);
				if (data && data !== '{}' && data !== 'null')
					node.setAttribute('data-paper-data', data);
			}
			return node && applyStyle(item, node, isRoot);
		}
	
		function setOptions(options) {
			if (!options)
				options = {};
			formatter = new Formatter(options.precision);
			return options;
		}
	
		Item.inject({
			exportSVG: function(options) {
				options = setOptions(options);
				return exportDefinitions(exportSVG(this, options, true), options);
			}
		});
	
		Project.inject({
			exportSVG: function(options) {
				options = setOptions(options);
				var layers = this.layers,
					view = this.getView(),
					size = view.getViewSize(),
					node = createElement('svg', {
						x: 0,
						y: 0,
						width: size.width,
						height: size.height,
						version: '1.1',
						xmlns: 'http://www.w3.org/2000/svg',
						'xmlns:xlink': 'http://www.w3.org/1999/xlink'
					}),
					parent = node,
					matrix = view._matrix;
				if (!matrix.isIdentity())
					parent = node.appendChild(
							createElement('g', getTransform(matrix)));
				for (var i = 0, l = layers.length; i < l; i++)
					parent.appendChild(exportSVG(layers[i], options, true));
				return exportDefinitions(node, options);
			}
		});
	};
	
	new function() {
	
		function getValue(node, name, isString, allowNull) {
			var namespace = SVGNamespaces[name],
				value = namespace
					? node.getAttributeNS(namespace, name)
					: node.getAttribute(name);
			if (value === 'null')
				value = null;
			return value == null
					? allowNull
						? null
						: isString
							? ''
							: 0
					: isString
						? value
						: parseFloat(value);
		}
	
		function getPoint(node, x, y, allowNull) {
			x = getValue(node, x, false, allowNull);
			y = getValue(node, y, false, allowNull);
			return allowNull && (x == null || y == null) ? null
					: new Point(x, y);
		}
	
		function getSize(node, w, h, allowNull) {
			w = getValue(node, w, false, allowNull);
			h = getValue(node, h, false, allowNull);
			return allowNull && (w == null || h == null) ? null
					: new Size(w, h);
		}
	
		function convertValue(value, type, lookup) {
			return value === 'none'
					? null
					: type === 'number'
						? parseFloat(value)
						: type === 'array'
							? value ? value.split(/[\s,]+/g).map(parseFloat) : []
							: type === 'color'
								? getDefinition(value) || value
								: type === 'lookup'
									? lookup[value]
									: value;
		}
	
		function importGroup(node, type, options, isRoot) {
			var nodes = node.childNodes,
				isClip = type === 'clippath',
				item = new Group(),
				project = item._project,
				currentStyle = project._currentStyle,
				children = [];
			if (!isClip) {
				item = applyAttributes(item, node, isRoot);
				project._currentStyle = item._style.clone();
			}
			if (isRoot) {
				var defs = node.querySelectorAll('defs');
				for (var i = 0, l = defs.length; i < l; i++) {
					importSVG(defs[i], options, false);
				}
			}
			for (var i = 0, l = nodes.length; i < l; i++) {
				var childNode = nodes[i],
					child;
				if (childNode.nodeType === 1
						&& childNode.nodeName.toLowerCase() !== 'defs'
						&& (child = importSVG(childNode, options, false))
						&& !(child instanceof Symbol))
					children.push(child);
			}
			item.addChildren(children);
			if (isClip)
				item = applyAttributes(item.reduce(), node, isRoot);
			project._currentStyle = currentStyle;
			if (isClip || type === 'defs') {
				item.remove();
				item = null;
			}
			return item;
		}
	
		function importPoly(node, type) {
			var coords = node.getAttribute('points').match(
						/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g),
				points = [];
			for (var i = 0, l = coords.length; i < l; i += 2)
				points.push(new Point(
						parseFloat(coords[i]),
						parseFloat(coords[i + 1])));
			var path = new Path(points);
			if (type === 'polygon')
				path.closePath();
			return path;
		}
	
		function importPath(node) {
			var data = node.getAttribute('d'),
				param = { pathData: data };
			return (data.match(/m/gi) || []).length > 1 || /z\S+/i.test(data)
					? new CompoundPath(param)
					: new Path(param);
		}
	
		function importGradient(node, type) {
			var id = (getValue(node, 'href', true) || '').substring(1),
				isRadial = type === 'radialgradient',
				gradient;
			if (id) {
				gradient = definitions[id].getGradient();
			} else {
				var nodes = node.childNodes,
					stops = [];
				for (var i = 0, l = nodes.length; i < l; i++) {
					var child = nodes[i];
					if (child.nodeType === 1)
						stops.push(applyAttributes(new GradientStop(), child));
				}
				gradient = new Gradient(stops, isRadial);
			}
			var origin, destination, highlight;
			if (isRadial) {
				origin = getPoint(node, 'cx', 'cy');
				destination = origin.add(getValue(node, 'r'), 0);
				highlight = getPoint(node, 'fx', 'fy', true);
			} else {
				origin = getPoint(node, 'x1', 'y1');
				destination = getPoint(node, 'x2', 'y2');
			}
			applyAttributes(
				new Color(gradient, origin, destination, highlight), node);
			return null;
		}
	
		var importers = {
			'#document': function (node, type, options, isRoot) {
				var nodes = node.childNodes;
				for (var i = 0, l = nodes.length; i < l; i++) {
					var child = nodes[i];
					if (child.nodeType === 1) {
						var next = child.nextSibling;
						document.body.appendChild(child);
						var item = importSVG(child, options, isRoot);
						if (next) {
							node.insertBefore(child, next);
						} else {
							node.appendChild(child);
						}
						return item;
					}
				}
			},
			g: importGroup,
			svg: importGroup,
			clippath: importGroup,
			polygon: importPoly,
			polyline: importPoly,
			path: importPath,
			lineargradient: importGradient,
			radialgradient: importGradient,
	
			image: function (node) {
				var raster = new Raster(getValue(node, 'href', true));
				raster.on('load', function() {
					var size = getSize(node, 'width', 'height');
					this.setSize(size);
					var center = this._matrix._transformPoint(
							getPoint(node, 'x', 'y').add(size.divide(2)));
					this.translate(center);
				});
				return raster;
			},
	
			symbol: function(node, type, options, isRoot) {
				return new Symbol(importGroup(node, type, options, isRoot), true);
			},
	
			defs: importGroup,
	
			use: function(node) {
				var id = (getValue(node, 'href', true) || '').substring(1),
					definition = definitions[id],
					point = getPoint(node, 'x', 'y');
				return definition
						? definition instanceof Symbol
							? definition.place(point)
							: definition.clone().translate(point)
						: null;
			},
	
			circle: function(node) {
				return new Shape.Circle(getPoint(node, 'cx', 'cy'),
						getValue(node, 'r'));
			},
	
			ellipse: function(node) {
				return new Shape.Ellipse({
					center: getPoint(node, 'cx', 'cy'),
					radius: getSize(node, 'rx', 'ry')
				});
			},
	
			rect: function(node) {
				var point = getPoint(node, 'x', 'y'),
					size = getSize(node, 'width', 'height'),
					radius = getSize(node, 'rx', 'ry');
				return new Shape.Rectangle(new Rectangle(point, size), radius);
			},
	
			line: function(node) {
				return new Path.Line(getPoint(node, 'x1', 'y1'),
						getPoint(node, 'x2', 'y2'));
			},
	
			text: function(node) {
				var text = new PointText(getPoint(node, 'x', 'y')
						.add(getPoint(node, 'dx', 'dy')));
				text.setContent(node.textContent.trim() || '');
				return text;
			}
		};
	
		function applyTransform(item, value, name, node) {
			var transforms = (node.getAttribute(name) || '').split(/\)\s*/g),
				matrix = new Matrix();
			for (var i = 0, l = transforms.length; i < l; i++) {
				var transform = transforms[i];
				if (!transform)
					break;
				var parts = transform.split(/\(\s*/),
					command = parts[0],
					v = parts[1].split(/[\s,]+/g);
				for (var j = 0, m = v.length; j < m; j++)
					v[j] = parseFloat(v[j]);
				switch (command) {
				case 'matrix':
					matrix.concatenate(
							new Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));
					break;
				case 'rotate':
					matrix.rotate(v[0], v[1], v[2]);
					break;
				case 'translate':
					matrix.translate(v[0], v[1]);
					break;
				case 'scale':
					matrix.scale(v);
					break;
				case 'skewX':
					matrix.skew(v[0], 0);
					break;
				case 'skewY':
					matrix.skew(0, v[0]);
					break;
				}
			}
			item.transform(matrix);
		}
	
		function applyOpacity(item, value, name) {
			var color = item[name === 'fill-opacity' ? 'getFillColor'
					: 'getStrokeColor']();
			if (color)
				color.setAlpha(parseFloat(value));
		}
	
		var attributes = Base.set(Base.each(SVGStyles, function(entry) {
			this[entry.attribute] = function(item, value) {
				item[entry.set](convertValue(value, entry.type, entry.fromSVG));
				if (entry.type === 'color' && item instanceof Shape) {
					var color = item[entry.get]();
					if (color)
						color.transform(new Matrix().translate(
								item.getPosition(true).negate()));
				}
			};
		}, {}), {
			id: function(item, value) {
				definitions[value] = item;
				if (item.setName)
					item.setName(value);
			},
	
			'clip-path': function(item, value) {
				var clip = getDefinition(value);
				if (clip) {
					clip = clip.clone();
					clip.setClipMask(true);
					if (item instanceof Group) {
						item.insertChild(0, clip);
					} else {
						return new Group(clip, item);
					}
				}
			},
	
			gradientTransform: applyTransform,
			transform: applyTransform,
	
			'fill-opacity': applyOpacity,
			'stroke-opacity': applyOpacity,
	
			visibility: function(item, value) {
				item.setVisible(value === 'visible');
			},
	
			display: function(item, value) {
				item.setVisible(value !== null);
			},
	
			'stop-color': function(item, value) {
				if (item.setColor)
					item.setColor(value);
			},
	
			'stop-opacity': function(item, value) {
				if (item._color)
					item._color.setAlpha(parseFloat(value));
			},
	
			offset: function(item, value) {
				var percentage = value.match(/(.*)%$/);
				item.setRampPoint(percentage
						? percentage[1] / 100
						: parseFloat(value));
			},
	
			viewBox: function(item, value, name, node, styles) {
				var rect = new Rectangle(convertValue(value, 'array')),
					size = getSize(node, 'width', 'height', true);
				if (item instanceof Group) {
					var scale = size ? rect.getSize().divide(size) : 1,
						matrix = new Matrix().translate(rect.getPoint()).scale(scale);
					item.transform(matrix.inverted());
				} else if (item instanceof Symbol) {
					if (size)
						rect.setSize(size);
					var clip = getAttribute(node, 'overflow', styles) != 'visible',
						group = item._definition;
					if (clip && !rect.contains(group.getBounds())) {
						clip = new Shape.Rectangle(rect).transform(group._matrix);
						clip.setClipMask(true);
						group.addChild(clip);
					}
				}
			}
		});
	
		function getAttribute(node, name, styles) {
			var attr = node.attributes[name],
				value = attr && attr.value;
			if (!value) {
				var style = Base.camelize(name);
				value = node.style[style];
				if (!value && styles.node[style] !== styles.parent[style])
					value = styles.node[style];
			}
			return !value
					? undefined
					: value === 'none'
						? null
						: value;
		}
	
		function applyAttributes(item, node, isRoot) {
			var styles = {
				node: DomElement.getStyles(node) || {},
				parent: !isRoot && DomElement.getStyles(node.parentNode) || {}
			};
			Base.each(attributes, function(apply, name) {
				var value = getAttribute(node, name, styles);
				if (value !== undefined)
					item = Base.pick(apply(item, value, name, node, styles), item);
			});
			return item;
		}
	
		var definitions = {};
		function getDefinition(value) {
			var match = value && value.match(/\((?:#|)([^)']+)/);
			return match && definitions[match[1]];
		}
	
		function importSVG(source, options, isRoot) {
			if (!source)
				return null;
			if (!options) {
				options = {};
			} else if (typeof options === 'function') {
				options = { onLoad: options };
			}
	
			var node = source,
				scope = paper;
	
			function onLoadCallback(svg) {
				paper = scope;
				var item = importSVG(svg, options, isRoot),
					onLoad = options.onLoad,
					view = scope.project && scope.getView();
				if (onLoad)
					onLoad.call(this, item);
				view.update();
			}
	
			if (isRoot) {
				if (typeof source === 'string' && !/^.*</.test(source)) {
					node = document.getElementById(source);
					if (node) {
						source = null;
					} else {
						return Http.request('get', source, onLoadCallback);
					}
				} else if (typeof File !== 'undefined' && source instanceof File) {
					var reader = new FileReader();
					reader.onload = function() {
						onLoadCallback(reader.result);
					};
					return reader.readAsText(source);
				}
			}
	
			if (typeof source === 'string')
				node = new DOMParser().parseFromString(source, 'image/svg+xml');
			if (!node.nodeName)
				throw new Error('Unsupported SVG source: ' + source);
			var type = node.nodeName.toLowerCase(),
				importer = importers[type],
				item,
				data = node.getAttribute && node.getAttribute('data-paper-data'),
				settings = scope.settings,
				applyMatrix = settings.applyMatrix;
			settings.applyMatrix = false;
			item = importer && importer(node, type, options, isRoot) || null;
			settings.applyMatrix = applyMatrix;
			if (item) {
				if (type !== '#document' && !(item instanceof Group))
					item = applyAttributes(item, node, isRoot);
				var onImport = options.onImport;
				if (onImport)
					item = onImport(node, item, options) || item;
				if (options.expandShapes && item instanceof Shape) {
					item.remove();
					item = item.toPath();
				}
				if (data)
					item._data = JSON.parse(data);
			}
			if (isRoot) {
				definitions = {};
				if (item && Base.pick(options.applyMatrix, applyMatrix))
					item.matrix.apply(true, true);
			}
			return item;
		}
	
		Item.inject({
			importSVG: function(node, options) {
				return this.addChild(importSVG(node, options, true));
			}
		});
	
		Project.inject({
			importSVG: function(node, options) {
				this.activate();
				return importSVG(node, options, true);
			}
		});
	};
	
	Base.exports.PaperScript = (function() {
		var exports, define,
			scope = this;
	!function(e,r){return"object"==typeof exports&&"object"==typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):(r(e.acorn||(e.acorn={})),void 0)}(this,function(e){"use strict";function r(e){fr=e||{};for(var r in mr)Object.prototype.hasOwnProperty.call(fr,r)||(fr[r]=mr[r]);hr=fr.sourceFile||null}function t(e,r){var t=vr(dr,e);r+=" ("+t.line+":"+t.column+")";var n=new SyntaxError(r);throw n.pos=e,n.loc=t,n.raisedAt=br,n}function n(e){function r(e){if(1==e.length)return t+="return str === "+JSON.stringify(e[0])+";";t+="switch(str){";for(var r=0;r<e.length;++r)t+="case "+JSON.stringify(e[r])+":";t+="return true}return false;"}e=e.split(" ");var t="",n=[];e:for(var a=0;a<e.length;++a){for(var o=0;o<n.length;++o)if(n[o][0].length==e[a].length){n[o].push(e[a]);continue e}n.push([e[a]])}if(n.length>3){n.sort(function(e,r){return r.length-e.length}),t+="switch(str.length){";for(var a=0;a<n.length;++a){var i=n[a];t+="case "+i[0].length+":",r(i)}t+="}"}else r(e);return new Function("str",t)}function a(){this.line=Ar,this.column=br-Sr}function o(){Ar=1,br=Sr=0,Er=!0,u()}function i(e,r){gr=br,fr.locations&&(kr=new a),wr=e,u(),Cr=r,Er=e.beforeExpr}function s(){var e=fr.onComment&&fr.locations&&new a,r=br,n=dr.indexOf("*/",br+=2);if(-1===n&&t(br-2,"Unterminated comment"),br=n+2,fr.locations){Kt.lastIndex=r;for(var o;(o=Kt.exec(dr))&&o.index<br;)++Ar,Sr=o.index+o[0].length}fr.onComment&&fr.onComment(!0,dr.slice(r+2,n),r,br,e,fr.locations&&new a)}function c(){for(var e=br,r=fr.onComment&&fr.locations&&new a,t=dr.charCodeAt(br+=2);pr>br&&10!==t&&13!==t&&8232!==t&&8233!==t;)++br,t=dr.charCodeAt(br);fr.onComment&&fr.onComment(!1,dr.slice(e+2,br),e,br,r,fr.locations&&new a)}function u(){for(;pr>br;){var e=dr.charCodeAt(br);if(32===e)++br;else if(13===e){++br;var r=dr.charCodeAt(br);10===r&&++br,fr.locations&&(++Ar,Sr=br)}else if(10===e||8232===e||8233===e)++br,fr.locations&&(++Ar,Sr=br);else if(e>8&&14>e)++br;else if(47===e){var r=dr.charCodeAt(br+1);if(42===r)s();else{if(47!==r)break;c()}}else if(160===e)++br;else{if(!(e>=5760&&Jt.test(String.fromCharCode(e))))break;++br}}}function l(){var e=dr.charCodeAt(br+1);return e>=48&&57>=e?E(!0):(++br,i(xt))}function f(){var e=dr.charCodeAt(br+1);return Er?(++br,k()):61===e?x(Et,2):x(wt,1)}function d(){var e=dr.charCodeAt(br+1);return 61===e?x(Et,2):x(Dt,1)}function p(e){var r=dr.charCodeAt(br+1);return r===e?x(124===e?Lt:Ut,2):61===r?x(Et,2):x(124===e?Rt:Tt,1)}function h(){var e=dr.charCodeAt(br+1);return 61===e?x(Et,2):x(Vt,1)}function m(e){var r=dr.charCodeAt(br+1);return r===e?45==r&&62==dr.charCodeAt(br+2)&&Gt.test(dr.slice(Lr,br))?(br+=3,c(),u(),g()):x(St,2):61===r?x(Et,2):x(At,1)}function v(e){var r=dr.charCodeAt(br+1),t=1;return r===e?(t=62===e&&62===dr.charCodeAt(br+2)?3:2,61===dr.charCodeAt(br+t)?x(Et,t+1):x(jt,t)):33==r&&60==e&&45==dr.charCodeAt(br+2)&&45==dr.charCodeAt(br+3)?(br+=4,c(),u(),g()):(61===r&&(t=61===dr.charCodeAt(br+2)?3:2),x(Ot,t))}function b(e){var r=dr.charCodeAt(br+1);return 61===r?x(qt,61===dr.charCodeAt(br+2)?3:2):x(61===e?Ct:It,1)}function y(e){switch(e){case 46:return l();case 40:return++br,i(mt);case 41:return++br,i(vt);case 59:return++br,i(yt);case 44:return++br,i(bt);case 91:return++br,i(ft);case 93:return++br,i(dt);case 123:return++br,i(pt);case 125:return++br,i(ht);case 58:return++br,i(gt);case 63:return++br,i(kt);case 48:var r=dr.charCodeAt(br+1);if(120===r||88===r)return C();case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return E(!1);case 34:case 39:return A(e);case 47:return f(e);case 37:case 42:return d();case 124:case 38:return p(e);case 94:return h();case 43:case 45:return m(e);case 60:case 62:return v(e);case 61:case 33:return b(e);case 126:return x(It,1)}return!1}function g(e){if(e?br=yr+1:yr=br,fr.locations&&(xr=new a),e)return k();if(br>=pr)return i(Br);var r=dr.charCodeAt(br);if(Qt(r)||92===r)return L();var n=y(r);if(n===!1){var o=String.fromCharCode(r);if("\\"===o||$t.test(o))return L();t(br,"Unexpected character '"+o+"'")}return n}function x(e,r){var t=dr.slice(br,br+r);br+=r,i(e,t)}function k(){for(var e,r,n="",a=br;;){br>=pr&&t(a,"Unterminated regular expression");var o=dr.charAt(br);if(Gt.test(o)&&t(a,"Unterminated regular expression"),e)e=!1;else{if("["===o)r=!0;else if("]"===o&&r)r=!1;else if("/"===o&&!r)break;e="\\"===o}++br}var n=dr.slice(a,br);++br;var s=I();return s&&!/^[gmsiy]*$/.test(s)&&t(a,"Invalid regexp flag"),i(jr,new RegExp(n,s))}function w(e,r){for(var t=br,n=0,a=0,o=null==r?1/0:r;o>a;++a){var i,s=dr.charCodeAt(br);if(i=s>=97?s-97+10:s>=65?s-65+10:s>=48&&57>=s?s-48:1/0,i>=e)break;++br,n=n*e+i}return br===t||null!=r&&br-t!==r?null:n}function C(){br+=2;var e=w(16);return null==e&&t(yr+2,"Expected hexadecimal number"),Qt(dr.charCodeAt(br))&&t(br,"Identifier directly after number"),i(Or,e)}function E(e){var r=br,n=!1,a=48===dr.charCodeAt(br);e||null!==w(10)||t(r,"Invalid number"),46===dr.charCodeAt(br)&&(++br,w(10),n=!0);var o=dr.charCodeAt(br);(69===o||101===o)&&(o=dr.charCodeAt(++br),(43===o||45===o)&&++br,null===w(10)&&t(r,"Invalid number"),n=!0),Qt(dr.charCodeAt(br))&&t(br,"Identifier directly after number");var s,c=dr.slice(r,br);return n?s=parseFloat(c):a&&1!==c.length?/[89]/.test(c)||Tr?t(r,"Invalid number"):s=parseInt(c,8):s=parseInt(c,10),i(Or,s)}function A(e){br++;for(var r="";;){br>=pr&&t(yr,"Unterminated string constant");var n=dr.charCodeAt(br);if(n===e)return++br,i(Dr,r);if(92===n){n=dr.charCodeAt(++br);var a=/^[0-7]+/.exec(dr.slice(br,br+3));for(a&&(a=a[0]);a&&parseInt(a,8)>255;)a=a.slice(0,a.length-1);if("0"===a&&(a=null),++br,a)Tr&&t(br-2,"Octal literal in strict mode"),r+=String.fromCharCode(parseInt(a,8)),br+=a.length-1;else switch(n){case 110:r+="\n";break;case 114:r+="\r";break;case 120:r+=String.fromCharCode(S(2));break;case 117:r+=String.fromCharCode(S(4));break;case 85:r+=String.fromCharCode(S(8));break;case 116:r+="	";break;case 98:r+="\b";break;case 118:r+="";break;case 102:r+="\f";break;case 48:r+="\0";break;case 13:10===dr.charCodeAt(br)&&++br;case 10:fr.locations&&(Sr=br,++Ar);break;default:r+=String.fromCharCode(n)}}else(13===n||10===n||8232===n||8233===n)&&t(yr,"Unterminated string constant"),r+=String.fromCharCode(n),++br}}function S(e){var r=w(16,e);return null===r&&t(yr,"Bad character escape sequence"),r}function I(){Bt=!1;for(var e,r=!0,n=br;;){var a=dr.charCodeAt(br);if(Yt(a))Bt&&(e+=dr.charAt(br)),++br;else{if(92!==a)break;Bt||(e=dr.slice(n,br)),Bt=!0,117!=dr.charCodeAt(++br)&&t(br,"Expecting Unicode escape sequence \\uXXXX"),++br;var o=S(4),i=String.fromCharCode(o);i||t(br-1,"Invalid Unicode escape"),(r?Qt(o):Yt(o))||t(br-4,"Invalid Unicode escape"),e+=i}r=!1}return Bt?e:dr.slice(n,br)}function L(){var e=I(),r=Fr;return Bt||(Wt(e)?r=lt[e]:(fr.forbidReserved&&(3===fr.ecmaVersion?Mt:zt)(e)||Tr&&Xt(e))&&t(yr,"The keyword '"+e+"' is reserved")),i(r,e)}function U(){Ir=yr,Lr=gr,Ur=kr,g()}function R(e){if(Tr=e,br=Lr,fr.locations)for(;Sr>br;)Sr=dr.lastIndexOf("\n",Sr-2)+1,--Ar;u(),g()}function V(){this.type=null,this.start=yr,this.end=null}function T(){this.start=xr,this.end=null,null!==hr&&(this.source=hr)}function q(){var e=new V;return fr.locations&&(e.loc=new T),fr.ranges&&(e.range=[yr,0]),e}function O(e){var r=new V;return r.start=e.start,fr.locations&&(r.loc=new T,r.loc.start=e.loc.start),fr.ranges&&(r.range=[e.range[0],0]),r}function j(e,r){return e.type=r,e.end=Lr,fr.locations&&(e.loc.end=Ur),fr.ranges&&(e.range[1]=Lr),e}function D(e){return fr.ecmaVersion>=5&&"ExpressionStatement"===e.type&&"Literal"===e.expression.type&&"use strict"===e.expression.value}function F(e){return wr===e?(U(),!0):void 0}function B(){return!fr.strictSemicolons&&(wr===Br||wr===ht||Gt.test(dr.slice(Lr,yr)))}function M(){F(yt)||B()||X()}function z(e){wr===e?U():X()}function X(){t(yr,"Unexpected token")}function N(e){"Identifier"!==e.type&&"MemberExpression"!==e.type&&t(e.start,"Assigning to rvalue"),Tr&&"Identifier"===e.type&&Nt(e.name)&&t(e.start,"Assigning to "+e.name+" in strict mode")}function W(e){Ir=Lr=br,fr.locations&&(Ur=new a),Rr=Tr=null,Vr=[],g();var r=e||q(),t=!0;for(e||(r.body=[]);wr!==Br;){var n=J();r.body.push(n),t&&D(n)&&R(!0),t=!1}return j(r,"Program")}function J(){(wr===wt||wr===Et&&"/="==Cr)&&g(!0);var e=wr,r=q();switch(e){case Mr:case Nr:U();var n=e===Mr;F(yt)||B()?r.label=null:wr!==Fr?X():(r.label=lr(),M());for(var a=0;a<Vr.length;++a){var o=Vr[a];if(null==r.label||o.name===r.label.name){if(null!=o.kind&&(n||"loop"===o.kind))break;if(r.label&&n)break}}return a===Vr.length&&t(r.start,"Unsyntactic "+e.keyword),j(r,n?"BreakStatement":"ContinueStatement");case Wr:return U(),M(),j(r,"DebuggerStatement");case Pr:return U(),Vr.push(Zt),r.body=J(),Vr.pop(),z(tt),r.test=P(),M(),j(r,"DoWhileStatement");case _r:if(U(),Vr.push(Zt),z(mt),wr===yt)return $(r,null);if(wr===rt){var i=q();return U(),G(i,!0),j(i,"VariableDeclaration"),1===i.declarations.length&&F(ut)?_(r,i):$(r,i)}var i=K(!1,!0);return F(ut)?(N(i),_(r,i)):$(r,i);case Gr:return U(),cr(r,!0);case Kr:return U(),r.test=P(),r.consequent=J(),r.alternate=F(Hr)?J():null,j(r,"IfStatement");case Qr:return Rr||t(yr,"'return' outside of function"),U(),F(yt)||B()?r.argument=null:(r.argument=K(),M()),j(r,"ReturnStatement");case Yr:U(),r.discriminant=P(),r.cases=[],z(pt),Vr.push(en);for(var s,c;wr!=ht;)if(wr===zr||wr===Jr){var u=wr===zr;s&&j(s,"SwitchCase"),r.cases.push(s=q()),s.consequent=[],U(),u?s.test=K():(c&&t(Ir,"Multiple default clauses"),c=!0,s.test=null),z(gt)}else s||X(),s.consequent.push(J());return s&&j(s,"SwitchCase"),U(),Vr.pop(),j(r,"SwitchStatement");case Zr:return U(),Gt.test(dr.slice(Lr,yr))&&t(Lr,"Illegal newline after throw"),r.argument=K(),M(),j(r,"ThrowStatement");case et:if(U(),r.block=H(),r.handler=null,wr===Xr){var l=q();U(),z(mt),l.param=lr(),Tr&&Nt(l.param.name)&&t(l.param.start,"Binding "+l.param.name+" in strict mode"),z(vt),l.guard=null,l.body=H(),r.handler=j(l,"CatchClause")}return r.guardedHandlers=qr,r.finalizer=F($r)?H():null,r.handler||r.finalizer||t(r.start,"Missing catch or finally clause"),j(r,"TryStatement");case rt:return U(),G(r),M(),j(r,"VariableDeclaration");case tt:return U(),r.test=P(),Vr.push(Zt),r.body=J(),Vr.pop(),j(r,"WhileStatement");case nt:return Tr&&t(yr,"'with' in strict mode"),U(),r.object=P(),r.body=J(),j(r,"WithStatement");case pt:return H();case yt:return U(),j(r,"EmptyStatement");default:var f=Cr,d=K();if(e===Fr&&"Identifier"===d.type&&F(gt)){for(var a=0;a<Vr.length;++a)Vr[a].name===f&&t(d.start,"Label '"+f+"' is already declared");var p=wr.isLoop?"loop":wr===Yr?"switch":null;return Vr.push({name:f,kind:p}),r.body=J(),Vr.pop(),r.label=d,j(r,"LabeledStatement")}return r.expression=d,M(),j(r,"ExpressionStatement")}}function P(){z(mt);var e=K();return z(vt),e}function H(e){var r,t=q(),n=!0,a=!1;for(t.body=[],z(pt);!F(ht);){var o=J();t.body.push(o),n&&e&&D(o)&&(r=a,R(a=!0)),n=!1}return a&&!r&&R(!1),j(t,"BlockStatement")}function $(e,r){return e.init=r,z(yt),e.test=wr===yt?null:K(),z(yt),e.update=wr===vt?null:K(),z(vt),e.body=J(),Vr.pop(),j(e,"ForStatement")}function _(e,r){return e.left=r,e.right=K(),z(vt),e.body=J(),Vr.pop(),j(e,"ForInStatement")}function G(e,r){for(e.declarations=[],e.kind="var";;){var n=q();if(n.id=lr(),Tr&&Nt(n.id.name)&&t(n.id.start,"Binding "+n.id.name+" in strict mode"),n.init=F(Ct)?K(!0,r):null,e.declarations.push(j(n,"VariableDeclarator")),!F(bt))break}return e}function K(e,r){var t=Q(r);if(!e&&wr===bt){var n=O(t);for(n.expressions=[t];F(bt);)n.expressions.push(Q(r));return j(n,"SequenceExpression")}return t}function Q(e){var r=Y(e);if(wr.isAssign){var t=O(r);return t.operator=Cr,t.left=r,U(),t.right=Q(e),N(r),j(t,"AssignmentExpression")}return r}function Y(e){var r=Z(e);if(F(kt)){var t=O(r);return t.test=r,t.consequent=K(!0),z(gt),t.alternate=K(!0,e),j(t,"ConditionalExpression")}return r}function Z(e){return er(rr(),-1,e)}function er(e,r,t){var n=wr.binop;if(null!=n&&(!t||wr!==ut)&&n>r){var a=O(e);a.left=e,a.operator=Cr,U(),a.right=er(rr(),n,t);var o=j(a,/&&|\|\|/.test(a.operator)?"LogicalExpression":"BinaryExpression");return er(o,r,t)}return e}function rr(){if(wr.prefix){var e=q(),r=wr.isUpdate;return e.operator=Cr,e.prefix=!0,Er=!0,U(),e.argument=rr(),r?N(e.argument):Tr&&"delete"===e.operator&&"Identifier"===e.argument.type&&t(e.start,"Deleting local variable in strict mode"),j(e,r?"UpdateExpression":"UnaryExpression")}for(var n=tr();wr.postfix&&!B();){var e=O(n);e.operator=Cr,e.prefix=!1,e.argument=n,N(n),U(),n=j(e,"UpdateExpression")}return n}function tr(){return nr(ar())}function nr(e,r){if(F(xt)){var t=O(e);return t.object=e,t.property=lr(!0),t.computed=!1,nr(j(t,"MemberExpression"),r)}if(F(ft)){var t=O(e);return t.object=e,t.property=K(),t.computed=!0,z(dt),nr(j(t,"MemberExpression"),r)}if(!r&&F(mt)){var t=O(e);return t.callee=e,t.arguments=ur(vt,!1),nr(j(t,"CallExpression"),r)}return e}function ar(){switch(wr){case ot:var e=q();return U(),j(e,"ThisExpression");case Fr:return lr();case Or:case Dr:case jr:var e=q();return e.value=Cr,e.raw=dr.slice(yr,gr),U(),j(e,"Literal");case it:case st:case ct:var e=q();return e.value=wr.atomValue,e.raw=wr.keyword,U(),j(e,"Literal");case mt:var r=xr,t=yr;U();var n=K();return n.start=t,n.end=gr,fr.locations&&(n.loc.start=r,n.loc.end=kr),fr.ranges&&(n.range=[t,gr]),z(vt),n;case ft:var e=q();return U(),e.elements=ur(dt,!0,!0),j(e,"ArrayExpression");case pt:return ir();case Gr:var e=q();return U(),cr(e,!1);case at:return or();default:X()}}function or(){var e=q();return U(),e.callee=nr(ar(),!0),e.arguments=F(mt)?ur(vt,!1):qr,j(e,"NewExpression")}function ir(){var e=q(),r=!0,n=!1;for(e.properties=[],U();!F(ht);){if(r)r=!1;else if(z(bt),fr.allowTrailingCommas&&F(ht))break;var a,o={key:sr()},i=!1;if(F(gt)?(o.value=K(!0),a=o.kind="init"):fr.ecmaVersion>=5&&"Identifier"===o.key.type&&("get"===o.key.name||"set"===o.key.name)?(i=n=!0,a=o.kind=o.key.name,o.key=sr(),wr!==mt&&X(),o.value=cr(q(),!1)):X(),"Identifier"===o.key.type&&(Tr||n))for(var s=0;s<e.properties.length;++s){var c=e.properties[s];if(c.key.name===o.key.name){var u=a==c.kind||i&&"init"===c.kind||"init"===a&&("get"===c.kind||"set"===c.kind);u&&!Tr&&"init"===a&&"init"===c.kind&&(u=!1),u&&t(o.key.start,"Redefinition of property")}}e.properties.push(o)}return j(e,"ObjectExpression")}function sr(){return wr===Or||wr===Dr?ar():lr(!0)}function cr(e,r){wr===Fr?e.id=lr():r?X():e.id=null,e.params=[];var n=!0;for(z(mt);!F(vt);)n?n=!1:z(bt),e.params.push(lr());var a=Rr,o=Vr;if(Rr=!0,Vr=[],e.body=H(!0),Rr=a,Vr=o,Tr||e.body.body.length&&D(e.body.body[0]))for(var i=e.id?-1:0;i<e.params.length;++i){var s=0>i?e.id:e.params[i];if((Xt(s.name)||Nt(s.name))&&t(s.start,"Defining '"+s.name+"' in strict mode"),i>=0)for(var c=0;i>c;++c)s.name===e.params[c].name&&t(s.start,"Argument name clash in strict mode")}return j(e,r?"FunctionDeclaration":"FunctionExpression")}function ur(e,r,t){for(var n=[],a=!0;!F(e);){if(a)a=!1;else if(z(bt),r&&fr.allowTrailingCommas&&F(e))break;t&&wr===bt?n.push(null):n.push(K(!0))}return n}function lr(e){var r=q();return r.name=wr===Fr?Cr:e&&!fr.forbidReserved&&wr.keyword||X(),Er=!1,U(),j(r,"Identifier")}e.version="0.4.0";var fr,dr,pr,hr;e.parse=function(e,t){return dr=String(e),pr=dr.length,r(t),o(),W(fr.program)};var mr=e.defaultOptions={ecmaVersion:5,strictSemicolons:!1,allowTrailingCommas:!0,forbidReserved:!1,locations:!1,onComment:null,ranges:!1,program:null,sourceFile:null},vr=e.getLineInfo=function(e,r){for(var t=1,n=0;;){Kt.lastIndex=n;var a=Kt.exec(e);if(!(a&&a.index<r))break;++t,n=a.index+a[0].length}return{line:t,column:r-n}};e.tokenize=function(e,t){function n(e){return g(e),a.start=yr,a.end=gr,a.startLoc=xr,a.endLoc=kr,a.type=wr,a.value=Cr,a}dr=String(e),pr=dr.length,r(t),o();var a={};return n.jumpTo=function(e,r){if(br=e,fr.locations){Ar=1,Sr=Kt.lastIndex=0;for(var t;(t=Kt.exec(dr))&&t.index<e;)++Ar,Sr=t.index+t[0].length}Er=r,u()},n};var br,yr,gr,xr,kr,wr,Cr,Er,Ar,Sr,Ir,Lr,Ur,Rr,Vr,Tr,qr=[],Or={type:"num"},jr={type:"regexp"},Dr={type:"string"},Fr={type:"name"},Br={type:"eof"},Mr={keyword:"break"},zr={keyword:"case",beforeExpr:!0},Xr={keyword:"catch"},Nr={keyword:"continue"},Wr={keyword:"debugger"},Jr={keyword:"default"},Pr={keyword:"do",isLoop:!0},Hr={keyword:"else",beforeExpr:!0},$r={keyword:"finally"},_r={keyword:"for",isLoop:!0},Gr={keyword:"function"},Kr={keyword:"if"},Qr={keyword:"return",beforeExpr:!0},Yr={keyword:"switch"},Zr={keyword:"throw",beforeExpr:!0},et={keyword:"try"},rt={keyword:"var"},tt={keyword:"while",isLoop:!0},nt={keyword:"with"},at={keyword:"new",beforeExpr:!0},ot={keyword:"this"},it={keyword:"null",atomValue:null},st={keyword:"true",atomValue:!0},ct={keyword:"false",atomValue:!1},ut={keyword:"in",binop:7,beforeExpr:!0},lt={"break":Mr,"case":zr,"catch":Xr,"continue":Nr,"debugger":Wr,"default":Jr,"do":Pr,"else":Hr,"finally":$r,"for":_r,"function":Gr,"if":Kr,"return":Qr,"switch":Yr,"throw":Zr,"try":et,"var":rt,"while":tt,"with":nt,"null":it,"true":st,"false":ct,"new":at,"in":ut,"instanceof":{keyword:"instanceof",binop:7,beforeExpr:!0},"this":ot,"typeof":{keyword:"typeof",prefix:!0,beforeExpr:!0},"void":{keyword:"void",prefix:!0,beforeExpr:!0},"delete":{keyword:"delete",prefix:!0,beforeExpr:!0}},ft={type:"[",beforeExpr:!0},dt={type:"]"},pt={type:"{",beforeExpr:!0},ht={type:"}"},mt={type:"(",beforeExpr:!0},vt={type:")"},bt={type:",",beforeExpr:!0},yt={type:";",beforeExpr:!0},gt={type:":",beforeExpr:!0},xt={type:"."},kt={type:"?",beforeExpr:!0},wt={binop:10,beforeExpr:!0},Ct={isAssign:!0,beforeExpr:!0},Et={isAssign:!0,beforeExpr:!0},At={binop:9,prefix:!0,beforeExpr:!0},St={postfix:!0,prefix:!0,isUpdate:!0},It={prefix:!0,beforeExpr:!0},Lt={binop:1,beforeExpr:!0},Ut={binop:2,beforeExpr:!0},Rt={binop:3,beforeExpr:!0},Vt={binop:4,beforeExpr:!0},Tt={binop:5,beforeExpr:!0},qt={binop:6,beforeExpr:!0},Ot={binop:7,beforeExpr:!0},jt={binop:8,beforeExpr:!0},Dt={binop:10,beforeExpr:!0};e.tokTypes={bracketL:ft,bracketR:dt,braceL:pt,braceR:ht,parenL:mt,parenR:vt,comma:bt,semi:yt,colon:gt,dot:xt,question:kt,slash:wt,eq:Ct,name:Fr,eof:Br,num:Or,regexp:jr,string:Dr};for(var Ft in lt)e.tokTypes["_"+Ft]=lt[Ft];var Bt,Mt=n("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile"),zt=n("class enum extends super const export import"),Xt=n("implements interface let package private protected public static yield"),Nt=n("eval arguments"),Wt=n("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this"),Jt=/[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/,Pt="\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc",Ht="\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f",$t=new RegExp("["+Pt+"]"),_t=new RegExp("["+Pt+Ht+"]"),Gt=/[\n\r\u2028\u2029]/,Kt=/\r\n|[\n\r\u2028\u2029]/g,Qt=e.isIdentifierStart=function(e){return 65>e?36===e:91>e?!0:97>e?95===e:123>e?!0:e>=170&&$t.test(String.fromCharCode(e))},Yt=e.isIdentifierChar=function(e){return 48>e?36===e:58>e?!0:65>e?!1:91>e?!0:97>e?95===e:123>e?!0:e>=170&&_t.test(String.fromCharCode(e))},Zt={kind:"loop"},en={kind:"switch"}});
	
		var binaryOperators = {
			'+': '__add',
			'-': '__subtract',
			'*': '__multiply',
			'/': '__divide',
			'%': '__modulo',
			'==': 'equals',
			'!=': 'equals'
		};
	
		var unaryOperators = {
			'-': '__negate',
			'+': null
		};
	
		var fields = Base.each(
			['add', 'subtract', 'multiply', 'divide', 'modulo', 'negate'],
			function(name) {
				this['__' + name] = '#' + name;
			},
			{}
		);
		Point.inject(fields);
		Size.inject(fields);
		Color.inject(fields);
	
		function __$__(left, operator, right) {
			var handler = binaryOperators[operator];
			if (left && left[handler]) {
				var res = left[handler](right);
				return operator === '!=' ? !res : res;
			}
			switch (operator) {
			case '+': return left + right;
			case '-': return left - right;
			case '*': return left * right;
			case '/': return left / right;
			case '%': return left % right;
			case '==': return left == right;
			case '!=': return left != right;
			}
		}
	
		function $__(operator, value) {
			var handler = unaryOperators[operator];
			if (handler && value && value[handler])
				return value[handler]();
			switch (operator) {
			case '+': return +value;
			case '-': return -value;
			}
		}
	
		function parse(code, options) {
			return scope.acorn.parse(code, options);
		}
	
		function compile(code, url, options) {
			if (!code)
				return '';
			options = options || {};
			url = url || '';
	
			var insertions = [];
	
			function getOffset(offset) {
				for (var i = 0, l = insertions.length; i < l; i++) {
					var insertion = insertions[i];
					if (insertion[0] >= offset)
						break;
					offset += insertion[1];
				}
				return offset;
			}
	
			function getCode(node) {
				return code.substring(getOffset(node.range[0]),
						getOffset(node.range[1]));
			}
	
			function getBetween(left, right) {
				return code.substring(getOffset(left.range[1]),
						getOffset(right.range[0]));
			}
	
			function replaceCode(node, str) {
				var start = getOffset(node.range[0]),
					end = getOffset(node.range[1]),
					insert = 0;
				for (var i = insertions.length - 1; i >= 0; i--) {
					if (start > insertions[i][0]) {
						insert = i + 1;
						break;
					}
				}
				insertions.splice(insert, 0, [start, str.length - end + start]);
				code = code.substring(0, start) + str + code.substring(end);
			}
	
			function walkAST(node, parent) {
				if (!node)
					return;
				for (var key in node) {
					if (key === 'range' || key === 'loc')
						continue;
					var value = node[key];
					if (Array.isArray(value)) {
						for (var i = 0, l = value.length; i < l; i++)
							walkAST(value[i], node);
					} else if (value && typeof value === 'object') {
						walkAST(value, node);
					}
				}
				switch (node.type) {
				case 'UnaryExpression':
					if (node.operator in unaryOperators
							&& node.argument.type !== 'Literal') {
						var arg = getCode(node.argument);
						replaceCode(node, '$__("' + node.operator + '", '
								+ arg + ')');
					}
					break;
				case 'BinaryExpression':
					if (node.operator in binaryOperators
							&& node.left.type !== 'Literal') {
						var left = getCode(node.left),
							right = getCode(node.right),
							between = getBetween(node.left, node.right),
							operator = node.operator;
						replaceCode(node, '__$__(' + left + ','
								+ between.replace(new RegExp('\\' + operator),
									'"' + operator + '"')
								+ ', ' + right + ')');
					}
					break;
				case 'UpdateExpression':
				case 'AssignmentExpression':
					var parentType = parent && parent.type;
					if (!(
							parentType === 'ForStatement'
							|| parentType === 'BinaryExpression'
								&& /^[=!<>]/.test(parent.operator)
							|| parentType === 'MemberExpression' && parent.computed
					)) {
						if (node.type === 'UpdateExpression') {
							var arg = getCode(node.argument),
								exp = '__$__(' + arg + ', "' + node.operator[0]
										+ '", 1)',
								str = arg + ' = ' + exp;
							if (!node.prefix
									&& (parentType === 'AssignmentExpression'
										|| parentType === 'VariableDeclarator')) {
								if (getCode(parent.left || parent.id) === arg)
									str = exp;
								str = arg + '; ' + str;
							}
							replaceCode(node, str);
						} else {
							if (/^.=$/.test(node.operator)
									&& node.left.type !== 'Literal') {
								var left = getCode(node.left),
									right = getCode(node.right);
								replaceCode(node, left + ' = __$__(' + left + ', "'
										+ node.operator[0] + '", ' + right + ')');
							}
						}
					}
					break;
				}
			}
			var sourceMap = null,
				browser = paper.browser,
				version = browser.versionNumber,
				lineBreaks = /\r\n|\n|\r/mg;
			if (browser.chrome && version >= 30
					|| browser.webkit && version >= 537.76
					|| browser.firefox && version >= 23) {
				var offset = 0;
				if (window.location.href.indexOf(url) === 0) {
					var html = document.getElementsByTagName('html')[0].innerHTML;
					offset = html.substr(0, html.indexOf(code) + 1).match(
							lineBreaks).length + 1;
				}
				var mappings = ['AAAA'];
				mappings.length = (code.match(lineBreaks) || []).length + 1 + offset;
				sourceMap = {
					version: 3,
					file: url,
					names:[],
					mappings: mappings.join(';AACA'),
					sourceRoot: '',
					sources: [url]
				};
				var source = options.source || !url && code;
				if (source)
					sourceMap.sourcesContent = [source];
			}
			walkAST(parse(code, { ranges: true }));
			if (sourceMap) {
				code = new Array(offset + 1).join('\n') + code
						+ "\n//# sourceMappingURL=data:application/json;base64,"
						+ (btoa(unescape(encodeURIComponent(
							JSON.stringify(sourceMap)))))
						+ "\n//# sourceURL=" + (url || 'paperscript');
			}
			return code;
		}
	
		function execute(code, scope, url, options) {
			paper = scope;
			var view = scope.getView(),
				tool = /\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\b/.test(code)
						? new Tool()
						: null,
				toolHandlers = tool ? tool._events : [],
				handlers = ['onFrame', 'onResize'].concat(toolHandlers),
				params = [],
				args = [],
				func;
			code = compile(code, url, options);
			function expose(scope, hidden) {
				for (var key in scope) {
					if ((hidden || !/^_/.test(key)) && new RegExp('([\\b\\s\\W]|^)'
							+ key.replace(/\$/g, '\\$') + '\\b').test(code)) {
						params.push(key);
						args.push(scope[key]);
					}
				}
			}
			expose({ __$__: __$__, $__: $__, paper: scope, view: view, tool: tool },
					true);
			expose(scope);
			handlers = Base.each(handlers, function(key) {
				if (new RegExp('\\s+' + key + '\\b').test(code)) {
					params.push(key);
					this.push(key + ': ' + key);
				}
			}, []).join(', ');
			if (handlers)
				code += '\nreturn { ' + handlers + ' };';
			var browser = paper.browser;
			if (browser.chrome || browser.firefox) {
				var script = document.createElement('script'),
					head = document.head || document.getElementsByTagName('head')[0];
				if (browser.firefox)
					code = '\n' + code;
				script.appendChild(document.createTextNode(
					'paper._execute = function(' + params + ') {' + code + '\n}'
				));
				head.appendChild(script);
				func = paper._execute;
				delete paper._execute;
				head.removeChild(script);
			} else {
				func = Function(params, code);
			}
			var res = func.apply(scope, args) || {};
			Base.each(toolHandlers, function(key) {
				var value = res[key];
				if (value)
					tool[key] = value;
			});
			if (view) {
				if (res.onResize)
					view.setOnResize(res.onResize);
				view.emit('resize', {
					size: view.size,
					delta: new Point()
				});
				if (res.onFrame)
					view.setOnFrame(res.onFrame);
				view.update();
			}
		}
	
		function loadScript(script) {
			if (/^text\/(?:x-|)paperscript$/.test(script.type)
					&& PaperScope.getAttribute(script, 'ignore') !== 'true') {
				var canvasId = PaperScope.getAttribute(script, 'canvas'),
					canvas = document.getElementById(canvasId),
					src = script.src || script.getAttribute('data-src'),
					async = PaperScope.hasAttribute(script, 'async'),
					scopeAttribute = 'data-paper-scope';
				if (!canvas)
					throw new Error('Unable to find canvas with id "'
							+ canvasId + '"');
				var scope = PaperScope.get(canvas.getAttribute(scopeAttribute))
							|| new PaperScope().setup(canvas);
				canvas.setAttribute(scopeAttribute, scope._id);
				if (src) {
					Http.request('get', src, function(code) {
						execute(code, scope, src);
					}, async);
				} else {
					execute(script.innerHTML, scope, script.baseURI);
				}
				script.setAttribute('data-paper-ignore', 'true');
				return scope;
			}
		}
	
		function loadAll() {
			Base.each(document.getElementsByTagName('script'), loadScript);
		}
	
		function load(script) {
			return script ? loadScript(script) : loadAll();
		}
	
		if (document.readyState === 'complete') {
			setTimeout(loadAll);
		} else {
			DomEvent.add(window, { load: loadAll });
		}
	
		return {
			compile: compile,
			execute: execute,
			load: load,
			parse: parse
		};
	
	}).call(this);
	
	paper = new (PaperScope.inject(Base.exports, {
		enumerable: true,
		Base: Base,
		Numerical: Numerical,
		Key: Key
	}))();
	
	if (true) {
		!(__WEBPACK_AMD_DEFINE_FACTORY__ = (paper), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (typeof module === 'object' && module) {
		module.exports = paper;
	}
	
	return paper;
	};


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports.changeCenter = changeCenter;
	exports.changeZoom = changeZoom;
	var Paper = __webpack_require__(2);
	
	function changeCenter(oldCenter, offset, factor) {
	  offset = offset.multiply(factor);
	  return offset;
	}
	
	function changeZoom(oldZoom, delta, center, position) {
	  var factor = 1.05;
	  var newZoom = delta < 0 ? oldZoom * factor : oldZoom / factor;
	  var beta = oldZoom / newZoom;
	  var pc = position.subtract(center);
	  var offset = position.subtract(pc.multiply(beta)).subtract(center);
	  return { newZoom: newZoom, offset: offset };
	}

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports.init = init;
	exports.add = add;
	var Paper = __webpack_require__(2);
	
	var animations = [];
	
	function stop(index) {
	  animations.splice(index, 1);
	}
	
	function onFrame(event) {
	  if (event.delta === 0) return;
	  animations.forEach(function (animation, index) {
	    animation.elapsedTime += event.delta;
	    var continueAnimation = animation.callback(animation.elapsedTime);
	    if (continueAnimation === false) {
	      stop(index);
	    }
	  });
	}
	
	function init() {
	  Paper.view.onFrame = onFrame;
	}
	
	function add(callback) {
	  animations.push({
	    callback: callback,
	    elapsedTime: 0
	  });
	}

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var Paper = __webpack_require__(2);
	var view = __webpack_require__(1);
	
	var Menu = (function () {
	  function Menu(onDone, params) {
	    var _this = this;
	
	    _classCallCheck(this, Menu);
	
	    view.reset();
	    this.onDone = onDone;
	    this.savedMaps = [];
	    for (var i = 0; i < localStorage.length; i++) {
	      var key = localStorage.key(i);
	      if (key.indexOf('map') === 0) {
	        this.savedMaps.push(JSON.parse(localStorage.getItem(key)));
	      }
	    }
	
	    this.menu = document.querySelector('#menu');
	    this.menu.style.display = 'initial';
	
	    var createMapButton = document.querySelector('#createMapButton');
	    createMapButton.addEventListener('click', function () {
	      return _this.onDone({ view: 'Create map' });
	    });
	
	    this.maps = document.querySelector('#maps');
	
	    this.savedMaps.forEach(function (map) {
	      var img = document.createElement('img');
	      img.src = map.dataURL;
	      img.addEventListener('click', function () {
	        return _this.onDone({ view: 'Game', params: map.map });
	      });
	      _this.maps.appendChild(img);
	    });
	  }
	
	  _createClass(Menu, [{
	    key: 'dispose',
	    value: function dispose() {
	      this.menu.style.display = '';
	      while (this.maps.firstChild) {
	        this.maps.removeChild(this.maps.firstChild);
	      }
	    }
	  }]);
	
	  return Menu;
	})();
	
	exports['default'] = Menu;
	module.exports = exports['default'];

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var Paper = __webpack_require__(2);
	var view = __webpack_require__(1);
	
	var MapEditor = (function () {
	  function MapEditor(callback) {
	    var _this = this;
	
	    _classCallCheck(this, MapEditor);
	
	    this.callback = callback;
	    this.course;
	    this.track;
	    this.start;
	    this.end;
	
	    this.mouseControls = new Paper.Tool();
	    var lastClick;
	    this.mouseControls.onMouseDown = function (e) {
	      var now = Date.now();
	      if (now - lastClick < 200) {
	        _this.onDoubleClick(e);
	      } else {
	        _this.onMouseDown(e);
	      }
	      lastClick = now;
	    };
	    this.mouseControls.onMouseDrag = function (e) {
	      return _this.onMouseDrag(e);
	    };
	  }
	
	  _createClass(MapEditor, [{
	    key: 'onMouseDown',
	    value: function onMouseDown(event) {
	      if (!this.track) {
	        this.track = new Paper.Path.Circle(event.point, 40);
	        this.track.fillColor = 'purple';
	        this.course = new Paper.Group(this.track);
	        view.addCourse(this.course);
	      }
	      if (this.track.contains(event.point)) {
	        this.isAdding = true;
	      } else {
	        this.isAdding = false;
	      }
	    }
	  }, {
	    key: 'onDoubleClick',
	    value: function onDoubleClick(event) {
	      if (!this.start) {
	        this.start = new Paper.Path.Circle(event.point, 60).intersect(this.track);
	        this.start.fillColor = 'teal';
	        this.course.addChild(this.start);
	      } else {
	        this.end = new Paper.Path.Circle(event.point, 60).intersect(this.track);
	        this.end.fillColor = 'yellow';
	        this.course.addChild(this.end);
	        this.done();
	      }
	    }
	  }, {
	    key: 'onMouseDrag',
	    value: function onMouseDrag(event) {
	      var editCircle = new Paper.Path.Circle(event.point, 40);
	      var newTrack;
	      if (this.isAdding) {
	        newTrack = this.track.unite(editCircle);
	      } else {
	        newTrack = this.track.subtract(editCircle);
	      }
	      this.track.remove();
	      this.track = newTrack;
	    }
	  }, {
	    key: 'done',
	    value: function done() {
	      this.mouseControls.remove();
	
	      var map = {
	        track: this.track.toJSON(),
	        start: this.start.toJSON(),
	        end: this.end.toJSON()
	      };
	
	      view.setView(this.track.bounds.expand(100));
	
	      var dataURL = document.querySelector('canvas').toDataURL("image/png");
	
	      this.course.remove();
	      var key = 'map-' + new Date().toISOString();
	      var value = { dataURL: dataURL, map: map };
	      localStorage.setItem(key, JSON.stringify(value));
	      this.callback({ view: 'Menu' });
	    }
	  }, {
	    key: 'dispose',
	    value: function dispose() {
	      this.course.remove();
	    }
	  }]);
	
	  return MapEditor;
	})();
	
	exports['default'] = MapEditor;
	module.exports = exports['default'];

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var Paper = __webpack_require__(2);
	var Player = __webpack_require__(8);
	var Game = __webpack_require__(9);
	var view = __webpack_require__(1);
	
	var GameGui = (function () {
	  function GameGui(callback, params) {
	    var _this = this;
	
	    _classCallCheck(this, GameGui);
	
	    this.callback = callback;
	    this.game;
	    this.nbrOfPlayers = 2;
	    this.players = [];
	    this.colors = ['#ff0000', '#0000ff'];
	    this.controls = new Paper.Group();
	    this.foreGround = new Paper.Group([this.controls]);
	    this.course = new Paper.Group();
	    this.mouseControls = new Paper.Tool();
	    this.mouseControls.onMouseDown = function (e) {
	      return _this.addPlayerClickEvent(e);
	    };
	
	    this.game = new Game(params);
	
	    var track = this.game.track;
	    track.closed = true;
	    track.fillColor = 'purple';
	
	    var startArea = this.game.start;
	    startArea.fillColor = 'teal';
	
	    var endArea = this.game.end;
	    endArea.fillColor = 'yellow';
	
	    this.course.addChild(track);
	    this.course.addChild(startArea);
	    this.course.addChild(endArea);
	    view.addCourse(this.course);
	
	    this.setViewToTrack();
	
	    this.mousewheelListener = document.addEventListener('mousewheel', function (event) {
	      if (event.wheelDelta === 0) return;
	      _this.mousewheel(event.wheelDelta < 0);
	    });
	
	    this.gestureendListener = document.addEventListener('gestureend', function (e) {
	      return _this.mousewheel(e.scale < 1);
	    }, false);
	  }
	
	  _createClass(GameGui, [{
	    key: 'addPlayerClickEvent',
	    value: function addPlayerClickEvent(event) {
	      var x = Math.round(event.point.x / 20) * 20;
	      var y = Math.round(event.point.y / 20) * 20;
	      var point = new Paper.Point(x, y);
	      if (this.game.start.contains(point)) {
	        this.game.addPlayer(point, new Paper.Point(0, 0));
	        this.players.push(new Player(this.colors.pop(), point));
	        if (this.players.length === this.nbrOfPlayers) {
	          this.startGame();
	        }
	      }
	    }
	  }, {
	    key: 'startGame',
	    value: function startGame() {
	      var _this2 = this;
	
	      this.players.forEach(function (p) {
	        return _this2.foreGround.appendBottom(p.elements);
	      });
	      this.mouseControls.onMouseDown = function (e) {
	        return _this2.onMouseDown(e);
	      };
	      this.game.startGame();
	      this.drawControls();
	    }
	  }, {
	    key: 'onMouseDown',
	    value: function onMouseDown(event) {
	      var item = event.getItem();
	      if (!item) {
	        return;
	      }
	      var itemClicked = item.hitTest(event.point).item;
	      if (itemClicked && itemClicked.movePlayerData) {
	        this.movePlayer(itemClicked.movePlayerData);
	      }
	    }
	  }, {
	    key: 'mousewheel',
	    value: function mousewheel(shouldZoomOut) {
	      if (shouldZoomOut) {
	        this.setViewToTrack();
	      } else {
	        this.setViewToControls();
	      }
	    }
	  }, {
	    key: 'movePlayer',
	    value: function movePlayer(relativeVector) {
	      var guiPlayer = this.players[this.game.currentPlayerIndex];
	      var player = this.game.movePlayer(relativeVector);
	      if (player.isInEndZone) {
	        this.endGame(player);
	      }
	      guiPlayer.addPosition(player.position);
	      this.nextTurn();
	    }
	  }, {
	    key: 'nextTurn',
	    value: function nextTurn() {
	      this.game.nextTurn();
	      this.controls.removeChildren();
	      if (!this.game.currentPlayer.isAlive) {
	        this.nextTurn();
	      }
	      this.drawControls();
	    }
	  }, {
	    key: 'drawControls',
	    value: function drawControls() {
	      var _this3 = this;
	
	      this.game.vectorsForControls.map(function (v) {
	        return _this3.createControl(v);
	      }).forEach(function (control) {
	        return _this3.controls.addChild(control);
	      });
	      this.setViewToControls();
	    }
	  }, {
	    key: 'setViewToControls',
	    value: function setViewToControls() {
	      if (!this.game.currentPlayer) return;
	      var playerBounds = this.controls.bounds.include(this.game.currentPlayer.position);
	      view.setView(playerBounds.expand(100));
	    }
	  }, {
	    key: 'setViewToTrack',
	    value: function setViewToTrack() {
	      view.setView(this.game.track.bounds);
	    }
	  }, {
	    key: 'createControl',
	    value: function createControl(controlObject) {
	      var circle = this.currentPlayer.createPositionElement(controlObject.absolute);
	      circle.movePlayerData = controlObject.relative;
	      return circle;
	    }
	  }, {
	    key: 'endGame',
	    value: function endGame(player) {
	      this.callback({ view: 'Menu', params: player });
	    }
	  }, {
	    key: 'dispose',
	    value: function dispose() {
	      var _this4 = this;
	
	      this.course.remove();
	      this.foreGround.remove();
	      document.removeEventListener('gestureend', this.gestureendListener);
	      document.removeEventListener('mosewheel', this.mousewheelListener);
	      setTimeout(function () {
	        return _this4.mouseControls.remove();
	      });
	    }
	  }, {
	    key: 'currentPlayer',
	    get: function get() {
	      return this.players[this.game.currentPlayerIndex];
	    }
	  }]);
	
	  return GameGui;
	})();
	
	exports['default'] = GameGui;
	module.exports = exports['default'];

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var Paper = __webpack_require__(2);
	
	var Player = (function () {
	  function Player(color, position) {
	    _classCallCheck(this, Player);
	
	    this.color = color;
	    this.path = new Paper.Path({
	      strokeColor: 'white',
	      strokeWidth: 1
	    });
	    this.elements = new Paper.Group([this.path]);
	
	    this.addPosition(position);
	  }
	
	  _createClass(Player, [{
	    key: 'addPosition',
	    value: function addPosition(position) {
	      this.path.add(position);
	      this.path.smooth();
	      var circle = this.createPositionElement(position);
	      this.elements.addChild(circle);
	    }
	  }, {
	    key: 'createPositionElement',
	    value: function createPositionElement(position) {
	      var circle = new Paper.Path.Circle(position, 5);
	      circle.fillColor = this.color;
	      circle.strokeColor = 'white';
	      circle.strokeWidth = 0.5;
	      return circle;
	    }
	  }]);
	
	  return Player;
	})();
	
	exports['default'] = Player;
	module.exports = exports['default'];

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var Car = __webpack_require__(10);
	var Paper = __webpack_require__(2);
	
	var Game = (function () {
	  function Game(map) {
	    _classCallCheck(this, Game);
	
	    this.scale = 20;
	    this.players = [];
	    this.start = Paper.project.importJSON(map.start);
	    this.end = Paper.project.importJSON(map.end);
	    this.track = Paper.project.importJSON(map.track);
	    this.currentPlayerIndex = 0;
	    this.vectorsForControls = [];
	  }
	
	  _createClass(Game, [{
	    key: 'startGame',
	    value: function startGame() {
	      this.setVectorsForControls();
	    }
	  }, {
	    key: 'setVectorsForControls',
	    value: function setVectorsForControls() {
	      var player = this.currentPlayer;
	      var vectorsForControls = [];
	      for (var y = 1; y >= -1; y--) {
	        for (var x = -1; x <= 1; x++) {
	          var playerRelativeVector = new Paper.Point(this.scale * x, this.scale * y).clone().add(player.direction);
	          var absoluteVector = playerRelativeVector.clone().add(player.position);
	          if (this.isPossiblePosition(absoluteVector)) {
	            vectorsForControls.push({
	              relative: playerRelativeVector,
	              absolute: absoluteVector
	            });
	          }
	        }
	      }
	
	      if (vectorsForControls.length === 0) {
	        player.isAlive = false;
	      }
	
	      this.vectorsForControls = vectorsForControls;
	    }
	  }, {
	    key: 'addPlayer',
	    value: function addPlayer(point, direction) {
	      this.players.push(new Car(point, direction));
	    }
	  }, {
	    key: 'movePlayer',
	    value: function movePlayer(vector) {
	      this.currentPlayer.move(vector);
	      var player = this.currentPlayer;
	      player.isInEndZone = this.isInZone(this.end, player.position);
	      return player;
	    }
	  }, {
	    key: 'nextTurn',
	    value: function nextTurn() {
	      this.setNextPlayer();
	      this.setVectorsForControls();
	    }
	  }, {
	    key: 'setNextPlayer',
	    value: function setNextPlayer() {
	      this.currentPlayerIndex++;
	      if (this.currentPlayerIndex === this.players.length) {
	        this.currentPlayerIndex = 0;
	      }
	    }
	  }, {
	    key: 'isPossiblePosition',
	    value: function isPossiblePosition(v) {
	      var carsOnThisPosition = this.players.filter(function (p) {
	        return p.position.clone().subtract(v).length === 0;
	      });
	      var noOtherCars = carsOnThisPosition.length === 0;
	      var isOnTrack = this.track.contains(v);
	      return noOtherCars && isOnTrack;
	    }
	  }, {
	    key: 'isInZone',
	    value: function isInZone(zone, position) {
	      return zone.contains(position);
	    }
	  }, {
	    key: 'currentPlayer',
	    get: function get() {
	      return this.players[this.currentPlayerIndex];
	    }
	  }]);
	
	  return Game;
	})();
	
	exports['default'] = Game;
	module.exports = exports['default'];

/***/ },
/* 10 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Car = (function () {
	  function Car(position, direction) {
	    _classCallCheck(this, Car);
	
	    this.positions = [position];
	    this.currentPositionIndex = 0;
	    this.direction = direction;
	    this.isAlive = true;
	    this.isInEndZone = false;
	  }
	
	  _createClass(Car, [{
	    key: "move",
	    value: function move(vector) {
	      if (!this.isValidMove(this.direction, vector)) {
	        return;
	      }
	
	      this.position = this.position.clone().add(vector);
	      this.direction = vector;
	    }
	  }, {
	    key: "isValidMove",
	    value: function isValidMove(direction, move) {
	      return true;
	    }
	  }, {
	    key: "position",
	    get: function get() {
	      return this.positions[this.currentPositionIndex];
	    },
	    set: function set(value) {
	      this.positions.push(value);
	      this.currentPositionIndex++;
	    }
	  }, {
	    key: "lastPosition",
	    get: function get() {
	      return this.positions[this.currentPositionIndex - 1];
	    }
	  }]);
	
	  return Car;
	})();
	
	exports["default"] = Car;
	module.exports = exports["default"];

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgM2MwNzZiZjZmYmQyNzIzZmZkNTMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3Mvdmlldy5qcyIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3BhcGVyL2Rpc3QvcGFwZXItZnVsbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2FuaW1hdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvbWVudS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvbWFwRWRpdG9yLmpzIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9nYW1lR3VpLmpzIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9wbGF5ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dhbWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Nhci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7O0FDdENBLG9CQUFPLENBQUMsQ0FBYyxDQUFDLENBQUM7QUFDeEIsS0FBSSxJQUFJLEdBQUcsbUJBQU8sQ0FBQyxDQUFjLENBQUMsQ0FBQztBQUNuQyxLQUFJLFNBQVMsR0FBRyxtQkFBTyxDQUFDLENBQW1CLENBQUMsQ0FBQztBQUM3QyxLQUFJLE9BQU8sR0FBRyxtQkFBTyxDQUFDLENBQWlCLENBQUMsQ0FBQzs7QUFFekMsS0FBSSxXQUFXLEdBQUcsSUFBSSxJQUFJLENBQUMsY0FBSTtVQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUM7RUFBQSxDQUFD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Q0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQSxtQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDO0FBQ2hDO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLFlBQVcsMkRBQTJEO0FBQ3RFLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLElBQUk7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLFlBQVc7QUFDWCxpREFBZ0Q7QUFDaEQsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsSUFBSTs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLHVDQUFzQyxpQkFBaUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLHVDQUFzQyxpQkFBaUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsdUNBQXNDLGlCQUFpQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBLGlDQUFnQztBQUNoQyxHQUFFOztBQUVGO0FBQ0EsaUNBQWdDO0FBQ2hDLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxJQUFJOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBLHVDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQSwwQ0FBeUMsZ0JBQWdCO0FBQ3pELEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EscUNBQW9DLE9BQU87QUFDM0M7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSx1Q0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILDJEQUEwRCxPQUFPO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVILGVBQWM7QUFDZCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQiw0Q0FBNEM7QUFDakU7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBLGlCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRixHQUFFO0FBQ0Y7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLHdDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSx3Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0EsMkNBQTBDLDhCQUE4QjtBQUN4RTtBQUNBLEdBQUU7O0FBRUY7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSw0Q0FBMkMsY0FBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsbURBQWtELE9BQU87QUFDekQ7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQWtELE9BQU87QUFDekQ7QUFDQTtBQUNBLG1DQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtB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QTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTJELE9BQU87QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSwrQkFBOEIsaUJBQWlCO0FBQy9DO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBLHVDQUFzQyxpQkFBaUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRCxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSx3Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMEMsYUFBYTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0Isa0NBQWtDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxxQ0FBb0MsYUFBYTtBQUNqRDtBQUNBO0FBQ0EsOENBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU8saURBQWlEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILHlCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEIsaUNBQWlDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsK0JBQStCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUEsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLDJCQUEyQjtBQUN0QyxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsMkJBQTJCO0FBQ3RDLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQix1QkFBdUI7QUFDekM7QUFDQSxxQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUEsRUFBQztBQUNEOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUIsWUFBWTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUEsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRixFQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLEtBQUk7QUFDSjtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsMkJBQTJCO0FBQ3RDO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsNkNBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXFCLCtCQUErQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxtQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQSxvQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLG1CQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQTZCLGFBQWE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsdUNBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLGtCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxRQUFPLGlCQUFpQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSwyREFBMEQsT0FBTztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsdUNBQXNDLE9BQU87QUFDN0M7QUFDQSxHQUFFOztBQUVGO0FBQ0EsNkNBQTRDLE9BQU87QUFDbkQ7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsdUNBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSwwQkFBeUIsY0FBYztBQUN2QyxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsMEJBQXlCLG9DQUFvQztBQUM3RDtBQUNBLHdDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLHVDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsdUNBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLG1DQUFtQztBQUNuRDtBQUNBO0FBQ0EsS0FBSTtBQUNKLG1CQUFrQixPQUFPO0FBQ3pCO0FBQ0Esc0NBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTRDLE9BQU87QUFDbkQ7QUFDQTs7QUFFQSxzREFBcUQsUUFBUTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxvQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFxRCxPQUFPO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0EsbUJBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSwwQ0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQSxxQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBLEVBQUM7QUFDRDtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUEsOEJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGLGtCQUFpQjtBQUNqQixhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUUsSUFBSTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsSUFBSTs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTixNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFnQjtBQUNoQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQixRQUFRLFVBQVU7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EscUNBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMENBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBc0MsT0FBTztBQUM3QztBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFJLENBQUMsU0FBUyxFQUFFLE1BQU0sQ0FBQyxFQUFFO0FBQzVDLGdCQUFPO1FBQ1I7O0FBRUQsV0FBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUNsRCxXQUFJLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQztNQUN6Qjs7O1lBRVUscUJBQUMsU0FBUyxFQUFFLElBQUksRUFBRTtBQUMzQixjQUFPLElBQUksQ0FBQztNQUNiOzs7VUF4QlcsZUFBRTtBQUNaLGNBQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQztNQUNsRDtVQU1XLGFBQUMsS0FBSyxFQUFDO0FBQ2pCLFdBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzNCLFdBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO01BQzdCOzs7VUFQZSxlQUFFO0FBQ2hCLGNBQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLEdBQUcsQ0FBQyxDQUFDLENBQUM7TUFDdEQ7OztVQWZrQixHQUFHOzs7c0JBQUgsR0FBRyIsImZpbGUiOiJhcHAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIDNjMDc2YmY2ZmJkMjcyM2ZmZDUzXG4gKiovIiwicmVxdWlyZSgnLi92aWV3cy92aWV3Jyk7XG52YXIgTWVudSA9IHJlcXVpcmUoJy4vdmlld3MvbWVudScpO1xudmFyIE1hcEVkaXRvciA9IHJlcXVpcmUoJy4vdmlld3MvbWFwRWRpdG9yJyk7XG52YXIgR2FtZUd1aSA9IHJlcXVpcmUoJy4vdmlld3MvZ2FtZUd1aScpO1xuXG52YXIgY3VycmVudFZpZXcgPSBuZXcgTWVudShkYXRhID0+IG9uRG9uZShkYXRhKSk7XG5cbmZ1bmN0aW9uIG9uRG9uZShkYXRhKXtcbiAgY3VycmVudFZpZXcuZGlzcG9zZSgpO1xuXG4gIHN3aXRjaChkYXRhLnZpZXcpe1xuICAgIGNhc2UgJ0NyZWF0ZSBtYXAnOlxuICAgICAgY3VycmVudFZpZXcgPSBuZXcgTWFwRWRpdG9yKGRhdGEgPT4gb25Eb25lKGRhdGEpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0dhbWUnOlxuICAgICAgY3VycmVudFZpZXcgPSBuZXcgR2FtZUd1aShkYXRhID0+IG9uRG9uZShkYXRhKSwgZGF0YS5wYXJhbXMpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGN1cnJlbnRWaWV3ID0gbmV3IE1lbnUoZGF0YSA9PiBvbkRvbmUoZGF0YSksIGRhdGEucGFyYW1zKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9hcHAuanNcbiAqKi8iLCJ2YXIgUGFwZXIgPSByZXF1aXJlKCdwYXBlcicpO1xudmFyIGNoYW5nZUNlbnRlciA9IHJlcXVpcmUoJy4vdXRpbHMnKS5jaGFuZ2VDZW50ZXI7XG52YXIgY2hhbmdlWm9vbSA9IHJlcXVpcmUoJy4vdXRpbHMnKS5jaGFuZ2Vab29tO1xudmFyIGFuaW1hdGlvbiA9IHJlcXVpcmUoJy4vYW5pbWF0aW9uJyk7XG5cbnZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxudmFyIHdpZHRoID0gZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aDtcbnZhciBoZWlnaHQgPSBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodDtcblxuaW5pdFBhcGVyKGNhbnZhcywgd2lkdGgsIGhlaWdodCk7XG5cbnZhciBtb3VzZUNvbnRyb2xzO1xuXG52YXIgb3V0ZXJCb3VuZHMgPSBuZXcgUGFwZXIuUmVjdGFuZ2xlKDAsIDAsIHdpZHRoICogMiwgaGVpZ2h0ICogMik7XG5cbnZhciBjb3Vyc2UgPSBuZXcgUGFwZXIuR3JvdXAoY3JlYXRlR3JpZChvdXRlckJvdW5kcykpO1xuY291cnNlLmNsaXBwZWQgPSB0cnVlO1xuXG52YXIgaW5pdGlhbEJvdW5kcyA9IFBhcGVyLnZpZXcuYm91bmRzLmNsb25lKCk7XG5cblBhcGVyLnZpZXcuZHJhdygpO1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0Vmlldyhib3VuZHMpe1xuICBpZihpc1NhbWVCb3VuZHMoUGFwZXIudmlldy5ib3VuZHMsIGJvdW5kcykpIHJldHVybjtcbiAgdmFyIGFzcGVjdFJhdGlvID0gd2lkdGgvaGVpZ2h0O1xuICB2YXIgc2l6ZSA9IGJvdW5kcy5zaXplLmNsb25lKCk7XG4gIHZhciBuZXdSYXRpbyA9IHNpemUud2lkdGgvc2l6ZS5oZWlnaHQ7XG4gIGlmKG5ld1JhdGlvICE9PSBhc3BlY3RSYXRpbyl7XG4gICAgaWYobmV3UmF0aW8gPCBhc3BlY3RSYXRpbyl7XG4gICAgICBzaXplLndpZHRoID0gc2l6ZS53aWR0aCAqIGFzcGVjdFJhdGlvL25ld1JhdGlvO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaXplLmhlaWdodCA9IHNpemUuaGVpZ2h0ICogbmV3UmF0aW8vYXNwZWN0UmF0aW87XG4gICAgfVxuICB9XG4gIHZhciBuZXdab29tID0gUGFwZXIudmlldy52aWV3U2l6ZS53aWR0aC9zaXplLndpZHRoO1xuICBuZXdab29tID0gbmV3Wm9vbSA+IDEgPyBuZXdab29tIDogMTtcbiAgY29uc29sZS5sb2coJ05ldyB2aWV3OicsIGJvdW5kcy5jZW50ZXIsIG5ld1pvb20pO1xuICBhbmltYXRlVmlldyhib3VuZHMuY2VudGVyLCBuZXdab29tKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0KCl7XG4gIHNldFZpZXcoaW5pdGlhbEJvdW5kcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRDb3Vyc2UoZWxlbWVudCl7XG4gIGNvdXJzZS5hcHBlbmRCb3R0b20oZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIGluaXRQYXBlcihjYW52YXMsIHdpZHRoLCBoZWlnaHQpe1xuICBjYW52YXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHdpZHRoKTtcbiAgY2FudmFzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgaGVpZ2h0KTtcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICBQYXBlci5zZXR1cChjYW52YXMpO1xuICBhbmltYXRpb24uaW5pdCgpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVHcmlkKHZpZXdCb3VuZHMpe1xuICB2YXIgZ3JpZCA9IG5ldyBQYXBlci5Hcm91cCgpO1xuICBmb3IodmFyIHggPSB2aWV3Qm91bmRzLmxlZnQ7IHggPCB2aWV3Qm91bmRzLnJpZ2h0OyB4ICs9IDIwKXtcbiAgICB2YXIgbGluZSA9IG5ldyBQYXBlci5QYXRoLlJlY3RhbmdsZShcbiAgICAgIG5ldyBQYXBlci5Qb2ludCh4IC0gMC41LCB2aWV3Qm91bmRzLnRvcCksXG4gICAgICBuZXcgUGFwZXIuUG9pbnQoeCArIDAuNSwgUGFwZXIudmlldy5ib3VuZHMuYm90dG9tKVxuICAgICk7XG4gICAgbGluZS5maWxsQ29sb3IgPSAnd2hpdGUnO1xuXG4gICAgZ3JpZC5hZGRDaGlsZChsaW5lKTtcbiAgfVxuICBmb3IodmFyIHkgPSB2aWV3Qm91bmRzLnRvcDsgeSA8IHZpZXdCb3VuZHMuYm90dG9tOyB5ICs9IDIwKXtcbiAgICB2YXIgbGluZSA9IG5ldyBQYXBlci5QYXRoLlJlY3RhbmdsZShcbiAgICAgIG5ldyBQYXBlci5Qb2ludCh2aWV3Qm91bmRzLmxlZnQsIHkpLFxuICAgICAgbmV3IFBhcGVyLlBvaW50KFBhcGVyLnZpZXcuYm91bmRzLnJpZ2h0LCB5ICsgMSlcbiAgICApO1xuICAgIGxpbmUuZmlsbENvbG9yID0gJ3doaXRlJztcblxuICAgIGdyaWQuYWRkQ2hpbGQobGluZSk7XG4gIH1cblxuICByZXR1cm4gZ3JpZDtcbn1cblxuZnVuY3Rpb24gaXNTYW1lQm91bmRzKHZpZXcxLCB2aWV3Mil7XG4gIHZhciBkaWZmID0gdmlldzEuY2VudGVyLnN1YnRyYWN0KHZpZXcyLmNlbnRlcikubGVuZ3RoXG4gIHJldHVybiBkaWZmIDwgMTtcbn1cblxuZnVuY3Rpb24gYW5pbWF0ZVZpZXcoY2VudGVyLCB6b29tKXtcbiAgdmFyIGFuaW1hdGlvbkR1cmF0aW9uID0gMC4zO1xuICB2YXIgc3RhcnRDZW50ZXIgPSBQYXBlci52aWV3LmNlbnRlci5jbG9uZSgpO1xuICB2YXIgZGVsdGFDZW50ZXIgPSBjZW50ZXIuY2xvbmUoKS5zdWJ0cmFjdChzdGFydENlbnRlcik7XG4gIHZhciBzdGFydFpvb20gPSBQYXBlci52aWV3Lnpvb207XG4gIHZhciBkZWx0YVpvb20gPSB6b29tIC0gc3RhcnRab29tO1xuICBhbmltYXRpb24uYWRkKGVsYXBzZWRUaW1lID0+IHtcbiAgICBpZihlbGFwc2VkVGltZSA+IGFuaW1hdGlvbkR1cmF0aW9uKXtcbiAgICAgIFBhcGVyLnZpZXcuY2VudGVyID0gY2VudGVyO1xuICAgICAgUGFwZXIudmlldy56b29tID0gem9vbTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVhc2VWYWx1ZSA9IGVsYXBzZWRUaW1lL2FuaW1hdGlvbkR1cmF0aW9uO1xuICAgICAgdmFyIGR0Q2VudGVyID0gZGVsdGFDZW50ZXIubXVsdGlwbHkoZWFzZVZhbHVlKTtcbiAgICAgIFBhcGVyLnZpZXcuY2VudGVyID0gc3RhcnRDZW50ZXIuYWRkKGR0Q2VudGVyKTtcbiAgICAgIHZhciBkdFpvb20gPSBkZWx0YVpvb20gKiBlYXNlVmFsdWU7XG4gICAgICBQYXBlci52aWV3Lnpvb20gPSBzdGFydFpvb20gKyBkdFpvb207XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3RhcihzdGFydCl7XG4gIGFuaW1hdGVTdGFyKHN0YXJ0LCBuZXcgUGFwZXIuUG9pbnQoMTAwLDEpLCA0ICsgTWF0aC5yYW5kb20oKSAqIDExKTtcbn1cblxuZnVuY3Rpb24gYW5pbWF0ZVN0YXIoc3RhcnQsIHZlbG9jaXR5LCBkaXN0YW5jZSl7XG4gIHZhciBzdGFyID0gbmV3IFBhcGVyLlBhdGguQ2lyY2xlKHN0YXJ0LCA1IC8gZGlzdGFuY2UpO1xuICBzdGFyLmZpbGxDb2xvciA9ICd3aGl0ZSc7XG4gIGFuaW1hdGlvbi5hZGQoZWxhcHNlZFRpbWUgPT4ge1xuICAgIHN0YXIucG9zaXRpb24gPSBzdGFydC5hZGQodmVsb2NpdHkubXVsdGlwbHkoZWxhcHNlZFRpbWUgLyBkaXN0YW5jZSkpO1xuICAgIGlmKCFvdXRlckJvdW5kcy5jb250YWlucyhzdGFyLnBvc2l0aW9uKSl7XG4gICAgICB2YXIgbmV3U3RhcnQgPSBuZXcgUGFwZXIuUG9pbnQucmFuZG9tKCkubXVsdGlwbHkob3V0ZXJCb3VuZHMuYm90dG9tTGVmdCk7XG4gICAgICBjcmVhdGVTdGFyKG5ld1N0YXJ0KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xufVxuXG5mb3IodmFyIGkgPSAwOyBpIDwgMTAwOyBpKyspe1xuICB2YXIgc3RhcnQgPSBuZXcgUGFwZXIuUG9pbnQucmFuZG9tKCkubXVsdGlwbHkob3V0ZXJCb3VuZHMuYm90dG9tUmlnaHQpO1xuICBjcmVhdGVTdGFyKHN0YXJ0KTtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL3ZpZXdzL3ZpZXcuanNcbiAqKi8iLCIvKiFcbiAqIFBhcGVyLmpzIHYwLjkuMjQgLSBUaGUgU3dpc3MgQXJteSBLbmlmZSBvZiBWZWN0b3IgR3JhcGhpY3MgU2NyaXB0aW5nLlxuICogaHR0cDovL3BhcGVyanMub3JnL1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMSAtIDIwMTQsIEp1ZXJnIExlaG5pICYgSm9uYXRoYW4gUHVja2V5XG4gKiBodHRwOi8vc2NyYXRjaGRpc2suY29tLyAmIGh0dHA6Ly9qb25hdGhhbnB1Y2tleS5jb20vXG4gKlxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGZvciBkZXRhaWxzLlxuICpcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogRGF0ZTogRnJpIEF1ZyAyMSAxNjozOTo0MSAyMDE1ICswMjAwXG4gKlxuICoqKlxuICpcbiAqIFN0cmFwcy5qcyAtIENsYXNzIGluaGVyaXRhbmNlIGxpYnJhcnkgd2l0aCBzdXBwb3J0IGZvciBiZWFuLXN0eWxlIGFjY2Vzc29yc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAwNiAtIDIwMTMgSnVlcmcgTGVobmlcbiAqIGh0dHA6Ly9zY3JhdGNoZGlzay5jb20vXG4gKlxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICpcbiAqKipcbiAqXG4gKiBBY29ybi5qc1xuICogaHR0cDovL21hcmlqbmhhdmVyYmVrZS5ubC9hY29ybi9cbiAqXG4gKiBBY29ybiBpcyBhIHRpbnksIGZhc3QgSmF2YVNjcmlwdCBwYXJzZXIgd3JpdHRlbiBpbiBKYXZhU2NyaXB0LFxuICogY3JlYXRlZCBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCByZWxlYXNlZCB1bmRlciBhbiBNSVQgbGljZW5zZS5cbiAqXG4gKi9cblxudmFyIHBhcGVyID0gbmV3IGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuXG52YXIgQmFzZSA9IG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIGhpZGRlbiA9IC9eKHN0YXRpY3N8ZW51bWVyYWJsZXxiZWFuc3xwcmVzZXJ2ZSkkLyxcblxuXHRcdGZvckVhY2ggPSBbXS5mb3JFYWNoIHx8IGZ1bmN0aW9uKGl0ZXIsIGJpbmQpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGl0ZXIuY2FsbChiaW5kLCB0aGlzW2ldLCBpLCB0aGlzKTtcblx0XHR9LFxuXG5cdFx0Zm9ySW4gPSBmdW5jdGlvbihpdGVyLCBiaW5kKSB7XG5cdFx0XHRmb3IgKHZhciBpIGluIHRoaXMpXG5cdFx0XHRcdGlmICh0aGlzLmhhc093blByb3BlcnR5KGkpKVxuXHRcdFx0XHRcdGl0ZXIuY2FsbChiaW5kLCB0aGlzW2ldLCBpLCB0aGlzKTtcblx0XHR9LFxuXG5cdFx0Y3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbihwcm90bykge1xuXHRcdFx0cmV0dXJuIHsgX19wcm90b19fOiBwcm90byB9O1xuXHRcdH0sXG5cblx0XHRkZXNjcmliZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgfHwgZnVuY3Rpb24ob2JqLCBuYW1lKSB7XG5cdFx0XHR2YXIgZ2V0ID0gb2JqLl9fbG9va3VwR2V0dGVyX18gJiYgb2JqLl9fbG9va3VwR2V0dGVyX18obmFtZSk7XG5cdFx0XHRyZXR1cm4gZ2V0XG5cdFx0XHRcdFx0PyB7IGdldDogZ2V0LCBzZXQ6IG9iai5fX2xvb2t1cFNldHRlcl9fKG5hbWUpLFxuXHRcdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH1cblx0XHRcdFx0XHQ6IG9iai5oYXNPd25Qcm9wZXJ0eShuYW1lKVxuXHRcdFx0XHRcdFx0PyB7IHZhbHVlOiBvYmpbbmFtZV0sIGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfVxuXHRcdFx0XHRcdFx0OiBudWxsO1xuXHRcdH0sXG5cblx0XHRfZGVmaW5lID0gT2JqZWN0LmRlZmluZVByb3BlcnR5IHx8IGZ1bmN0aW9uKG9iaiwgbmFtZSwgZGVzYykge1xuXHRcdFx0aWYgKChkZXNjLmdldCB8fCBkZXNjLnNldCkgJiYgb2JqLl9fZGVmaW5lR2V0dGVyX18pIHtcblx0XHRcdFx0aWYgKGRlc2MuZ2V0KVxuXHRcdFx0XHRcdG9iai5fX2RlZmluZUdldHRlcl9fKG5hbWUsIGRlc2MuZ2V0KTtcblx0XHRcdFx0aWYgKGRlc2Muc2V0KVxuXHRcdFx0XHRcdG9iai5fX2RlZmluZVNldHRlcl9fKG5hbWUsIGRlc2Muc2V0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9ialtuYW1lXSA9IGRlc2MudmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdH0sXG5cblx0XHRkZWZpbmUgPSBmdW5jdGlvbihvYmosIG5hbWUsIGRlc2MpIHtcblx0XHRcdGRlbGV0ZSBvYmpbbmFtZV07XG5cdFx0XHRyZXR1cm4gX2RlZmluZShvYmosIG5hbWUsIGRlc2MpO1xuXHRcdH07XG5cblx0ZnVuY3Rpb24gaW5qZWN0KGRlc3QsIHNyYywgZW51bWVyYWJsZSwgYmVhbnMsIHByZXNlcnZlKSB7XG5cdFx0dmFyIGJlYW5zTmFtZXMgPSB7fTtcblxuXHRcdGZ1bmN0aW9uIGZpZWxkKG5hbWUsIHZhbCkge1xuXHRcdFx0dmFsID0gdmFsIHx8ICh2YWwgPSBkZXNjcmliZShzcmMsIG5hbWUpKVxuXHRcdFx0XHRcdCYmICh2YWwuZ2V0ID8gdmFsIDogdmFsLnZhbHVlKTtcblx0XHRcdGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyAmJiB2YWxbMF0gPT09ICcjJylcblx0XHRcdFx0dmFsID0gZGVzdFt2YWwuc3Vic3RyaW5nKDEpXSB8fCB2YWw7XG5cdFx0XHR2YXIgaXNGdW5jID0gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyxcblx0XHRcdFx0cmVzID0gdmFsLFxuXHRcdFx0XHRwcmV2ID0gcHJlc2VydmUgfHwgaXNGdW5jICYmICF2YWwuYmFzZVxuXHRcdFx0XHRcdFx0PyAodmFsICYmIHZhbC5nZXQgPyBuYW1lIGluIGRlc3QgOiBkZXN0W25hbWVdKVxuXHRcdFx0XHRcdFx0OiBudWxsLFxuXHRcdFx0XHRiZWFuO1xuXHRcdFx0aWYgKCFwcmVzZXJ2ZSB8fCAhcHJldikge1xuXHRcdFx0XHRpZiAoaXNGdW5jICYmIHByZXYpXG5cdFx0XHRcdFx0dmFsLmJhc2UgPSBwcmV2O1xuXHRcdFx0XHRpZiAoaXNGdW5jICYmIGJlYW5zICE9PSBmYWxzZVxuXHRcdFx0XHRcdFx0JiYgKGJlYW4gPSBuYW1lLm1hdGNoKC9eKFtnc11ldHxpcykoKFtBLVpdKSguKikpJC8pKSlcblx0XHRcdFx0XHRiZWFuc05hbWVzW2JlYW5bM10udG9Mb3dlckNhc2UoKSArIGJlYW5bNF1dID0gYmVhblsyXTtcblx0XHRcdFx0aWYgKCFyZXMgfHwgaXNGdW5jIHx8ICFyZXMuZ2V0IHx8IHR5cGVvZiByZXMuZ2V0ICE9PSAnZnVuY3Rpb24nXG5cdFx0XHRcdFx0XHR8fCAhQmFzZS5pc1BsYWluT2JqZWN0KHJlcykpXG5cdFx0XHRcdFx0cmVzID0geyB2YWx1ZTogcmVzLCB3cml0YWJsZTogdHJ1ZSB9O1xuXHRcdFx0XHRpZiAoKGRlc2NyaWJlKGRlc3QsIG5hbWUpXG5cdFx0XHRcdFx0XHR8fCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KS5jb25maWd1cmFibGUpIHtcblx0XHRcdFx0XHRyZXMuY29uZmlndXJhYmxlID0gdHJ1ZTtcblx0XHRcdFx0XHRyZXMuZW51bWVyYWJsZSA9IGVudW1lcmFibGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVmaW5lKGRlc3QsIG5hbWUsIHJlcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChzcmMpIHtcblx0XHRcdGZvciAodmFyIG5hbWUgaW4gc3JjKSB7XG5cdFx0XHRcdGlmIChzcmMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIWhpZGRlbi50ZXN0KG5hbWUpKVxuXHRcdFx0XHRcdGZpZWxkKG5hbWUpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgbmFtZSBpbiBiZWFuc05hbWVzKSB7XG5cdFx0XHRcdHZhciBwYXJ0ID0gYmVhbnNOYW1lc1tuYW1lXSxcblx0XHRcdFx0XHRzZXQgPSBkZXN0WydzZXQnICsgcGFydF0sXG5cdFx0XHRcdFx0Z2V0ID0gZGVzdFsnZ2V0JyArIHBhcnRdIHx8IHNldCAmJiBkZXN0WydpcycgKyBwYXJ0XTtcblx0XHRcdFx0aWYgKGdldCAmJiAoYmVhbnMgPT09IHRydWUgfHwgZ2V0Lmxlbmd0aCA9PT0gMCkpXG5cdFx0XHRcdFx0ZmllbGQobmFtZSwgeyBnZXQ6IGdldCwgc2V0OiBzZXQgfSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBkZXN0O1xuXHR9XG5cblx0ZnVuY3Rpb24gZWFjaChvYmosIGl0ZXIsIGJpbmQpIHtcblx0XHRpZiAob2JqKVxuXHRcdFx0KCdsZW5ndGgnIGluIG9iaiAmJiAhb2JqLmdldExlbmd0aFxuXHRcdFx0XHRcdCYmIHR5cGVvZiBvYmoubGVuZ3RoID09PSAnbnVtYmVyJ1xuXHRcdFx0XHQ/IGZvckVhY2hcblx0XHRcdFx0OiBmb3JJbikuY2FsbChvYmosIGl0ZXIsIGJpbmQgPSBiaW5kIHx8IG9iaik7XG5cdFx0cmV0dXJuIGJpbmQ7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXQob2JqLCBwcm9wcywgZXhjbHVkZSkge1xuXHRcdGZvciAodmFyIGtleSBpbiBwcm9wcylcblx0XHRcdGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICEoZXhjbHVkZSAmJiBleGNsdWRlW2tleV0pKVxuXHRcdFx0XHRvYmpba2V5XSA9IHByb3BzW2tleV07XG5cdFx0cmV0dXJuIG9iajtcblx0fVxuXG5cdHJldHVybiBpbmplY3QoZnVuY3Rpb24gQmFzZSgpIHtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRzZXQodGhpcywgYXJndW1lbnRzW2ldKTtcblx0fSwge1xuXHRcdGluamVjdDogZnVuY3Rpb24oc3JjKSB7XG5cdFx0XHRpZiAoc3JjKSB7XG5cdFx0XHRcdHZhciBzdGF0aWNzID0gc3JjLnN0YXRpY3MgPT09IHRydWUgPyBzcmMgOiBzcmMuc3RhdGljcyxcblx0XHRcdFx0XHRiZWFucyA9IHNyYy5iZWFucyxcblx0XHRcdFx0XHRwcmVzZXJ2ZSA9IHNyYy5wcmVzZXJ2ZTtcblx0XHRcdFx0aWYgKHN0YXRpY3MgIT09IHNyYylcblx0XHRcdFx0XHRpbmplY3QodGhpcy5wcm90b3R5cGUsIHNyYywgc3JjLmVudW1lcmFibGUsIGJlYW5zLCBwcmVzZXJ2ZSk7XG5cdFx0XHRcdGluamVjdCh0aGlzLCBzdGF0aWNzLCB0cnVlLCBiZWFucywgcHJlc2VydmUpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHR0aGlzLmluamVjdChhcmd1bWVudHNbaV0pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdGV4dGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYmFzZSA9IHRoaXMsXG5cdFx0XHRcdGN0b3IsXG5cdFx0XHRcdHByb3RvO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRpZiAoY3RvciA9IGFyZ3VtZW50c1tpXS5pbml0aWFsaXplKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y3RvciA9IGN0b3IgfHwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH07XG5cdFx0XHRwcm90byA9IGN0b3IucHJvdG90eXBlID0gY3JlYXRlKHRoaXMucHJvdG90eXBlKTtcblx0XHRcdGRlZmluZShwcm90bywgJ2NvbnN0cnVjdG9yJyxcblx0XHRcdFx0XHR7IHZhbHVlOiBjdG9yLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuXHRcdFx0aW5qZWN0KGN0b3IsIHRoaXMsIHRydWUpO1xuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpXG5cdFx0XHRcdHRoaXMuaW5qZWN0LmFwcGx5KGN0b3IsIGFyZ3VtZW50cyk7XG5cdFx0XHRjdG9yLmJhc2UgPSBiYXNlO1xuXHRcdFx0cmV0dXJuIGN0b3I7XG5cdFx0fVxuXHR9LCB0cnVlKS5pbmplY3Qoe1xuXHRcdGluamVjdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHNyYyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0aWYgKHNyYylcblx0XHRcdFx0XHRpbmplY3QodGhpcywgc3JjLCBzcmMuZW51bWVyYWJsZSwgc3JjLmJlYW5zLCBzcmMucHJlc2VydmUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdGV4dGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcmVzID0gY3JlYXRlKHRoaXMpO1xuXHRcdFx0cmV0dXJuIHJlcy5pbmplY3QuYXBwbHkocmVzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRlYWNoOiBmdW5jdGlvbihpdGVyLCBiaW5kKSB7XG5cdFx0XHRyZXR1cm4gZWFjaCh0aGlzLCBpdGVyLCBiaW5kKTtcblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbihwcm9wcykge1xuXHRcdFx0cmV0dXJuIHNldCh0aGlzLCBwcm9wcyk7XG5cdFx0fSxcblxuXHRcdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcblx0XHR9LFxuXG5cdFx0c3RhdGljczoge1xuXHRcdFx0ZWFjaDogZWFjaCxcblx0XHRcdGNyZWF0ZTogY3JlYXRlLFxuXHRcdFx0ZGVmaW5lOiBkZWZpbmUsXG5cdFx0XHRkZXNjcmliZTogZGVzY3JpYmUsXG5cdFx0XHRzZXQ6IHNldCxcblxuXHRcdFx0Y2xvbmU6IGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0XHRyZXR1cm4gc2V0KG5ldyBvYmouY29uc3RydWN0b3IoKSwgb2JqKTtcblx0XHRcdH0sXG5cblx0XHRcdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0XHR2YXIgY3RvciA9IG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvcjtcblx0XHRcdFx0cmV0dXJuIGN0b3IgJiYgKGN0b3IgPT09IE9iamVjdCB8fCBjdG9yID09PSBCYXNlXG5cdFx0XHRcdFx0XHR8fCBjdG9yLm5hbWUgPT09ICdPYmplY3QnKTtcblx0XHRcdH0sXG5cblx0XHRcdHBpY2s6IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdFx0cmV0dXJuIGEgIT09IHVuZGVmaW5lZCA/IGEgOiBiO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59O1xuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpXG5cdG1vZHVsZS5leHBvcnRzID0gQmFzZTtcblxuQmFzZS5pbmplY3Qoe1xuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2lkICE9IG51bGxcblx0XHRcdD8gICh0aGlzLl9jbGFzcyB8fCAnT2JqZWN0JykgKyAodGhpcy5fbmFtZVxuXHRcdFx0XHQ/IFwiICdcIiArIHRoaXMuX25hbWUgKyBcIidcIlxuXHRcdFx0XHQ6ICcgQCcgKyB0aGlzLl9pZClcblx0XHRcdDogJ3sgJyArIEJhc2UuZWFjaCh0aGlzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0XHRcdGlmICghL15fLy50ZXN0KGtleSkpIHtcblx0XHRcdFx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblx0XHRcdFx0XHR0aGlzLnB1c2goa2V5ICsgJzogJyArICh0eXBlID09PSAnbnVtYmVyJ1xuXHRcdFx0XHRcdFx0XHQ/IEZvcm1hdHRlci5pbnN0YW5jZS5udW1iZXIodmFsdWUpXG5cdFx0XHRcdFx0XHRcdDogdHlwZSA9PT0gJ3N0cmluZycgPyBcIidcIiArIHZhbHVlICsgXCInXCIgOiB2YWx1ZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCBbXSkuam9pbignLCAnKSArICcgfSc7XG5cdH0sXG5cblx0Z2V0Q2xhc3NOYW1lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xhc3MgfHwgJyc7XG5cdH0sXG5cblx0ZXhwb3J0SlNPTjogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHJldHVybiBCYXNlLmV4cG9ydEpTT04odGhpcywgb3B0aW9ucyk7XG5cdH0sXG5cblx0dG9KU09OOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUodGhpcyk7XG5cdH0sXG5cblx0X3NldDogZnVuY3Rpb24ocHJvcHMsIGV4Y2x1ZGUsIGRvbnRDaGVjaykge1xuXHRcdGlmIChwcm9wcyAmJiAoZG9udENoZWNrIHx8IEJhc2UuaXNQbGFpbk9iamVjdChwcm9wcykpKSB7XG5cdFx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzLl9maWx0ZXJpbmcgfHwgcHJvcHMpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIga2V5ID0ga2V5c1tpXTtcblx0XHRcdFx0aWYgKCEoZXhjbHVkZSAmJiBleGNsdWRlW2tleV0pKSB7XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gcHJvcHNba2V5XTtcblx0XHRcdFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRcdHRoaXNba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH0sXG5cblx0c3RhdGljczoge1xuXG5cdFx0ZXhwb3J0czoge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZVxuXHRcdH0sXG5cblx0XHRleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZCgpIHtcblx0XHRcdHZhciByZXMgPSBleHRlbmQuYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuXHRcdFx0XHRuYW1lID0gcmVzLnByb3RvdHlwZS5fY2xhc3M7XG5cdFx0XHRpZiAobmFtZSAmJiAhQmFzZS5leHBvcnRzW25hbWVdKVxuXHRcdFx0XHRCYXNlLmV4cG9ydHNbbmFtZV0gPSByZXM7XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH0sXG5cblx0XHRlcXVhbHM6IGZ1bmN0aW9uKG9iajEsIG9iajIpIHtcblx0XHRcdGlmIChvYmoxID09PSBvYmoyKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdGlmIChvYmoxICYmIG9iajEuZXF1YWxzKVxuXHRcdFx0XHRyZXR1cm4gb2JqMS5lcXVhbHMob2JqMik7XG5cdFx0XHRpZiAob2JqMiAmJiBvYmoyLmVxdWFscylcblx0XHRcdFx0cmV0dXJuIG9iajIuZXF1YWxzKG9iajEpO1xuXHRcdFx0aWYgKG9iajEgJiYgb2JqMlxuXHRcdFx0XHRcdCYmIHR5cGVvZiBvYmoxID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqMiA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkob2JqMSkgJiYgQXJyYXkuaXNBcnJheShvYmoyKSkge1xuXHRcdFx0XHRcdHZhciBsZW5ndGggPSBvYmoxLmxlbmd0aDtcblx0XHRcdFx0XHRpZiAobGVuZ3RoICE9PSBvYmoyLmxlbmd0aClcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdFx0XHRcdGlmICghQmFzZS5lcXVhbHMob2JqMVtsZW5ndGhdLCBvYmoyW2xlbmd0aF0pKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqMSksXG5cdFx0XHRcdFx0XHRsZW5ndGggPSBrZXlzLmxlbmd0aDtcblx0XHRcdFx0XHRpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhvYmoyKS5sZW5ndGgpXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRcdFx0XHR2YXIga2V5ID0ga2V5c1tsZW5ndGhdO1xuXHRcdFx0XHRcdFx0aWYgKCEob2JqMi5oYXNPd25Qcm9wZXJ0eShrZXkpXG5cdFx0XHRcdFx0XHRcdFx0JiYgQmFzZS5lcXVhbHMob2JqMVtrZXldLCBvYmoyW2tleV0pKSlcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXG5cdFx0cmVhZDogZnVuY3Rpb24obGlzdCwgc3RhcnQsIG9wdGlvbnMsIGxlbmd0aCkge1xuXHRcdFx0aWYgKHRoaXMgPT09IEJhc2UpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gdGhpcy5wZWVrKGxpc3QsIHN0YXJ0KTtcblx0XHRcdFx0bGlzdC5fX2luZGV4Kys7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH1cblx0XHRcdHZhciBwcm90byA9IHRoaXMucHJvdG90eXBlLFxuXHRcdFx0XHRyZWFkSW5kZXggPSBwcm90by5fcmVhZEluZGV4LFxuXHRcdFx0XHRpbmRleCA9IHN0YXJ0IHx8IHJlYWRJbmRleCAmJiBsaXN0Ll9faW5kZXggfHwgMDtcblx0XHRcdGlmICghbGVuZ3RoKVxuXHRcdFx0XHRsZW5ndGggPSBsaXN0Lmxlbmd0aCAtIGluZGV4O1xuXHRcdFx0dmFyIG9iaiA9IGxpc3RbaW5kZXhdO1xuXHRcdFx0aWYgKG9iaiBpbnN0YW5jZW9mIHRoaXNcblx0XHRcdFx0fHwgb3B0aW9ucyAmJiBvcHRpb25zLnJlYWROdWxsICYmIG9iaiA9PSBudWxsICYmIGxlbmd0aCA8PSAxKSB7XG5cdFx0XHRcdGlmIChyZWFkSW5kZXgpXG5cdFx0XHRcdFx0bGlzdC5fX2luZGV4ID0gaW5kZXggKyAxO1xuXHRcdFx0XHRyZXR1cm4gb2JqICYmIG9wdGlvbnMgJiYgb3B0aW9ucy5jbG9uZSA/IG9iai5jbG9uZSgpIDogb2JqO1xuXHRcdFx0fVxuXHRcdFx0b2JqID0gQmFzZS5jcmVhdGUodGhpcy5wcm90b3R5cGUpO1xuXHRcdFx0aWYgKHJlYWRJbmRleClcblx0XHRcdFx0b2JqLl9fcmVhZCA9IHRydWU7XG5cdFx0XHRvYmogPSBvYmouaW5pdGlhbGl6ZS5hcHBseShvYmosIGluZGV4ID4gMCB8fCBsZW5ndGggPCBsaXN0Lmxlbmd0aFxuXHRcdFx0XHQ/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QsIGluZGV4LCBpbmRleCArIGxlbmd0aClcblx0XHRcdFx0OiBsaXN0KSB8fCBvYmo7XG5cdFx0XHRpZiAocmVhZEluZGV4KSB7XG5cdFx0XHRcdGxpc3QuX19pbmRleCA9IGluZGV4ICsgb2JqLl9fcmVhZDtcblx0XHRcdFx0b2JqLl9fcmVhZCA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fSxcblxuXHRcdHBlZWs6IGZ1bmN0aW9uKGxpc3QsIHN0YXJ0KSB7XG5cdFx0XHRyZXR1cm4gbGlzdFtsaXN0Ll9faW5kZXggPSBzdGFydCB8fCBsaXN0Ll9faW5kZXggfHwgMF07XG5cdFx0fSxcblxuXHRcdHJlbWFpbjogZnVuY3Rpb24obGlzdCkge1xuXHRcdFx0cmV0dXJuIGxpc3QubGVuZ3RoIC0gKGxpc3QuX19pbmRleCB8fCAwKTtcblx0XHR9LFxuXG5cdFx0cmVhZEFsbDogZnVuY3Rpb24obGlzdCwgc3RhcnQsIG9wdGlvbnMpIHtcblx0XHRcdHZhciByZXMgPSBbXSxcblx0XHRcdFx0ZW50cnk7XG5cdFx0XHRmb3IgKHZhciBpID0gc3RhcnQgfHwgMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHJlcy5wdXNoKEFycmF5LmlzQXJyYXkoZW50cnkgPSBsaXN0W2ldKVxuXHRcdFx0XHRcdFx0PyB0aGlzLnJlYWQoZW50cnksIDAsIG9wdGlvbnMpXG5cdFx0XHRcdFx0XHQ6IHRoaXMucmVhZChsaXN0LCBpLCBvcHRpb25zLCAxKSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH0sXG5cblx0XHRyZWFkTmFtZWQ6IGZ1bmN0aW9uKGxpc3QsIG5hbWUsIHN0YXJ0LCBvcHRpb25zLCBsZW5ndGgpIHtcblx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuZ2V0TmFtZWQobGlzdCwgbmFtZSksXG5cdFx0XHRcdGhhc09iamVjdCA9IHZhbHVlICE9PSB1bmRlZmluZWQ7XG5cdFx0XHRpZiAoaGFzT2JqZWN0KSB7XG5cdFx0XHRcdHZhciBmaWx0ZXJlZCA9IGxpc3QuX2ZpbHRlcmVkO1xuXHRcdFx0XHRpZiAoIWZpbHRlcmVkKSB7XG5cdFx0XHRcdFx0ZmlsdGVyZWQgPSBsaXN0Ll9maWx0ZXJlZCA9IEJhc2UuY3JlYXRlKGxpc3RbMF0pO1xuXHRcdFx0XHRcdGZpbHRlcmVkLl9maWx0ZXJpbmcgPSBsaXN0WzBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZpbHRlcmVkW25hbWVdID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMucmVhZChoYXNPYmplY3QgPyBbdmFsdWVdIDogbGlzdCwgc3RhcnQsIG9wdGlvbnMsIGxlbmd0aCk7XG5cdFx0fSxcblxuXHRcdGdldE5hbWVkOiBmdW5jdGlvbihsaXN0LCBuYW1lKSB7XG5cdFx0XHR2YXIgYXJnID0gbGlzdFswXTtcblx0XHRcdGlmIChsaXN0Ll9oYXNPYmplY3QgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0bGlzdC5faGFzT2JqZWN0ID0gbGlzdC5sZW5ndGggPT09IDEgJiYgQmFzZS5pc1BsYWluT2JqZWN0KGFyZyk7XG5cdFx0XHRpZiAobGlzdC5faGFzT2JqZWN0KVxuXHRcdFx0XHRyZXR1cm4gbmFtZSA/IGFyZ1tuYW1lXSA6IGxpc3QuX2ZpbHRlcmVkIHx8IGFyZztcblx0XHR9LFxuXG5cdFx0aGFzTmFtZWQ6IGZ1bmN0aW9uKGxpc3QsIG5hbWUpIHtcblx0XHRcdHJldHVybiAhIXRoaXMuZ2V0TmFtZWQobGlzdCwgbmFtZSk7XG5cdFx0fSxcblxuXHRcdGlzUGxhaW5WYWx1ZTogZnVuY3Rpb24ob2JqLCBhc1N0cmluZykge1xuXHRcdFx0cmV0dXJuIHRoaXMuaXNQbGFpbk9iamVjdChvYmopIHx8IEFycmF5LmlzQXJyYXkob2JqKVxuXHRcdFx0XHRcdHx8IGFzU3RyaW5nICYmIHR5cGVvZiBvYmogPT09ICdzdHJpbmcnO1xuXHRcdH0sXG5cblx0XHRzZXJpYWxpemU6IGZ1bmN0aW9uKG9iaiwgb3B0aW9ucywgY29tcGFjdCwgZGljdGlvbmFyeSkge1xuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHRcdHZhciByb290ID0gIWRpY3Rpb25hcnksXG5cdFx0XHRcdHJlcztcblx0XHRcdGlmIChyb290KSB7XG5cdFx0XHRcdG9wdGlvbnMuZm9ybWF0dGVyID0gbmV3IEZvcm1hdHRlcihvcHRpb25zLnByZWNpc2lvbik7XG5cdFx0XHRcdGRpY3Rpb25hcnkgPSB7XG5cdFx0XHRcdFx0bGVuZ3RoOiAwLFxuXHRcdFx0XHRcdGRlZmluaXRpb25zOiB7fSxcblx0XHRcdFx0XHRyZWZlcmVuY2VzOiB7fSxcblx0XHRcdFx0XHRhZGQ6IGZ1bmN0aW9uKGl0ZW0sIGNyZWF0ZSkge1xuXHRcdFx0XHRcdFx0dmFyIGlkID0gJyMnICsgaXRlbS5faWQsXG5cdFx0XHRcdFx0XHRcdHJlZiA9IHRoaXMucmVmZXJlbmNlc1tpZF07XG5cdFx0XHRcdFx0XHRpZiAoIXJlZikge1xuXHRcdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCsrO1xuXHRcdFx0XHRcdFx0XHR2YXIgcmVzID0gY3JlYXRlLmNhbGwoaXRlbSksXG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGl0ZW0uX2NsYXNzO1xuXHRcdFx0XHRcdFx0XHRpZiAobmFtZSAmJiByZXNbMF0gIT09IG5hbWUpXG5cdFx0XHRcdFx0XHRcdFx0cmVzLnVuc2hpZnQobmFtZSk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuZGVmaW5pdGlvbnNbaWRdID0gcmVzO1xuXHRcdFx0XHRcdFx0XHRyZWYgPSB0aGlzLnJlZmVyZW5jZXNbaWRdID0gW2lkXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiByZWY7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0aWYgKG9iaiAmJiBvYmouX3NlcmlhbGl6ZSkge1xuXHRcdFx0XHRyZXMgPSBvYmouX3NlcmlhbGl6ZShvcHRpb25zLCBkaWN0aW9uYXJ5KTtcblx0XHRcdFx0dmFyIG5hbWUgPSBvYmouX2NsYXNzO1xuXHRcdFx0XHRpZiAobmFtZSAmJiAhY29tcGFjdCAmJiAhcmVzLl9jb21wYWN0ICYmIHJlc1swXSAhPT0gbmFtZSlcblx0XHRcdFx0XHRyZXMudW5zaGlmdChuYW1lKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG5cdFx0XHRcdHJlcyA9IFtdO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdFx0cmVzW2ldID0gQmFzZS5zZXJpYWxpemUob2JqW2ldLCBvcHRpb25zLCBjb21wYWN0LFxuXHRcdFx0XHRcdFx0XHRkaWN0aW9uYXJ5KTtcblx0XHRcdFx0aWYgKGNvbXBhY3QpXG5cdFx0XHRcdFx0cmVzLl9jb21wYWN0ID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSBpZiAoQmFzZS5pc1BsYWluT2JqZWN0KG9iaikpIHtcblx0XHRcdFx0cmVzID0ge307XG5cdFx0XHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHZhciBrZXkgPSBrZXlzW2ldO1xuXHRcdFx0XHRcdHJlc1trZXldID0gQmFzZS5zZXJpYWxpemUob2JqW2tleV0sIG9wdGlvbnMsIGNvbXBhY3QsXG5cdFx0XHRcdFx0XHRcdGRpY3Rpb25hcnkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdHJlcyA9IG9wdGlvbnMuZm9ybWF0dGVyLm51bWJlcihvYmosIG9wdGlvbnMucHJlY2lzaW9uKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlcyA9IG9iajtcblx0XHRcdH1cblx0XHRcdHJldHVybiByb290ICYmIGRpY3Rpb25hcnkubGVuZ3RoID4gMFxuXHRcdFx0XHRcdD8gW1snZGljdGlvbmFyeScsIGRpY3Rpb25hcnkuZGVmaW5pdGlvbnNdLCByZXNdXG5cdFx0XHRcdFx0OiByZXM7XG5cdFx0fSxcblxuXHRcdGRlc2VyaWFsaXplOiBmdW5jdGlvbihqc29uLCBjcmVhdGUsIF9kYXRhLCBfaXNEaWN0aW9uYXJ5KSB7XG5cdFx0XHR2YXIgcmVzID0ganNvbixcblx0XHRcdFx0aXNSb290ID0gIV9kYXRhO1xuXHRcdFx0X2RhdGEgPSBfZGF0YSB8fCB7fTtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGpzb24pKSB7XG5cdFx0XHRcdHZhciB0eXBlID0ganNvblswXSxcblx0XHRcdFx0XHRpc0RpY3Rpb25hcnkgPSB0eXBlID09PSAnZGljdGlvbmFyeSc7XG5cdFx0XHRcdGlmIChqc29uLmxlbmd0aCA9PSAxICYmIC9eIy8udGVzdCh0eXBlKSlcblx0XHRcdFx0XHRyZXR1cm4gX2RhdGEuZGljdGlvbmFyeVt0eXBlXTtcblx0XHRcdFx0dHlwZSA9IEJhc2UuZXhwb3J0c1t0eXBlXTtcblx0XHRcdFx0cmVzID0gW107XG5cdFx0XHRcdGlmIChfaXNEaWN0aW9uYXJ5KVxuXHRcdFx0XHRcdF9kYXRhLmRpY3Rpb25hcnkgPSByZXM7XG5cdFx0XHRcdGZvciAodmFyIGkgPSB0eXBlID8gMSA6IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRyZXMucHVzaChCYXNlLmRlc2VyaWFsaXplKGpzb25baV0sIGNyZWF0ZSwgX2RhdGEsXG5cdFx0XHRcdFx0XHRcdGlzRGljdGlvbmFyeSkpO1xuXHRcdFx0XHRpZiAodHlwZSkge1xuXHRcdFx0XHRcdHZhciBhcmdzID0gcmVzO1xuXHRcdFx0XHRcdGlmIChjcmVhdGUpIHtcblx0XHRcdFx0XHRcdHJlcyA9IGNyZWF0ZSh0eXBlLCBhcmdzKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzID0gQmFzZS5jcmVhdGUodHlwZS5wcm90b3R5cGUpO1xuXHRcdFx0XHRcdFx0dHlwZS5hcHBseShyZXMsIGFyZ3MpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChCYXNlLmlzUGxhaW5PYmplY3QoanNvbikpIHtcblx0XHRcdFx0cmVzID0ge307XG5cdFx0XHRcdGlmIChfaXNEaWN0aW9uYXJ5KVxuXHRcdFx0XHRcdF9kYXRhLmRpY3Rpb25hcnkgPSByZXM7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBqc29uKVxuXHRcdFx0XHRcdHJlc1trZXldID0gQmFzZS5kZXNlcmlhbGl6ZShqc29uW2tleV0sIGNyZWF0ZSwgX2RhdGEpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGlzUm9vdCAmJiBqc29uICYmIGpzb24ubGVuZ3RoICYmIGpzb25bMF1bMF0gPT09ICdkaWN0aW9uYXJ5J1xuXHRcdFx0XHRcdD8gcmVzWzFdXG5cdFx0XHRcdFx0OiByZXM7XG5cdFx0fSxcblxuXHRcdGV4cG9ydEpTT046IGZ1bmN0aW9uKG9iaiwgb3B0aW9ucykge1xuXHRcdFx0dmFyIGpzb24gPSBCYXNlLnNlcmlhbGl6ZShvYmosIG9wdGlvbnMpO1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5hc1N0cmluZyA9PT0gZmFsc2Vcblx0XHRcdFx0XHQ/IGpzb25cblx0XHRcdFx0XHQ6IEpTT04uc3RyaW5naWZ5KGpzb24pO1xuXHRcdH0sXG5cblx0XHRpbXBvcnRKU09OOiBmdW5jdGlvbihqc29uLCB0YXJnZXQpIHtcblx0XHRcdHJldHVybiBCYXNlLmRlc2VyaWFsaXplKFxuXHRcdFx0XHRcdHR5cGVvZiBqc29uID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoanNvbikgOiBqc29uLFxuXHRcdFx0XHRcdGZ1bmN0aW9uKHR5cGUsIGFyZ3MpIHtcblx0XHRcdFx0XHRcdHZhciBvYmogPSB0YXJnZXQgJiYgdGFyZ2V0LmNvbnN0cnVjdG9yID09PSB0eXBlXG5cdFx0XHRcdFx0XHRcdFx0PyB0YXJnZXRcblx0XHRcdFx0XHRcdFx0XHQ6IEJhc2UuY3JlYXRlKHR5cGUucHJvdG90eXBlKSxcblx0XHRcdFx0XHRcdFx0aXNUYXJnZXQgPSBvYmogPT09IHRhcmdldDtcblx0XHRcdFx0XHRcdGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBvYmogaW5zdGFuY2VvZiBJdGVtXG5cdFx0XHRcdFx0XHRcdFx0JiYgKGlzVGFyZ2V0IHx8ICEob2JqIGluc3RhbmNlb2YgTGF5ZXIpKSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgYXJnID0gYXJnc1swXTtcblx0XHRcdFx0XHRcdFx0aWYgKEJhc2UuaXNQbGFpbk9iamVjdChhcmcpKVxuXHRcdFx0XHRcdFx0XHRcdGFyZy5pbnNlcnQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHR5cGUuYXBwbHkob2JqLCBhcmdzKTtcblx0XHRcdFx0XHRcdGlmIChpc1RhcmdldClcblx0XHRcdFx0XHRcdFx0dGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdHNwbGljZTogZnVuY3Rpb24obGlzdCwgaXRlbXMsIGluZGV4LCByZW1vdmUpIHtcblx0XHRcdHZhciBhbW91bnQgPSBpdGVtcyAmJiBpdGVtcy5sZW5ndGgsXG5cdFx0XHRcdGFwcGVuZCA9IGluZGV4ID09PSB1bmRlZmluZWQ7XG5cdFx0XHRpbmRleCA9IGFwcGVuZCA/IGxpc3QubGVuZ3RoIDogaW5kZXg7XG5cdFx0XHRpZiAoaW5kZXggPiBsaXN0Lmxlbmd0aClcblx0XHRcdFx0aW5kZXggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspXG5cdFx0XHRcdGl0ZW1zW2ldLl9pbmRleCA9IGluZGV4ICsgaTtcblx0XHRcdGlmIChhcHBlbmQpIHtcblx0XHRcdFx0bGlzdC5wdXNoLmFwcGx5KGxpc3QsIGl0ZW1zKTtcblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGFyZ3MgPSBbaW5kZXgsIHJlbW92ZV07XG5cdFx0XHRcdGlmIChpdGVtcylcblx0XHRcdFx0XHRhcmdzLnB1c2guYXBwbHkoYXJncywgaXRlbXMpO1xuXHRcdFx0XHR2YXIgcmVtb3ZlZCA9IGxpc3Quc3BsaWNlLmFwcGx5KGxpc3QsIGFyZ3MpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHJlbW92ZWQubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdHJlbW92ZWRbaV0uX2luZGV4ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gaW5kZXggKyBhbW91bnQsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRsaXN0W2ldLl9pbmRleCA9IGk7XG5cdFx0XHRcdHJldHVybiByZW1vdmVkO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRjYXBpdGFsaXplOiBmdW5jdGlvbihzdHIpIHtcblx0XHRcdHJldHVybiBzdHIucmVwbGFjZSgvXFxiW2Etel0vZywgZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRcdFx0cmV0dXJuIG1hdGNoLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0Y2FtZWxpemU6IGZ1bmN0aW9uKHN0cikge1xuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC8tKC4pL2csIGZ1bmN0aW9uKGFsbCwgY2hyKSB7XG5cdFx0XHRcdHJldHVybiBjaHIudG9VcHBlckNhc2UoKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRoeXBoZW5hdGU6IGZ1bmN0aW9uKHN0cikge1xuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBFbWl0dGVyID0ge1xuXHRvbjogZnVuY3Rpb24odHlwZSwgZnVuYykge1xuXHRcdGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdEJhc2UuZWFjaCh0eXBlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0XHRcdHRoaXMub24oa2V5LCB2YWx1ZSk7XG5cdFx0XHR9LCB0aGlzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHR5cGVzID0gdGhpcy5fZXZlbnRUeXBlcyxcblx0XHRcdFx0ZW50cnkgPSB0eXBlcyAmJiB0eXBlc1t0eXBlXSxcblx0XHRcdFx0aGFuZGxlcnMgPSB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cdFx0XHRoYW5kbGVycyA9IGhhbmRsZXJzW3R5cGVdID0gaGFuZGxlcnNbdHlwZV0gfHwgW107XG5cdFx0XHRpZiAoaGFuZGxlcnMuaW5kZXhPZihmdW5jKSA9PT0gLTEpIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaChmdW5jKTtcblx0XHRcdFx0aWYgKGVudHJ5ICYmIGVudHJ5Lmluc3RhbGwgJiYgaGFuZGxlcnMubGVuZ3RoID09IDEpXG5cdFx0XHRcdFx0ZW50cnkuaW5zdGFsbC5jYWxsKHRoaXMsIHR5cGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRvZmY6IGZ1bmN0aW9uKHR5cGUsIGZ1bmMpIHtcblx0XHRpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRCYXNlLmVhY2godHlwZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHRcdFx0XHR0aGlzLm9mZihrZXksIHZhbHVlKTtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgdHlwZXMgPSB0aGlzLl9ldmVudFR5cGVzLFxuXHRcdFx0ZW50cnkgPSB0eXBlcyAmJiB0eXBlc1t0eXBlXSxcblx0XHRcdGhhbmRsZXJzID0gdGhpcy5fY2FsbGJhY2tzICYmIHRoaXMuX2NhbGxiYWNrc1t0eXBlXSxcblx0XHRcdGluZGV4O1xuXHRcdGlmIChoYW5kbGVycykge1xuXHRcdFx0aWYgKCFmdW5jIHx8IChpbmRleCA9IGhhbmRsZXJzLmluZGV4T2YoZnVuYykpICE9PSAtMVxuXHRcdFx0XHRcdCYmIGhhbmRsZXJzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRpZiAoZW50cnkgJiYgZW50cnkudW5pbnN0YWxsKVxuXHRcdFx0XHRcdGVudHJ5LnVuaW5zdGFsbC5jYWxsKHRoaXMsIHR5cGUpO1xuXHRcdFx0XHRkZWxldGUgdGhpcy5fY2FsbGJhY2tzW3R5cGVdO1xuXHRcdFx0fSBlbHNlIGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0b25jZTogZnVuY3Rpb24odHlwZSwgZnVuYykge1xuXHRcdHJldHVybiB0aGlzLm9uKHR5cGUsIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy5vZmYodHlwZSwgZnVuYyk7XG5cdFx0fSk7XG5cdH0sXG5cblx0ZW1pdDogZnVuY3Rpb24odHlwZSwgZXZlbnQpIHtcblx0XHR2YXIgaGFuZGxlcnMgPSB0aGlzLl9jYWxsYmFja3MgJiYgdGhpcy5fY2FsbGJhY2tzW3R5cGVdO1xuXHRcdGlmICghaGFuZGxlcnMpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0dmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cdFx0aGFuZGxlcnMgPSBoYW5kbGVycy5zbGljZSgpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAoaGFuZGxlcnNbaV0uYXBwbHkodGhpcywgYXJncykgPT09IGZhbHNlKSB7XG5cdFx0XHRcdGlmIChldmVudCAmJiBldmVudC5zdG9wKVxuXHRcdFx0XHRcdGV2ZW50LnN0b3AoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdHJlc3BvbmRzOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0cmV0dXJuICEhKHRoaXMuX2NhbGxiYWNrcyAmJiB0aGlzLl9jYWxsYmFja3NbdHlwZV0pO1xuXHR9LFxuXG5cdGF0dGFjaDogJyNvbicsXG5cdGRldGFjaDogJyNvZmYnLFxuXHRmaXJlOiAnI2VtaXQnLFxuXG5cdF9pbnN0YWxsRXZlbnRzOiBmdW5jdGlvbihpbnN0YWxsKSB7XG5cdFx0dmFyIGhhbmRsZXJzID0gdGhpcy5fY2FsbGJhY2tzLFxuXHRcdFx0a2V5ID0gaW5zdGFsbCA/ICdpbnN0YWxsJyA6ICd1bmluc3RhbGwnO1xuXHRcdGZvciAodmFyIHR5cGUgaW4gaGFuZGxlcnMpIHtcblx0XHRcdGlmIChoYW5kbGVyc1t0eXBlXS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHZhciB0eXBlcyA9IHRoaXMuX2V2ZW50VHlwZXMsXG5cdFx0XHRcdFx0ZW50cnkgPSB0eXBlcyAmJiB0eXBlc1t0eXBlXSxcblx0XHRcdFx0XHRmdW5jID0gZW50cnkgJiYgZW50cnlba2V5XTtcblx0XHRcdFx0aWYgKGZ1bmMpXG5cdFx0XHRcdFx0ZnVuYy5jYWxsKHRoaXMsIHR5cGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0aW5qZWN0OiBmdW5jdGlvbiBpbmplY3Qoc3JjKSB7XG5cdFx0XHR2YXIgZXZlbnRzID0gc3JjLl9ldmVudHM7XG5cdFx0XHRpZiAoZXZlbnRzKSB7XG5cdFx0XHRcdHZhciB0eXBlcyA9IHt9O1xuXHRcdFx0XHRCYXNlLmVhY2goZXZlbnRzLCBmdW5jdGlvbihlbnRyeSwga2V5KSB7XG5cdFx0XHRcdFx0dmFyIGlzU3RyaW5nID0gdHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJyxcblx0XHRcdFx0XHRcdG5hbWUgPSBpc1N0cmluZyA/IGVudHJ5IDoga2V5LFxuXHRcdFx0XHRcdFx0cGFydCA9IEJhc2UuY2FwaXRhbGl6ZShuYW1lKSxcblx0XHRcdFx0XHRcdHR5cGUgPSBuYW1lLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdHR5cGVzW3R5cGVdID0gaXNTdHJpbmcgPyB7fSA6IGVudHJ5O1xuXHRcdFx0XHRcdG5hbWUgPSAnXycgKyBuYW1lO1xuXHRcdFx0XHRcdHNyY1snZ2V0JyArIHBhcnRdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpc1tuYW1lXTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHNyY1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24oZnVuYykge1xuXHRcdFx0XHRcdFx0dmFyIHByZXYgPSB0aGlzW25hbWVdO1xuXHRcdFx0XHRcdFx0aWYgKHByZXYpXG5cdFx0XHRcdFx0XHRcdHRoaXMub2ZmKHR5cGUsIHByZXYpO1xuXHRcdFx0XHRcdFx0aWYgKGZ1bmMpXG5cdFx0XHRcdFx0XHRcdHRoaXMub24odHlwZSwgZnVuYyk7XG5cdFx0XHRcdFx0XHR0aGlzW25hbWVdID0gZnVuYztcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0c3JjLl9ldmVudFR5cGVzID0gdHlwZXM7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaW5qZWN0LmJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9XG5cdH1cbn07XG5cbnZhciBQYXBlclNjb3BlID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQYXBlclNjb3BlJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQYXBlclNjb3BlKCkge1xuXHRcdHBhcGVyID0gdGhpcztcblx0XHR0aGlzLnNldHRpbmdzID0gbmV3IEJhc2Uoe1xuXHRcdFx0YXBwbHlNYXRyaXg6IHRydWUsXG5cdFx0XHRoYW5kbGVTaXplOiA0LFxuXHRcdFx0aGl0VG9sZXJhbmNlOiAwXG5cdFx0fSk7XG5cdFx0dGhpcy5wcm9qZWN0ID0gbnVsbDtcblx0XHR0aGlzLnByb2plY3RzID0gW107XG5cdFx0dGhpcy50b29scyA9IFtdO1xuXHRcdHRoaXMucGFsZXR0ZXMgPSBbXTtcblx0XHR0aGlzLl9pZCA9IFBhcGVyU2NvcGUuX2lkKys7XG5cdFx0UGFwZXJTY29wZS5fc2NvcGVzW3RoaXMuX2lkXSA9IHRoaXM7XG5cdFx0dmFyIHByb3RvID0gUGFwZXJTY29wZS5wcm90b3R5cGU7XG5cdFx0aWYgKCF0aGlzLnN1cHBvcnQpIHtcblx0XHRcdHZhciBjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KDEsIDEpO1xuXHRcdFx0cHJvdG8uc3VwcG9ydCA9IHtcblx0XHRcdFx0bmF0aXZlRGFzaDogJ3NldExpbmVEYXNoJyBpbiBjdHggfHwgJ21vekRhc2gnIGluIGN0eCxcblx0XHRcdFx0bmF0aXZlQmxlbmRNb2RlczogQmxlbmRNb2RlLm5hdGl2ZU1vZGVzXG5cdFx0XHR9O1xuXHRcdFx0Q2FudmFzUHJvdmlkZXIucmVsZWFzZShjdHgpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5icm93c2VyKSB7XG5cdFx0XHR2YXIgYWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdHBsYXRmb3JtID0gKC8od2luKS8uZXhlYyhhZ2VudClcblx0XHRcdFx0XHRcdHx8IC8obWFjKS8uZXhlYyhhZ2VudClcblx0XHRcdFx0XHRcdHx8IC8obGludXgpLy5leGVjKGFnZW50KVxuXHRcdFx0XHRcdFx0fHwgW10pWzBdLFxuXHRcdFx0XHRicm93c2VyID0gcHJvdG8uYnJvd3NlciA9IHsgcGxhdGZvcm06IHBsYXRmb3JtIH07XG5cdFx0XHRpZiAocGxhdGZvcm0pXG5cdFx0XHRcdGJyb3dzZXJbcGxhdGZvcm1dID0gdHJ1ZTtcblx0XHRcdGFnZW50LnJlcGxhY2UoXG5cdFx0XHRcdC8ob3BlcmF8Y2hyb21lfHNhZmFyaXx3ZWJraXR8ZmlyZWZveHxtc2llfHRyaWRlbnR8YXRvbSlcXC8/XFxzKihbLlxcZF0rKSg/Oi4qdmVyc2lvblxcLyhbLlxcZF0rKSk/KD86LipydlxcOihbLlxcZF0rKSk/L2csXG5cdFx0XHRcdGZ1bmN0aW9uKGFsbCwgbiwgdjEsIHYyLCBydikge1xuXHRcdFx0XHRcdGlmICghYnJvd3Nlci5jaHJvbWUpIHtcblx0XHRcdFx0XHRcdHZhciB2ID0gbiA9PT0gJ29wZXJhJyA/IHYyIDogdjE7XG5cdFx0XHRcdFx0XHRpZiAobiA9PT0gJ3RyaWRlbnQnKSB7XG5cdFx0XHRcdFx0XHRcdHYgPSBydjtcblx0XHRcdFx0XHRcdFx0biA9ICdtc2llJztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyb3dzZXIudmVyc2lvbiA9IHY7XG5cdFx0XHRcdFx0XHRicm93c2VyLnZlcnNpb25OdW1iZXIgPSBwYXJzZUZsb2F0KHYpO1xuXHRcdFx0XHRcdFx0YnJvd3Nlci5uYW1lID0gbjtcblx0XHRcdFx0XHRcdGJyb3dzZXJbbl0gPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHRcdGlmIChicm93c2VyLmNocm9tZSlcblx0XHRcdFx0ZGVsZXRlIGJyb3dzZXIud2Via2l0O1xuXHRcdFx0aWYgKGJyb3dzZXIuYXRvbSlcblx0XHRcdFx0ZGVsZXRlIGJyb3dzZXIuY2hyb21lO1xuXHRcdH1cblx0fSxcblxuXHR2ZXJzaW9uOiAnMC45LjI0JyxcblxuXHRnZXRWaWV3OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0ICYmIHRoaXMucHJvamVjdC5nZXRWaWV3KCk7XG5cdH0sXG5cblx0Z2V0UGFwZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGV4ZWN1dGU6IGZ1bmN0aW9uKGNvZGUsIHVybCwgb3B0aW9ucykge1xuXHRcdHBhcGVyLlBhcGVyU2NyaXB0LmV4ZWN1dGUoY29kZSwgdGhpcywgdXJsLCBvcHRpb25zKTtcblx0XHRWaWV3LnVwZGF0ZUZvY3VzKCk7XG5cdH0sXG5cblx0aW5zdGFsbDogZnVuY3Rpb24oc2NvcGUpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0QmFzZS5lYWNoKFsncHJvamVjdCcsICd2aWV3JywgJ3Rvb2wnXSwgZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRCYXNlLmRlZmluZShzY29wZSwga2V5LCB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhhdFtrZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcylcblx0XHRcdGlmICghL15fLy50ZXN0KGtleSkgJiYgdGhpc1trZXldKVxuXHRcdFx0XHRzY29wZVtrZXldID0gdGhpc1trZXldO1xuXHR9LFxuXG5cdHNldHVwOiBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0cGFwZXIgPSB0aGlzO1xuXHRcdHRoaXMucHJvamVjdCA9IG5ldyBQcm9qZWN0KGVsZW1lbnQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcblx0XHRwYXBlciA9IHRoaXM7XG5cdH0sXG5cblx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSB0aGlzLnByb2plY3RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuXHRcdFx0dGhpcy5wcm9qZWN0c1tpXS5yZW1vdmUoKTtcblx0XHRmb3IgKHZhciBpID0gdGhpcy50b29scy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcblx0XHRcdHRoaXMudG9vbHNbaV0ucmVtb3ZlKCk7XG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMucGFsZXR0ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG5cdFx0XHR0aGlzLnBhbGV0dGVzW2ldLnJlbW92ZSgpO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5jbGVhcigpO1xuXHRcdGRlbGV0ZSBQYXBlclNjb3BlLl9zY29wZXNbdGhpcy5faWRdO1xuXHR9LFxuXG5cdHN0YXRpY3M6IG5ldyBmdW5jdGlvbigpIHtcblx0XHRmdW5jdGlvbiBoYW5kbGVBdHRyaWJ1dGUobmFtZSkge1xuXHRcdFx0bmFtZSArPSAnQXR0cmlidXRlJztcblx0XHRcdHJldHVybiBmdW5jdGlvbihlbCwgYXR0cikge1xuXHRcdFx0XHRyZXR1cm4gZWxbbmFtZV0oYXR0cikgfHwgZWxbbmFtZV0oJ2RhdGEtcGFwZXItJyArIGF0dHIpO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0X3Njb3Blczoge30sXG5cdFx0XHRfaWQ6IDAsXG5cblx0XHRcdGdldDogZnVuY3Rpb24oaWQpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3Njb3Blc1tpZF0gfHwgbnVsbDtcblx0XHRcdH0sXG5cblx0XHRcdGdldEF0dHJpYnV0ZTogaGFuZGxlQXR0cmlidXRlKCdnZXQnKSxcblx0XHRcdGhhc0F0dHJpYnV0ZTogaGFuZGxlQXR0cmlidXRlKCdoYXMnKVxuXHRcdH07XG5cdH1cbn0pO1xuXG52YXIgUGFwZXJTY29wZUl0ZW0gPSBCYXNlLmV4dGVuZChFbWl0dGVyLCB7XG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oYWN0aXZhdGUpIHtcblx0XHR0aGlzLl9zY29wZSA9IHBhcGVyO1xuXHRcdHRoaXMuX2luZGV4ID0gdGhpcy5fc2NvcGVbdGhpcy5fbGlzdF0ucHVzaCh0aGlzKSAtIDE7XG5cdFx0aWYgKGFjdGl2YXRlIHx8ICF0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdKVxuXHRcdFx0dGhpcy5hY3RpdmF0ZSgpO1xuXHR9LFxuXG5cdGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX3Njb3BlKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdHZhciBwcmV2ID0gdGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXTtcblx0XHRpZiAocHJldiAmJiBwcmV2ICE9PSB0aGlzKVxuXHRcdFx0cHJldi5lbWl0KCdkZWFjdGl2YXRlJyk7XG5cdFx0dGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXSA9IHRoaXM7XG5cdFx0dGhpcy5lbWl0KCdhY3RpdmF0ZScsIHByZXYpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdGlzQWN0aXZlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXSA9PT0gdGhpcztcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9pbmRleCA9PSBudWxsKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdEJhc2Uuc3BsaWNlKHRoaXMuX3Njb3BlW3RoaXMuX2xpc3RdLCBudWxsLCB0aGlzLl9pbmRleCwgMSk7XG5cdFx0aWYgKHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0gPT0gdGhpcylcblx0XHRcdHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0gPSBudWxsO1xuXHRcdHRoaXMuX3Njb3BlID0gbnVsbDtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSk7XG5cbnZhciBGb3JtYXR0ZXIgPSBCYXNlLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKHByZWNpc2lvbikge1xuXHRcdHRoaXMucHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDU7XG5cdFx0dGhpcy5tdWx0aXBsaWVyID0gTWF0aC5wb3coMTAsIHRoaXMucHJlY2lzaW9uKTtcblx0fSxcblxuXHRudW1iZXI6IGZ1bmN0aW9uKHZhbCkge1xuXHRcdHJldHVybiBNYXRoLnJvdW5kKHZhbCAqIHRoaXMubXVsdGlwbGllcikgLyB0aGlzLm11bHRpcGxpZXI7XG5cdH0sXG5cblx0cGFpcjogZnVuY3Rpb24odmFsMSwgdmFsMiwgc2VwYXJhdG9yKSB7XG5cdFx0cmV0dXJuIHRoaXMubnVtYmVyKHZhbDEpICsgKHNlcGFyYXRvciB8fCAnLCcpICsgdGhpcy5udW1iZXIodmFsMik7XG5cdH0sXG5cblx0cG9pbnQ6IGZ1bmN0aW9uKHZhbCwgc2VwYXJhdG9yKSB7XG5cdFx0cmV0dXJuIHRoaXMubnVtYmVyKHZhbC54KSArIChzZXBhcmF0b3IgfHwgJywnKSArIHRoaXMubnVtYmVyKHZhbC55KTtcblx0fSxcblxuXHRzaXplOiBmdW5jdGlvbih2YWwsIHNlcGFyYXRvcikge1xuXHRcdHJldHVybiB0aGlzLm51bWJlcih2YWwud2lkdGgpICsgKHNlcGFyYXRvciB8fCAnLCcpXG5cdFx0XHRcdCsgdGhpcy5udW1iZXIodmFsLmhlaWdodCk7XG5cdH0sXG5cblx0cmVjdGFuZ2xlOiBmdW5jdGlvbih2YWwsIHNlcGFyYXRvcikge1xuXHRcdHJldHVybiB0aGlzLnBvaW50KHZhbCwgc2VwYXJhdG9yKSArIChzZXBhcmF0b3IgfHwgJywnKVxuXHRcdFx0XHQrIHRoaXMuc2l6ZSh2YWwsIHNlcGFyYXRvcik7XG5cdH1cbn0pO1xuXG5Gb3JtYXR0ZXIuaW5zdGFuY2UgPSBuZXcgRm9ybWF0dGVyKCk7XG5cbnZhciBOdW1lcmljYWwgPSBuZXcgZnVuY3Rpb24oKSB7XG5cblx0dmFyIGFic2Npc3NhcyA9IFtcblx0XHRbICAwLjU3NzM1MDI2OTE4OTYyNTc2NDUwOTE0ODhdLFxuXHRcdFswLDAuNzc0NTk2NjY5MjQxNDgzMzc3MDM1ODUzMV0sXG5cdFx0WyAgMC4zMzk5ODEwNDM1ODQ4NTYyNjQ4MDI2NjU4LDAuODYxMTM2MzExNTk0MDUyNTc1MjIzOTQ2NV0sXG5cdFx0WzAsMC41Mzg0NjkzMTAxMDU2ODMwOTEwMzYzMTQ0LDAuOTA2MTc5ODQ1OTM4NjYzOTkyNzk3NjI2OV0sXG5cdFx0WyAgMC4yMzg2MTkxODYwODMxOTY5MDg2MzA1MDE3LDAuNjYxMjA5Mzg2NDY2MjY0NTEzNjYxMzk5NiwwLjkzMjQ2OTUxNDIwMzE1MjAyNzgxMjMwMTZdLFxuXHRcdFswLDAuNDA1ODQ1MTUxMzc3Mzk3MTY2OTA2NjA2NCwwLjc0MTUzMTE4NTU5OTM5NDQzOTg2Mzg2NDgsMC45NDkxMDc5MTIzNDI3NTg1MjQ1MjYxODk3XSxcblx0XHRbICAwLjE4MzQzNDY0MjQ5NTY0OTgwNDkzOTQ3NjEsMC41MjU1MzI0MDk5MTYzMjg5ODU4MTc3MzkwLDAuNzk2NjY2NDc3NDEzNjI2NzM5NTkxNTUzOSwwLjk2MDI4OTg1NjQ5NzUzNjIzMTY4MzU2MDldLFxuXHRcdFswLDAuMzI0MjUzNDIzNDAzODA4OTI5MDM4NTM4MCwwLjYxMzM3MTQzMjcwMDU5MDM5NzMwODcwMjAsMC44MzYwMzExMDczMjY2MzU3OTQyOTk0Mjk4LDAuOTY4MTYwMjM5NTA3NjI2MDg5ODM1NTc2Ml0sXG5cdFx0WyAgMC4xNDg4NzQzMzg5ODE2MzEyMTA4ODQ4MjYwLDAuNDMzMzk1Mzk0MTI5MjQ3MTkwNzk5MjY1OSwwLjY3OTQwOTU2ODI5OTAyNDQwNjIzNDMyNzQsMC44NjUwNjMzNjY2ODg5ODQ1MTA3MzIwOTY3LDAuOTczOTA2NTI4NTE3MTcxNzIwMDc3OTY0MF0sXG5cdFx0WzAsMC4yNjk1NDMxNTU5NTIzNDQ5NzIzMzE1MzIwLDAuNTE5MDk2MTI5MjA2ODExODE1OTI1NzI1NywwLjczMDE1MjAwNTU3NDA0OTMyNDA5MzQxNjMsMC44ODcwNjI1OTk3NjgwOTUyOTkwNzUxNTc4LDAuOTc4MjI4NjU4MTQ2MDU2OTkyODAzOTM4MF0sXG5cdFx0WyAgMC4xMjUyMzM0MDg1MTE0Njg5MTU0NzI0NDE0LDAuMzY3ODMxNDk4OTk4MTgwMTkzNzUyNjkxNSwwLjU4NzMxNzk1NDI4NjYxNzQ0NzI5NjcwMjQsMC43Njk5MDI2NzQxOTQzMDQ2ODcwMzY4OTM4LDAuOTA0MTE3MjU2MzcwNDc0ODU2Njc4NDY1OSwwLjk4MTU2MDYzNDI0NjcxOTI1MDY5MDU0OTFdLFxuXHRcdFswLDAuMjMwNDU4MzE1OTU1MTM0Nzk0MDY1NTI4MSwwLjQ0ODQ5Mjc1MTAzNjQ0Njg1Mjg3NzkxMjksMC42NDIzNDkzMzk0NDAzNDAyMjA2NDM5ODQ2LDAuODAxNTc4MDkwNzMzMzA5OTEyNzk0MjA2NSwwLjkxNzU5ODM5OTIyMjk3Nzk2NTIwNjU0NzgsMC45ODQxODMwNTQ3MTg1ODgxNDk0NzI4Mjk0XSxcblx0XHRbICAwLjEwODA1NDk0ODcwNzM0MzY2MjA2NjI0NDcsMC4zMTkxMTIzNjg5Mjc4ODk3NjA0MzU2NzE4LDAuNTE1MjQ4NjM2MzU4MTU0MDkxOTY1MjkwNywwLjY4NzI5MjkwNDgxMTY4NTQ3MDE0ODAxOTgsMC44MjcyMDEzMTUwNjk3NjQ5OTMxODk3OTQ3LDAuOTI4NDM0ODgzNjYzNTczNTE3MzM2MzkxMSwwLjk4NjI4MzgwODY5NjgxMjMzODg0MTU5NzNdLFxuXHRcdFswLDAuMjAxMTk0MDkzOTk3NDM0NTIyMzAwNjI4MywwLjM5NDE1MTM0NzA3NzU2MzM2OTg5NzIwNzQsMC41NzA5NzIxNzI2MDg1Mzg4NDc1MzcyMjY3LDAuNzI0NDE3NzMxMzYwMTcwMDQ3NDE2MTg2MSwwLjg0ODIwNjU4MzQxMDQyNzIxNjIwMDY0ODMsMC45MzcyNzMzOTI0MDA3MDU5MDQzMDc3NTg5LDAuOTg3OTkyNTE4MDIwNDg1NDI4NDg5NTY1N10sXG5cdFx0WyAgMC4wOTUwMTI1MDk4Mzc2Mzc0NDAxODUzMTkzLDAuMjgxNjAzNTUwNzc5MjU4OTEzMjMwNDYwNSwwLjQ1ODAxNjc3NzY1NzIyNzM4NjM0MjQxOTQsMC42MTc4NzYyNDQ0MDI2NDM3NDg0NDY2NzE4LDAuNzU1NDA0NDA4MzU1MDAzMDMzODk1MTAxMiwwLjg2NTYzMTIwMjM4NzgzMTc0Mzg4MDQ2NzksMC45NDQ1NzUwMjMwNzMyMzI1NzYwNzc5ODg0LDAuOTg5NDAwOTM0OTkxNjQ5OTMyNTk2MTU0Ml1cblx0XTtcblxuXHR2YXIgd2VpZ2h0cyA9IFtcblx0XHRbMV0sXG5cdFx0WzAuODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4OSwwLjU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTZdLFxuXHRcdFswLjY1MjE0NTE1NDg2MjU0NjE0MjYyNjkzNjEsMC4zNDc4NTQ4NDUxMzc0NTM4NTczNzMwNjM5XSxcblx0XHRbMC41Njg4ODg4ODg4ODg4ODg4ODg4ODg4ODg5LDAuNDc4NjI4NjcwNDk5MzY2NDY4MDQxMjkxNSwwLjIzNjkyNjg4NTA1NjE4OTA4NzUxNDI2NDBdLFxuXHRcdFswLjQ2NzkxMzkzNDU3MjY5MTA0NzM4OTg3MDMsMC4zNjA3NjE1NzMwNDgxMzg2MDc1Njk4MzM1LDAuMTcxMzI0NDkyMzc5MTcwMzQ1MDQwMjk2MV0sXG5cdFx0WzAuNDE3OTU5MTgzNjczNDY5Mzg3NzU1MTAyMCwwLjM4MTgzMDA1MDUwNTExODk0NDk1MDM2OTgsMC4yNzk3MDUzOTE0ODkyNzY2Njc5MDE0Njc4LDAuMTI5NDg0OTY2MTY4ODY5NjkzMjcwNjExNF0sXG5cdFx0WzAuMzYyNjgzNzgzMzc4MzYxOTgyOTY1MTUwNCwwLjMxMzcwNjY0NTg3Nzg4NzI4NzMzNzk2MjIsMC4yMjIzODEwMzQ0NTMzNzQ0NzA1NDQzNTYwLDAuMTAxMjI4NTM2MjkwMzc2MjU5MTUyNTMxNF0sXG5cdFx0WzAuMzMwMjM5MzU1MDAxMjU5NzYzMTY0NTI1MSwwLjMxMjM0NzA3NzA0MDAwMjg0MDA2ODYzMDQsMC4yNjA2MTA2OTY0MDI5MzU0NjIzMTg3NDI5LDAuMTgwNjQ4MTYwNjk0ODU3NDA0MDU4NDcyMCwwLjA4MTI3NDM4ODM2MTU3NDQxMTk3MTg5MjJdLFxuXHRcdFswLjI5NTUyNDIyNDcxNDc1Mjg3MDE3Mzg5MzAsMC4yNjkyNjY3MTkzMDk5OTYzNTUwOTEyMjY5LDAuMjE5MDg2MzYyNTE1OTgyMDQzOTk1NTM0OSwwLjE0OTQ1MTM0OTE1MDU4MDU5MzE0NTc3NjMsMC4wNjY2NzEzNDQzMDg2ODgxMzc1OTM1Njg4XSxcblx0XHRbMC4yNzI5MjUwODY3Nzc5MDA2MzA3MTQ0ODM1LDAuMjYyODA0NTQ0NTEwMjQ2NjYyMTgwNjg4OSwwLjIzMzE5Mzc2NDU5MTk5MDQ3OTkxODUyMzcsMC4xODYyOTAyMTA5Mjc3MzQyNTE0MjYwOTc2LDAuMTI1NTgwMzY5NDY0OTA0NjI0NjM0Njk0MywwLjA1NTY2ODU2NzExNjE3MzY2NjQ4Mjc1MzddLFxuXHRcdFswLjI0OTE0NzA0NTgxMzQwMjc4NTAwMDU2MjQsMC4yMzM0OTI1MzY1MzgzNTQ4MDg3NjA4NDk5LDAuMjAzMTY3NDI2NzIzMDY1OTIxNzQ5MDY0NSwwLjE2MDA3ODMyODU0MzM0NjIyNjMzNDY1MjUsMC4xMDY5MzkzMjU5OTUzMTg0MzA5NjAyNTQ3LDAuMDQ3MTc1MzM2Mzg2NTExODI3MTk0NjE2MF0sXG5cdFx0WzAuMjMyNTUxNTUzMjMwODczOTEwMTk0NTg5NSwwLjIyNjI4MzE4MDI2Mjg5NzIzODQxMjA5MDIsMC4yMDc4MTYwNDc1MzY4ODg1MDIzMTI1MjMyLDAuMTc4MTQ1OTgwNzYxOTQ1NzM4MjgwMDQ2NywwLjEzODg3MzUxMDIxOTc4NzIzODQ2MzYwMTgsMC4wOTIxMjE0OTk4Mzc3Mjg0NDc5MTQ0MjE4LDAuMDQwNDg0MDA0NzY1MzE1ODc5NTIwMDIxNl0sXG5cdFx0WzAuMjE1MjYzODUzNDYzMTU3NzkwMTk1ODc2NCwwLjIwNTE5ODQ2MzcyMTI5NTYwMzk2NTkyNDEsMC4xODU1MzgzOTc0Nzc5Mzc4MTM3NDE3MTY2LDAuMTU3MjAzMTY3MTU4MTkzNTM0NTY5NjAxOSwwLjEyMTUxODU3MDY4NzkwMzE4NDY4OTQxNDgsMC4wODAxNTgwODcxNTk3NjAyMDk4MDU2MzMzLDAuMDM1MTE5NDYwMzMxNzUxODYzMDMxODMyOV0sXG5cdFx0WzAuMjAyNTc4MjQxOTI1NTYxMjcyODgwNjIwMiwwLjE5ODQzMTQ4NTMyNzExMTU3NjQ1NjExODMsMC4xODYxNjEwMDAwMTU1NjIyMTEwMjY4MDA2LDAuMTY2MjY5MjA1ODE2OTkzOTMzNTUzMjAwOSwwLjEzOTU3MDY3NzkyNjE1NDMxNDQ0NzgwNDgsMC4xMDcxNTkyMjA0NjcxNzE5MzUwMTE4Njk1LDAuMDcwMzY2MDQ3NDg4MTA4MTI0NzA5MjY3NCwwLjAzMDc1MzI0MTk5NjExNzI2ODM1NDYyODRdLFxuXHRcdFswLjE4OTQ1MDYxMDQ1NTA2ODQ5NjI4NTM5NjcsMC4xODI2MDM0MTUwNDQ5MjM1ODg4NjY3NjM3LDAuMTY5MTU2NTE5Mzk1MDAyNTM4MTg5MzEyMSwwLjE0OTU5NTk4ODgxNjU3NjczMjA4MTUwMTcsMC4xMjQ2Mjg5NzEyNTU1MzM4NzIwNTI0NzYzLDAuMDk1MTU4NTExNjgyNDkyNzg0ODA5OTI1MSwwLjA2MjI1MzUyMzkzODY0Nzg5Mjg2Mjg0MzgsMC4wMjcxNTI0NTk0MTE3NTQwOTQ4NTE3ODA2XVxuXHRdO1xuXG5cdHZhciBhYnMgPSBNYXRoLmFicyxcblx0XHRzcXJ0ID0gTWF0aC5zcXJ0LFxuXHRcdHBvdyA9IE1hdGgucG93LFxuXHRcdFRPTEVSQU5DRSA9IDFlLTYsXG5cdFx0RVBTSUxPTiA9IDFlLTEyLFxuXHRcdE1BQ0hJTkVfRVBTSUxPTiA9IDEuMTJlLTE2O1xuXG5cdHJldHVybiB7XG5cdFx0VE9MRVJBTkNFOiBUT0xFUkFOQ0UsXG5cdFx0RVBTSUxPTjogRVBTSUxPTixcblx0XHRNQUNISU5FX0VQU0lMT046IE1BQ0hJTkVfRVBTSUxPTixcblx0XHRLQVBQQTogNCAqIChzcXJ0KDIpIC0gMSkgLyAzLFxuXG5cdFx0aXNaZXJvOiBmdW5jdGlvbih2YWwpIHtcblx0XHRcdHJldHVybiBhYnModmFsKSA8PSBFUFNJTE9OO1xuXHRcdH0sXG5cblx0XHRpbnRlZ3JhdGU6IGZ1bmN0aW9uKGYsIGEsIGIsIG4pIHtcblx0XHRcdHZhciB4ID0gYWJzY2lzc2FzW24gLSAyXSxcblx0XHRcdFx0dyA9IHdlaWdodHNbbiAtIDJdLFxuXHRcdFx0XHRBID0gKGIgLSBhKSAqIDAuNSxcblx0XHRcdFx0QiA9IEEgKyBhLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bSA9IChuICsgMSkgPj4gMSxcblx0XHRcdFx0c3VtID0gbiAmIDEgPyB3W2krK10gKiBmKEIpIDogMDtcblx0XHRcdHdoaWxlIChpIDwgbSkge1xuXHRcdFx0XHR2YXIgQXggPSBBICogeFtpXTtcblx0XHRcdFx0c3VtICs9IHdbaSsrXSAqIChmKEIgKyBBeCkgKyBmKEIgLSBBeCkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIEEgKiBzdW07XG5cdFx0fSxcblxuXHRcdGZpbmRSb290OiBmdW5jdGlvbihmLCBkZiwgeCwgYSwgYiwgbiwgdG9sZXJhbmNlKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHR2YXIgZnggPSBmKHgpLFxuXHRcdFx0XHRcdGR4ID0gZnggLyBkZih4KSxcblx0XHRcdFx0XHRueCA9IHggLSBkeDtcblx0XHRcdFx0aWYgKGFicyhkeCkgPCB0b2xlcmFuY2UpXG5cdFx0XHRcdFx0cmV0dXJuIG54O1xuXHRcdFx0XHRpZiAoZnggPiAwKSB7XG5cdFx0XHRcdFx0YiA9IHg7XG5cdFx0XHRcdFx0eCA9IG54IDw9IGEgPyAoYSArIGIpICogMC41IDogbng7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YSA9IHg7XG5cdFx0XHRcdFx0eCA9IG54ID49IGIgPyAoYSArIGIpICogMC41IDogbng7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB4O1xuXHRcdH0sXG5cblx0XHRzb2x2ZVF1YWRyYXRpYzogZnVuY3Rpb24oYSwgYiwgYywgcm9vdHMsIG1pbiwgbWF4KSB7XG5cdFx0XHR2YXIgY291bnQgPSAwLFxuXHRcdFx0XHR4MSwgeDIgPSBJbmZpbml0eSxcblx0XHRcdFx0QiA9IGIsXG5cdFx0XHRcdEQ7XG5cdFx0XHRiIC89IDI7XG5cdFx0XHREID0gYiAqIGIgLSBhICogYztcblx0XHRcdGlmIChEICE9PSAwICYmIGFicyhEKSA8IE1BQ0hJTkVfRVBTSUxPTikge1xuXHRcdFx0XHR2YXIgZ21DID0gcG93KGFicyhhICogYiAqIGMpLCAxIC8gMyk7XG5cdFx0XHRcdGlmIChnbUMgPCAxZS04KSB7XG5cdFx0XHRcdFx0dmFyIG11bHQgPSBwb3coMTAsIGFicyhcblx0XHRcdFx0XHRcdE1hdGguZmxvb3IoTWF0aC5sb2coZ21DKSAqIE1hdGguTE9HMTBFKSkpO1xuXHRcdFx0XHRcdGlmICghaXNGaW5pdGUobXVsdCkpXG5cdFx0XHRcdFx0XHRtdWx0ID0gMDtcblx0XHRcdFx0XHRhICo9IG11bHQ7XG5cdFx0XHRcdFx0YiAqPSBtdWx0O1xuXHRcdFx0XHRcdGMgKj0gbXVsdDtcblx0XHRcdFx0XHREID0gYiAqIGIgLSBhICogYztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFicyhhKSA8IEVQU0lMT04pIHtcblx0XHRcdFx0aWYgKGFicyhCKSA8IEVQU0lMT04pXG5cdFx0XHRcdFx0cmV0dXJuIGFicyhjKSA8IEVQU0lMT04gPyAtMSA6IDA7XG5cdFx0XHRcdHgxID0gLWMgLyBCO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKEQgPj0gLU1BQ0hJTkVfRVBTSUxPTikge1xuXHRcdFx0XHRcdEQgPSBEIDwgMCA/IDAgOiBEO1xuXHRcdFx0XHRcdHZhciBSID0gc3FydChEKTtcblx0XHRcdFx0XHRpZiAoYiA+PSBNQUNISU5FX0VQU0lMT04gJiYgYiA8PSBNQUNISU5FX0VQU0lMT04pIHtcblx0XHRcdFx0XHRcdHgxID0gYWJzKGEpID49IGFicyhjKSA/IFIgLyBhIDogLWMgLyBSO1xuXHRcdFx0XHRcdFx0eDIgPSAteDE7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHZhciBxID0gLShiICsgKGIgPCAwID8gLTEgOiAxKSAqIFIpO1xuXHRcdFx0XHRcdFx0eDEgPSBxIC8gYTtcblx0XHRcdFx0XHRcdHgyID0gYyAvIHE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoaXNGaW5pdGUoeDEpICYmIChtaW4gPT0gbnVsbCB8fCB4MSA+PSBtaW4gJiYgeDEgPD0gbWF4KSlcblx0XHRcdFx0cm9vdHNbY291bnQrK10gPSB4MTtcblx0XHRcdGlmICh4MiAhPT0geDFcblx0XHRcdFx0XHQmJiBpc0Zpbml0ZSh4MikgJiYgKG1pbiA9PSBudWxsIHx8IHgyID49IG1pbiAmJiB4MiA8PSBtYXgpKVxuXHRcdFx0XHRyb290c1tjb3VudCsrXSA9IHgyO1xuXHRcdFx0cmV0dXJuIGNvdW50O1xuXHRcdH0sXG5cblx0XHRzb2x2ZUN1YmljOiBmdW5jdGlvbihhLCBiLCBjLCBkLCByb290cywgbWluLCBtYXgpIHtcblx0XHRcdHZhciBjb3VudCA9IDAsXG5cdFx0XHRcdHgsIGIxLCBjMjtcblx0XHRcdGlmIChhYnMoYSkgPCBFUFNJTE9OKSB7XG5cdFx0XHRcdGEgPSBiO1xuXHRcdFx0XHRiMSA9IGM7XG5cdFx0XHRcdGMyID0gZDtcblx0XHRcdFx0eCA9IEluZmluaXR5O1xuXHRcdFx0fSBlbHNlIGlmIChhYnMoZCkgPCBFUFNJTE9OKSB7XG5cdFx0XHRcdGIxID0gYjtcblx0XHRcdFx0YzIgPSBjO1xuXHRcdFx0XHR4ID0gMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBlYyA9IDEgKyBNQUNISU5FX0VQU0lMT04sXG5cdFx0XHRcdFx0eDAsIHEsIHFkLCB0LCByLCBzLCB0bXA7XG5cdFx0XHRcdHggPSAtKGIgLyBhKSAvIDM7XG5cdFx0XHRcdHRtcCA9IGEgKiB4LFxuXHRcdFx0XHRiMSA9IHRtcCArIGIsXG5cdFx0XHRcdGMyID0gYjEgKiB4ICsgYyxcblx0XHRcdFx0cWQgPSAodG1wICsgYjEpICogeCArIGMyLFxuXHRcdFx0XHRxID0gYzIgKiB4ICsgZDtcblx0XHRcdFx0dCA9IHEgL2E7XG5cdFx0XHRcdHIgPSBwb3coYWJzKHQpLCAxLzMpO1xuXHRcdFx0XHRzID0gdCA8IDAgPyAtMSA6IDE7XG5cdFx0XHRcdHQgPSAtcWQgLyBhO1xuXHRcdFx0XHRyID0gdCA+IDAgPyAxLjMyNDcxNzk1NzIgKiBNYXRoLm1heChyLCBzcXJ0KHQpKSA6IHI7XG5cdFx0XHRcdHgwID0geCAtIHMgKiByO1xuXHRcdFx0XHRpZiAoeDAgIT09IHgpIHtcblx0XHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0XHR4ID0geDA7XG5cdFx0XHRcdFx0XHR0bXAgPSBhICogeCxcblx0XHRcdFx0XHRcdGIxID0gdG1wICsgYixcblx0XHRcdFx0XHRcdGMyID0gYjEgKiB4ICsgYyxcblx0XHRcdFx0XHRcdHFkID0gKHRtcCArIGIxKSAqIHggKyBjMixcblx0XHRcdFx0XHRcdHEgPSBjMiAqIHggKyBkO1xuXHRcdFx0XHRcdFx0eDAgPSBxZCA9PT0gMCA/IHggOiB4IC0gcSAvIHFkIC8gZWM7XG5cdFx0XHRcdFx0XHRpZiAoeDAgPT09IHgpIHtcblx0XHRcdFx0XHRcdFx0eCA9IHgwO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IHdoaWxlIChzICogeDAgPiBzICogeCk7XG5cdFx0XHRcdFx0aWYgKGFicyhhKSAqIHggKiB4ID4gYWJzKGQgLyB4KSkge1xuXHRcdFx0XHRcdFx0YzIgPSAtZCAvIHg7XG5cdFx0XHRcdFx0XHRiMSA9IChjMiAtIGMpIC8geDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHZhciBjb3VudCA9IE51bWVyaWNhbC5zb2x2ZVF1YWRyYXRpYyhhLCBiMSwgYzIsIHJvb3RzLCBtaW4sIG1heCk7XG5cdFx0XHRpZiAoaXNGaW5pdGUoeCkgJiYgKGNvdW50ID09PSAwIHx8IHggIT09IHJvb3RzW2NvdW50IC0gMV0pXG5cdFx0XHRcdFx0JiYgKG1pbiA9PSBudWxsIHx8IHggPj0gbWluICYmIHggPD0gbWF4KSlcblx0XHRcdFx0cm9vdHNbY291bnQrK10gPSB4O1xuXHRcdFx0cmV0dXJuIGNvdW50O1xuXHRcdH1cblx0fTtcbn07XG5cbnZhciBVSUQgPSB7XG5cdF9pZDogMSxcblx0X3Bvb2xzOiB7fSxcblxuXHRnZXQ6IGZ1bmN0aW9uKGN0b3IpIHtcblx0XHRpZiAoY3Rvcikge1xuXHRcdFx0dmFyIG5hbWUgPSBjdG9yLl9jbGFzcyxcblx0XHRcdFx0cG9vbCA9IHRoaXMuX3Bvb2xzW25hbWVdO1xuXHRcdFx0aWYgKCFwb29sKVxuXHRcdFx0XHRwb29sID0gdGhpcy5fcG9vbHNbbmFtZV0gPSB7IF9pZDogMSB9O1xuXHRcdFx0cmV0dXJuIHBvb2wuX2lkKys7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLl9pZCsrO1xuXHRcdH1cblx0fVxufTtcblxudmFyIFBvaW50ID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQb2ludCcsXG5cdF9yZWFkSW5kZXg6IHRydWUsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUG9pbnQoYXJnMCwgYXJnMSkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIGFyZzA7XG5cdFx0aWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHR2YXIgaGFzWSA9IHR5cGVvZiBhcmcxID09PSAnbnVtYmVyJztcblx0XHRcdHRoaXMueCA9IGFyZzA7XG5cdFx0XHR0aGlzLnkgPSBoYXNZID8gYXJnMSA6IGFyZzA7XG5cdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdHRoaXMuX19yZWFkID0gaGFzWSA/IDIgOiAxO1xuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgYXJnMCA9PT0gbnVsbCkge1xuXHRcdFx0dGhpcy54ID0gdGhpcy55ID0gMDtcblx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0dGhpcy5fX3JlYWQgPSBhcmcwID09PSBudWxsID8gMSA6IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFyZzApKSB7XG5cdFx0XHRcdHRoaXMueCA9IGFyZzBbMF07XG5cdFx0XHRcdHRoaXMueSA9IGFyZzAubGVuZ3RoID4gMSA/IGFyZzBbMV0gOiBhcmcwWzBdO1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLnggIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLnggPSBhcmcwLng7XG5cdFx0XHRcdHRoaXMueSA9IGFyZzAueTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC53aWR0aCAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMueCA9IGFyZzAud2lkdGg7XG5cdFx0XHRcdHRoaXMueSA9IGFyZzAuaGVpZ2h0O1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLmFuZ2xlICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy54ID0gYXJnMC5sZW5ndGg7XG5cdFx0XHRcdHRoaXMueSA9IDA7XG5cdFx0XHRcdHRoaXMuc2V0QW5nbGUoYXJnMC5hbmdsZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnggPSB0aGlzLnkgPSAwO1xuXHRcdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdFx0dGhpcy5fX3JlYWQgPSAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHR0aGlzLl9fcmVhZCA9IDE7XG5cdFx0fVxuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24oeCwgeSkge1xuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0cmV0dXJuIHRoaXMgPT09IHBvaW50IHx8IHBvaW50XG5cdFx0XHRcdCYmICh0aGlzLnggPT09IHBvaW50LnggJiYgdGhpcy55ID09PSBwb2ludC55XG5cdFx0XHRcdFx0fHwgQXJyYXkuaXNBcnJheShwb2ludClcblx0XHRcdFx0XHRcdCYmIHRoaXMueCA9PT0gcG9pbnRbMF0gJiYgdGhpcy55ID09PSBwb2ludFsxXSlcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcblx0XHRyZXR1cm4gJ3sgeDogJyArIGYubnVtYmVyKHRoaXMueCkgKyAnLCB5OiAnICsgZi5udW1iZXIodGhpcy55KSArICcgfSc7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHZhciBmID0gb3B0aW9ucy5mb3JtYXR0ZXI7XG5cdFx0cmV0dXJuIFtmLm51bWJlcih0aGlzLngpLCBmLm51bWJlcih0aGlzLnkpXTtcblx0fSxcblxuXHRnZXRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55KTtcblx0fSxcblxuXHRzZXRMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCkge1xuXHRcdGlmICh0aGlzLmlzWmVybygpKSB7XG5cdFx0XHR2YXIgYW5nbGUgPSB0aGlzLl9hbmdsZSB8fCAwO1xuXHRcdFx0dGhpcy5zZXQoXG5cdFx0XHRcdE1hdGguY29zKGFuZ2xlKSAqIGxlbmd0aCxcblx0XHRcdFx0TWF0aC5zaW4oYW5nbGUpICogbGVuZ3RoXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgc2NhbGUgPSBsZW5ndGggLyB0aGlzLmdldExlbmd0aCgpO1xuXHRcdFx0aWYgKE51bWVyaWNhbC5pc1plcm8oc2NhbGUpKVxuXHRcdFx0XHR0aGlzLmdldEFuZ2xlKCk7XG5cdFx0XHR0aGlzLnNldChcblx0XHRcdFx0dGhpcy54ICogc2NhbGUsXG5cdFx0XHRcdHRoaXMueSAqIHNjYWxlXG5cdFx0XHQpO1xuXHRcdH1cblx0fSxcblx0Z2V0QW5nbGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEFuZ2xlSW5SYWRpYW5zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKiAxODAgLyBNYXRoLlBJO1xuXHR9LFxuXG5cdHNldEFuZ2xlOiBmdW5jdGlvbihhbmdsZSkge1xuXHRcdHRoaXMuc2V0QW5nbGVJblJhZGlhbnMuY2FsbCh0aGlzLCBhbmdsZSAqIE1hdGguUEkgLyAxODApO1xuXHR9LFxuXG5cdGdldEFuZ2xlSW5EZWdyZWVzOiAnI2dldEFuZ2xlJyxcblx0c2V0QW5nbGVJbkRlZ3JlZXM6ICcjc2V0QW5nbGUnLFxuXG5cdGdldEFuZ2xlSW5SYWRpYW5zOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiB0aGlzLmlzWmVybygpXG5cdFx0XHRcdFx0PyB0aGlzLl9hbmdsZSB8fCAwXG5cdFx0XHRcdFx0OiB0aGlzLl9hbmdsZSA9IE1hdGguYXRhbjIodGhpcy55LCB0aGlzLngpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGRpdiA9IHRoaXMuZ2V0TGVuZ3RoKCkgKiBwb2ludC5nZXRMZW5ndGgoKTtcblx0XHRcdGlmIChOdW1lcmljYWwuaXNaZXJvKGRpdikpIHtcblx0XHRcdFx0cmV0dXJuIE5hTjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBhID0gdGhpcy5kb3QocG9pbnQpIC8gZGl2O1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5hY29zKGEgPCAtMSA/IC0xIDogYSA+IDEgPyAxIDogYSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHNldEFuZ2xlSW5SYWRpYW5zOiBmdW5jdGlvbihhbmdsZSkge1xuXHRcdHRoaXMuX2FuZ2xlID0gYW5nbGU7XG5cdFx0aWYgKCF0aGlzLmlzWmVybygpKSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gdGhpcy5nZXRMZW5ndGgoKTtcblx0XHRcdHRoaXMuc2V0KFxuXHRcdFx0XHRNYXRoLmNvcyhhbmdsZSkgKiBsZW5ndGgsXG5cdFx0XHRcdE1hdGguc2luKGFuZ2xlKSAqIGxlbmd0aFxuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UXVhZHJhbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnggPj0gMCA/IHRoaXMueSA+PSAwID8gMSA6IDQgOiB0aGlzLnkgPj0gMCA/IDIgOiAzO1xuXHR9XG59LCB7XG5cdGJlYW5zOiBmYWxzZSxcblxuXHRnZXREaXJlY3RlZEFuZ2xlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIE1hdGguYXRhbjIodGhpcy5jcm9zcyhwb2ludCksIHRoaXMuZG90KHBvaW50KSkgKiAxODAgLyBNYXRoLlBJO1xuXHR9LFxuXG5cdGdldERpc3RhbmNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHR4ID0gcG9pbnQueCAtIHRoaXMueCxcblx0XHRcdHkgPSBwb2ludC55IC0gdGhpcy55LFxuXHRcdFx0ZCA9IHggKiB4ICsgeSAqIHksXG5cdFx0XHRzcXVhcmVkID0gQmFzZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHNxdWFyZWQgPyBkIDogTWF0aC5zcXJ0KGQpO1xuXHR9LFxuXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24obGVuZ3RoKSB7XG5cdFx0aWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0bGVuZ3RoID0gMTtcblx0XHR2YXIgY3VycmVudCA9IHRoaXMuZ2V0TGVuZ3RoKCksXG5cdFx0XHRzY2FsZSA9IGN1cnJlbnQgIT09IDAgPyBsZW5ndGggLyBjdXJyZW50IDogMCxcblx0XHRcdHBvaW50ID0gbmV3IFBvaW50KHRoaXMueCAqIHNjYWxlLCB0aGlzLnkgKiBzY2FsZSk7XG5cdFx0aWYgKHNjYWxlID49IDApXG5cdFx0XHRwb2ludC5fYW5nbGUgPSB0aGlzLl9hbmdsZTtcblx0XHRyZXR1cm4gcG9pbnQ7XG5cdH0sXG5cblx0cm90YXRlOiBmdW5jdGlvbihhbmdsZSwgY2VudGVyKSB7XG5cdFx0aWYgKGFuZ2xlID09PSAwKVxuXHRcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKTtcblx0XHRhbmdsZSA9IGFuZ2xlICogTWF0aC5QSSAvIDE4MDtcblx0XHR2YXIgcG9pbnQgPSBjZW50ZXIgPyB0aGlzLnN1YnRyYWN0KGNlbnRlcikgOiB0aGlzLFxuXHRcdFx0cyA9IE1hdGguc2luKGFuZ2xlKSxcblx0XHRcdGMgPSBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0cG9pbnQgPSBuZXcgUG9pbnQoXG5cdFx0XHRwb2ludC54ICogYyAtIHBvaW50LnkgKiBzLFxuXHRcdFx0cG9pbnQueCAqIHMgKyBwb2ludC55ICogY1xuXHRcdCk7XG5cdFx0cmV0dXJuIGNlbnRlciA/IHBvaW50LmFkZChjZW50ZXIpIDogcG9pbnQ7XG5cdH0sXG5cblx0dHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRyZXR1cm4gbWF0cml4ID8gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludCh0aGlzKSA6IHRoaXM7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyBwb2ludC54LCB0aGlzLnkgKyBwb2ludC55KTtcblx0fSxcblxuXHRzdWJ0cmFjdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54IC0gcG9pbnQueCwgdGhpcy55IC0gcG9pbnQueSk7XG5cdH0sXG5cblx0bXVsdGlwbHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAqIHBvaW50LngsIHRoaXMueSAqIHBvaW50LnkpO1xuXHR9LFxuXG5cdGRpdmlkZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54IC8gcG9pbnQueCwgdGhpcy55IC8gcG9pbnQueSk7XG5cdH0sXG5cblx0bW9kdWxvOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggJSBwb2ludC54LCB0aGlzLnkgJSBwb2ludC55KTtcblx0fSxcblxuXHRuZWdhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUG9pbnQoLXRoaXMueCwgLXRoaXMueSk7XG5cdH0sXG5cblx0aXNJbnNpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLmNvbnRhaW5zKHRoaXMpO1xuXHR9LFxuXG5cdGlzQ2xvc2U6IGZ1bmN0aW9uKHBvaW50LCB0b2xlcmFuY2UpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXREaXN0YW5jZShwb2ludCkgPCB0b2xlcmFuY2U7XG5cdH0sXG5cblx0aXNDb2xsaW5lYXI6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0cmV0dXJuIE1hdGguYWJzKHRoaXMuY3Jvc3MocG9pbnQpKSA8IDAuMDAwMDAxO1xuXHR9LFxuXG5cdGlzQ29saW5lYXI6ICcjaXNDb2xsaW5lYXInLFxuXG5cdGlzT3J0aG9nb25hbDogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRyZXR1cm4gTWF0aC5hYnModGhpcy5kb3QocG9pbnQpKSA8IDAuMDAwMDAxO1xuXHR9LFxuXG5cdGlzWmVybzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIE51bWVyaWNhbC5pc1plcm8odGhpcy54KSAmJiBOdW1lcmljYWwuaXNaZXJvKHRoaXMueSk7XG5cdH0sXG5cblx0aXNOYU46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBpc05hTih0aGlzLngpIHx8IGlzTmFOKHRoaXMueSk7XG5cdH0sXG5cblx0ZG90OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHRoaXMueCAqIHBvaW50LnggKyB0aGlzLnkgKiBwb2ludC55O1xuXHR9LFxuXG5cdGNyb3NzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHRoaXMueCAqIHBvaW50LnkgLSB0aGlzLnkgKiBwb2ludC54O1xuXHR9LFxuXG5cdHByb2plY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRpZiAocG9pbnQuaXNaZXJvKCkpIHtcblx0XHRcdHJldHVybiBuZXcgUG9pbnQoMCwgMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBzY2FsZSA9IHRoaXMuZG90KHBvaW50KSAvIHBvaW50LmRvdChwb2ludCk7XG5cdFx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0XHRwb2ludC54ICogc2NhbGUsXG5cdFx0XHRcdHBvaW50LnkgKiBzY2FsZVxuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdG1pbjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcG9pbnQxID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRwb2ludDIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0XHRNYXRoLm1pbihwb2ludDEueCwgcG9pbnQyLngpLFxuXHRcdFx0XHRNYXRoLm1pbihwb2ludDEueSwgcG9pbnQyLnkpXG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHRtYXg6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHBvaW50MSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0cG9pbnQyID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIG5ldyBQb2ludChcblx0XHRcdFx0TWF0aC5tYXgocG9pbnQxLngsIHBvaW50Mi54KSxcblx0XHRcdFx0TWF0aC5tYXgocG9pbnQxLnksIHBvaW50Mi55KVxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0cmFuZG9tOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBuZXcgUG9pbnQoTWF0aC5yYW5kb20oKSwgTWF0aC5yYW5kb20oKSk7XG5cdFx0fVxuXHR9XG59LCBCYXNlLmVhY2goWydyb3VuZCcsICdjZWlsJywgJ2Zsb29yJywgJ2FicyddLCBmdW5jdGlvbihuYW1lKSB7XG5cdHZhciBvcCA9IE1hdGhbbmFtZV07XG5cdHRoaXNbbmFtZV0gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KG9wKHRoaXMueCksIG9wKHRoaXMueSkpO1xuXHR9O1xufSwge30pKTtcblxudmFyIExpbmtlZFBvaW50ID0gUG9pbnQuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUG9pbnQoeCwgeSwgb3duZXIsIHNldHRlcikge1xuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX293bmVyID0gb3duZXI7XG5cdFx0dGhpcy5fc2V0dGVyID0gc2V0dGVyO1xuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24oeCwgeSwgX2RvbnROb3RpZnkpIHtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHRpZiAoIV9kb250Tm90aWZ5KVxuXHRcdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRYOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5feDtcblx0fSxcblxuXHRzZXRYOiBmdW5jdGlvbih4KSB7XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0fSxcblxuXHRnZXRZOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5feTtcblx0fSxcblxuXHRzZXRZOiBmdW5jdGlvbih5KSB7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0fVxufSk7XG5cbnZhciBTaXplID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdTaXplJyxcblx0X3JlYWRJbmRleDogdHJ1ZSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBTaXplKGFyZzAsIGFyZzEpIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiBhcmcwO1xuXHRcdGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0dmFyIGhhc0hlaWdodCA9IHR5cGVvZiBhcmcxID09PSAnbnVtYmVyJztcblx0XHRcdHRoaXMud2lkdGggPSBhcmcwO1xuXHRcdFx0dGhpcy5oZWlnaHQgPSBoYXNIZWlnaHQgPyBhcmcxIDogYXJnMDtcblx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0dGhpcy5fX3JlYWQgPSBoYXNIZWlnaHQgPyAyIDogMTtcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IGFyZzAgPT09IG51bGwpIHtcblx0XHRcdHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IDA7XG5cdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdHRoaXMuX19yZWFkID0gYXJnMCA9PT0gbnVsbCA/IDEgOiAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcmcwKSkge1xuXHRcdFx0XHR0aGlzLndpZHRoID0gYXJnMFswXTtcblx0XHRcdFx0dGhpcy5oZWlnaHQgPSBhcmcwLmxlbmd0aCA+IDEgPyBhcmcwWzFdIDogYXJnMFswXTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC53aWR0aCAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMud2lkdGggPSBhcmcwLndpZHRoO1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IGFyZzAuaGVpZ2h0O1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLnggIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLndpZHRoID0gYXJnMC54O1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IGFyZzAueTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IDA7XG5cdFx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0XHR0aGlzLl9fcmVhZCA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdHRoaXMuX19yZWFkID0gMTtcblx0XHR9XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc2l6ZSkge1xuXHRcdHJldHVybiBzaXplID09PSB0aGlzIHx8IHNpemUgJiYgKHRoaXMud2lkdGggPT09IHNpemUud2lkdGhcblx0XHRcdFx0JiYgdGhpcy5oZWlnaHQgPT09IHNpemUuaGVpZ2h0XG5cdFx0XHRcdHx8IEFycmF5LmlzQXJyYXkoc2l6ZSkgJiYgdGhpcy53aWR0aCA9PT0gc2l6ZVswXVxuXHRcdFx0XHRcdCYmIHRoaXMuaGVpZ2h0ID09PSBzaXplWzFdKSB8fCBmYWxzZTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG5cdFx0cmV0dXJuICd7IHdpZHRoOiAnICsgZi5udW1iZXIodGhpcy53aWR0aClcblx0XHRcdFx0KyAnLCBoZWlnaHQ6ICcgKyBmLm51bWJlcih0aGlzLmhlaWdodCkgKyAnIH0nO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgZiA9IG9wdGlvbnMuZm9ybWF0dGVyO1xuXHRcdHJldHVybiBbZi5udW1iZXIodGhpcy53aWR0aCksXG5cdFx0XHRcdGYubnVtYmVyKHRoaXMuaGVpZ2h0KV07XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoICsgc2l6ZS53aWR0aCwgdGhpcy5oZWlnaHQgKyBzaXplLmhlaWdodCk7XG5cdH0sXG5cblx0c3VidHJhY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGggLSBzaXplLndpZHRoLCB0aGlzLmhlaWdodCAtIHNpemUuaGVpZ2h0KTtcblx0fSxcblxuXHRtdWx0aXBseTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCAqIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0ICogc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdGRpdmlkZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCAvIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0IC8gc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdG1vZHVsbzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCAlIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0ICUgc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdG5lZ2F0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBTaXplKC10aGlzLndpZHRoLCAtdGhpcy5oZWlnaHQpO1xuXHR9LFxuXG5cdGlzWmVybzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIE51bWVyaWNhbC5pc1plcm8odGhpcy53aWR0aCkgJiYgTnVtZXJpY2FsLmlzWmVybyh0aGlzLmhlaWdodCk7XG5cdH0sXG5cblx0aXNOYU46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBpc05hTih0aGlzLndpZHRoKSB8fCBpc05hTih0aGlzLmhlaWdodCk7XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdG1pbjogZnVuY3Rpb24oc2l6ZTEsIHNpemUyKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNpemUoXG5cdFx0XHRcdE1hdGgubWluKHNpemUxLndpZHRoLCBzaXplMi53aWR0aCksXG5cdFx0XHRcdE1hdGgubWluKHNpemUxLmhlaWdodCwgc2l6ZTIuaGVpZ2h0KSk7XG5cdFx0fSxcblxuXHRcdG1heDogZnVuY3Rpb24oc2l6ZTEsIHNpemUyKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNpemUoXG5cdFx0XHRcdE1hdGgubWF4KHNpemUxLndpZHRoLCBzaXplMi53aWR0aCksXG5cdFx0XHRcdE1hdGgubWF4KHNpemUxLmhlaWdodCwgc2l6ZTIuaGVpZ2h0KSk7XG5cdFx0fSxcblxuXHRcdHJhbmRvbTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNpemUoTWF0aC5yYW5kb20oKSwgTWF0aC5yYW5kb20oKSk7XG5cdFx0fVxuXHR9XG59LCBCYXNlLmVhY2goWydyb3VuZCcsICdjZWlsJywgJ2Zsb29yJywgJ2FicyddLCBmdW5jdGlvbihuYW1lKSB7XG5cdHZhciBvcCA9IE1hdGhbbmFtZV07XG5cdHRoaXNbbmFtZV0gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFNpemUob3AodGhpcy53aWR0aCksIG9wKHRoaXMuaGVpZ2h0KSk7XG5cdH07XG59LCB7fSkpO1xuXG52YXIgTGlua2VkU2l6ZSA9IFNpemUuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU2l6ZSh3aWR0aCwgaGVpZ2h0LCBvd25lciwgc2V0dGVyKSB7XG5cdFx0dGhpcy5fd2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0dGhpcy5fb3duZXIgPSBvd25lcjtcblx0XHR0aGlzLl9zZXR0ZXIgPSBzZXR0ZXI7XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBfZG9udE5vdGlmeSkge1xuXHRcdHRoaXMuX3dpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdGlmICghX2RvbnROb3RpZnkpXG5cdFx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldFdpZHRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fd2lkdGg7XG5cdH0sXG5cblx0c2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG5cdFx0dGhpcy5fd2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHR9LFxuXG5cdGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2hlaWdodDtcblx0fSxcblxuXHRzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuXHRcdHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHR9XG59KTtcblxudmFyIFJlY3RhbmdsZSA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnUmVjdGFuZ2xlJyxcblx0X3JlYWRJbmRleDogdHJ1ZSxcblx0YmVhbnM6IHRydWUsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUmVjdGFuZ2xlKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiBhcmcwLFxuXHRcdFx0cmVhZCA9IDA7XG5cdFx0aWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHR0aGlzLnggPSBhcmcwO1xuXHRcdFx0dGhpcy55ID0gYXJnMTtcblx0XHRcdHRoaXMud2lkdGggPSBhcmcyO1xuXHRcdFx0dGhpcy5oZWlnaHQgPSBhcmczO1xuXHRcdFx0cmVhZCA9IDQ7XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCBhcmcwID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLnggPSB0aGlzLnkgPSB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSAwO1xuXHRcdFx0cmVhZCA9IGFyZzAgPT09IG51bGwgPyAxIDogMDtcblx0XHR9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFyZzApKSB7XG5cdFx0XHRcdHRoaXMueCA9IGFyZzBbMF07XG5cdFx0XHRcdHRoaXMueSA9IGFyZzBbMV07XG5cdFx0XHRcdHRoaXMud2lkdGggPSBhcmcwWzJdO1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IGFyZzBbM107XG5cdFx0XHRcdHJlYWQgPSAxO1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLnggIT09IHVuZGVmaW5lZCB8fCBhcmcwLndpZHRoICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy54ID0gYXJnMC54IHx8IDA7XG5cdFx0XHRcdHRoaXMueSA9IGFyZzAueSB8fCAwO1xuXHRcdFx0XHR0aGlzLndpZHRoID0gYXJnMC53aWR0aCB8fCAwO1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IGFyZzAuaGVpZ2h0IHx8IDA7XG5cdFx0XHRcdHJlYWQgPSAxO1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLmZyb20gPT09IHVuZGVmaW5lZCAmJiBhcmcwLnRvID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy54ID0gdGhpcy55ID0gdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gMDtcblx0XHRcdFx0dGhpcy5fc2V0KGFyZzApO1xuXHRcdFx0XHRyZWFkID0gMTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFyZWFkKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAnZnJvbScpLFxuXHRcdFx0XHRuZXh0ID0gQmFzZS5wZWVrKGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLnggPSBwb2ludC54O1xuXHRcdFx0dGhpcy55ID0gcG9pbnQueTtcblx0XHRcdGlmIChuZXh0ICYmIG5leHQueCAhPT0gdW5kZWZpbmVkIHx8IEJhc2UuaGFzTmFtZWQoYXJndW1lbnRzLCAndG8nKSkge1xuXHRcdFx0XHR2YXIgdG8gPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAndG8nKTtcblx0XHRcdFx0dGhpcy53aWR0aCA9IHRvLnggLSBwb2ludC54O1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IHRvLnkgLSBwb2ludC55O1xuXHRcdFx0XHRpZiAodGhpcy53aWR0aCA8IDApIHtcblx0XHRcdFx0XHR0aGlzLnggPSB0by54O1xuXHRcdFx0XHRcdHRoaXMud2lkdGggPSAtdGhpcy53aWR0aDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5oZWlnaHQgPCAwKSB7XG5cdFx0XHRcdFx0dGhpcy55ID0gdG8ueTtcblx0XHRcdFx0XHR0aGlzLmhlaWdodCA9IC10aGlzLmhlaWdodDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdFx0dGhpcy53aWR0aCA9IHNpemUud2lkdGg7XG5cdFx0XHRcdHRoaXMuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdFx0XHR9XG5cdFx0XHRyZWFkID0gYXJndW1lbnRzLl9faW5kZXg7XG5cdFx0fVxuXHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdHRoaXMuX19yZWFkID0gcmVhZDtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24ocmVjdCkge1xuXHRcdHZhciBydCA9IEJhc2UuaXNQbGFpblZhbHVlKHJlY3QpXG5cdFx0XHRcdD8gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKVxuXHRcdFx0XHQ6IHJlY3Q7XG5cdFx0cmV0dXJuIHJ0ID09PSB0aGlzXG5cdFx0XHRcdHx8IHJ0ICYmIHRoaXMueCA9PT0gcnQueCAmJiB0aGlzLnkgPT09IHJ0Lnlcblx0XHRcdFx0XHQmJiB0aGlzLndpZHRoID09PSBydC53aWR0aCAmJiB0aGlzLmhlaWdodCA9PT0gcnQuaGVpZ2h0XG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcblx0XHRyZXR1cm4gJ3sgeDogJyArIGYubnVtYmVyKHRoaXMueClcblx0XHRcdFx0KyAnLCB5OiAnICsgZi5udW1iZXIodGhpcy55KVxuXHRcdFx0XHQrICcsIHdpZHRoOiAnICsgZi5udW1iZXIodGhpcy53aWR0aClcblx0XHRcdFx0KyAnLCBoZWlnaHQ6ICcgKyBmLm51bWJlcih0aGlzLmhlaWdodClcblx0XHRcdFx0KyAnIH0nO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgZiA9IG9wdGlvbnMuZm9ybWF0dGVyO1xuXHRcdHJldHVybiBbZi5udW1iZXIodGhpcy54KSxcblx0XHRcdFx0Zi5udW1iZXIodGhpcy55KSxcblx0XHRcdFx0Zi5udW1iZXIodGhpcy53aWR0aCksXG5cdFx0XHRcdGYubnVtYmVyKHRoaXMuaGVpZ2h0KV07XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdHZhciBjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcblx0XHRyZXR1cm4gbmV3IGN0b3IodGhpcy54LCB0aGlzLnksIHRoaXMsICdzZXRQb2ludCcpO1xuXHR9LFxuXG5cdHNldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy54ID0gcG9pbnQueDtcblx0XHR0aGlzLnkgPSBwb2ludC55O1xuXHR9LFxuXG5cdGdldFNpemU6IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdHZhciBjdG9yID0gX2RvbnRMaW5rID8gU2l6ZSA6IExpbmtlZFNpemU7XG5cdFx0cmV0dXJuIG5ldyBjdG9yKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLCAnc2V0U2l6ZScpO1xuXHR9LFxuXG5cdHNldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKHRoaXMuX2ZpeFgpXG5cdFx0XHR0aGlzLnggKz0gKHRoaXMud2lkdGggLSBzaXplLndpZHRoKSAqIHRoaXMuX2ZpeFg7XG5cdFx0aWYgKHRoaXMuX2ZpeFkpXG5cdFx0XHR0aGlzLnkgKz0gKHRoaXMuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpICogdGhpcy5fZml4WTtcblx0XHR0aGlzLndpZHRoID0gc2l6ZS53aWR0aDtcblx0XHR0aGlzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdHRoaXMuX2ZpeFcgPSAxO1xuXHRcdHRoaXMuX2ZpeEggPSAxO1xuXHR9LFxuXG5cdGdldExlZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLng7XG5cdH0sXG5cblx0c2V0TGVmdDogZnVuY3Rpb24obGVmdCkge1xuXHRcdGlmICghdGhpcy5fZml4Vylcblx0XHRcdHRoaXMud2lkdGggLT0gbGVmdCAtIHRoaXMueDtcblx0XHR0aGlzLnggPSBsZWZ0O1xuXHRcdHRoaXMuX2ZpeFggPSAwO1xuXHR9LFxuXG5cdGdldFRvcDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMueTtcblx0fSxcblxuXHRzZXRUb3A6IGZ1bmN0aW9uKHRvcCkge1xuXHRcdGlmICghdGhpcy5fZml4SClcblx0XHRcdHRoaXMuaGVpZ2h0IC09IHRvcCAtIHRoaXMueTtcblx0XHR0aGlzLnkgPSB0b3A7XG5cdFx0dGhpcy5fZml4WSA9IDA7XG5cdH0sXG5cblx0Z2V0UmlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoO1xuXHR9LFxuXG5cdHNldFJpZ2h0OiBmdW5jdGlvbihyaWdodCkge1xuXHRcdGlmICh0aGlzLl9maXhYICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fZml4WCAhPT0gMSlcblx0XHRcdHRoaXMuX2ZpeFcgPSAwO1xuXHRcdGlmICh0aGlzLl9maXhXKVxuXHRcdFx0dGhpcy54ID0gcmlnaHQgLSB0aGlzLndpZHRoO1xuXHRcdGVsc2Vcblx0XHRcdHRoaXMud2lkdGggPSByaWdodCAtIHRoaXMueDtcblx0XHR0aGlzLl9maXhYID0gMTtcblx0fSxcblxuXHRnZXRCb3R0b206IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodDtcblx0fSxcblxuXHRzZXRCb3R0b206IGZ1bmN0aW9uKGJvdHRvbSkge1xuXHRcdGlmICh0aGlzLl9maXhZICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fZml4WSAhPT0gMSlcblx0XHRcdHRoaXMuX2ZpeEggPSAwO1xuXHRcdGlmICh0aGlzLl9maXhIKVxuXHRcdFx0dGhpcy55ID0gYm90dG9tIC0gdGhpcy5oZWlnaHQ7XG5cdFx0ZWxzZVxuXHRcdFx0dGhpcy5oZWlnaHQgPSBib3R0b20gLSB0aGlzLnk7XG5cdFx0dGhpcy5fZml4WSA9IDE7XG5cdH0sXG5cblx0Z2V0Q2VudGVyWDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGggKiAwLjU7XG5cdH0sXG5cblx0c2V0Q2VudGVyWDogZnVuY3Rpb24oeCkge1xuXHRcdHRoaXMueCA9IHggLSB0aGlzLndpZHRoICogMC41O1xuXHRcdHRoaXMuX2ZpeFggPSAwLjU7XG5cdH0sXG5cblx0Z2V0Q2VudGVyWTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMueSArIHRoaXMuaGVpZ2h0ICogMC41O1xuXHR9LFxuXG5cdHNldENlbnRlclk6IGZ1bmN0aW9uKHkpIHtcblx0XHR0aGlzLnkgPSB5IC0gdGhpcy5oZWlnaHQgKiAwLjU7XG5cdFx0dGhpcy5fZml4WSA9IDAuNTtcblx0fSxcblxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdHZhciBjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcblx0XHRyZXR1cm4gbmV3IGN0b3IodGhpcy5nZXRDZW50ZXJYKCksIHRoaXMuZ2V0Q2VudGVyWSgpLCB0aGlzLCAnc2V0Q2VudGVyJyk7XG5cdH0sXG5cblx0c2V0Q2VudGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5zZXRDZW50ZXJYKHBvaW50LngpO1xuXHRcdHRoaXMuc2V0Q2VudGVyWShwb2ludC55KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0O1xuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLndpZHRoID09PSAwIHx8IHRoaXMuaGVpZ2h0ID09PSAwO1xuXHR9LFxuXG5cdGNvbnRhaW5zOiBmdW5jdGlvbihhcmcpIHtcblx0XHRyZXR1cm4gYXJnICYmIGFyZy53aWR0aCAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdHx8IChBcnJheS5pc0FycmF5KGFyZykgPyBhcmcgOiBhcmd1bWVudHMpLmxlbmd0aCA9PSA0XG5cdFx0XHRcdD8gdGhpcy5fY29udGFpbnNSZWN0YW5nbGUoUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSlcblx0XHRcdFx0OiB0aGlzLl9jb250YWluc1BvaW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0dmFyIHggPSBwb2ludC54LFxuXHRcdFx0eSA9IHBvaW50Lnk7XG5cdFx0cmV0dXJuIHggPj0gdGhpcy54ICYmIHkgPj0gdGhpcy55XG5cdFx0XHRcdCYmIHggPD0gdGhpcy54ICsgdGhpcy53aWR0aFxuXHRcdFx0XHQmJiB5IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuXHR9LFxuXG5cdF9jb250YWluc1JlY3RhbmdsZTogZnVuY3Rpb24ocmVjdCkge1xuXHRcdHZhciB4ID0gcmVjdC54LFxuXHRcdFx0eSA9IHJlY3QueTtcblx0XHRyZXR1cm4geCA+PSB0aGlzLnggJiYgeSA+PSB0aGlzLnlcblx0XHRcdFx0JiYgeCArIHJlY3Qud2lkdGggPD0gdGhpcy54ICsgdGhpcy53aWR0aFxuXHRcdFx0XHQmJiB5ICsgcmVjdC5oZWlnaHQgPD0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG5cdH0sXG5cblx0aW50ZXJzZWN0czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiByZWN0LnggKyByZWN0LndpZHRoID4gdGhpcy54XG5cdFx0XHRcdCYmIHJlY3QueSArIHJlY3QuaGVpZ2h0ID4gdGhpcy55XG5cdFx0XHRcdCYmIHJlY3QueCA8IHRoaXMueCArIHRoaXMud2lkdGhcblx0XHRcdFx0JiYgcmVjdC55IDwgdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG5cdH0sXG5cblx0dG91Y2hlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiByZWN0LnggKyByZWN0LndpZHRoID49IHRoaXMueFxuXHRcdFx0XHQmJiByZWN0LnkgKyByZWN0LmhlaWdodCA+PSB0aGlzLnlcblx0XHRcdFx0JiYgcmVjdC54IDw9IHRoaXMueCArIHRoaXMud2lkdGhcblx0XHRcdFx0JiYgcmVjdC55IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuXHR9LFxuXG5cdGludGVyc2VjdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0eDEgPSBNYXRoLm1heCh0aGlzLngsIHJlY3QueCksXG5cdFx0XHR5MSA9IE1hdGgubWF4KHRoaXMueSwgcmVjdC55KSxcblx0XHRcdHgyID0gTWF0aC5taW4odGhpcy54ICsgdGhpcy53aWR0aCwgcmVjdC54ICsgcmVjdC53aWR0aCksXG5cdFx0XHR5MiA9IE1hdGgubWluKHRoaXMueSArIHRoaXMuaGVpZ2h0LCByZWN0LnkgKyByZWN0LmhlaWdodCk7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcblx0fSxcblxuXHR1bml0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0eDEgPSBNYXRoLm1pbih0aGlzLngsIHJlY3QueCksXG5cdFx0XHR5MSA9IE1hdGgubWluKHRoaXMueSwgcmVjdC55KSxcblx0XHRcdHgyID0gTWF0aC5tYXgodGhpcy54ICsgdGhpcy53aWR0aCwgcmVjdC54ICsgcmVjdC53aWR0aCksXG5cdFx0XHR5MiA9IE1hdGgubWF4KHRoaXMueSArIHRoaXMuaGVpZ2h0LCByZWN0LnkgKyByZWN0LmhlaWdodCk7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcblx0fSxcblxuXHRpbmNsdWRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dmFyIHgxID0gTWF0aC5taW4odGhpcy54LCBwb2ludC54KSxcblx0XHRcdHkxID0gTWF0aC5taW4odGhpcy55LCBwb2ludC55KSxcblx0XHRcdHgyID0gTWF0aC5tYXgodGhpcy54ICsgdGhpcy53aWR0aCwgcG9pbnQueCksXG5cdFx0XHR5MiA9IE1hdGgubWF4KHRoaXMueSArIHRoaXMuaGVpZ2h0LCBwb2ludC55KTtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuXHR9LFxuXG5cdGV4cGFuZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFtb3VudCA9IFNpemUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0aG9yID0gYW1vdW50LndpZHRoLFxuXHRcdFx0dmVyID0gYW1vdW50LmhlaWdodDtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLnggLSBob3IgLyAyLCB0aGlzLnkgLSB2ZXIgLyAyLFxuXHRcdFx0XHR0aGlzLndpZHRoICsgaG9yLCB0aGlzLmhlaWdodCArIHZlcik7XG5cdH0sXG5cblx0c2NhbGU6IGZ1bmN0aW9uKGhvciwgdmVyKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXhwYW5kKHRoaXMud2lkdGggKiBob3IgLSB0aGlzLndpZHRoLFxuXHRcdFx0XHR0aGlzLmhlaWdodCAqICh2ZXIgPT09IHVuZGVmaW5lZCA/IGhvciA6IHZlcikgLSB0aGlzLmhlaWdodCk7XG5cdH1cbn0sIEJhc2UuZWFjaChbXG5cdFx0WydUb3AnLCAnTGVmdCddLCBbJ1RvcCcsICdSaWdodCddLFxuXHRcdFsnQm90dG9tJywgJ0xlZnQnXSwgWydCb3R0b20nLCAnUmlnaHQnXSxcblx0XHRbJ0xlZnQnLCAnQ2VudGVyJ10sIFsnVG9wJywgJ0NlbnRlciddLFxuXHRcdFsnUmlnaHQnLCAnQ2VudGVyJ10sIFsnQm90dG9tJywgJ0NlbnRlciddXG5cdF0sXG5cdGZ1bmN0aW9uKHBhcnRzLCBpbmRleCkge1xuXHRcdHZhciBwYXJ0ID0gcGFydHMuam9pbignJyk7XG5cdFx0dmFyIHhGaXJzdCA9IC9eW1JMXS8udGVzdChwYXJ0KTtcblx0XHRpZiAoaW5kZXggPj0gNClcblx0XHRcdHBhcnRzWzFdICs9IHhGaXJzdCA/ICdZJyA6ICdYJztcblx0XHR2YXIgeCA9IHBhcnRzW3hGaXJzdCA/IDAgOiAxXSxcblx0XHRcdHkgPSBwYXJ0c1t4Rmlyc3QgPyAxIDogMF0sXG5cdFx0XHRnZXRYID0gJ2dldCcgKyB4LFxuXHRcdFx0Z2V0WSA9ICdnZXQnICsgeSxcblx0XHRcdHNldFggPSAnc2V0JyArIHgsXG5cdFx0XHRzZXRZID0gJ3NldCcgKyB5LFxuXHRcdFx0Z2V0ID0gJ2dldCcgKyBwYXJ0LFxuXHRcdFx0c2V0ID0gJ3NldCcgKyBwYXJ0O1xuXHRcdHRoaXNbZ2V0XSA9IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdFx0dmFyIGN0b3IgPSBfZG9udExpbmsgPyBQb2ludCA6IExpbmtlZFBvaW50O1xuXHRcdFx0cmV0dXJuIG5ldyBjdG9yKHRoaXNbZ2V0WF0oKSwgdGhpc1tnZXRZXSgpLCB0aGlzLCBzZXQpO1xuXHRcdH07XG5cdFx0dGhpc1tzZXRdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzW3NldFhdKHBvaW50LngpO1xuXHRcdFx0dGhpc1tzZXRZXShwb2ludC55KTtcblx0XHR9O1xuXHR9LCB7XG5cdFx0YmVhbnM6IHRydWVcblx0fVxuKSk7XG5cbnZhciBMaW5rZWRSZWN0YW5nbGUgPSBSZWN0YW5nbGUuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQsIG93bmVyLCBzZXR0ZXIpIHtcblx0XHR0aGlzLnNldCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcblx0XHR0aGlzLl9vd25lciA9IG93bmVyO1xuXHRcdHRoaXMuX3NldHRlciA9IHNldHRlcjtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQsIF9kb250Tm90aWZ5KSB7XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5fd2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0sIG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIHByb3RvID0gUmVjdGFuZ2xlLnByb3RvdHlwZTtcblxuXHRyZXR1cm4gQmFzZS5lYWNoKFsneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCddLCBmdW5jdGlvbihrZXkpIHtcblx0XHR2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShrZXkpO1xuXHRcdHZhciBpbnRlcm5hbCA9ICdfJyArIGtleTtcblx0XHR0aGlzWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzW2ludGVybmFsXTtcblx0XHR9O1xuXG5cdFx0dGhpc1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHRoaXNbaW50ZXJuYWxdID0gdmFsdWU7XG5cdFx0XHRpZiAoIXRoaXMuX2RvbnROb3RpZnkpXG5cdFx0XHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdFx0fTtcblx0fSwgQmFzZS5lYWNoKFsnUG9pbnQnLCAnU2l6ZScsICdDZW50ZXInLFxuXHRcdFx0J0xlZnQnLCAnVG9wJywgJ1JpZ2h0JywgJ0JvdHRvbScsICdDZW50ZXJYJywgJ0NlbnRlclknLFxuXHRcdFx0J1RvcExlZnQnLCAnVG9wUmlnaHQnLCAnQm90dG9tTGVmdCcsICdCb3R0b21SaWdodCcsXG5cdFx0XHQnTGVmdENlbnRlcicsICdUb3BDZW50ZXInLCAnUmlnaHRDZW50ZXInLCAnQm90dG9tQ2VudGVyJ10sXG5cdFx0ZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHR2YXIgbmFtZSA9ICdzZXQnICsga2V5O1xuXHRcdFx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLl9kb250Tm90aWZ5ID0gdHJ1ZTtcblx0XHRcdFx0cHJvdG9bbmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0dGhpcy5fZG9udE5vdGlmeSA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHRcdFx0fTtcblx0XHR9LCB7XG5cdFx0XHRpc1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX293bmVyLl9ib3VuZHNTZWxlY3RlZDtcblx0XHRcdH0sXG5cblx0XHRcdHNldFNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuXHRcdFx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcjtcblx0XHRcdFx0aWYgKG93bmVyLnNldFNlbGVjdGVkKSB7XG5cdFx0XHRcdFx0b3duZXIuX2JvdW5kc1NlbGVjdGVkID0gc2VsZWN0ZWQ7XG5cdFx0XHRcdFx0b3duZXIuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQgfHwgb3duZXIuX3NlbGVjdGVkU2VnbWVudFN0YXRlID4gMCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KVxuXHQpO1xufSk7XG5cbnZhciBNYXRyaXggPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ01hdHJpeCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gTWF0cml4KGFyZykge1xuXHRcdHZhciBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0XHRvayA9IHRydWU7XG5cdFx0aWYgKGNvdW50ID09PSA2KSB7XG5cdFx0XHR0aGlzLnNldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDEpIHtcblx0XHRcdGlmIChhcmcgaW5zdGFuY2VvZiBNYXRyaXgpIHtcblx0XHRcdFx0dGhpcy5zZXQoYXJnLl9hLCBhcmcuX2MsIGFyZy5fYiwgYXJnLl9kLCBhcmcuX3R4LCBhcmcuX3R5KTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdHRoaXMuc2V0LmFwcGx5KHRoaXMsIGFyZyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvayA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDApIHtcblx0XHRcdHRoaXMucmVzZXQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b2sgPSBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKCFvaylcblx0XHRcdHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgbWF0cml4IHBhcmFtZXRlcnMnKTtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKGEsIGMsIGIsIGQsIHR4LCB0eSwgX2RvbnROb3RpZnkpIHtcblx0XHR0aGlzLl9hID0gYTtcblx0XHR0aGlzLl9jID0gYztcblx0XHR0aGlzLl9iID0gYjtcblx0XHR0aGlzLl9kID0gZDtcblx0XHR0aGlzLl90eCA9IHR4O1xuXHRcdHRoaXMuX3R5ID0gdHk7XG5cdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKHRoaXMuZ2V0VmFsdWVzKCksIG9wdGlvbnMpO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcjtcblx0XHRpZiAob3duZXIpIHtcblx0XHRcdGlmIChvd25lci5fYXBwbHlNYXRyaXgpIHtcblx0XHRcdFx0b3duZXIudHJhbnNmb3JtKG51bGwsIHRydWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3duZXIuX2NoYW5nZWQoOSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IE1hdHJpeCh0aGlzLl9hLCB0aGlzLl9jLCB0aGlzLl9iLCB0aGlzLl9kLFxuXHRcdFx0XHR0aGlzLl90eCwgdGhpcy5fdHkpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24obXgpIHtcblx0XHRyZXR1cm4gbXggPT09IHRoaXMgfHwgbXggJiYgdGhpcy5fYSA9PT0gbXguX2EgJiYgdGhpcy5fYiA9PT0gbXguX2Jcblx0XHRcdFx0JiYgdGhpcy5fYyA9PT0gbXguX2MgJiYgdGhpcy5fZCA9PT0gbXguX2Rcblx0XHRcdFx0JiYgdGhpcy5fdHggPT09IG14Ll90eCAmJiB0aGlzLl90eSA9PT0gbXguX3R5XG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcblx0XHRyZXR1cm4gJ1tbJyArIFtmLm51bWJlcih0aGlzLl9hKSwgZi5udW1iZXIodGhpcy5fYiksXG5cdFx0XHRcdFx0Zi5udW1iZXIodGhpcy5fdHgpXS5qb2luKCcsICcpICsgJ10sIFsnXG5cdFx0XHRcdCsgW2YubnVtYmVyKHRoaXMuX2MpLCBmLm51bWJlcih0aGlzLl9kKSxcblx0XHRcdFx0XHRmLm51bWJlcih0aGlzLl90eSldLmpvaW4oJywgJykgKyAnXV0nO1xuXHR9LFxuXG5cdHJlc2V0OiBmdW5jdGlvbihfZG9udE5vdGlmeSkge1xuXHRcdHRoaXMuX2EgPSB0aGlzLl9kID0gMTtcblx0XHR0aGlzLl9jID0gdGhpcy5fYiA9IHRoaXMuX3R4ID0gdGhpcy5fdHkgPSAwO1xuXHRcdGlmICghX2RvbnROb3RpZnkpXG5cdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0YXBwbHk6IGZ1bmN0aW9uKHJlY3Vyc2l2ZWx5LCBfc2V0QXBwbHlNYXRyaXgpIHtcblx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcjtcblx0XHRpZiAob3duZXIpIHtcblx0XHRcdG93bmVyLnRyYW5zZm9ybShudWxsLCB0cnVlLCBCYXNlLnBpY2socmVjdXJzaXZlbHksIHRydWUpLFxuXHRcdFx0XHRcdF9zZXRBcHBseU1hdHJpeCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc0lkZW50aXR5KCk7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdHggPSBwb2ludC54LFxuXHRcdFx0eSA9IHBvaW50Lnk7XG5cdFx0dGhpcy5fdHggKz0geCAqIHRoaXMuX2EgKyB5ICogdGhpcy5fYjtcblx0XHR0aGlzLl90eSArPSB4ICogdGhpcy5fYyArIHkgKiB0aGlzLl9kO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzY2FsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNjYWxlID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHsgcmVhZE51bGw6IHRydWUgfSk7XG5cdFx0aWYgKGNlbnRlcilcblx0XHRcdHRoaXMudHJhbnNsYXRlKGNlbnRlcik7XG5cdFx0dGhpcy5fYSAqPSBzY2FsZS54O1xuXHRcdHRoaXMuX2MgKj0gc2NhbGUueDtcblx0XHR0aGlzLl9iICo9IHNjYWxlLnk7XG5cdFx0dGhpcy5fZCAqPSBzY2FsZS55O1xuXHRcdGlmIChjZW50ZXIpXG5cdFx0XHR0aGlzLnRyYW5zbGF0ZShjZW50ZXIubmVnYXRlKCkpO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyb3RhdGU6IGZ1bmN0aW9uKGFuZ2xlICkge1xuXHRcdGFuZ2xlICo9IE1hdGguUEkgLyAxODA7XG5cdFx0dmFyIGNlbnRlciA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAxKSxcblx0XHRcdHggPSBjZW50ZXIueCxcblx0XHRcdHkgPSBjZW50ZXIueSxcblx0XHRcdGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcblx0XHRcdHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcblx0XHRcdHR4ID0geCAtIHggKiBjb3MgKyB5ICogc2luLFxuXHRcdFx0dHkgPSB5IC0geCAqIHNpbiAtIHkgKiBjb3MsXG5cdFx0XHRhID0gdGhpcy5fYSxcblx0XHRcdGIgPSB0aGlzLl9iLFxuXHRcdFx0YyA9IHRoaXMuX2MsXG5cdFx0XHRkID0gdGhpcy5fZDtcblx0XHR0aGlzLl9hID0gY29zICogYSArIHNpbiAqIGI7XG5cdFx0dGhpcy5fYiA9IC1zaW4gKiBhICsgY29zICogYjtcblx0XHR0aGlzLl9jID0gY29zICogYyArIHNpbiAqIGQ7XG5cdFx0dGhpcy5fZCA9IC1zaW4gKiBjICsgY29zICogZDtcblx0XHR0aGlzLl90eCArPSB0eCAqIGEgKyB0eSAqIGI7XG5cdFx0dGhpcy5fdHkgKz0gdHggKiBjICsgdHkgKiBkO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzaGVhcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNoZWFyID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHsgcmVhZE51bGw6IHRydWUgfSk7XG5cdFx0aWYgKGNlbnRlcilcblx0XHRcdHRoaXMudHJhbnNsYXRlKGNlbnRlcik7XG5cdFx0dmFyIGEgPSB0aGlzLl9hLFxuXHRcdFx0YyA9IHRoaXMuX2M7XG5cdFx0dGhpcy5fYSArPSBzaGVhci55ICogdGhpcy5fYjtcblx0XHR0aGlzLl9jICs9IHNoZWFyLnkgKiB0aGlzLl9kO1xuXHRcdHRoaXMuX2IgKz0gc2hlYXIueCAqIGE7XG5cdFx0dGhpcy5fZCArPSBzaGVhci54ICogYztcblx0XHRpZiAoY2VudGVyKVxuXHRcdFx0dGhpcy50cmFuc2xhdGUoY2VudGVyLm5lZ2F0ZSgpKTtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2tldzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNrZXcgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwgeyByZWFkTnVsbDogdHJ1ZSB9KSxcblx0XHRcdHRvUmFkaWFucyA9IE1hdGguUEkgLyAxODAsXG5cdFx0XHRzaGVhciA9IG5ldyBQb2ludChNYXRoLnRhbihza2V3LnggKiB0b1JhZGlhbnMpLFxuXHRcdFx0XHRNYXRoLnRhbihza2V3LnkgKiB0b1JhZGlhbnMpKTtcblx0XHRyZXR1cm4gdGhpcy5zaGVhcihzaGVhciwgY2VudGVyKTtcblx0fSxcblxuXHRjb25jYXRlbmF0ZTogZnVuY3Rpb24obXgpIHtcblx0XHR2YXIgYTEgPSB0aGlzLl9hLFxuXHRcdFx0YjEgPSB0aGlzLl9iLFxuXHRcdFx0YzEgPSB0aGlzLl9jLFxuXHRcdFx0ZDEgPSB0aGlzLl9kLFxuXHRcdFx0YTIgPSBteC5fYSxcblx0XHRcdGIyID0gbXguX2IsXG5cdFx0XHRjMiA9IG14Ll9jLFxuXHRcdFx0ZDIgPSBteC5fZCxcblx0XHRcdHR4MiA9IG14Ll90eCxcblx0XHRcdHR5MiA9IG14Ll90eTtcblx0XHR0aGlzLl9hID0gYTIgKiBhMSArIGMyICogYjE7XG5cdFx0dGhpcy5fYiA9IGIyICogYTEgKyBkMiAqIGIxO1xuXHRcdHRoaXMuX2MgPSBhMiAqIGMxICsgYzIgKiBkMTtcblx0XHR0aGlzLl9kID0gYjIgKiBjMSArIGQyICogZDE7XG5cdFx0dGhpcy5fdHggKz0gdHgyICogYTEgKyB0eTIgKiBiMTtcblx0XHR0aGlzLl90eSArPSB0eDIgKiBjMSArIHR5MiAqIGQxO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRwcmVDb25jYXRlbmF0ZTogZnVuY3Rpb24obXgpIHtcblx0XHR2YXIgYTEgPSB0aGlzLl9hLFxuXHRcdFx0YjEgPSB0aGlzLl9iLFxuXHRcdFx0YzEgPSB0aGlzLl9jLFxuXHRcdFx0ZDEgPSB0aGlzLl9kLFxuXHRcdFx0dHgxID0gdGhpcy5fdHgsXG5cdFx0XHR0eTEgPSB0aGlzLl90eSxcblx0XHRcdGEyID0gbXguX2EsXG5cdFx0XHRiMiA9IG14Ll9iLFxuXHRcdFx0YzIgPSBteC5fYyxcblx0XHRcdGQyID0gbXguX2QsXG5cdFx0XHR0eDIgPSBteC5fdHgsXG5cdFx0XHR0eTIgPSBteC5fdHk7XG5cdFx0dGhpcy5fYSA9IGEyICogYTEgKyBiMiAqIGMxO1xuXHRcdHRoaXMuX2IgPSBhMiAqIGIxICsgYjIgKiBkMTtcblx0XHR0aGlzLl9jID0gYzIgKiBhMSArIGQyICogYzE7XG5cdFx0dGhpcy5fZCA9IGMyICogYjEgKyBkMiAqIGQxO1xuXHRcdHRoaXMuX3R4ID0gYTIgKiB0eDEgKyBiMiAqIHR5MSArIHR4Mjtcblx0XHR0aGlzLl90eSA9IGMyICogdHgxICsgZDIgKiB0eTEgKyB0eTI7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNoYWluOiBmdW5jdGlvbihteCkge1xuXHRcdHZhciBhMSA9IHRoaXMuX2EsXG5cdFx0XHRiMSA9IHRoaXMuX2IsXG5cdFx0XHRjMSA9IHRoaXMuX2MsXG5cdFx0XHRkMSA9IHRoaXMuX2QsXG5cdFx0XHR0eDEgPSB0aGlzLl90eCxcblx0XHRcdHR5MSA9IHRoaXMuX3R5LFxuXHRcdFx0YTIgPSBteC5fYSxcblx0XHRcdGIyID0gbXguX2IsXG5cdFx0XHRjMiA9IG14Ll9jLFxuXHRcdFx0ZDIgPSBteC5fZCxcblx0XHRcdHR4MiA9IG14Ll90eCxcblx0XHRcdHR5MiA9IG14Ll90eTtcblx0XHRyZXR1cm4gbmV3IE1hdHJpeChcblx0XHRcdFx0YTIgKiBhMSArIGMyICogYjEsXG5cdFx0XHRcdGEyICogYzEgKyBjMiAqIGQxLFxuXHRcdFx0XHRiMiAqIGExICsgZDIgKiBiMSxcblx0XHRcdFx0YjIgKiBjMSArIGQyICogZDEsXG5cdFx0XHRcdHR4MSArIHR4MiAqIGExICsgdHkyICogYjEsXG5cdFx0XHRcdHR5MSArIHR4MiAqIGMxICsgdHkyICogZDEpO1xuXHR9LFxuXG5cdGlzSWRlbnRpdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9hID09PSAxICYmIHRoaXMuX2MgPT09IDAgJiYgdGhpcy5fYiA9PT0gMCAmJiB0aGlzLl9kID09PSAxXG5cdFx0XHRcdCYmIHRoaXMuX3R4ID09PSAwICYmIHRoaXMuX3R5ID09PSAwO1xuXHR9LFxuXG5cdG9yTnVsbElmSWRlbnRpdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmlzSWRlbnRpdHkoKSA/IG51bGwgOiB0aGlzO1xuXHR9LFxuXG5cdGlzSW52ZXJ0aWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5fZ2V0RGV0ZXJtaW5hbnQoKTtcblx0fSxcblxuXHRpc1Npbmd1bGFyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2dldERldGVybWluYW50KCk7XG5cdH0sXG5cblx0dHJhbnNmb3JtOiBmdW5jdGlvbiggc3JjLCBkc3QsIGNvdW50KSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAzXG5cdFx0XHQ/IHRoaXMuX3RyYW5zZm9ybVBvaW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSlcblx0XHRcdDogdGhpcy5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMoc3JjLCBkc3QsIGNvdW50KTtcblx0fSxcblxuXHRfdHJhbnNmb3JtUG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCBkZXN0LCBfZG9udE5vdGlmeSkge1xuXHRcdHZhciB4ID0gcG9pbnQueCxcblx0XHRcdHkgPSBwb2ludC55O1xuXHRcdGlmICghZGVzdClcblx0XHRcdGRlc3QgPSBuZXcgUG9pbnQoKTtcblx0XHRyZXR1cm4gZGVzdC5zZXQoXG5cdFx0XHR4ICogdGhpcy5fYSArIHkgKiB0aGlzLl9iICsgdGhpcy5fdHgsXG5cdFx0XHR4ICogdGhpcy5fYyArIHkgKiB0aGlzLl9kICsgdGhpcy5fdHksXG5cdFx0XHRfZG9udE5vdGlmeVxuXHRcdCk7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUNvb3JkaW5hdGVzOiBmdW5jdGlvbihzcmMsIGRzdCwgY291bnQpIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRqID0gMCxcblx0XHRcdG1heCA9IDIgKiBjb3VudDtcblx0XHR3aGlsZSAoaSA8IG1heCkge1xuXHRcdFx0dmFyIHggPSBzcmNbaSsrXSxcblx0XHRcdFx0eSA9IHNyY1tpKytdO1xuXHRcdFx0ZHN0W2orK10gPSB4ICogdGhpcy5fYSArIHkgKiB0aGlzLl9iICsgdGhpcy5fdHg7XG5cdFx0XHRkc3RbaisrXSA9IHggKiB0aGlzLl9jICsgeSAqIHRoaXMuX2QgKyB0aGlzLl90eTtcblx0XHR9XG5cdFx0cmV0dXJuIGRzdDtcblx0fSxcblxuXHRfdHJhbnNmb3JtQ29ybmVyczogZnVuY3Rpb24ocmVjdCkge1xuXHRcdHZhciB4MSA9IHJlY3QueCxcblx0XHRcdHkxID0gcmVjdC55LFxuXHRcdFx0eDIgPSB4MSArIHJlY3Qud2lkdGgsXG5cdFx0XHR5MiA9IHkxICsgcmVjdC5oZWlnaHQsXG5cdFx0XHRjb29yZHMgPSBbIHgxLCB5MSwgeDIsIHkxLCB4MiwgeTIsIHgxLCB5MiBdO1xuXHRcdHJldHVybiB0aGlzLl90cmFuc2Zvcm1Db29yZGluYXRlcyhjb29yZHMsIGNvb3JkcywgNCk7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUJvdW5kczogZnVuY3Rpb24oYm91bmRzLCBkZXN0LCBfZG9udE5vdGlmeSkge1xuXHRcdHZhciBjb29yZHMgPSB0aGlzLl90cmFuc2Zvcm1Db3JuZXJzKGJvdW5kcyksXG5cdFx0XHRtaW4gPSBjb29yZHMuc2xpY2UoMCwgMiksXG5cdFx0XHRtYXggPSBjb29yZHMuc2xpY2UoKTtcblx0XHRmb3IgKHZhciBpID0gMjsgaSA8IDg7IGkrKykge1xuXHRcdFx0dmFyIHZhbCA9IGNvb3Jkc1tpXSxcblx0XHRcdFx0aiA9IGkgJiAxO1xuXHRcdFx0aWYgKHZhbCA8IG1pbltqXSlcblx0XHRcdFx0bWluW2pdID0gdmFsO1xuXHRcdFx0ZWxzZSBpZiAodmFsID4gbWF4W2pdKVxuXHRcdFx0XHRtYXhbal0gPSB2YWw7XG5cdFx0fVxuXHRcdGlmICghZGVzdClcblx0XHRcdGRlc3QgPSBuZXcgUmVjdGFuZ2xlKCk7XG5cdFx0cmV0dXJuIGRlc3Quc2V0KG1pblswXSwgbWluWzFdLCBtYXhbMF0gLSBtaW5bMF0sIG1heFsxXSAtIG1pblsxXSxcblx0XHRcdFx0X2RvbnROb3RpZnkpO1xuXHR9LFxuXG5cdGludmVyc2VUcmFuc2Zvcm06IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbnZlcnNlVHJhbnNmb3JtKFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0X2dldERldGVybWluYW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGV0ID0gdGhpcy5fYSAqIHRoaXMuX2QgLSB0aGlzLl9iICogdGhpcy5fYztcblx0XHRyZXR1cm4gaXNGaW5pdGUoZGV0KSAmJiAhTnVtZXJpY2FsLmlzWmVybyhkZXQpXG5cdFx0XHRcdCYmIGlzRmluaXRlKHRoaXMuX3R4KSAmJiBpc0Zpbml0ZSh0aGlzLl90eSlcblx0XHRcdFx0PyBkZXQgOiBudWxsO1xuXHR9LFxuXG5cdF9pbnZlcnNlVHJhbnNmb3JtOiBmdW5jdGlvbihwb2ludCwgZGVzdCwgX2RvbnROb3RpZnkpIHtcblx0XHR2YXIgZGV0ID0gdGhpcy5fZ2V0RGV0ZXJtaW5hbnQoKTtcblx0XHRpZiAoIWRldClcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdHZhciB4ID0gcG9pbnQueCAtIHRoaXMuX3R4LFxuXHRcdFx0eSA9IHBvaW50LnkgLSB0aGlzLl90eTtcblx0XHRpZiAoIWRlc3QpXG5cdFx0XHRkZXN0ID0gbmV3IFBvaW50KCk7XG5cdFx0cmV0dXJuIGRlc3Quc2V0KFxuXHRcdFx0KHggKiB0aGlzLl9kIC0geSAqIHRoaXMuX2IpIC8gZGV0LFxuXHRcdFx0KHkgKiB0aGlzLl9hIC0geCAqIHRoaXMuX2MpIC8gZGV0LFxuXHRcdFx0X2RvbnROb3RpZnlcblx0XHQpO1xuXHR9LFxuXG5cdGRlY29tcG9zZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGEgPSB0aGlzLl9hLCBiID0gdGhpcy5fYiwgYyA9IHRoaXMuX2MsIGQgPSB0aGlzLl9kO1xuXHRcdGlmIChOdW1lcmljYWwuaXNaZXJvKGEgKiBkIC0gYiAqIGMpKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR2YXIgc2NhbGVYID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuXHRcdGEgLz0gc2NhbGVYO1xuXHRcdGIgLz0gc2NhbGVYO1xuXG5cdFx0dmFyIHNoZWFyID0gYSAqIGMgKyBiICogZDtcblx0XHRjIC09IGEgKiBzaGVhcjtcblx0XHRkIC09IGIgKiBzaGVhcjtcblxuXHRcdHZhciBzY2FsZVkgPSBNYXRoLnNxcnQoYyAqIGMgKyBkICogZCk7XG5cdFx0YyAvPSBzY2FsZVk7XG5cdFx0ZCAvPSBzY2FsZVk7XG5cdFx0c2hlYXIgLz0gc2NhbGVZO1xuXG5cdFx0aWYgKGEgKiBkIDwgYiAqIGMpIHtcblx0XHRcdGEgPSAtYTtcblx0XHRcdGIgPSAtYjtcblx0XHRcdHNoZWFyID0gLXNoZWFyO1xuXHRcdFx0c2NhbGVYID0gLXNjYWxlWDtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0c2NhbGluZzogbmV3IFBvaW50KHNjYWxlWCwgc2NhbGVZKSxcblx0XHRcdHJvdGF0aW9uOiAtTWF0aC5hdGFuMihiLCBhKSAqIDE4MCAvIE1hdGguUEksXG5cdFx0XHRzaGVhcmluZzogc2hlYXJcblx0XHR9O1xuXHR9LFxuXG5cdGdldFZhbHVlczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFsgdGhpcy5fYSwgdGhpcy5fYywgdGhpcy5fYiwgdGhpcy5fZCwgdGhpcy5fdHgsIHRoaXMuX3R5IF07XG5cdH0sXG5cblx0Z2V0VHJhbnNsYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy5fdHgsIHRoaXMuX3R5KTtcblx0fSxcblxuXHRnZXRTY2FsaW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKHRoaXMuZGVjb21wb3NlKCkgfHwge30pLnNjYWxpbmc7XG5cdH0sXG5cblx0Z2V0Um90YXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAodGhpcy5kZWNvbXBvc2UoKSB8fCB7fSkucm90YXRpb247XG5cdH0sXG5cblx0aW52ZXJ0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkZXQgPSB0aGlzLl9nZXREZXRlcm1pbmFudCgpO1xuXHRcdHJldHVybiBkZXQgJiYgbmV3IE1hdHJpeChcblx0XHRcdFx0dGhpcy5fZCAvIGRldCxcblx0XHRcdFx0LXRoaXMuX2MgLyBkZXQsXG5cdFx0XHRcdC10aGlzLl9iIC8gZGV0LFxuXHRcdFx0XHR0aGlzLl9hIC8gZGV0LFxuXHRcdFx0XHQodGhpcy5fYiAqIHRoaXMuX3R5IC0gdGhpcy5fZCAqIHRoaXMuX3R4KSAvIGRldCxcblx0XHRcdFx0KHRoaXMuX2MgKiB0aGlzLl90eCAtIHRoaXMuX2EgKiB0aGlzLl90eSkgLyBkZXQpO1xuXHR9LFxuXG5cdHNoaWZ0bGVzczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBNYXRyaXgodGhpcy5fYSwgdGhpcy5fYywgdGhpcy5fYiwgdGhpcy5fZCwgMCwgMCk7XG5cdH0sXG5cblx0YXBwbHlUb0NvbnRleHQ6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdGN0eC50cmFuc2Zvcm0odGhpcy5fYSwgdGhpcy5fYywgdGhpcy5fYiwgdGhpcy5fZCwgdGhpcy5fdHgsIHRoaXMuX3R5KTtcblx0fVxufSwgQmFzZS5lYWNoKFsnYScsICdjJywgJ2InLCAnZCcsICd0eCcsICd0eSddLCBmdW5jdGlvbihuYW1lKSB7XG5cdHZhciBwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKG5hbWUpLFxuXHRcdHByb3AgPSAnXycgKyBuYW1lO1xuXHR0aGlzWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpc1twcm9wXTtcblx0fTtcblx0dGhpc1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHR0aGlzW3Byb3BdID0gdmFsdWU7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9O1xufSwge30pKTtcblxudmFyIExpbmUgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0xpbmUnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIExpbmUoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCkge1xuXHRcdHZhciBhc1ZlY3RvciA9IGZhbHNlO1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIHtcblx0XHRcdHRoaXMuX3B4ID0gYXJnMDtcblx0XHRcdHRoaXMuX3B5ID0gYXJnMTtcblx0XHRcdHRoaXMuX3Z4ID0gYXJnMjtcblx0XHRcdHRoaXMuX3Z5ID0gYXJnMztcblx0XHRcdGFzVmVjdG9yID0gYXJnNDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcHggPSBhcmcwLng7XG5cdFx0XHR0aGlzLl9weSA9IGFyZzAueTtcblx0XHRcdHRoaXMuX3Z4ID0gYXJnMS54O1xuXHRcdFx0dGhpcy5fdnkgPSBhcmcxLnk7XG5cdFx0XHRhc1ZlY3RvciA9IGFyZzI7XG5cdFx0fVxuXHRcdGlmICghYXNWZWN0b3IpIHtcblx0XHRcdHRoaXMuX3Z4IC09IHRoaXMuX3B4O1xuXHRcdFx0dGhpcy5fdnkgLT0gdGhpcy5fcHk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMuX3B4LCB0aGlzLl9weSk7XG5cdH0sXG5cblx0Z2V0VmVjdG9yOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMuX3Z4LCB0aGlzLl92eSk7XG5cdH0sXG5cblx0Z2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRWZWN0b3IoKS5nZXRMZW5ndGgoKTtcblx0fSxcblxuXHRpbnRlcnNlY3Q6IGZ1bmN0aW9uKGxpbmUsIGlzSW5maW5pdGUpIHtcblx0XHRyZXR1cm4gTGluZS5pbnRlcnNlY3QoXG5cdFx0XHRcdHRoaXMuX3B4LCB0aGlzLl9weSwgdGhpcy5fdngsIHRoaXMuX3Z5LFxuXHRcdFx0XHRsaW5lLl9weCwgbGluZS5fcHksIGxpbmUuX3Z4LCBsaW5lLl92eSxcblx0XHRcdFx0dHJ1ZSwgaXNJbmZpbml0ZSk7XG5cdH0sXG5cblx0Z2V0U2lkZTogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRyZXR1cm4gTGluZS5nZXRTaWRlKFxuXHRcdFx0XHR0aGlzLl9weCwgdGhpcy5fcHksIHRoaXMuX3Z4LCB0aGlzLl92eSxcblx0XHRcdFx0cG9pbnQueCwgcG9pbnQueSwgdHJ1ZSk7XG5cdH0sXG5cblx0Z2V0RGlzdGFuY2U6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0cmV0dXJuIE1hdGguYWJzKExpbmUuZ2V0U2lnbmVkRGlzdGFuY2UoXG5cdFx0XHRcdHRoaXMuX3B4LCB0aGlzLl9weSwgdGhpcy5fdngsIHRoaXMuX3Z5LFxuXHRcdFx0XHRwb2ludC54LCBwb2ludC55LCB0cnVlKSk7XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdGludGVyc2VjdDogZnVuY3Rpb24oYXB4LCBhcHksIGF2eCwgYXZ5LCBicHgsIGJweSwgYnZ4LCBidnksIGFzVmVjdG9yLFxuXHRcdFx0XHRpc0luZmluaXRlKSB7XG5cdFx0XHRpZiAoIWFzVmVjdG9yKSB7XG5cdFx0XHRcdGF2eCAtPSBhcHg7XG5cdFx0XHRcdGF2eSAtPSBhcHk7XG5cdFx0XHRcdGJ2eCAtPSBicHg7XG5cdFx0XHRcdGJ2eSAtPSBicHk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3Jvc3MgPSBhdnggKiBidnkgLSBhdnkgKiBidng7XG5cdFx0XHRpZiAoIU51bWVyaWNhbC5pc1plcm8oY3Jvc3MpKSB7XG5cdFx0XHRcdHZhciBkeCA9IGFweCAtIGJweCxcblx0XHRcdFx0XHRkeSA9IGFweSAtIGJweSxcblx0XHRcdFx0XHR0YSA9IChidnggKiBkeSAtIGJ2eSAqIGR4KSAvIGNyb3NzLFxuXHRcdFx0XHRcdHRiID0gKGF2eCAqIGR5IC0gYXZ5ICogZHgpIC8gY3Jvc3M7XG5cdFx0XHRcdGlmIChpc0luZmluaXRlIHx8IDAgPD0gdGEgJiYgdGEgPD0gMSAmJiAwIDw9IHRiICYmIHRiIDw9IDEpXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBQb2ludChcblx0XHRcdFx0XHRcdFx0XHRhcHggKyB0YSAqIGF2eCxcblx0XHRcdFx0XHRcdFx0XHRhcHkgKyB0YSAqIGF2eSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGdldFNpZGU6IGZ1bmN0aW9uKHB4LCBweSwgdngsIHZ5LCB4LCB5LCBhc1ZlY3Rvcikge1xuXHRcdFx0aWYgKCFhc1ZlY3Rvcikge1xuXHRcdFx0XHR2eCAtPSBweDtcblx0XHRcdFx0dnkgLT0gcHk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdjJ4ID0geCAtIHB4LFxuXHRcdFx0XHR2MnkgPSB5IC0gcHksXG5cdFx0XHRcdGNjdyA9IHYyeCAqIHZ5IC0gdjJ5ICogdng7XG5cdFx0XHRpZiAoY2N3ID09PSAwKSB7XG5cdFx0XHRcdGNjdyA9IHYyeCAqIHZ4ICsgdjJ5ICogdnk7XG5cdFx0XHRcdGlmIChjY3cgPiAwKSB7XG5cdFx0XHRcdFx0djJ4IC09IHZ4O1xuXHRcdFx0XHRcdHYyeSAtPSB2eTtcblx0XHRcdFx0XHRjY3cgPSB2MnggKiB2eCArIHYyeSAqIHZ5O1xuXHRcdFx0XHRcdGlmIChjY3cgPCAwKVxuXHRcdFx0XHRcdFx0Y2N3ID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNjdyA8IDAgPyAtMSA6IGNjdyA+IDAgPyAxIDogMDtcblx0XHR9LFxuXG5cdFx0Z2V0U2lnbmVkRGlzdGFuY2U6IGZ1bmN0aW9uKHB4LCBweSwgdngsIHZ5LCB4LCB5LCBhc1ZlY3Rvcikge1xuXHRcdFx0aWYgKCFhc1ZlY3Rvcikge1xuXHRcdFx0XHR2eCAtPSBweDtcblx0XHRcdFx0dnkgLT0gcHk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gTnVtZXJpY2FsLmlzWmVybyh2eClcblx0XHRcdFx0XHQ/IHZ5ID49IDAgPyBweCAtIHggOiB4IC0gcHhcblx0XHRcdFx0XHQ6IE51bWVyaWNhbC5pc1plcm8odnkpXG5cdFx0XHRcdFx0XHQ/IHZ4ID49IDAgPyB5IC0gcHkgOiBweSAtIHlcblx0XHRcdFx0XHRcdDogKHZ4ICogKHkgLSBweSkgLSB2eSAqICh4IC0gcHgpKSAvIE1hdGguc3FydCh2eCAqIHZ4ICsgdnkgKiB2eSk7XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIFByb2plY3QgPSBQYXBlclNjb3BlSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQcm9qZWN0Jyxcblx0X2xpc3Q6ICdwcm9qZWN0cycsXG5cdF9yZWZlcmVuY2U6ICdwcm9qZWN0JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQcm9qZWN0KGVsZW1lbnQpIHtcblx0XHRQYXBlclNjb3BlSXRlbS5jYWxsKHRoaXMsIHRydWUpO1xuXHRcdHRoaXMubGF5ZXJzID0gW107XG5cdFx0dGhpcy5fYWN0aXZlTGF5ZXIgPSBudWxsO1xuXHRcdHRoaXMuc3ltYm9scyA9IFtdO1xuXHRcdHRoaXMuX2N1cnJlbnRTdHlsZSA9IG5ldyBTdHlsZShudWxsLCBudWxsLCB0aGlzKTtcblx0XHR0aGlzLl92aWV3ID0gVmlldy5jcmVhdGUodGhpcyxcblx0XHRcdFx0ZWxlbWVudCB8fCBDYW52YXNQcm92aWRlci5nZXRDYW52YXMoMSwgMSkpO1xuXHRcdHRoaXMuX3NlbGVjdGVkSXRlbXMgPSB7fTtcblx0XHR0aGlzLl9zZWxlY3RlZEl0ZW1Db3VudCA9IDA7XG5cdFx0dGhpcy5fdXBkYXRlVmVyc2lvbiA9IDA7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgZGljdGlvbmFyeSkge1xuXHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZSh0aGlzLmxheWVycywgb3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG5cdH0sXG5cblx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSB0aGlzLmxheWVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcblx0XHRcdHRoaXMubGF5ZXJzW2ldLnJlbW92ZSgpO1xuXHRcdHRoaXMuc3ltYm9scyA9IFtdO1xuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmxheWVycy5sZW5ndGggPT09IDA7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG5cdFx0aWYgKCFyZW1vdmUuYmFzZS5jYWxsKHRoaXMpKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdGlmICh0aGlzLl92aWV3KVxuXHRcdFx0dGhpcy5fdmlldy5yZW1vdmUoKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRnZXRWaWV3OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fdmlldztcblx0fSxcblxuXHRnZXRDdXJyZW50U3R5bGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jdXJyZW50U3R5bGU7XG5cdH0sXG5cblx0c2V0Q3VycmVudFN0eWxlOiBmdW5jdGlvbihzdHlsZSkge1xuXHRcdHRoaXMuX2N1cnJlbnRTdHlsZS5pbml0aWFsaXplKHN0eWxlKTtcblx0fSxcblxuXHRnZXRJbmRleDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2luZGV4O1xuXHR9LFxuXG5cdGdldE9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zY29wZS5zZXR0aW5ncztcblx0fSxcblxuXHRnZXRBY3RpdmVMYXllcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FjdGl2ZUxheWVyIHx8IG5ldyBMYXllcih7IHByb2plY3Q6IHRoaXMgfSk7XG5cdH0sXG5cblx0Z2V0U2VsZWN0ZWRJdGVtczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGl0ZW1zID0gW107XG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fc2VsZWN0ZWRJdGVtcykge1xuXHRcdFx0dmFyIGl0ZW0gPSB0aGlzLl9zZWxlY3RlZEl0ZW1zW2lkXTtcblx0XHRcdGlmIChpdGVtLmlzSW5zZXJ0ZWQoKSlcblx0XHRcdFx0aXRlbXMucHVzaChpdGVtKTtcblx0XHR9XG5cdFx0cmV0dXJuIGl0ZW1zO1xuXHR9LFxuXG5cdGluc2VydENoaWxkOiBmdW5jdGlvbihpbmRleCwgaXRlbSwgX3ByZXNlcnZlKSB7XG5cdFx0aWYgKGl0ZW0gaW5zdGFuY2VvZiBMYXllcikge1xuXHRcdFx0aXRlbS5fcmVtb3ZlKGZhbHNlLCB0cnVlKTtcblx0XHRcdEJhc2Uuc3BsaWNlKHRoaXMubGF5ZXJzLCBbaXRlbV0sIGluZGV4LCAwKTtcblx0XHRcdGl0ZW0uX3NldFByb2plY3QodGhpcywgdHJ1ZSk7XG5cdFx0XHRpZiAodGhpcy5fY2hhbmdlcylcblx0XHRcdFx0aXRlbS5fY2hhbmdlZCg1KTtcblx0XHRcdGlmICghdGhpcy5fYWN0aXZlTGF5ZXIpXG5cdFx0XHRcdHRoaXMuX2FjdGl2ZUxheWVyID0gaXRlbTtcblx0XHR9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBJdGVtKSB7XG5cdFx0XHQodGhpcy5fYWN0aXZlTGF5ZXJcblx0XHRcdFx0fHwgdGhpcy5pbnNlcnRDaGlsZChpbmRleCwgbmV3IExheWVyKEl0ZW0uTk9fSU5TRVJUKSkpXG5cdFx0XHRcdFx0Lmluc2VydENoaWxkKGluZGV4LCBpdGVtLCBfcHJlc2VydmUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpdGVtID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIGl0ZW07XG5cdH0sXG5cblx0YWRkQ2hpbGQ6IGZ1bmN0aW9uKGl0ZW0sIF9wcmVzZXJ2ZSkge1xuXHRcdHJldHVybiB0aGlzLmluc2VydENoaWxkKHVuZGVmaW5lZCwgaXRlbSwgX3ByZXNlcnZlKTtcblx0fSxcblxuXHRfdXBkYXRlU2VsZWN0aW9uOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dmFyIGlkID0gaXRlbS5faWQsXG5cdFx0XHRzZWxlY3RlZEl0ZW1zID0gdGhpcy5fc2VsZWN0ZWRJdGVtcztcblx0XHRpZiAoaXRlbS5fc2VsZWN0ZWQpIHtcblx0XHRcdGlmIChzZWxlY3RlZEl0ZW1zW2lkXSAhPT0gaXRlbSkge1xuXHRcdFx0XHR0aGlzLl9zZWxlY3RlZEl0ZW1Db3VudCsrO1xuXHRcdFx0XHRzZWxlY3RlZEl0ZW1zW2lkXSA9IGl0ZW07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChzZWxlY3RlZEl0ZW1zW2lkXSA9PT0gaXRlbSkge1xuXHRcdFx0dGhpcy5fc2VsZWN0ZWRJdGVtQ291bnQtLTtcblx0XHRcdGRlbGV0ZSBzZWxlY3RlZEl0ZW1zW2lkXTtcblx0XHR9XG5cdH0sXG5cblx0c2VsZWN0QWxsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGF5ZXJzID0gdGhpcy5sYXllcnM7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsYXllcnMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0bGF5ZXJzW2ldLnNldEZ1bGx5U2VsZWN0ZWQodHJ1ZSk7XG5cdH0sXG5cblx0ZGVzZWxlY3RBbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWxlY3RlZEl0ZW1zID0gdGhpcy5fc2VsZWN0ZWRJdGVtcztcblx0XHRmb3IgKHZhciBpIGluIHNlbGVjdGVkSXRlbXMpXG5cdFx0XHRzZWxlY3RlZEl0ZW1zW2ldLnNldEZ1bGx5U2VsZWN0ZWQoZmFsc2UpO1xuXHR9LFxuXG5cdGhpdFRlc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdG9wdGlvbnMgPSBIaXRSZXN1bHQuZ2V0T3B0aW9ucyhCYXNlLnJlYWQoYXJndW1lbnRzKSk7XG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMubGF5ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgcmVzID0gdGhpcy5sYXllcnNbaV0uX2hpdFRlc3QocG9pbnQsIG9wdGlvbnMpO1xuXHRcdFx0aWYgKHJlcykgcmV0dXJuIHJlcztcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0SXRlbXM6IGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0cmV0dXJuIEl0ZW0uX2dldEl0ZW1zKHRoaXMubGF5ZXJzLCBtYXRjaCk7XG5cdH0sXG5cblx0Z2V0SXRlbTogZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRyZXR1cm4gSXRlbS5fZ2V0SXRlbXModGhpcy5sYXllcnMsIG1hdGNoLCBudWxsLCBudWxsLCB0cnVlKVswXSB8fCBudWxsO1xuXHR9LFxuXG5cdGltcG9ydEpTT046IGZ1bmN0aW9uKGpzb24pIHtcblx0XHR0aGlzLmFjdGl2YXRlKCk7XG5cdFx0dmFyIGxheWVyID0gdGhpcy5fYWN0aXZlTGF5ZXI7XG5cdFx0cmV0dXJuIEJhc2UuaW1wb3J0SlNPTihqc29uLCBsYXllciAmJiBsYXllci5pc0VtcHR5KCkgJiYgbGF5ZXIpO1xuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKGN0eCwgbWF0cml4LCBwaXhlbFJhdGlvKSB7XG5cdFx0dGhpcy5fdXBkYXRlVmVyc2lvbisrO1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0bWF0cml4LmFwcGx5VG9Db250ZXh0KGN0eCk7XG5cdFx0dmFyIHBhcmFtID0gbmV3IEJhc2Uoe1xuXHRcdFx0b2Zmc2V0OiBuZXcgUG9pbnQoMCwgMCksXG5cdFx0XHRwaXhlbFJhdGlvOiBwaXhlbFJhdGlvLFxuXHRcdFx0dmlld01hdHJpeDogbWF0cml4LmlzSWRlbnRpdHkoKSA/IG51bGwgOiBtYXRyaXgsXG5cdFx0XHRtYXRyaWNlczogW25ldyBNYXRyaXgoKV0sXG5cdFx0XHR1cGRhdGVNYXRyaXg6IHRydWVcblx0XHR9KTtcblx0XHRmb3IgKHZhciBpID0gMCwgbGF5ZXJzID0gdGhpcy5sYXllcnMsIGwgPSBsYXllcnMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0bGF5ZXJzW2ldLmRyYXcoY3R4LCBwYXJhbSk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblxuXHRcdGlmICh0aGlzLl9zZWxlY3RlZEl0ZW1Db3VudCA+IDApIHtcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRjdHguc3Ryb2tlV2lkdGggPSAxO1xuXHRcdFx0dmFyIGl0ZW1zID0gdGhpcy5fc2VsZWN0ZWRJdGVtcyxcblx0XHRcdFx0c2l6ZSA9IHRoaXMuX3Njb3BlLnNldHRpbmdzLmhhbmRsZVNpemUsXG5cdFx0XHRcdHZlcnNpb24gPSB0aGlzLl91cGRhdGVWZXJzaW9uO1xuXHRcdFx0Zm9yICh2YXIgaWQgaW4gaXRlbXMpXG5cdFx0XHRcdGl0ZW1zW2lkXS5fZHJhd1NlbGVjdGlvbihjdHgsIG1hdHJpeCwgc2l6ZSwgaXRlbXMsIHZlcnNpb24pO1xuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgU3ltYm9sID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdTeW1ib2wnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFN5bWJvbChpdGVtLCBkb250Q2VudGVyKSB7XG5cdFx0dGhpcy5faWQgPSBVSUQuZ2V0KCk7XG5cdFx0dGhpcy5wcm9qZWN0ID0gcGFwZXIucHJvamVjdDtcblx0XHR0aGlzLnByb2plY3Quc3ltYm9scy5wdXNoKHRoaXMpO1xuXHRcdGlmIChpdGVtKVxuXHRcdFx0dGhpcy5zZXREZWZpbml0aW9uKGl0ZW0sIGRvbnRDZW50ZXIpO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHRyZXR1cm4gZGljdGlvbmFyeS5hZGQodGhpcywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUoW3RoaXMuX2NsYXNzLCB0aGlzLl9kZWZpbml0aW9uXSxcblx0XHRcdFx0XHRvcHRpb25zLCBmYWxzZSwgZGljdGlvbmFyeSk7XG5cdFx0fSk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKGZsYWdzKSB7XG5cdFx0aWYgKGZsYWdzICYgOCkge1xuXHRcdFx0SXRlbS5fY2xlYXJCb3VuZHNDYWNoZSh0aGlzKTtcblx0XHR9XG5cdFx0aWYgKGZsYWdzICYgMSkge1xuXHRcdFx0dGhpcy5wcm9qZWN0Ll9uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0fVxuXHR9LFxuXG5cdGdldERlZmluaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9kZWZpbml0aW9uO1xuXHR9LFxuXG5cdHNldERlZmluaXRpb246IGZ1bmN0aW9uKGl0ZW0sIF9kb250Q2VudGVyKSB7XG5cdFx0aWYgKGl0ZW0uX3BhcmVudFN5bWJvbClcblx0XHRcdGl0ZW0gPSBpdGVtLmNsb25lKCk7XG5cdFx0aWYgKHRoaXMuX2RlZmluaXRpb24pXG5cdFx0XHR0aGlzLl9kZWZpbml0aW9uLl9wYXJlbnRTeW1ib2wgPSBudWxsO1xuXHRcdHRoaXMuX2RlZmluaXRpb24gPSBpdGVtO1xuXHRcdGl0ZW0ucmVtb3ZlKCk7XG5cdFx0aXRlbS5zZXRTZWxlY3RlZChmYWxzZSk7XG5cdFx0aWYgKCFfZG9udENlbnRlcilcblx0XHRcdGl0ZW0uc2V0UG9zaXRpb24obmV3IFBvaW50KCkpO1xuXHRcdGl0ZW0uX3BhcmVudFN5bWJvbCA9IHRoaXM7XG5cdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0fSxcblxuXHRwbGFjZTogZnVuY3Rpb24ocG9zaXRpb24pIHtcblx0XHRyZXR1cm4gbmV3IFBsYWNlZFN5bWJvbCh0aGlzLCBwb3NpdGlvbik7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU3ltYm9sKHRoaXMuX2RlZmluaXRpb24uY2xvbmUoZmFsc2UpKTtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKHN5bWJvbCkge1xuXHRcdHJldHVybiBzeW1ib2wgPT09IHRoaXNcblx0XHRcdFx0fHwgc3ltYm9sICYmIHRoaXMuZGVmaW5pdGlvbi5lcXVhbHMoc3ltYm9sLmRlZmluaXRpb24pXG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9XG59KTtcblxudmFyIEl0ZW0gPSBCYXNlLmV4dGVuZChFbWl0dGVyLCB7XG5cdHN0YXRpY3M6IHtcblx0XHRleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZChzcmMpIHtcblx0XHRcdGlmIChzcmMuX3NlcmlhbGl6ZUZpZWxkcylcblx0XHRcdFx0c3JjLl9zZXJpYWxpemVGaWVsZHMgPSBuZXcgQmFzZShcblx0XHRcdFx0XHRcdHRoaXMucHJvdG90eXBlLl9zZXJpYWxpemVGaWVsZHMsIHNyYy5fc2VyaWFsaXplRmllbGRzKTtcblx0XHRcdHJldHVybiBleHRlbmQuYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHROT19JTlNFUlQ6IHsgaW5zZXJ0OiBmYWxzZSB9XG5cdH0sXG5cblx0X2NsYXNzOiAnSXRlbScsXG5cdF9hcHBseU1hdHJpeDogdHJ1ZSxcblx0X2NhbkFwcGx5TWF0cml4OiB0cnVlLFxuXHRfYm91bmRzU2VsZWN0ZWQ6IGZhbHNlLFxuXHRfc2VsZWN0Q2hpbGRyZW46IGZhbHNlLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0bmFtZTogbnVsbCxcblx0XHRhcHBseU1hdHJpeDogbnVsbCxcblx0XHRtYXRyaXg6IG5ldyBNYXRyaXgoKSxcblx0XHRwaXZvdDogbnVsbCxcblx0XHRsb2NrZWQ6IGZhbHNlLFxuXHRcdHZpc2libGU6IHRydWUsXG5cdFx0YmxlbmRNb2RlOiAnbm9ybWFsJyxcblx0XHRvcGFjaXR5OiAxLFxuXHRcdGd1aWRlOiBmYWxzZSxcblx0XHRzZWxlY3RlZDogZmFsc2UsXG5cdFx0Y2xpcE1hc2s6IGZhbHNlLFxuXHRcdGRhdGE6IHt9XG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gSXRlbSgpIHtcblx0fSxcblxuXHRfaW5pdGlhbGl6ZTogZnVuY3Rpb24ocHJvcHMsIHBvaW50KSB7XG5cdFx0dmFyIGhhc1Byb3BzID0gcHJvcHMgJiYgQmFzZS5pc1BsYWluT2JqZWN0KHByb3BzKSxcblx0XHRcdGludGVybmFsID0gaGFzUHJvcHMgJiYgcHJvcHMuaW50ZXJuYWwgPT09IHRydWUsXG5cdFx0XHRtYXRyaXggPSB0aGlzLl9tYXRyaXggPSBuZXcgTWF0cml4KCksXG5cdFx0XHRwcm9qZWN0ID0gaGFzUHJvcHMgJiYgcHJvcHMucHJvamVjdCB8fCBwYXBlci5wcm9qZWN0O1xuXHRcdGlmICghaW50ZXJuYWwpXG5cdFx0XHR0aGlzLl9pZCA9IFVJRC5nZXQoKTtcblx0XHR0aGlzLl9hcHBseU1hdHJpeCA9IHRoaXMuX2NhbkFwcGx5TWF0cml4ICYmIHBhcGVyLnNldHRpbmdzLmFwcGx5TWF0cml4O1xuXHRcdGlmIChwb2ludClcblx0XHRcdG1hdHJpeC50cmFuc2xhdGUocG9pbnQpO1xuXHRcdG1hdHJpeC5fb3duZXIgPSB0aGlzO1xuXHRcdHRoaXMuX3N0eWxlID0gbmV3IFN0eWxlKHByb2plY3QuX2N1cnJlbnRTdHlsZSwgdGhpcywgcHJvamVjdCk7XG5cdFx0aWYgKCF0aGlzLl9wcm9qZWN0KSB7XG5cdFx0XHRpZiAoaW50ZXJuYWwgfHwgaGFzUHJvcHMgJiYgcHJvcHMuaW5zZXJ0ID09PSBmYWxzZSkge1xuXHRcdFx0XHR0aGlzLl9zZXRQcm9qZWN0KHByb2plY3QpO1xuXHRcdFx0fSBlbHNlIGlmIChoYXNQcm9wcyAmJiBwcm9wcy5wYXJlbnQpIHtcblx0XHRcdFx0dGhpcy5zZXRQYXJlbnQocHJvcHMucGFyZW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdChwcm9qZWN0Ll9hY3RpdmVMYXllciB8fCBuZXcgTGF5ZXIoKSkuYWRkQ2hpbGQodGhpcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChoYXNQcm9wcyAmJiBwcm9wcyAhPT0gSXRlbS5OT19JTlNFUlQpXG5cdFx0XHR0aGlzLl9zZXQocHJvcHMsIHsgaW5zZXJ0OiB0cnVlLCBwcm9qZWN0OiB0cnVlLCBwYXJlbnQ6IHRydWUgfSxcblx0XHRcdFx0XHR0cnVlKTtcblx0XHRyZXR1cm4gaGFzUHJvcHM7XG5cdH0sXG5cblx0X2V2ZW50czogbmV3IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIG1vdXNlRmxhZ3MgPSB7XG5cdFx0XHRtb3VzZWRvd246IHtcblx0XHRcdFx0bW91c2Vkb3duOiAxLFxuXHRcdFx0XHRtb3VzZWRyYWc6IDEsXG5cdFx0XHRcdGNsaWNrOiAxLFxuXHRcdFx0XHRkb3VibGVjbGljazogMVxuXHRcdFx0fSxcblx0XHRcdG1vdXNldXA6IHtcblx0XHRcdFx0bW91c2V1cDogMSxcblx0XHRcdFx0bW91c2VkcmFnOiAxLFxuXHRcdFx0XHRjbGljazogMSxcblx0XHRcdFx0ZG91YmxlY2xpY2s6IDFcblx0XHRcdH0sXG5cdFx0XHRtb3VzZW1vdmU6IHtcblx0XHRcdFx0bW91c2VkcmFnOiAxLFxuXHRcdFx0XHRtb3VzZW1vdmU6IDEsXG5cdFx0XHRcdG1vdXNlZW50ZXI6IDEsXG5cdFx0XHRcdG1vdXNlbGVhdmU6IDFcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dmFyIG1vdXNlRXZlbnQgPSB7XG5cdFx0XHRpbnN0YWxsOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRcdHZhciBjb3VudGVycyA9IHRoaXMuZ2V0VmlldygpLl9ldmVudENvdW50ZXJzO1xuXHRcdFx0XHRpZiAoY291bnRlcnMpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gbW91c2VGbGFncykge1xuXHRcdFx0XHRcdFx0Y291bnRlcnNba2V5XSA9IChjb3VudGVyc1trZXldIHx8IDApXG5cdFx0XHRcdFx0XHRcdFx0KyAobW91c2VGbGFnc1trZXldW3R5cGVdIHx8IDApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVuaW5zdGFsbDogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0XHR2YXIgY291bnRlcnMgPSB0aGlzLmdldFZpZXcoKS5fZXZlbnRDb3VudGVycztcblx0XHRcdFx0aWYgKGNvdW50ZXJzKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIG1vdXNlRmxhZ3MpXG5cdFx0XHRcdFx0XHRjb3VudGVyc1trZXldIC09IG1vdXNlRmxhZ3Nba2V5XVt0eXBlXSB8fCAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHJldHVybiBCYXNlLmVhY2goWydvbk1vdXNlRG93bicsICdvbk1vdXNlVXAnLCAnb25Nb3VzZURyYWcnLCAnb25DbGljaycsXG5cdFx0XHQnb25Eb3VibGVDbGljaycsICdvbk1vdXNlTW92ZScsICdvbk1vdXNlRW50ZXInLCAnb25Nb3VzZUxlYXZlJ10sXG5cdFx0XHRmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRcdHRoaXNbbmFtZV0gPSBtb3VzZUV2ZW50O1xuXHRcdFx0fSwge1xuXHRcdFx0XHRvbkZyYW1lOiB7XG5cdFx0XHRcdFx0aW5zdGFsbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9hbmltYXRlSXRlbSh0cnVlKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHVuaW5zdGFsbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9hbmltYXRlSXRlbShmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdG9uTG9hZDoge31cblx0XHRcdH1cblx0XHQpO1xuXHR9LFxuXG5cdF9hbmltYXRlSXRlbTogZnVuY3Rpb24oYW5pbWF0ZSkge1xuXHRcdHRoaXMuZ2V0VmlldygpLl9hbmltYXRlSXRlbSh0aGlzLCBhbmltYXRlKTtcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0dmFyIHByb3BzID0ge30sXG5cdFx0XHR0aGF0ID0gdGhpcztcblxuXHRcdGZ1bmN0aW9uIHNlcmlhbGl6ZShmaWVsZHMpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBmaWVsZHMpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gdGhhdFtrZXldO1xuXHRcdFx0XHRpZiAoIUJhc2UuZXF1YWxzKHZhbHVlLCBrZXkgPT09ICdsZWFkaW5nJ1xuXHRcdFx0XHRcdFx0PyBmaWVsZHMuZm9udFNpemUgKiAxLjIgOiBmaWVsZHNba2V5XSkpIHtcblx0XHRcdFx0XHRwcm9wc1trZXldID0gQmFzZS5zZXJpYWxpemUodmFsdWUsIG9wdGlvbnMsXG5cdFx0XHRcdFx0XHRcdGtleSAhPT0gJ2RhdGEnLCBkaWN0aW9uYXJ5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHNlcmlhbGl6ZSh0aGlzLl9zZXJpYWxpemVGaWVsZHMpO1xuXHRcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBHcm91cCkpXG5cdFx0XHRzZXJpYWxpemUodGhpcy5fc3R5bGUuX2RlZmF1bHRzKTtcblx0XHRyZXR1cm4gWyB0aGlzLl9jbGFzcywgcHJvcHMgXTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oZmxhZ3MpIHtcblx0XHR2YXIgc3ltYm9sID0gdGhpcy5fcGFyZW50U3ltYm9sLFxuXHRcdFx0Y2FjaGVQYXJlbnQgPSB0aGlzLl9wYXJlbnQgfHwgc3ltYm9sLFxuXHRcdFx0cHJvamVjdCA9IHRoaXMuX3Byb2plY3Q7XG5cdFx0aWYgKGZsYWdzICYgOCkge1xuXHRcdFx0dGhpcy5fYm91bmRzID0gdGhpcy5fcG9zaXRpb24gPSB0aGlzLl9kZWNvbXBvc2VkID1cblx0XHRcdFx0XHR0aGlzLl9nbG9iYWxNYXRyaXggPSB0aGlzLl9jdXJyZW50UGF0aCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKGNhY2hlUGFyZW50XG5cdFx0XHRcdCYmIChmbGFncyAmIDQwKSkge1xuXHRcdFx0SXRlbS5fY2xlYXJCb3VuZHNDYWNoZShjYWNoZVBhcmVudCk7XG5cdFx0fVxuXHRcdGlmIChmbGFncyAmIDIpIHtcblx0XHRcdEl0ZW0uX2NsZWFyQm91bmRzQ2FjaGUodGhpcyk7XG5cdFx0fVxuXHRcdGlmIChwcm9qZWN0KSB7XG5cdFx0XHRpZiAoZmxhZ3MgJiAxKSB7XG5cdFx0XHRcdHByb2plY3QuX25lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmIChwcm9qZWN0Ll9jaGFuZ2VzKSB7XG5cdFx0XHRcdHZhciBlbnRyeSA9IHByb2plY3QuX2NoYW5nZXNCeUlkW3RoaXMuX2lkXTtcblx0XHRcdFx0aWYgKGVudHJ5KSB7XG5cdFx0XHRcdFx0ZW50cnkuZmxhZ3MgfD0gZmxhZ3M7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZW50cnkgPSB7IGl0ZW06IHRoaXMsIGZsYWdzOiBmbGFncyB9O1xuXHRcdFx0XHRcdHByb2plY3QuX2NoYW5nZXNCeUlkW3RoaXMuX2lkXSA9IGVudHJ5O1xuXHRcdFx0XHRcdHByb2plY3QuX2NoYW5nZXMucHVzaChlbnRyeSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHN5bWJvbClcblx0XHRcdHN5bWJvbC5fY2hhbmdlZChmbGFncyk7XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbihwcm9wcykge1xuXHRcdGlmIChwcm9wcylcblx0XHRcdHRoaXMuX3NldChwcm9wcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0SWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pZDtcblx0fSxcblxuXHRnZXROYW1lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbmFtZTtcblx0fSxcblxuXHRzZXROYW1lOiBmdW5jdGlvbihuYW1lLCB1bmlxdWUpIHtcblxuXHRcdGlmICh0aGlzLl9uYW1lKVxuXHRcdFx0dGhpcy5fcmVtb3ZlTmFtZWQoKTtcblx0XHRpZiAobmFtZSA9PT0gKCtuYW1lKSArICcnKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdCdOYW1lcyBjb25zaXN0aW5nIG9ubHkgb2YgbnVtYmVycyBhcmUgbm90IHN1cHBvcnRlZC4nKTtcblx0XHR2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdGlmIChuYW1lICYmIHBhcmVudCkge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gcGFyZW50Ll9jaGlsZHJlbixcblx0XHRcdFx0bmFtZWRDaGlsZHJlbiA9IHBhcmVudC5fbmFtZWRDaGlsZHJlbixcblx0XHRcdFx0b3JpZyA9IG5hbWUsXG5cdFx0XHRcdGkgPSAxO1xuXHRcdFx0d2hpbGUgKHVuaXF1ZSAmJiBjaGlsZHJlbltuYW1lXSlcblx0XHRcdFx0bmFtZSA9IG9yaWcgKyAnICcgKyAoaSsrKTtcblx0XHRcdChuYW1lZENoaWxkcmVuW25hbWVdID0gbmFtZWRDaGlsZHJlbltuYW1lXSB8fCBbXSkucHVzaCh0aGlzKTtcblx0XHRcdGNoaWxkcmVuW25hbWVdID0gdGhpcztcblx0XHR9XG5cdFx0dGhpcy5fbmFtZSA9IG5hbWUgfHwgdW5kZWZpbmVkO1xuXHRcdHRoaXMuX2NoYW5nZWQoMTI4KTtcblx0fSxcblxuXHRnZXRTdHlsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N0eWxlO1xuXHR9LFxuXG5cdHNldFN0eWxlOiBmdW5jdGlvbihzdHlsZSkge1xuXHRcdHRoaXMuZ2V0U3R5bGUoKS5zZXQoc3R5bGUpO1xuXHR9XG59LCBCYXNlLmVhY2goWydsb2NrZWQnLCAndmlzaWJsZScsICdibGVuZE1vZGUnLCAnb3BhY2l0eScsICdndWlkZSddLFxuXHRmdW5jdGlvbihuYW1lKSB7XG5cdFx0dmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUobmFtZSksXG5cdFx0XHRuYW1lID0gJ18nICsgbmFtZTtcblx0XHR0aGlzWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzW25hbWVdO1xuXHRcdH07XG5cdFx0dGhpc1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICh2YWx1ZSAhPSB0aGlzW25hbWVdKSB7XG5cdFx0XHRcdHRoaXNbbmFtZV0gPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy5fY2hhbmdlZChuYW1lID09PSAnX2xvY2tlZCdcblx0XHRcdFx0XHRcdD8gMTI4IDogMTI5KTtcblx0XHRcdH1cblx0XHR9O1xuXHR9LFxue30pLCB7XG5cdGJlYW5zOiB0cnVlLFxuXG5cdF9sb2NrZWQ6IGZhbHNlLFxuXG5cdF92aXNpYmxlOiB0cnVlLFxuXG5cdF9ibGVuZE1vZGU6ICdub3JtYWwnLFxuXG5cdF9vcGFjaXR5OiAxLFxuXG5cdF9ndWlkZTogZmFsc2UsXG5cblx0aXNTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX3NlbGVjdENoaWxkcmVuKSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRpZiAoY2hpbGRyZW5baV0uaXNTZWxlY3RlZCgpKVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fc2VsZWN0ZWQ7XG5cdH0sXG5cblx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkLCBub0NoaWxkcmVuKSB7XG5cdFx0aWYgKCFub0NoaWxkcmVuICYmIHRoaXMuX3NlbGVjdENoaWxkcmVuKSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRjaGlsZHJlbltpXS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdFx0fVxuXHRcdGlmICgoc2VsZWN0ZWQgPSAhIXNlbGVjdGVkKSBeIHRoaXMuX3NlbGVjdGVkKSB7XG5cdFx0XHR0aGlzLl9zZWxlY3RlZCA9IHNlbGVjdGVkO1xuXHRcdFx0dGhpcy5fcHJvamVjdC5fdXBkYXRlU2VsZWN0aW9uKHRoaXMpO1xuXHRcdFx0dGhpcy5fY2hhbmdlZCgxMjkpO1xuXHRcdH1cblx0fSxcblxuXHRfc2VsZWN0ZWQ6IGZhbHNlLFxuXG5cdGlzRnVsbHlTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuICYmIHRoaXMuX3NlbGVjdGVkKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0aWYgKCFjaGlsZHJlbltpXS5pc0Z1bGx5U2VsZWN0ZWQoKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3NlbGVjdGVkO1xuXHR9LFxuXG5cdHNldEZ1bGx5U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0Y2hpbGRyZW5baV0uc2V0RnVsbHlTZWxlY3RlZChzZWxlY3RlZCk7XG5cdFx0fVxuXHRcdHRoaXMuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQsIHRydWUpO1xuXHR9LFxuXG5cdGlzQ2xpcE1hc2s6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jbGlwTWFzaztcblx0fSxcblxuXHRzZXRDbGlwTWFzazogZnVuY3Rpb24oY2xpcE1hc2spIHtcblx0XHRpZiAodGhpcy5fY2xpcE1hc2sgIT0gKGNsaXBNYXNrID0gISFjbGlwTWFzaykpIHtcblx0XHRcdHRoaXMuX2NsaXBNYXNrID0gY2xpcE1hc2s7XG5cdFx0XHRpZiAoY2xpcE1hc2spIHtcblx0XHRcdFx0dGhpcy5zZXRGaWxsQ29sb3IobnVsbCk7XG5cdFx0XHRcdHRoaXMuc2V0U3Ryb2tlQ29sb3IobnVsbCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDEyOSk7XG5cdFx0XHRpZiAodGhpcy5fcGFyZW50KVxuXHRcdFx0XHR0aGlzLl9wYXJlbnQuX2NoYW5nZWQoMTAyNCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9jbGlwTWFzazogZmFsc2UsXG5cblx0Z2V0RGF0YTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9kYXRhKVxuXHRcdFx0dGhpcy5fZGF0YSA9IHt9O1xuXHRcdHJldHVybiB0aGlzLl9kYXRhO1xuXHR9LFxuXG5cdHNldERhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHR0aGlzLl9kYXRhID0gZGF0YTtcblx0fSxcblxuXHRnZXRQb3NpdGlvbjogZnVuY3Rpb24oX2RvbnRMaW5rKSB7XG5cdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb24sXG5cdFx0XHRjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcblx0XHRpZiAoIXBvc2l0aW9uKSB7XG5cdFx0XHR2YXIgcGl2b3QgPSB0aGlzLl9waXZvdDtcblx0XHRcdHBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb24gPSBwaXZvdFxuXHRcdFx0XHRcdD8gdGhpcy5fbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChwaXZvdClcblx0XHRcdFx0XHQ6IHRoaXMuZ2V0Qm91bmRzKCkuZ2V0Q2VudGVyKHRydWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gbmV3IGN0b3IocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdGhpcywgJ3NldFBvc2l0aW9uJyk7XG5cdH0sXG5cblx0c2V0UG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudHJhbnNsYXRlKFBvaW50LnJlYWQoYXJndW1lbnRzKS5zdWJ0cmFjdCh0aGlzLmdldFBvc2l0aW9uKHRydWUpKSk7XG5cdH0sXG5cblx0Z2V0UGl2b3Q6IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdHZhciBwaXZvdCA9IHRoaXMuX3Bpdm90O1xuXHRcdGlmIChwaXZvdCkge1xuXHRcdFx0dmFyIGN0b3IgPSBfZG9udExpbmsgPyBQb2ludCA6IExpbmtlZFBvaW50O1xuXHRcdFx0cGl2b3QgPSBuZXcgY3RvcihwaXZvdC54LCBwaXZvdC55LCB0aGlzLCAnc2V0UGl2b3QnKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBpdm90O1xuXHR9LFxuXG5cdHNldFBpdm90OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9waXZvdCA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7IGNsb25lOiB0cnVlLCByZWFkTnVsbDogdHJ1ZSB9KTtcblx0XHR0aGlzLl9wb3NpdGlvbiA9IHVuZGVmaW5lZDtcblx0fSxcblxuXHRfcGl2b3Q6IG51bGwsXG59LCBCYXNlLmVhY2goWydib3VuZHMnLCAnc3Ryb2tlQm91bmRzJywgJ2hhbmRsZUJvdW5kcycsICdyb3VnaEJvdW5kcycsXG5cdFx0J2ludGVybmFsQm91bmRzJywgJ2ludGVybmFsUm91Z2hCb3VuZHMnXSxcblx0ZnVuY3Rpb24oa2V5KSB7XG5cdFx0dmFyIGdldHRlciA9ICdnZXQnICsgQmFzZS5jYXBpdGFsaXplKGtleSksXG5cdFx0XHRtYXRjaCA9IGtleS5tYXRjaCgvXmludGVybmFsKC4qKSQvKSxcblx0XHRcdGludGVybmFsR2V0dGVyID0gbWF0Y2ggPyAnZ2V0JyArIG1hdGNoWzFdIDogbnVsbDtcblx0XHR0aGlzW2dldHRlcl0gPSBmdW5jdGlvbihfbWF0cml4KSB7XG5cdFx0XHR2YXIgYm91bmRzR2V0dGVyID0gdGhpcy5fYm91bmRzR2V0dGVyLFxuXHRcdFx0XHRuYW1lID0gIWludGVybmFsR2V0dGVyICYmICh0eXBlb2YgYm91bmRzR2V0dGVyID09PSAnc3RyaW5nJ1xuXHRcdFx0XHRcdFx0PyBib3VuZHNHZXR0ZXIgOiBib3VuZHNHZXR0ZXIgJiYgYm91bmRzR2V0dGVyW2dldHRlcl0pXG5cdFx0XHRcdFx0XHR8fCBnZXR0ZXIsXG5cdFx0XHRcdGJvdW5kcyA9IHRoaXMuX2dldENhY2hlZEJvdW5kcyhuYW1lLCBfbWF0cml4LCB0aGlzLFxuXHRcdFx0XHRcdFx0aW50ZXJuYWxHZXR0ZXIpO1xuXHRcdFx0cmV0dXJuIGtleSA9PT0gJ2JvdW5kcydcblx0XHRcdFx0XHQ/IG5ldyBMaW5rZWRSZWN0YW5nbGUoYm91bmRzLngsIGJvdW5kcy55LCBib3VuZHMud2lkdGgsXG5cdFx0XHRcdFx0XHRcdGJvdW5kcy5oZWlnaHQsIHRoaXMsICdzZXRCb3VuZHMnKVxuXHRcdFx0XHRcdDogYm91bmRzO1xuXHRcdH07XG5cdH0sXG57XG5cdGJlYW5zOiB0cnVlLFxuXG5cdF9nZXRCb3VuZHM6IGZ1bmN0aW9uKGdldHRlciwgbWF0cml4LCBjYWNoZUl0ZW0pIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoIWNoaWxkcmVuIHx8IGNoaWxkcmVuLmxlbmd0aCA9PSAwKVxuXHRcdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoKTtcblx0XHRJdGVtLl91cGRhdGVCb3VuZHNDYWNoZSh0aGlzLCBjYWNoZUl0ZW0pO1xuXHRcdHZhciB4MSA9IEluZmluaXR5LFxuXHRcdFx0eDIgPSAteDEsXG5cdFx0XHR5MSA9IHgxLFxuXHRcdFx0eTIgPSB4Mjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cdFx0XHRpZiAoY2hpbGQuX3Zpc2libGUgJiYgIWNoaWxkLmlzRW1wdHkoKSkge1xuXHRcdFx0XHR2YXIgcmVjdCA9IGNoaWxkLl9nZXRDYWNoZWRCb3VuZHMoZ2V0dGVyLFxuXHRcdFx0XHRcdFx0bWF0cml4ICYmIG1hdHJpeC5jaGFpbihjaGlsZC5fbWF0cml4KSwgY2FjaGVJdGVtKTtcblx0XHRcdFx0eDEgPSBNYXRoLm1pbihyZWN0LngsIHgxKTtcblx0XHRcdFx0eTEgPSBNYXRoLm1pbihyZWN0LnksIHkxKTtcblx0XHRcdFx0eDIgPSBNYXRoLm1heChyZWN0LnggKyByZWN0LndpZHRoLCB4Mik7XG5cdFx0XHRcdHkyID0gTWF0aC5tYXgocmVjdC55ICsgcmVjdC5oZWlnaHQsIHkyKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGlzRmluaXRlKHgxKVxuXHRcdFx0XHQ/IG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKVxuXHRcdFx0XHQ6IG5ldyBSZWN0YW5nbGUoKTtcblx0fSxcblxuXHRzZXRCb3VuZHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCksXG5cdFx0XHRtYXRyaXggPSBuZXcgTWF0cml4KCksXG5cdFx0XHRjZW50ZXIgPSByZWN0LmdldENlbnRlcigpO1xuXHRcdG1hdHJpeC50cmFuc2xhdGUoY2VudGVyKTtcblx0XHRpZiAocmVjdC53aWR0aCAhPSBib3VuZHMud2lkdGggfHwgcmVjdC5oZWlnaHQgIT0gYm91bmRzLmhlaWdodCkge1xuXHRcdFx0bWF0cml4LnNjYWxlKFxuXHRcdFx0XHRcdGJvdW5kcy53aWR0aCAhPSAwID8gcmVjdC53aWR0aCAvIGJvdW5kcy53aWR0aCA6IDEsXG5cdFx0XHRcdFx0Ym91bmRzLmhlaWdodCAhPSAwID8gcmVjdC5oZWlnaHQgLyBib3VuZHMuaGVpZ2h0IDogMSk7XG5cdFx0fVxuXHRcdGNlbnRlciA9IGJvdW5kcy5nZXRDZW50ZXIoKTtcblx0XHRtYXRyaXgudHJhbnNsYXRlKC1jZW50ZXIueCwgLWNlbnRlci55KTtcblx0XHR0aGlzLnRyYW5zZm9ybShtYXRyaXgpO1xuXHR9LFxuXG5cdF9nZXRDYWNoZWRCb3VuZHM6IGZ1bmN0aW9uKGdldHRlciwgbWF0cml4LCBjYWNoZUl0ZW0sIGludGVybmFsR2V0dGVyKSB7XG5cdFx0bWF0cml4ID0gbWF0cml4ICYmIG1hdHJpeC5vck51bGxJZklkZW50aXR5KCk7XG5cdFx0dmFyIF9tYXRyaXggPSBpbnRlcm5hbEdldHRlciA/IG51bGwgOiB0aGlzLl9tYXRyaXgub3JOdWxsSWZJZGVudGl0eSgpLFxuXHRcdFx0Y2FjaGUgPSAoIW1hdHJpeCB8fCBtYXRyaXguZXF1YWxzKF9tYXRyaXgpKSAmJiBnZXR0ZXI7XG5cdFx0SXRlbS5fdXBkYXRlQm91bmRzQ2FjaGUodGhpcy5fcGFyZW50IHx8IHRoaXMuX3BhcmVudFN5bWJvbCwgY2FjaGVJdGVtKTtcblx0XHRpZiAoY2FjaGUgJiYgdGhpcy5fYm91bmRzICYmIHRoaXMuX2JvdW5kc1tjYWNoZV0pXG5cdFx0XHRyZXR1cm4gdGhpcy5fYm91bmRzW2NhY2hlXS5jbG9uZSgpO1xuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9nZXRCb3VuZHMoaW50ZXJuYWxHZXR0ZXIgfHwgZ2V0dGVyLFxuXHRcdFx0XHRtYXRyaXggfHwgX21hdHJpeCwgY2FjaGVJdGVtKTtcblx0XHRpZiAoY2FjaGUpIHtcblx0XHRcdGlmICghdGhpcy5fYm91bmRzKVxuXHRcdFx0XHR0aGlzLl9ib3VuZHMgPSB7fTtcblx0XHRcdHZhciBjYWNoZWQgPSB0aGlzLl9ib3VuZHNbY2FjaGVdID0gYm91bmRzLmNsb25lKCk7XG5cdFx0XHRjYWNoZWQuX2ludGVybmFsID0gISFpbnRlcm5hbEdldHRlcjtcblx0XHR9XG5cdFx0cmV0dXJuIGJvdW5kcztcblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0X3VwZGF0ZUJvdW5kc0NhY2hlOiBmdW5jdGlvbihwYXJlbnQsIGl0ZW0pIHtcblx0XHRcdGlmIChwYXJlbnQpIHtcblx0XHRcdFx0dmFyIGlkID0gaXRlbS5faWQsXG5cdFx0XHRcdFx0cmVmID0gcGFyZW50Ll9ib3VuZHNDYWNoZSA9IHBhcmVudC5fYm91bmRzQ2FjaGUgfHwge1xuXHRcdFx0XHRcdFx0aWRzOiB7fSxcblx0XHRcdFx0XHRcdGxpc3Q6IFtdXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKCFyZWYuaWRzW2lkXSkge1xuXHRcdFx0XHRcdHJlZi5saXN0LnB1c2goaXRlbSk7XG5cdFx0XHRcdFx0cmVmLmlkc1tpZF0gPSBpdGVtO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9jbGVhckJvdW5kc0NhY2hlOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHR2YXIgY2FjaGUgPSBpdGVtLl9ib3VuZHNDYWNoZTtcblx0XHRcdGlmIChjYWNoZSkge1xuXHRcdFx0XHRpdGVtLl9ib3VuZHMgPSBpdGVtLl9wb3NpdGlvbiA9IGl0ZW0uX2JvdW5kc0NhY2hlID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbGlzdCA9IGNhY2hlLmxpc3QsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKyl7XG5cdFx0XHRcdFx0dmFyIG90aGVyID0gbGlzdFtpXTtcblx0XHRcdFx0XHRpZiAob3RoZXIgIT09IGl0ZW0pIHtcblx0XHRcdFx0XHRcdG90aGVyLl9ib3VuZHMgPSBvdGhlci5fcG9zaXRpb24gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRpZiAob3RoZXIuX2JvdW5kc0NhY2hlKVxuXHRcdFx0XHRcdFx0XHRJdGVtLl9jbGVhckJvdW5kc0NhY2hlKG90aGVyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxufSksIHtcblx0YmVhbnM6IHRydWUsXG5cblx0X2RlY29tcG9zZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RlY29tcG9zZWQgPSB0aGlzLl9tYXRyaXguZGVjb21wb3NlKCk7XG5cdH0sXG5cblx0Z2V0Um90YXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkZWNvbXBvc2VkID0gdGhpcy5fZGVjb21wb3NlZCB8fCB0aGlzLl9kZWNvbXBvc2UoKTtcblx0XHRyZXR1cm4gZGVjb21wb3NlZCAmJiBkZWNvbXBvc2VkLnJvdGF0aW9uO1xuXHR9LFxuXG5cdHNldFJvdGF0aW9uOiBmdW5jdGlvbihyb3RhdGlvbikge1xuXHRcdHZhciBjdXJyZW50ID0gdGhpcy5nZXRSb3RhdGlvbigpO1xuXHRcdGlmIChjdXJyZW50ICE9IG51bGwgJiYgcm90YXRpb24gIT0gbnVsbCkge1xuXHRcdFx0dmFyIGRlY29tcG9zZWQgPSB0aGlzLl9kZWNvbXBvc2VkO1xuXHRcdFx0dGhpcy5yb3RhdGUocm90YXRpb24gLSBjdXJyZW50KTtcblx0XHRcdGRlY29tcG9zZWQucm90YXRpb24gPSByb3RhdGlvbjtcblx0XHRcdHRoaXMuX2RlY29tcG9zZWQgPSBkZWNvbXBvc2VkO1xuXHRcdH1cblx0fSxcblxuXHRnZXRTY2FsaW5nOiBmdW5jdGlvbihfZG9udExpbmspIHtcblx0XHR2YXIgZGVjb21wb3NlZCA9IHRoaXMuX2RlY29tcG9zZWQgfHwgdGhpcy5fZGVjb21wb3NlKCksXG5cdFx0XHRzY2FsaW5nID0gZGVjb21wb3NlZCAmJiBkZWNvbXBvc2VkLnNjYWxpbmcsXG5cdFx0XHRjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcblx0XHRyZXR1cm4gc2NhbGluZyAmJiBuZXcgY3RvcihzY2FsaW5nLngsIHNjYWxpbmcueSwgdGhpcywgJ3NldFNjYWxpbmcnKTtcblx0fSxcblxuXHRzZXRTY2FsaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VycmVudCA9IHRoaXMuZ2V0U2NhbGluZygpO1xuXHRcdGlmIChjdXJyZW50KSB7XG5cdFx0XHR2YXIgc2NhbGluZyA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7IGNsb25lOiB0cnVlIH0pLFxuXHRcdFx0XHRkZWNvbXBvc2VkID0gdGhpcy5fZGVjb21wb3NlZDtcblx0XHRcdHRoaXMuc2NhbGUoc2NhbGluZy54IC8gY3VycmVudC54LCBzY2FsaW5nLnkgLyBjdXJyZW50LnkpO1xuXHRcdFx0ZGVjb21wb3NlZC5zY2FsaW5nID0gc2NhbGluZztcblx0XHRcdHRoaXMuX2RlY29tcG9zZWQgPSBkZWNvbXBvc2VkO1xuXHRcdH1cblx0fSxcblxuXHRnZXRNYXRyaXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXRyaXg7XG5cdH0sXG5cblx0c2V0TWF0cml4OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWF0cml4ID0gdGhpcy5fbWF0cml4O1xuXHRcdG1hdHJpeC5pbml0aWFsaXplLmFwcGx5KG1hdHJpeCwgYXJndW1lbnRzKTtcblx0XHRpZiAodGhpcy5fYXBwbHlNYXRyaXgpIHtcblx0XHRcdHRoaXMudHJhbnNmb3JtKG51bGwsIHRydWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRHbG9iYWxNYXRyaXg6IGZ1bmN0aW9uKF9kb250Q2xvbmUpIHtcblx0XHR2YXIgbWF0cml4ID0gdGhpcy5fZ2xvYmFsTWF0cml4LFxuXHRcdFx0dXBkYXRlVmVyc2lvbiA9IHRoaXMuX3Byb2plY3QuX3VwZGF0ZVZlcnNpb247XG5cdFx0aWYgKG1hdHJpeCAmJiBtYXRyaXguX3VwZGF0ZVZlcnNpb24gIT09IHVwZGF0ZVZlcnNpb24pXG5cdFx0XHRtYXRyaXggPSBudWxsO1xuXHRcdGlmICghbWF0cml4KSB7XG5cdFx0XHRtYXRyaXggPSB0aGlzLl9nbG9iYWxNYXRyaXggPSB0aGlzLl9tYXRyaXguY2xvbmUoKTtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0XHRpZiAocGFyZW50KVxuXHRcdFx0XHRtYXRyaXgucHJlQ29uY2F0ZW5hdGUocGFyZW50LmdldEdsb2JhbE1hdHJpeCh0cnVlKSk7XG5cdFx0XHRtYXRyaXguX3VwZGF0ZVZlcnNpb24gPSB1cGRhdGVWZXJzaW9uO1xuXHRcdH1cblx0XHRyZXR1cm4gX2RvbnRDbG9uZSA/IG1hdHJpeCA6IG1hdHJpeC5jbG9uZSgpO1xuXHR9LFxuXG5cdGdldEFwcGx5TWF0cml4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fYXBwbHlNYXRyaXg7XG5cdH0sXG5cblx0c2V0QXBwbHlNYXRyaXg6IGZ1bmN0aW9uKGFwcGx5KSB7XG5cdFx0aWYgKHRoaXMuX2FwcGx5TWF0cml4ID0gdGhpcy5fY2FuQXBwbHlNYXRyaXggJiYgISFhcHBseSlcblx0XHRcdHRoaXMudHJhbnNmb3JtKG51bGwsIHRydWUpO1xuXHR9LFxuXG5cdGdldFRyYW5zZm9ybUNvbnRlbnQ6ICcjZ2V0QXBwbHlNYXRyaXgnLFxuXHRzZXRUcmFuc2Zvcm1Db250ZW50OiAnI3NldEFwcGx5TWF0cml4Jyxcbn0sIHtcblx0Z2V0UHJvamVjdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Byb2plY3Q7XG5cdH0sXG5cblx0X3NldFByb2plY3Q6IGZ1bmN0aW9uKHByb2plY3QsIGluc3RhbGxFdmVudHMpIHtcblx0XHRpZiAodGhpcy5fcHJvamVjdCAhPT0gcHJvamVjdCkge1xuXHRcdFx0aWYgKHRoaXMuX3Byb2plY3QpXG5cdFx0XHRcdHRoaXMuX2luc3RhbGxFdmVudHMoZmFsc2UpO1xuXHRcdFx0dGhpcy5fcHJvamVjdCA9IHByb2plY3Q7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRjaGlsZHJlbltpXS5fc2V0UHJvamVjdChwcm9qZWN0KTtcblx0XHRcdGluc3RhbGxFdmVudHMgPSB0cnVlO1xuXHRcdH1cblx0XHRpZiAoaW5zdGFsbEV2ZW50cylcblx0XHRcdHRoaXMuX2luc3RhbGxFdmVudHModHJ1ZSk7XG5cdH0sXG5cblx0Z2V0VmlldzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Byb2plY3QuZ2V0VmlldygpO1xuXHR9LFxuXG5cdF9pbnN0YWxsRXZlbnRzOiBmdW5jdGlvbiBfaW5zdGFsbEV2ZW50cyhpbnN0YWxsKSB7XG5cdFx0X2luc3RhbGxFdmVudHMuYmFzZS5jYWxsKHRoaXMsIGluc3RhbGwpO1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0Y2hpbGRyZW5baV0uX2luc3RhbGxFdmVudHMoaW5zdGFsbCk7XG5cdH0sXG5cblx0Z2V0TGF5ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzO1xuXHRcdHdoaWxlIChwYXJlbnQgPSBwYXJlbnQuX3BhcmVudCkge1xuXHRcdFx0aWYgKHBhcmVudCBpbnN0YW5jZW9mIExheWVyKVxuXHRcdFx0XHRyZXR1cm4gcGFyZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRnZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQ7XG5cdH0sXG5cblx0c2V0UGFyZW50OiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0uYWRkQ2hpbGQodGhpcyk7XG5cdH0sXG5cblx0Z2V0Q2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaGlsZHJlbjtcblx0fSxcblxuXHRzZXRDaGlsZHJlbjogZnVuY3Rpb24oaXRlbXMpIHtcblx0XHR0aGlzLnJlbW92ZUNoaWxkcmVuKCk7XG5cdFx0dGhpcy5hZGRDaGlsZHJlbihpdGVtcyk7XG5cdH0sXG5cblx0Z2V0Rmlyc3RDaGlsZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoaWxkcmVuICYmIHRoaXMuX2NoaWxkcmVuWzBdIHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0TGFzdENoaWxkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hpbGRyZW4gJiYgdGhpcy5fY2hpbGRyZW5bdGhpcy5fY2hpbGRyZW4ubGVuZ3RoIC0gMV1cblx0XHRcdFx0fHwgbnVsbDtcblx0fSxcblxuXHRnZXROZXh0U2libGluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLl9wYXJlbnQuX2NoaWxkcmVuW3RoaXMuX2luZGV4ICsgMV0gfHwgbnVsbDtcblx0fSxcblxuXHRnZXRQcmV2aW91c1NpYmxpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQgJiYgdGhpcy5fcGFyZW50Ll9jaGlsZHJlblt0aGlzLl9pbmRleCAtIDFdIHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbmRleDtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbSA9PT0gdGhpcyB8fCBpdGVtICYmIHRoaXMuX2NsYXNzID09PSBpdGVtLl9jbGFzc1xuXHRcdFx0XHQmJiB0aGlzLl9zdHlsZS5lcXVhbHMoaXRlbS5fc3R5bGUpXG5cdFx0XHRcdCYmIHRoaXMuX21hdHJpeC5lcXVhbHMoaXRlbS5fbWF0cml4KVxuXHRcdFx0XHQmJiB0aGlzLl9sb2NrZWQgPT09IGl0ZW0uX2xvY2tlZFxuXHRcdFx0XHQmJiB0aGlzLl92aXNpYmxlID09PSBpdGVtLl92aXNpYmxlXG5cdFx0XHRcdCYmIHRoaXMuX2JsZW5kTW9kZSA9PT0gaXRlbS5fYmxlbmRNb2RlXG5cdFx0XHRcdCYmIHRoaXMuX29wYWNpdHkgPT09IGl0ZW0uX29wYWNpdHlcblx0XHRcdFx0JiYgdGhpcy5fY2xpcE1hc2sgPT09IGl0ZW0uX2NsaXBNYXNrXG5cdFx0XHRcdCYmIHRoaXMuX2d1aWRlID09PSBpdGVtLl9ndWlkZVxuXHRcdFx0XHQmJiB0aGlzLl9lcXVhbHMoaXRlbSlcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0X2VxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiBCYXNlLmVxdWFscyh0aGlzLl9jaGlsZHJlbiwgaXRlbS5fY2hpbGRyZW4pO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbihpbnNlcnQpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xvbmUobmV3IHRoaXMuY29uc3RydWN0b3IoSXRlbS5OT19JTlNFUlQpLCBpbnNlcnQpO1xuXHR9LFxuXG5cdF9jbG9uZTogZnVuY3Rpb24oY29weSwgaW5zZXJ0LCBpbmNsdWRlTWF0cml4KSB7XG5cdFx0dmFyIGtleXMgPSBbJ19sb2NrZWQnLCAnX3Zpc2libGUnLCAnX2JsZW5kTW9kZScsICdfb3BhY2l0eScsXG5cdFx0XHRcdCdfY2xpcE1hc2snLCAnX2d1aWRlJ10sXG5cdFx0XHRjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGNvcHkuc2V0U3R5bGUodGhpcy5fc3R5bGUpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjb3B5LmFkZENoaWxkKGNoaWxkcmVuW2ldLmNsb25lKGZhbHNlKSwgdHJ1ZSk7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBrZXkgPSBrZXlzW2ldO1xuXHRcdFx0aWYgKHRoaXMuaGFzT3duUHJvcGVydHkoa2V5KSlcblx0XHRcdFx0Y29weVtrZXldID0gdGhpc1trZXldO1xuXHRcdH1cblx0XHRpZiAoaW5jbHVkZU1hdHJpeCAhPT0gZmFsc2UpXG5cdFx0XHRjb3B5Ll9tYXRyaXguaW5pdGlhbGl6ZSh0aGlzLl9tYXRyaXgpO1xuXHRcdGNvcHkuc2V0QXBwbHlNYXRyaXgodGhpcy5fYXBwbHlNYXRyaXgpO1xuXHRcdGNvcHkuc2V0UGl2b3QodGhpcy5fcGl2b3QpO1xuXHRcdGNvcHkuc2V0U2VsZWN0ZWQodGhpcy5fc2VsZWN0ZWQpO1xuXHRcdGNvcHkuX2RhdGEgPSB0aGlzLl9kYXRhID8gQmFzZS5jbG9uZSh0aGlzLl9kYXRhKSA6IG51bGw7XG5cdFx0aWYgKGluc2VydCB8fCBpbnNlcnQgPT09IHVuZGVmaW5lZClcblx0XHRcdGNvcHkuaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0aWYgKHRoaXMuX25hbWUpXG5cdFx0XHRjb3B5LnNldE5hbWUodGhpcy5fbmFtZSwgdHJ1ZSk7XG5cdFx0cmV0dXJuIGNvcHk7XG5cdH0sXG5cblx0Y29weVRvOiBmdW5jdGlvbihpdGVtT3JQcm9qZWN0KSB7XG5cdFx0cmV0dXJuIGl0ZW1PclByb2plY3QuYWRkQ2hpbGQodGhpcy5jbG9uZShmYWxzZSkpO1xuXHR9LFxuXG5cdHJhc3Rlcml6ZTogZnVuY3Rpb24ocmVzb2x1dGlvbikge1xuXHRcdHZhciBib3VuZHMgPSB0aGlzLmdldFN0cm9rZUJvdW5kcygpLFxuXHRcdFx0c2NhbGUgPSAocmVzb2x1dGlvbiB8fCB0aGlzLmdldFZpZXcoKS5nZXRSZXNvbHV0aW9uKCkpIC8gNzIsXG5cdFx0XHR0b3BMZWZ0ID0gYm91bmRzLmdldFRvcExlZnQoKS5mbG9vcigpLFxuXHRcdFx0Ym90dG9tUmlnaHQgPSBib3VuZHMuZ2V0Qm90dG9tUmlnaHQoKS5jZWlsKCksXG5cdFx0XHRzaXplID0gbmV3IFNpemUoYm90dG9tUmlnaHQuc3VidHJhY3QodG9wTGVmdCkpLFxuXHRcdFx0Y2FudmFzID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKHNpemUubXVsdGlwbHkoc2NhbGUpKSxcblx0XHRcdGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLFxuXHRcdFx0bWF0cml4ID0gbmV3IE1hdHJpeCgpLnNjYWxlKHNjYWxlKS50cmFuc2xhdGUodG9wTGVmdC5uZWdhdGUoKSk7XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRtYXRyaXguYXBwbHlUb0NvbnRleHQoY3R4KTtcblx0XHR0aGlzLmRyYXcoY3R4LCBuZXcgQmFzZSh7IG1hdHJpY2VzOiBbbWF0cml4XSB9KSk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR2YXIgcmFzdGVyID0gbmV3IFJhc3RlcihJdGVtLk5PX0lOU0VSVCk7XG5cdFx0cmFzdGVyLnNldENhbnZhcyhjYW52YXMpO1xuXHRcdHJhc3Rlci50cmFuc2Zvcm0obmV3IE1hdHJpeCgpLnRyYW5zbGF0ZSh0b3BMZWZ0LmFkZChzaXplLmRpdmlkZSgyKSkpXG5cdFx0XHRcdC5zY2FsZSgxIC8gc2NhbGUpKTtcblx0XHRyYXN0ZXIuaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0cmV0dXJuIHJhc3Rlcjtcblx0fSxcblxuXHRjb250YWluczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5fY29udGFpbnMoXG5cdFx0XHRcdHRoaXMuX21hdHJpeC5faW52ZXJzZVRyYW5zZm9ybShQb2ludC5yZWFkKGFyZ3VtZW50cykpKTtcblx0fSxcblxuXHRfY29udGFpbnM6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0aWYgKHRoaXMuX2NoaWxkcmVuKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0aWYgKHRoaXMuX2NoaWxkcmVuW2ldLmNvbnRhaW5zKHBvaW50KSlcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHBvaW50LmlzSW5zaWRlKHRoaXMuZ2V0SW50ZXJuYWxCb3VuZHMoKSk7XG5cdH0sXG5cblx0aXNJbnNpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLmNvbnRhaW5zKHRoaXMuZ2V0Qm91bmRzKCkpO1xuXHR9LFxuXG5cdF9hc1BhdGhJdGVtOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBhdGguUmVjdGFuZ2xlKHtcblx0XHRcdHJlY3RhbmdsZTogdGhpcy5nZXRJbnRlcm5hbEJvdW5kcygpLFxuXHRcdFx0bWF0cml4OiB0aGlzLl9tYXRyaXgsXG5cdFx0XHRpbnNlcnQ6IGZhbHNlLFxuXHRcdH0pO1xuXHR9LFxuXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uKGl0ZW0sIF9tYXRyaXgpIHtcblx0XHRpZiAoIShpdGVtIGluc3RhbmNlb2YgSXRlbSkpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0cmV0dXJuIHRoaXMuX2FzUGF0aEl0ZW0oKS5nZXRJbnRlcnNlY3Rpb25zKGl0ZW0uX2FzUGF0aEl0ZW0oKSxcblx0XHRcdFx0X21hdHJpeCB8fCBpdGVtLl9tYXRyaXgpLmxlbmd0aCA+IDA7XG5cdH0sXG5cblx0aGl0VGVzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2hpdFRlc3QoXG5cdFx0XHRcdFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0SGl0UmVzdWx0LmdldE9wdGlvbnMoQmFzZS5yZWFkKGFyZ3VtZW50cykpKTtcblx0fSxcblxuXHRfaGl0VGVzdDogZnVuY3Rpb24ocG9pbnQsIG9wdGlvbnMpIHtcblx0XHRpZiAodGhpcy5fbG9ja2VkIHx8ICF0aGlzLl92aXNpYmxlIHx8IHRoaXMuX2d1aWRlICYmICFvcHRpb25zLmd1aWRlc1xuXHRcdFx0XHR8fCB0aGlzLmlzRW1wdHkoKSlcblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0dmFyIG1hdHJpeCA9IHRoaXMuX21hdHJpeCxcblx0XHRcdHBhcmVudFRvdGFsTWF0cml4ID0gb3B0aW9ucy5fdG90YWxNYXRyaXgsXG5cdFx0XHR2aWV3ID0gdGhpcy5nZXRWaWV3KCksXG5cdFx0XHR0b3RhbE1hdHJpeCA9IG9wdGlvbnMuX3RvdGFsTWF0cml4ID0gcGFyZW50VG90YWxNYXRyaXhcblx0XHRcdFx0XHQ/IHBhcmVudFRvdGFsTWF0cml4LmNoYWluKG1hdHJpeClcblx0XHRcdFx0XHQ6IHRoaXMuZ2V0R2xvYmFsTWF0cml4KCkucHJlQ29uY2F0ZW5hdGUodmlldy5fbWF0cml4KSxcblx0XHRcdHRvbGVyYW5jZVBhZGRpbmcgPSBvcHRpb25zLl90b2xlcmFuY2VQYWRkaW5nID0gbmV3IFNpemUoXG5cdFx0XHRcdFx0XHRQYXRoLl9nZXRQZW5QYWRkaW5nKDEsIHRvdGFsTWF0cml4LmludmVydGVkKCkpXG5cdFx0XHRcdFx0KS5tdWx0aXBseShcblx0XHRcdFx0XHRcdE1hdGgubWF4KG9wdGlvbnMudG9sZXJhbmNlLCAwLjAwMDAwMSlcblx0XHRcdFx0XHQpO1xuXHRcdHBvaW50ID0gbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKHBvaW50KTtcblxuXHRcdGlmICghdGhpcy5fY2hpbGRyZW4gJiYgIXRoaXMuZ2V0SW50ZXJuYWxSb3VnaEJvdW5kcygpXG5cdFx0XHRcdC5leHBhbmQodG9sZXJhbmNlUGFkZGluZy5tdWx0aXBseSgyKSkuX2NvbnRhaW5zUG9pbnQocG9pbnQpKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0dmFyIGNoZWNrU2VsZiA9ICEob3B0aW9ucy5ndWlkZXMgJiYgIXRoaXMuX2d1aWRlXG5cdFx0XHRcdHx8IG9wdGlvbnMuc2VsZWN0ZWQgJiYgIXRoaXMuX3NlbGVjdGVkXG5cdFx0XHRcdHx8IG9wdGlvbnMudHlwZSAmJiBvcHRpb25zLnR5cGUgIT09IEJhc2UuaHlwaGVuYXRlKHRoaXMuX2NsYXNzKVxuXHRcdFx0XHR8fCBvcHRpb25zLmNsYXNzICYmICEodGhpcyBpbnN0YW5jZW9mIG9wdGlvbnMuY2xhc3MpKSxcblx0XHRcdHRoYXQgPSB0aGlzLFxuXHRcdFx0cmVzO1xuXG5cdFx0ZnVuY3Rpb24gY2hlY2tCb3VuZHModHlwZSwgcGFydCkge1xuXHRcdFx0dmFyIHB0ID0gYm91bmRzWydnZXQnICsgcGFydF0oKTtcblx0XHRcdGlmIChwb2ludC5zdWJ0cmFjdChwdCkuZGl2aWRlKHRvbGVyYW5jZVBhZGRpbmcpLmxlbmd0aCA8PSAxKVxuXHRcdFx0XHRyZXR1cm4gbmV3IEhpdFJlc3VsdCh0eXBlLCB0aGF0LFxuXHRcdFx0XHRcdFx0eyBuYW1lOiBCYXNlLmh5cGhlbmF0ZShwYXJ0KSwgcG9pbnQ6IHB0IH0pO1xuXHRcdH1cblxuXHRcdGlmIChjaGVja1NlbGYgJiYgKG9wdGlvbnMuY2VudGVyIHx8IG9wdGlvbnMuYm91bmRzKSAmJiB0aGlzLl9wYXJlbnQpIHtcblx0XHRcdHZhciBib3VuZHMgPSB0aGlzLmdldEludGVybmFsQm91bmRzKCk7XG5cdFx0XHRpZiAob3B0aW9ucy5jZW50ZXIpXG5cdFx0XHRcdHJlcyA9IGNoZWNrQm91bmRzKCdjZW50ZXInLCAnQ2VudGVyJyk7XG5cdFx0XHRpZiAoIXJlcyAmJiBvcHRpb25zLmJvdW5kcykge1xuXHRcdFx0XHR2YXIgcG9pbnRzID0gW1xuXHRcdFx0XHRcdCdUb3BMZWZ0JywgJ1RvcFJpZ2h0JywgJ0JvdHRvbUxlZnQnLCAnQm90dG9tUmlnaHQnLFxuXHRcdFx0XHRcdCdMZWZ0Q2VudGVyJywgJ1RvcENlbnRlcicsICdSaWdodENlbnRlcicsICdCb3R0b21DZW50ZXInXG5cdFx0XHRcdF07XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgOCAmJiAhcmVzOyBpKyspXG5cdFx0XHRcdFx0cmVzID0gY2hlY2tCb3VuZHMoJ2JvdW5kcycsIHBvaW50c1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGNoaWxkcmVuID0gIXJlcyAmJiB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoY2hpbGRyZW4pIHtcblx0XHRcdHZhciBvcHRzID0gdGhpcy5fZ2V0Q2hpbGRIaXRUZXN0T3B0aW9ucyhvcHRpb25zKTtcblx0XHRcdGZvciAodmFyIGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDAgJiYgIXJlczsgaS0tKVxuXHRcdFx0XHRyZXMgPSBjaGlsZHJlbltpXS5faGl0VGVzdChwb2ludCwgb3B0cyk7XG5cdFx0fVxuXHRcdGlmICghcmVzICYmIGNoZWNrU2VsZilcblx0XHRcdHJlcyA9IHRoaXMuX2hpdFRlc3RTZWxmKHBvaW50LCBvcHRpb25zKTtcblx0XHRpZiAocmVzICYmIHJlcy5wb2ludClcblx0XHRcdHJlcy5wb2ludCA9IG1hdHJpeC50cmFuc2Zvcm0ocmVzLnBvaW50KTtcblx0XHRvcHRpb25zLl90b3RhbE1hdHJpeCA9IHBhcmVudFRvdGFsTWF0cml4O1xuXHRcdHJldHVybiByZXM7XG5cdH0sXG5cblx0X2dldENoaWxkSGl0VGVzdE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gb3B0aW9ucztcblx0fSxcblxuXHRfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uKHBvaW50LCBvcHRpb25zKSB7XG5cdFx0aWYgKG9wdGlvbnMuZmlsbCAmJiB0aGlzLmhhc0ZpbGwoKSAmJiB0aGlzLl9jb250YWlucyhwb2ludCkpXG5cdFx0XHRyZXR1cm4gbmV3IEhpdFJlc3VsdCgnZmlsbCcsIHRoaXMpO1xuXHR9LFxuXG5cdG1hdGNoZXM6IGZ1bmN0aW9uKG5hbWUsIGNvbXBhcmUpIHtcblx0XHRmdW5jdGlvbiBtYXRjaE9iamVjdChvYmoxLCBvYmoyKSB7XG5cdFx0XHRmb3IgKHZhciBpIGluIG9iajEpIHtcblx0XHRcdFx0aWYgKG9iajEuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHR2YXIgdmFsMSA9IG9iajFbaV0sXG5cdFx0XHRcdFx0XHR2YWwyID0gb2JqMltpXTtcblx0XHRcdFx0XHRpZiAoQmFzZS5pc1BsYWluT2JqZWN0KHZhbDEpICYmIEJhc2UuaXNQbGFpbk9iamVjdCh2YWwyKSkge1xuXHRcdFx0XHRcdFx0aWYgKCFtYXRjaE9iamVjdCh2YWwxLCB2YWwyKSlcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIUJhc2UuZXF1YWxzKHZhbDEsIHZhbDIpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgbmFtZTtcblx0XHRpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBuYW1lKSB7XG5cdFx0XHRcdGlmIChuYW1lLmhhc093blByb3BlcnR5KGtleSkgJiYgIXRoaXMubWF0Y2hlcyhrZXksIG5hbWVba2V5XSkpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmV0dXJuIG5hbWUodGhpcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciB2YWx1ZSA9IC9eKGVtcHR5fGVkaXRhYmxlKSQvLnRlc3QobmFtZSlcblx0XHRcdFx0XHQ/IHRoaXNbJ2lzJyArIEJhc2UuY2FwaXRhbGl6ZShuYW1lKV0oKVxuXHRcdFx0XHRcdDogbmFtZSA9PT0gJ3R5cGUnXG5cdFx0XHRcdFx0XHQ/IEJhc2UuaHlwaGVuYXRlKHRoaXMuX2NsYXNzKVxuXHRcdFx0XHRcdFx0OiB0aGlzW25hbWVdO1xuXHRcdFx0aWYgKC9eKGNvbnN0cnVjdG9yfGNsYXNzKSQvLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIGNvbXBhcmUpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoY29tcGFyZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuXHRcdFx0XHRpZiAoIWNvbXBhcmUudGVzdCh2YWx1ZSkpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgY29tcGFyZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRpZiAoIWNvbXBhcmUodmFsdWUpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoQmFzZS5pc1BsYWluT2JqZWN0KGNvbXBhcmUpKSB7XG5cdFx0XHRcdGlmICghbWF0Y2hPYmplY3QoY29tcGFyZSwgdmFsdWUpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIUJhc2UuZXF1YWxzKHZhbHVlLCBjb21wYXJlKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdGdldEl0ZW1zOiBmdW5jdGlvbihtYXRjaCkge1xuXHRcdHJldHVybiBJdGVtLl9nZXRJdGVtcyh0aGlzLl9jaGlsZHJlbiwgbWF0Y2gsIHRoaXMuX21hdHJpeCk7XG5cdH0sXG5cblx0Z2V0SXRlbTogZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRyZXR1cm4gSXRlbS5fZ2V0SXRlbXModGhpcy5fY2hpbGRyZW4sIG1hdGNoLCB0aGlzLl9tYXRyaXgsIG51bGwsIHRydWUpXG5cdFx0XHRcdFswXSB8fCBudWxsO1xuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRfZ2V0SXRlbXM6IGZ1bmN0aW9uIF9nZXRJdGVtcyhjaGlsZHJlbiwgbWF0Y2gsIG1hdHJpeCwgcGFyYW0sXG5cdFx0XHRcdGZpcnN0T25seSkge1xuXHRcdFx0aWYgKCFwYXJhbSAmJiB0eXBlb2YgbWF0Y2ggPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdHZhciBvdmVybGFwcGluZyA9IG1hdGNoLm92ZXJsYXBwaW5nLFxuXHRcdFx0XHRcdGluc2lkZSA9IG1hdGNoLmluc2lkZSxcblx0XHRcdFx0XHRib3VuZHMgPSBvdmVybGFwcGluZyB8fCBpbnNpZGUsXG5cdFx0XHRcdFx0cmVjdCA9XHRib3VuZHMgJiYgUmVjdGFuZ2xlLnJlYWQoW2JvdW5kc10pO1xuXHRcdFx0XHRwYXJhbSA9IHtcblx0XHRcdFx0XHRpdGVtczogW10sXG5cdFx0XHRcdFx0aW5zaWRlOiAhIWluc2lkZSxcblx0XHRcdFx0XHRvdmVybGFwcGluZzogISFvdmVybGFwcGluZyxcblx0XHRcdFx0XHRyZWN0OiByZWN0LFxuXHRcdFx0XHRcdHBhdGg6IG92ZXJsYXBwaW5nICYmIG5ldyBQYXRoLlJlY3RhbmdsZSh7XG5cdFx0XHRcdFx0XHRyZWN0YW5nbGU6IHJlY3QsXG5cdFx0XHRcdFx0XHRpbnNlcnQ6IGZhbHNlXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKGJvdW5kcylcblx0XHRcdFx0XHRtYXRjaCA9IEJhc2Uuc2V0KHt9LCBtYXRjaCxcblx0XHRcdFx0XHRcdFx0eyBpbnNpZGU6IHRydWUsIG92ZXJsYXBwaW5nOiB0cnVlIH0pO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGl0ZW1zID0gcGFyYW0gJiYgcGFyYW0uaXRlbXMsXG5cdFx0XHRcdHJlY3QgPSBwYXJhbSAmJiBwYXJhbS5yZWN0O1xuXHRcdFx0bWF0cml4ID0gcmVjdCAmJiAobWF0cml4IHx8IG5ldyBNYXRyaXgoKSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXSxcblx0XHRcdFx0XHRjaGlsZE1hdHJpeCA9IG1hdHJpeCAmJiBtYXRyaXguY2hhaW4oY2hpbGQuX21hdHJpeCksXG5cdFx0XHRcdFx0YWRkID0gdHJ1ZTtcblx0XHRcdFx0aWYgKHJlY3QpIHtcblx0XHRcdFx0XHR2YXIgYm91bmRzID0gY2hpbGQuZ2V0Qm91bmRzKGNoaWxkTWF0cml4KTtcblx0XHRcdFx0XHRpZiAoIXJlY3QuaW50ZXJzZWN0cyhib3VuZHMpKVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0aWYgKCEocGFyYW0uaW5zaWRlICYmIHJlY3QuY29udGFpbnMoYm91bmRzKSlcblx0XHRcdFx0XHRcdFx0JiYgIShwYXJhbS5vdmVybGFwcGluZyAmJiAoYm91bmRzLmNvbnRhaW5zKHJlY3QpXG5cdFx0XHRcdFx0XHRcdFx0fHwgcGFyYW0ucGF0aC5pbnRlcnNlY3RzKGNoaWxkLCBjaGlsZE1hdHJpeCkpKSlcblx0XHRcdFx0XHRcdGFkZCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChhZGQgJiYgY2hpbGQubWF0Y2hlcyhtYXRjaCkpIHtcblx0XHRcdFx0XHRpdGVtcy5wdXNoKGNoaWxkKTtcblx0XHRcdFx0XHRpZiAoZmlyc3RPbmx5KVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0X2dldEl0ZW1zKGNoaWxkLl9jaGlsZHJlbiwgbWF0Y2gsXG5cdFx0XHRcdFx0XHRjaGlsZE1hdHJpeCwgcGFyYW0sXG5cdFx0XHRcdFx0XHRmaXJzdE9ubHkpO1xuXHRcdFx0XHRpZiAoZmlyc3RPbmx5ICYmIGl0ZW1zLmxlbmd0aCA+IDApXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaXRlbXM7XG5cdFx0fVxuXHR9XG59LCB7XG5cblx0aW1wb3J0SlNPTjogZnVuY3Rpb24oanNvbikge1xuXHRcdHZhciByZXMgPSBCYXNlLmltcG9ydEpTT04oanNvbiwgdGhpcyk7XG5cdFx0cmV0dXJuIHJlcyAhPT0gdGhpc1xuXHRcdFx0XHQ/IHRoaXMuYWRkQ2hpbGQocmVzKVxuXHRcdFx0XHQ6IHJlcztcblx0fSxcblxuXHRhZGRDaGlsZDogZnVuY3Rpb24oaXRlbSwgX3ByZXNlcnZlKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5zZXJ0Q2hpbGQodW5kZWZpbmVkLCBpdGVtLCBfcHJlc2VydmUpO1xuXHR9LFxuXG5cdGluc2VydENoaWxkOiBmdW5jdGlvbihpbmRleCwgaXRlbSwgX3ByZXNlcnZlKSB7XG5cdFx0dmFyIHJlcyA9IGl0ZW0gPyB0aGlzLmluc2VydENoaWxkcmVuKGluZGV4LCBbaXRlbV0sIF9wcmVzZXJ2ZSkgOiBudWxsO1xuXHRcdHJldHVybiByZXMgJiYgcmVzWzBdO1xuXHR9LFxuXG5cdGFkZENoaWxkcmVuOiBmdW5jdGlvbihpdGVtcywgX3ByZXNlcnZlKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5zZXJ0Q2hpbGRyZW4odGhpcy5fY2hpbGRyZW4ubGVuZ3RoLCBpdGVtcywgX3ByZXNlcnZlKTtcblx0fSxcblxuXHRpbnNlcnRDaGlsZHJlbjogZnVuY3Rpb24oaW5kZXgsIGl0ZW1zLCBfcHJlc2VydmUsIF9wcm90bykge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGlmIChjaGlsZHJlbiAmJiBpdGVtcyAmJiBpdGVtcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRpdGVtcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShpdGVtcyk7XG5cdFx0XHRmb3IgKHZhciBpID0gaXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0dmFyIGl0ZW0gPSBpdGVtc1tpXTtcblx0XHRcdFx0aWYgKF9wcm90byAmJiAhKGl0ZW0gaW5zdGFuY2VvZiBfcHJvdG8pKSB7XG5cdFx0XHRcdFx0aXRlbXMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBzaGlmdCA9IGl0ZW0uX3BhcmVudCA9PT0gdGhpcyAmJiBpdGVtLl9pbmRleCA8IGluZGV4O1xuXHRcdFx0XHRcdGlmIChpdGVtLl9yZW1vdmUoZmFsc2UsIHRydWUpICYmIHNoaWZ0KVxuXHRcdFx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0QmFzZS5zcGxpY2UoY2hpbGRyZW4sIGl0ZW1zLCBpbmRleCwgMCk7XG5cdFx0XHR2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3QsXG5cdFx0XHRcdG5vdGlmeVNlbGYgPSBwcm9qZWN0ICYmIHByb2plY3QuX2NoYW5nZXM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuXHRcdFx0XHRpdGVtLl9wYXJlbnQgPSB0aGlzO1xuXHRcdFx0XHRpdGVtLl9zZXRQcm9qZWN0KHRoaXMuX3Byb2plY3QsIHRydWUpO1xuXHRcdFx0XHRpZiAoaXRlbS5fbmFtZSlcblx0XHRcdFx0XHRpdGVtLnNldE5hbWUoaXRlbS5fbmFtZSk7XG5cdFx0XHRcdGlmIChub3RpZnlTZWxmKVxuXHRcdFx0XHRcdHRoaXMuX2NoYW5nZWQoNSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDExKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aXRlbXMgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gaXRlbXM7XG5cdH0sXG5cblx0X2luc2VydFNpYmxpbmc6IGZ1bmN0aW9uKGluZGV4LCBpdGVtLCBfcHJlc2VydmUpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50XG5cdFx0XHRcdD8gdGhpcy5fcGFyZW50Lmluc2VydENoaWxkKGluZGV4LCBpdGVtLCBfcHJlc2VydmUpXG5cdFx0XHRcdDogbnVsbDtcblx0fSxcblxuXHRpbnNlcnRBYm92ZTogZnVuY3Rpb24oaXRlbSwgX3ByZXNlcnZlKSB7XG5cdFx0cmV0dXJuIGl0ZW0uX2luc2VydFNpYmxpbmcoaXRlbS5faW5kZXggKyAxLCB0aGlzLCBfcHJlc2VydmUpO1xuXHR9LFxuXG5cdGluc2VydEJlbG93OiBmdW5jdGlvbihpdGVtLCBfcHJlc2VydmUpIHtcblx0XHRyZXR1cm4gaXRlbS5faW5zZXJ0U2libGluZyhpdGVtLl9pbmRleCwgdGhpcywgX3ByZXNlcnZlKTtcblx0fSxcblxuXHRzZW5kVG9CYWNrOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKHRoaXMuX3BhcmVudCB8fCB0aGlzIGluc3RhbmNlb2YgTGF5ZXIgJiYgdGhpcy5fcHJvamVjdClcblx0XHRcdFx0Lmluc2VydENoaWxkKDAsIHRoaXMpO1xuXHR9LFxuXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICh0aGlzLl9wYXJlbnQgfHwgdGhpcyBpbnN0YW5jZW9mIExheWVyICYmIHRoaXMuX3Byb2plY3QpXG5cdFx0XHRcdC5hZGRDaGlsZCh0aGlzKTtcblx0fSxcblxuXHRhcHBlbmRUb3A6ICcjYWRkQ2hpbGQnLFxuXG5cdGFwcGVuZEJvdHRvbTogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLmluc2VydENoaWxkKDAsIGl0ZW0pO1xuXHR9LFxuXG5cdG1vdmVBYm92ZTogJyNpbnNlcnRBYm92ZScsXG5cblx0bW92ZUJlbG93OiAnI2luc2VydEJlbG93JyxcblxuXHRyZWR1Y2U6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9jaGlsZHJlbiAmJiB0aGlzLl9jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcblx0XHRcdHZhciBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuWzBdLnJlZHVjZSgpO1xuXHRcdFx0Y2hpbGQuaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0XHRjaGlsZC5zZXRTdHlsZSh0aGlzLl9zdHlsZSk7XG5cdFx0XHR0aGlzLnJlbW92ZSgpO1xuXHRcdFx0cmV0dXJuIGNoaWxkO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfcmVtb3ZlTmFtZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0aWYgKHBhcmVudCkge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gcGFyZW50Ll9jaGlsZHJlbixcblx0XHRcdFx0bmFtZWRDaGlsZHJlbiA9IHBhcmVudC5fbmFtZWRDaGlsZHJlbixcblx0XHRcdFx0bmFtZSA9IHRoaXMuX25hbWUsXG5cdFx0XHRcdG5hbWVkQXJyYXkgPSBuYW1lZENoaWxkcmVuW25hbWVdLFxuXHRcdFx0XHRpbmRleCA9IG5hbWVkQXJyYXkgPyBuYW1lZEFycmF5LmluZGV4T2YodGhpcykgOiAtMTtcblx0XHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0aWYgKGNoaWxkcmVuW25hbWVdID09IHRoaXMpXG5cdFx0XHRcdFx0ZGVsZXRlIGNoaWxkcmVuW25hbWVdO1xuXHRcdFx0XHRuYW1lZEFycmF5LnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdGlmIChuYW1lZEFycmF5Lmxlbmd0aCkge1xuXHRcdFx0XHRcdGNoaWxkcmVuW25hbWVdID0gbmFtZWRBcnJheVtuYW1lZEFycmF5Lmxlbmd0aCAtIDFdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlbGV0ZSBuYW1lZENoaWxkcmVuW25hbWVdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmU6IGZ1bmN0aW9uKG5vdGlmeVNlbGYsIG5vdGlmeVBhcmVudCkge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0aWYgKHBhcmVudCkge1xuXHRcdFx0aWYgKHRoaXMuX25hbWUpXG5cdFx0XHRcdHRoaXMuX3JlbW92ZU5hbWVkKCk7XG5cdFx0XHRpZiAodGhpcy5faW5kZXggIT0gbnVsbClcblx0XHRcdFx0QmFzZS5zcGxpY2UocGFyZW50Ll9jaGlsZHJlbiwgbnVsbCwgdGhpcy5faW5kZXgsIDEpO1xuXHRcdFx0dGhpcy5faW5zdGFsbEV2ZW50cyhmYWxzZSk7XG5cdFx0XHRpZiAobm90aWZ5U2VsZikge1xuXHRcdFx0XHR2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3Q7XG5cdFx0XHRcdGlmIChwcm9qZWN0ICYmIHByb2plY3QuX2NoYW5nZXMpXG5cdFx0XHRcdFx0dGhpcy5fY2hhbmdlZCg1KTtcblx0XHRcdH1cblx0XHRcdGlmIChub3RpZnlQYXJlbnQpXG5cdFx0XHRcdHBhcmVudC5fY2hhbmdlZCgxMSk7XG5cdFx0XHR0aGlzLl9wYXJlbnQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9yZW1vdmUodHJ1ZSwgdHJ1ZSk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHR2YXIgb2sgPSBpdGVtICYmIGl0ZW0uaW5zZXJ0QmVsb3codGhpcyk7XG5cdFx0aWYgKG9rKVxuXHRcdFx0dGhpcy5yZW1vdmUoKTtcblx0XHRyZXR1cm4gb2s7XG5cdH0sXG5cblx0cmVtb3ZlQ2hpbGRyZW46IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG5cdFx0aWYgKCF0aGlzLl9jaGlsZHJlbilcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdGZyb20gPSBmcm9tIHx8IDA7XG5cdFx0dG8gPSBCYXNlLnBpY2sodG8sIHRoaXMuX2NoaWxkcmVuLmxlbmd0aCk7XG5cdFx0dmFyIHJlbW92ZWQgPSBCYXNlLnNwbGljZSh0aGlzLl9jaGlsZHJlbiwgbnVsbCwgZnJvbSwgdG8gLSBmcm9tKTtcblx0XHRmb3IgKHZhciBpID0gcmVtb3ZlZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0cmVtb3ZlZFtpXS5fcmVtb3ZlKHRydWUsIGZhbHNlKTtcblx0XHR9XG5cdFx0aWYgKHJlbW92ZWQubGVuZ3RoID4gMClcblx0XHRcdHRoaXMuX2NoYW5nZWQoMTEpO1xuXHRcdHJldHVybiByZW1vdmVkO1xuXHR9LFxuXG5cdGNsZWFyOiAnI3JlbW92ZUNoaWxkcmVuJyxcblxuXHRyZXZlcnNlQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9jaGlsZHJlbikge1xuXHRcdFx0dGhpcy5fY2hpbGRyZW4ucmV2ZXJzZSgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHRoaXMuX2NoaWxkcmVuW2ldLl9pbmRleCA9IGk7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDExKTtcblx0XHR9XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9jaGlsZHJlbiB8fCB0aGlzLl9jaGlsZHJlbi5sZW5ndGggPT09IDA7XG5cdH0sXG5cblx0aXNFZGl0YWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGl0ZW0gPSB0aGlzO1xuXHRcdHdoaWxlIChpdGVtKSB7XG5cdFx0XHRpZiAoIWl0ZW0uX3Zpc2libGUgfHwgaXRlbS5fbG9ja2VkKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRpdGVtID0gaXRlbS5fcGFyZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRoYXNGaWxsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTdHlsZSgpLmhhc0ZpbGwoKTtcblx0fSxcblxuXHRoYXNTdHJva2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFN0eWxlKCkuaGFzU3Ryb2tlKCk7XG5cdH0sXG5cblx0aGFzU2hhZG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTdHlsZSgpLmhhc1NoYWRvdygpO1xuXHR9LFxuXG5cdF9nZXRPcmRlcjogZnVuY3Rpb24oaXRlbSkge1xuXHRcdGZ1bmN0aW9uIGdldExpc3QoaXRlbSkge1xuXHRcdFx0dmFyIGxpc3QgPSBbXTtcblx0XHRcdGRvIHtcblx0XHRcdFx0bGlzdC51bnNoaWZ0KGl0ZW0pO1xuXHRcdFx0fSB3aGlsZSAoaXRlbSA9IGl0ZW0uX3BhcmVudCk7XG5cdFx0XHRyZXR1cm4gbGlzdDtcblx0XHR9XG5cdFx0dmFyIGxpc3QxID0gZ2V0TGlzdCh0aGlzKSxcblx0XHRcdGxpc3QyID0gZ2V0TGlzdChpdGVtKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IE1hdGgubWluKGxpc3QxLmxlbmd0aCwgbGlzdDIubGVuZ3RoKTsgaSA8IGw7IGkrKykge1xuXHRcdFx0aWYgKGxpc3QxW2ldICE9IGxpc3QyW2ldKSB7XG5cdFx0XHRcdHJldHVybiBsaXN0MVtpXS5faW5kZXggPCBsaXN0MltpXS5faW5kZXggPyAxIDogLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdGhhc0NoaWxkcmVuOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hpbGRyZW4gJiYgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoID4gMDtcblx0fSxcblxuXHRpc0luc2VydGVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmlzSW5zZXJ0ZWQoKSA6IGZhbHNlO1xuXHR9LFxuXG5cdGlzQWJvdmU6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0T3JkZXIoaXRlbSkgPT09IC0xO1xuXHR9LFxuXG5cdGlzQmVsb3c6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0T3JkZXIoaXRlbSkgPT09IDE7XG5cdH0sXG5cblx0aXNQYXJlbnQ6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ID09PSBpdGVtO1xuXHR9LFxuXG5cdGlzQ2hpbGQ6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbSAmJiBpdGVtLl9wYXJlbnQgPT09IHRoaXM7XG5cdH0sXG5cblx0aXNEZXNjZW5kYW50OiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXM7XG5cdFx0d2hpbGUgKHBhcmVudCA9IHBhcmVudC5fcGFyZW50KSB7XG5cdFx0XHRpZiAocGFyZW50ID09IGl0ZW0pXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0aXNBbmNlc3RvcjogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiBpdGVtID8gaXRlbS5pc0Rlc2NlbmRhbnQodGhpcykgOiBmYWxzZTtcblx0fSxcblxuXHRpc0dyb3VwZWRXaXRoOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHR3aGlsZSAocGFyZW50KSB7XG5cdFx0XHRpZiAocGFyZW50Ll9wYXJlbnRcblx0XHRcdFx0JiYgL14oR3JvdXB8TGF5ZXJ8Q29tcG91bmRQYXRoKSQvLnRlc3QocGFyZW50Ll9jbGFzcylcblx0XHRcdFx0JiYgaXRlbS5pc0Rlc2NlbmRhbnQocGFyZW50KSlcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0dHJhbnNsYXRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbXggPSBuZXcgTWF0cml4KCk7XG5cdFx0cmV0dXJuIHRoaXMudHJhbnNmb3JtKG14LnRyYW5zbGF0ZS5hcHBseShteCwgYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0cm90YXRlOiBmdW5jdGlvbihhbmdsZSApIHtcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm0obmV3IE1hdHJpeCgpLnJvdGF0ZShhbmdsZSxcblx0XHRcdFx0UG9pbnQucmVhZChhcmd1bWVudHMsIDEsIHsgcmVhZE51bGw6IHRydWUgfSlcblx0XHRcdFx0XHR8fCB0aGlzLmdldFBvc2l0aW9uKHRydWUpKSk7XG5cdH1cbn0sIEJhc2UuZWFjaChbJ3NjYWxlJywgJ3NoZWFyJywgJ3NrZXcnXSwgZnVuY3Rpb24obmFtZSkge1xuXHR0aGlzW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHsgcmVhZE51bGw6IHRydWUgfSk7XG5cdFx0cmV0dXJuIHRoaXMudHJhbnNmb3JtKG5ldyBNYXRyaXgoKVtuYW1lXShwb2ludCxcblx0XHRcdFx0Y2VudGVyIHx8IHRoaXMuZ2V0UG9zaXRpb24odHJ1ZSkpKTtcblx0fTtcbn0sIHtcblxufSksIHtcblx0dHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgsIF9hcHBseU1hdHJpeCwgX2FwcGx5UmVjdXJzaXZlbHksXG5cdFx0XHRfc2V0QXBwbHlNYXRyaXgpIHtcblx0XHRpZiAobWF0cml4ICYmIG1hdHJpeC5pc0lkZW50aXR5KCkpXG5cdFx0XHRtYXRyaXggPSBudWxsO1xuXHRcdHZhciBfbWF0cml4ID0gdGhpcy5fbWF0cml4LFxuXHRcdFx0YXBwbHlNYXRyaXggPSAoX2FwcGx5TWF0cml4IHx8IHRoaXMuX2FwcGx5TWF0cml4KVxuXHRcdFx0XHRcdCYmICgoIV9tYXRyaXguaXNJZGVudGl0eSgpIHx8IG1hdHJpeClcblx0XHRcdFx0XHRcdHx8IF9hcHBseU1hdHJpeCAmJiBfYXBwbHlSZWN1cnNpdmVseSAmJiB0aGlzLl9jaGlsZHJlbik7XG5cdFx0aWYgKCFtYXRyaXggJiYgIWFwcGx5TWF0cml4KVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0aWYgKG1hdHJpeClcblx0XHRcdF9tYXRyaXgucHJlQ29uY2F0ZW5hdGUobWF0cml4KTtcblx0XHRpZiAoYXBwbHlNYXRyaXggPSBhcHBseU1hdHJpeCAmJiB0aGlzLl90cmFuc2Zvcm1Db250ZW50KF9tYXRyaXgsXG5cdFx0XHRcdFx0X2FwcGx5UmVjdXJzaXZlbHksIF9zZXRBcHBseU1hdHJpeCkpIHtcblx0XHRcdHZhciBwaXZvdCA9IHRoaXMuX3Bpdm90LFxuXHRcdFx0XHRzdHlsZSA9IHRoaXMuX3N0eWxlLFxuXHRcdFx0XHRmaWxsQ29sb3IgPSBzdHlsZS5nZXRGaWxsQ29sb3IodHJ1ZSksXG5cdFx0XHRcdHN0cm9rZUNvbG9yID0gc3R5bGUuZ2V0U3Ryb2tlQ29sb3IodHJ1ZSk7XG5cdFx0XHRpZiAocGl2b3QpXG5cdFx0XHRcdF9tYXRyaXguX3RyYW5zZm9ybVBvaW50KHBpdm90LCBwaXZvdCwgdHJ1ZSk7XG5cdFx0XHRpZiAoZmlsbENvbG9yKVxuXHRcdFx0XHRmaWxsQ29sb3IudHJhbnNmb3JtKF9tYXRyaXgpO1xuXHRcdFx0aWYgKHN0cm9rZUNvbG9yKVxuXHRcdFx0XHRzdHJva2VDb2xvci50cmFuc2Zvcm0oX21hdHJpeCk7XG5cdFx0XHRfbWF0cml4LnJlc2V0KHRydWUpO1xuXHRcdFx0aWYgKF9zZXRBcHBseU1hdHJpeCAmJiB0aGlzLl9jYW5BcHBseU1hdHJpeClcblx0XHRcdFx0dGhpcy5fYXBwbHlNYXRyaXggPSB0cnVlO1xuXHRcdH1cblx0XHR2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzLFxuXHRcdFx0cG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbjtcblx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHRcdHZhciBkZWNvbXAgPSBib3VuZHMgJiYgbWF0cml4ICYmIG1hdHJpeC5kZWNvbXBvc2UoKTtcblx0XHRpZiAoZGVjb21wICYmICFkZWNvbXAuc2hlYXJpbmcgJiYgZGVjb21wLnJvdGF0aW9uICUgOTAgPT09IDApIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBib3VuZHMpIHtcblx0XHRcdFx0dmFyIHJlY3QgPSBib3VuZHNba2V5XTtcblx0XHRcdFx0aWYgKGFwcGx5TWF0cml4IHx8ICFyZWN0Ll9pbnRlcm5hbClcblx0XHRcdFx0XHRtYXRyaXguX3RyYW5zZm9ybUJvdW5kcyhyZWN0LCByZWN0KTtcblx0XHRcdH1cblx0XHRcdHZhciBnZXR0ZXIgPSB0aGlzLl9ib3VuZHNHZXR0ZXIsXG5cdFx0XHRcdHJlY3QgPSBib3VuZHNbZ2V0dGVyICYmIGdldHRlci5nZXRCb3VuZHMgfHwgZ2V0dGVyIHx8ICdnZXRCb3VuZHMnXTtcblx0XHRcdGlmIChyZWN0KVxuXHRcdFx0XHR0aGlzLl9wb3NpdGlvbiA9IHJlY3QuZ2V0Q2VudGVyKHRydWUpO1xuXHRcdFx0dGhpcy5fYm91bmRzID0gYm91bmRzO1xuXHRcdH0gZWxzZSBpZiAobWF0cml4ICYmIHBvc2l0aW9uKSB7XG5cdFx0XHR0aGlzLl9wb3NpdGlvbiA9IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQocG9zaXRpb24sIHBvc2l0aW9uKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUNvbnRlbnQ6IGZ1bmN0aW9uKG1hdHJpeCwgYXBwbHlSZWN1cnNpdmVseSwgc2V0QXBwbHlNYXRyaXgpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoY2hpbGRyZW4pIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRjaGlsZHJlbltpXS50cmFuc2Zvcm0obWF0cml4LCB0cnVlLCBhcHBseVJlY3Vyc2l2ZWx5LFxuXHRcdFx0XHRcdFx0c2V0QXBwbHlNYXRyaXgpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9LFxuXG5cdGdsb2JhbFRvTG9jYWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEdsb2JhbE1hdHJpeCh0cnVlKS5faW52ZXJzZVRyYW5zZm9ybShcblx0XHRcdFx0UG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRsb2NhbFRvR2xvYmFsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRHbG9iYWxNYXRyaXgodHJ1ZSkuX3RyYW5zZm9ybVBvaW50KFxuXHRcdFx0XHRQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdHBhcmVudFRvTG9jYWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0oUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRsb2NhbFRvUGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdGZpdEJvdW5kczogZnVuY3Rpb24ocmVjdGFuZ2xlLCBmaWxsKSB7XG5cdFx0cmVjdGFuZ2xlID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKTtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKSxcblx0XHRcdGl0ZW1SYXRpbyA9IGJvdW5kcy5oZWlnaHQgLyBib3VuZHMud2lkdGgsXG5cdFx0XHRyZWN0UmF0aW8gPSByZWN0YW5nbGUuaGVpZ2h0IC8gcmVjdGFuZ2xlLndpZHRoLFxuXHRcdFx0c2NhbGUgPSAoZmlsbCA/IGl0ZW1SYXRpbyA+IHJlY3RSYXRpbyA6IGl0ZW1SYXRpbyA8IHJlY3RSYXRpbylcblx0XHRcdFx0XHQ/IHJlY3RhbmdsZS53aWR0aCAvIGJvdW5kcy53aWR0aFxuXHRcdFx0XHRcdDogcmVjdGFuZ2xlLmhlaWdodCAvIGJvdW5kcy5oZWlnaHQsXG5cdFx0XHRuZXdCb3VuZHMgPSBuZXcgUmVjdGFuZ2xlKG5ldyBQb2ludCgpLFxuXHRcdFx0XHRcdG5ldyBTaXplKGJvdW5kcy53aWR0aCAqIHNjYWxlLCBib3VuZHMuaGVpZ2h0ICogc2NhbGUpKTtcblx0XHRuZXdCb3VuZHMuc2V0Q2VudGVyKHJlY3RhbmdsZS5nZXRDZW50ZXIoKSk7XG5cdFx0dGhpcy5zZXRCb3VuZHMobmV3Qm91bmRzKTtcblx0fSxcblxuXHRfc2V0U3R5bGVzOiBmdW5jdGlvbihjdHgpIHtcblx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdGZpbGxDb2xvciA9IHN0eWxlLmdldEZpbGxDb2xvcigpLFxuXHRcdFx0c3Ryb2tlQ29sb3IgPSBzdHlsZS5nZXRTdHJva2VDb2xvcigpLFxuXHRcdFx0c2hhZG93Q29sb3IgPSBzdHlsZS5nZXRTaGFkb3dDb2xvcigpO1xuXHRcdGlmIChmaWxsQ29sb3IpXG5cdFx0XHRjdHguZmlsbFN0eWxlID0gZmlsbENvbG9yLnRvQ2FudmFzU3R5bGUoY3R4KTtcblx0XHRpZiAoc3Ryb2tlQ29sb3IpIHtcblx0XHRcdHZhciBzdHJva2VXaWR0aCA9IHN0eWxlLmdldFN0cm9rZVdpZHRoKCk7XG5cdFx0XHRpZiAoc3Ryb2tlV2lkdGggPiAwKSB7XG5cdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZUNvbG9yLnRvQ2FudmFzU3R5bGUoY3R4KTtcblx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IHN0cm9rZVdpZHRoO1xuXHRcdFx0XHR2YXIgc3Ryb2tlSm9pbiA9IHN0eWxlLmdldFN0cm9rZUpvaW4oKSxcblx0XHRcdFx0XHRzdHJva2VDYXAgPSBzdHlsZS5nZXRTdHJva2VDYXAoKSxcblx0XHRcdFx0XHRtaXRlckxpbWl0ID0gc3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuXHRcdFx0XHRpZiAoc3Ryb2tlSm9pbilcblx0XHRcdFx0XHRjdHgubGluZUpvaW4gPSBzdHJva2VKb2luO1xuXHRcdFx0XHRpZiAoc3Ryb2tlQ2FwKVxuXHRcdFx0XHRcdGN0eC5saW5lQ2FwID0gc3Ryb2tlQ2FwO1xuXHRcdFx0XHRpZiAobWl0ZXJMaW1pdClcblx0XHRcdFx0XHRjdHgubWl0ZXJMaW1pdCA9IG1pdGVyTGltaXQ7XG5cdFx0XHRcdGlmIChwYXBlci5zdXBwb3J0Lm5hdGl2ZURhc2gpIHtcblx0XHRcdFx0XHR2YXIgZGFzaEFycmF5ID0gc3R5bGUuZ2V0RGFzaEFycmF5KCksXG5cdFx0XHRcdFx0XHRkYXNoT2Zmc2V0ID0gc3R5bGUuZ2V0RGFzaE9mZnNldCgpO1xuXHRcdFx0XHRcdGlmIChkYXNoQXJyYXkgJiYgZGFzaEFycmF5Lmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0aWYgKCdzZXRMaW5lRGFzaCcgaW4gY3R4KSB7XG5cdFx0XHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChkYXNoQXJyYXkpO1xuXHRcdFx0XHRcdFx0XHRjdHgubGluZURhc2hPZmZzZXQgPSBkYXNoT2Zmc2V0O1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y3R4Lm1vekRhc2ggPSBkYXNoQXJyYXk7XG5cdFx0XHRcdFx0XHRcdGN0eC5tb3pEYXNoT2Zmc2V0ID0gZGFzaE9mZnNldDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHNoYWRvd0NvbG9yKSB7XG5cdFx0XHR2YXIgc2hhZG93Qmx1ciA9IHN0eWxlLmdldFNoYWRvd0JsdXIoKTtcblx0XHRcdGlmIChzaGFkb3dCbHVyID4gMCkge1xuXHRcdFx0XHRjdHguc2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvci50b0NhbnZhc1N0eWxlKGN0eCk7XG5cdFx0XHRcdGN0eC5zaGFkb3dCbHVyID0gc2hhZG93Qmx1cjtcblx0XHRcdFx0dmFyIG9mZnNldCA9IHRoaXMuZ2V0U2hhZG93T2Zmc2V0KCk7XG5cdFx0XHRcdGN0eC5zaGFkb3dPZmZzZXRYID0gb2Zmc2V0Lng7XG5cdFx0XHRcdGN0eC5zaGFkb3dPZmZzZXRZID0gb2Zmc2V0Lnk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0sIHBhcmVudFN0cm9rZU1hdHJpeCkge1xuXHRcdHZhciB1cGRhdGVWZXJzaW9uID0gdGhpcy5fdXBkYXRlVmVyc2lvbiA9IHRoaXMuX3Byb2plY3QuX3VwZGF0ZVZlcnNpb247XG5cdFx0aWYgKCF0aGlzLl92aXNpYmxlIHx8IHRoaXMuX29wYWNpdHkgPT09IDApXG5cdFx0XHRyZXR1cm47XG5cdFx0dmFyIG1hdHJpY2VzID0gcGFyYW0ubWF0cmljZXMsXG5cdFx0XHR2aWV3TWF0cml4ID0gcGFyYW0udmlld01hdHJpeCxcblx0XHRcdG1hdHJpeCA9IHRoaXMuX21hdHJpeCxcblx0XHRcdGdsb2JhbE1hdHJpeCA9IG1hdHJpY2VzW21hdHJpY2VzLmxlbmd0aCAtIDFdLmNoYWluKG1hdHJpeCk7XG5cdFx0aWYgKCFnbG9iYWxNYXRyaXguaXNJbnZlcnRpYmxlKCkpXG5cdFx0XHRyZXR1cm47XG5cblx0XHRmdW5jdGlvbiBnZXRWaWV3TWF0cml4KG1hdHJpeCkge1xuXHRcdFx0cmV0dXJuIHZpZXdNYXRyaXggPyB2aWV3TWF0cml4LmNoYWluKG1hdHJpeCkgOiBtYXRyaXg7XG5cdFx0fVxuXG5cdFx0bWF0cmljZXMucHVzaChnbG9iYWxNYXRyaXgpO1xuXHRcdGlmIChwYXJhbS51cGRhdGVNYXRyaXgpIHtcblx0XHRcdGdsb2JhbE1hdHJpeC5fdXBkYXRlVmVyc2lvbiA9IHVwZGF0ZVZlcnNpb247XG5cdFx0XHR0aGlzLl9nbG9iYWxNYXRyaXggPSBnbG9iYWxNYXRyaXg7XG5cdFx0fVxuXG5cdFx0dmFyIGJsZW5kTW9kZSA9IHRoaXMuX2JsZW5kTW9kZSxcblx0XHRcdG9wYWNpdHkgPSB0aGlzLl9vcGFjaXR5LFxuXHRcdFx0bm9ybWFsQmxlbmQgPSBibGVuZE1vZGUgPT09ICdub3JtYWwnLFxuXHRcdFx0bmF0aXZlQmxlbmQgPSBCbGVuZE1vZGUubmF0aXZlTW9kZXNbYmxlbmRNb2RlXSxcblx0XHRcdGRpcmVjdCA9IG5vcm1hbEJsZW5kICYmIG9wYWNpdHkgPT09IDFcblx0XHRcdFx0XHR8fCBwYXJhbS5kb250U3RhcnRcblx0XHRcdFx0XHR8fCBwYXJhbS5jbGlwXG5cdFx0XHRcdFx0fHwgKG5hdGl2ZUJsZW5kIHx8IG5vcm1hbEJsZW5kICYmIG9wYWNpdHkgPCAxKVxuXHRcdFx0XHRcdFx0JiYgdGhpcy5fY2FuQ29tcG9zaXRlKCksXG5cdFx0XHRwaXhlbFJhdGlvID0gcGFyYW0ucGl4ZWxSYXRpbyB8fCAxLFxuXHRcdFx0bWFpbkN0eCwgaXRlbU9mZnNldCwgcHJldk9mZnNldDtcblx0XHRpZiAoIWRpcmVjdCkge1xuXHRcdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0U3Ryb2tlQm91bmRzKGdldFZpZXdNYXRyaXgoZ2xvYmFsTWF0cml4KSk7XG5cdFx0XHRpZiAoIWJvdW5kcy53aWR0aCB8fCAhYm91bmRzLmhlaWdodClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0cHJldk9mZnNldCA9IHBhcmFtLm9mZnNldDtcblx0XHRcdGl0ZW1PZmZzZXQgPSBwYXJhbS5vZmZzZXQgPSBib3VuZHMuZ2V0VG9wTGVmdCgpLmZsb29yKCk7XG5cdFx0XHRtYWluQ3R4ID0gY3R4O1xuXHRcdFx0Y3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dChib3VuZHMuZ2V0U2l6ZSgpLmNlaWwoKS5hZGQoMSlcblx0XHRcdFx0XHQubXVsdGlwbHkocGl4ZWxSYXRpbykpO1xuXHRcdFx0aWYgKHBpeGVsUmF0aW8gIT09IDEpXG5cdFx0XHRcdGN0eC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcblx0XHR9XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHR2YXIgc3Ryb2tlTWF0cml4ID0gcGFyZW50U3Ryb2tlTWF0cml4XG5cdFx0XHRcdD8gcGFyZW50U3Ryb2tlTWF0cml4LmNoYWluKG1hdHJpeClcblx0XHRcdFx0OiAhdGhpcy5nZXRTdHJva2VTY2FsaW5nKHRydWUpICYmIGdldFZpZXdNYXRyaXgoZ2xvYmFsTWF0cml4KSxcblx0XHRcdGNsaXAgPSAhZGlyZWN0ICYmIHBhcmFtLmNsaXBJdGVtLFxuXHRcdFx0dHJhbnNmb3JtID0gIXN0cm9rZU1hdHJpeCB8fCBjbGlwO1xuXHRcdGlmIChkaXJlY3QpIHtcblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG5cdFx0XHRpZiAobmF0aXZlQmxlbmQpXG5cdFx0XHRcdGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBibGVuZE1vZGU7XG5cdFx0fSBlbHNlIGlmICh0cmFuc2Zvcm0pIHtcblx0XHRcdGN0eC50cmFuc2xhdGUoLWl0ZW1PZmZzZXQueCwgLWl0ZW1PZmZzZXQueSk7XG5cdFx0fVxuXHRcdGlmICh0cmFuc2Zvcm0pXG5cdFx0XHQoZGlyZWN0ID8gbWF0cml4IDogZ2V0Vmlld01hdHJpeChnbG9iYWxNYXRyaXgpKS5hcHBseVRvQ29udGV4dChjdHgpO1xuXHRcdGlmIChjbGlwKVxuXHRcdFx0cGFyYW0uY2xpcEl0ZW0uZHJhdyhjdHgsIHBhcmFtLmV4dGVuZCh7IGNsaXA6IHRydWUgfSkpO1xuXHRcdGlmIChzdHJva2VNYXRyaXgpIHtcblx0XHRcdGN0eC5zZXRUcmFuc2Zvcm0ocGl4ZWxSYXRpbywgMCwgMCwgcGl4ZWxSYXRpbywgMCwgMCk7XG5cdFx0XHR2YXIgb2Zmc2V0ID0gcGFyYW0ub2Zmc2V0O1xuXHRcdFx0aWYgKG9mZnNldClcblx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSgtb2Zmc2V0LngsIC1vZmZzZXQueSk7XG5cdFx0fVxuXHRcdHRoaXMuX2RyYXcoY3R4LCBwYXJhbSwgc3Ryb2tlTWF0cml4KTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdG1hdHJpY2VzLnBvcCgpO1xuXHRcdGlmIChwYXJhbS5jbGlwICYmICFwYXJhbS5kb250RmluaXNoKVxuXHRcdFx0Y3R4LmNsaXAoKTtcblx0XHRpZiAoIWRpcmVjdCkge1xuXHRcdFx0QmxlbmRNb2RlLnByb2Nlc3MoYmxlbmRNb2RlLCBjdHgsIG1haW5DdHgsIG9wYWNpdHksXG5cdFx0XHRcdFx0aXRlbU9mZnNldC5zdWJ0cmFjdChwcmV2T2Zmc2V0KS5tdWx0aXBseShwaXhlbFJhdGlvKSk7XG5cdFx0XHRDYW52YXNQcm92aWRlci5yZWxlYXNlKGN0eCk7XG5cdFx0XHRwYXJhbS5vZmZzZXQgPSBwcmV2T2Zmc2V0O1xuXHRcdH1cblx0fSxcblxuXHRfaXNVcGRhdGVkOiBmdW5jdGlvbih1cGRhdGVWZXJzaW9uKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHRpZiAocGFyZW50IGluc3RhbmNlb2YgQ29tcG91bmRQYXRoKVxuXHRcdFx0cmV0dXJuIHBhcmVudC5faXNVcGRhdGVkKHVwZGF0ZVZlcnNpb24pO1xuXHRcdHZhciB1cGRhdGVkID0gdGhpcy5fdXBkYXRlVmVyc2lvbiA9PT0gdXBkYXRlVmVyc2lvbjtcblx0XHRpZiAoIXVwZGF0ZWQgJiYgcGFyZW50ICYmIHBhcmVudC5fdmlzaWJsZVxuXHRcdFx0XHQmJiBwYXJlbnQuX2lzVXBkYXRlZCh1cGRhdGVWZXJzaW9uKSkge1xuXHRcdFx0dGhpcy5fdXBkYXRlVmVyc2lvbiA9IHVwZGF0ZVZlcnNpb247XG5cdFx0XHR1cGRhdGVkID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIHVwZGF0ZWQ7XG5cdH0sXG5cblx0X2RyYXdTZWxlY3Rpb246IGZ1bmN0aW9uKGN0eCwgbWF0cml4LCBzaXplLCBzZWxlY3RlZEl0ZW1zLCB1cGRhdGVWZXJzaW9uKSB7XG5cdFx0aWYgKCh0aGlzLl9kcmF3U2VsZWN0ZWQgfHwgdGhpcy5fYm91bmRzU2VsZWN0ZWQpXG5cdFx0XHRcdCYmIHRoaXMuX2lzVXBkYXRlZCh1cGRhdGVWZXJzaW9uKSkge1xuXHRcdFx0dmFyIGNvbG9yID0gdGhpcy5nZXRTZWxlY3RlZENvbG9yKHRydWUpXG5cdFx0XHRcdFx0fHwgdGhpcy5nZXRMYXllcigpLmdldFNlbGVjdGVkQ29sb3IodHJ1ZSksXG5cdFx0XHRcdG14ID0gbWF0cml4LmNoYWluKHRoaXMuZ2V0R2xvYmFsTWF0cml4KHRydWUpKTtcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGUgPSBjb2xvclxuXHRcdFx0XHRcdD8gY29sb3IudG9DYW52YXNTdHlsZShjdHgpIDogJyMwMDlkZWMnO1xuXHRcdFx0aWYgKHRoaXMuX2RyYXdTZWxlY3RlZClcblx0XHRcdFx0dGhpcy5fZHJhd1NlbGVjdGVkKGN0eCwgbXgsIHNlbGVjdGVkSXRlbXMpO1xuXHRcdFx0aWYgKHRoaXMuX2JvdW5kc1NlbGVjdGVkKSB7XG5cdFx0XHRcdHZhciBoYWxmID0gc2l6ZSAvIDI7XG5cdFx0XHRcdFx0Y29vcmRzID0gbXguX3RyYW5zZm9ybUNvcm5lcnModGhpcy5nZXRJbnRlcm5hbEJvdW5kcygpKTtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKylcblx0XHRcdFx0XHRjdHhbaSA9PT0gMCA/ICdtb3ZlVG8nIDogJ2xpbmVUbyddKGNvb3Jkc1tpXSwgY29vcmRzWysraV0pO1xuXHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspXG5cdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KGNvb3Jkc1tpXSAtIGhhbGYsIGNvb3Jkc1srK2ldIC0gaGFsZixcblx0XHRcdFx0XHRcdFx0c2l6ZSwgc2l6ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9jYW5Db21wb3NpdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSwgQmFzZS5lYWNoKFsnZG93bicsICdkcmFnJywgJ3VwJywgJ21vdmUnXSwgZnVuY3Rpb24obmFtZSkge1xuXHR0aGlzWydyZW1vdmVPbicgKyBCYXNlLmNhcGl0YWxpemUobmFtZSldID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhhc2ggPSB7fTtcblx0XHRoYXNoW25hbWVdID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcy5yZW1vdmVPbihoYXNoKTtcblx0fTtcbn0sIHtcblxuXHRyZW1vdmVPbjogZnVuY3Rpb24ob2JqKSB7XG5cdFx0Zm9yICh2YXIgbmFtZSBpbiBvYmopIHtcblx0XHRcdGlmIChvYmpbbmFtZV0pIHtcblx0XHRcdFx0dmFyIGtleSA9ICdtb3VzZScgKyBuYW1lLFxuXHRcdFx0XHRcdHByb2plY3QgPSB0aGlzLl9wcm9qZWN0LFxuXHRcdFx0XHRcdHNldHMgPSBwcm9qZWN0Ll9yZW1vdmVTZXRzID0gcHJvamVjdC5fcmVtb3ZlU2V0cyB8fCB7fTtcblx0XHRcdFx0c2V0c1trZXldID0gc2V0c1trZXldIHx8IHt9O1xuXHRcdFx0XHRzZXRzW2tleV1bdGhpcy5faWRdID0gdGhpcztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pKTtcblxudmFyIEdyb3VwID0gSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdHcm91cCcsXG5cdF9zZWxlY3RDaGlsZHJlbjogdHJ1ZSxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdGNoaWxkcmVuOiBbXVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEdyb3VwKGFyZykge1xuXHRcdHRoaXMuX2NoaWxkcmVuID0gW107XG5cdFx0dGhpcy5fbmFtZWRDaGlsZHJlbiA9IHt9O1xuXHRcdGlmICghdGhpcy5faW5pdGlhbGl6ZShhcmcpKVxuXHRcdFx0dGhpcy5hZGRDaGlsZHJlbihBcnJheS5pc0FycmF5KGFyZykgPyBhcmcgOiBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbiBfY2hhbmdlZChmbGFncykge1xuXHRcdF9jaGFuZ2VkLmJhc2UuY2FsbCh0aGlzLCBmbGFncyk7XG5cdFx0aWYgKGZsYWdzICYgMTAyNikge1xuXHRcdFx0dGhpcy5fY2xpcEl0ZW0gPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRDbGlwSXRlbTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNsaXBJdGVtID0gdGhpcy5fY2xpcEl0ZW07XG5cdFx0aWYgKGNsaXBJdGVtID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGNsaXBJdGVtID0gbnVsbDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuXHRcdFx0XHRpZiAoY2hpbGQuX2NsaXBNYXNrKSB7XG5cdFx0XHRcdFx0Y2xpcEl0ZW0gPSBjaGlsZDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY2xpcEl0ZW0gPSBjbGlwSXRlbTtcblx0XHR9XG5cdFx0cmV0dXJuIGNsaXBJdGVtO1xuXHR9LFxuXG5cdGlzQ2xpcHBlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5fZ2V0Q2xpcEl0ZW0oKTtcblx0fSxcblxuXHRzZXRDbGlwcGVkOiBmdW5jdGlvbihjbGlwcGVkKSB7XG5cdFx0dmFyIGNoaWxkID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cdFx0aWYgKGNoaWxkKVxuXHRcdFx0Y2hpbGQuc2V0Q2xpcE1hc2soY2xpcHBlZCk7XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0pIHtcblx0XHR2YXIgY2xpcCA9IHBhcmFtLmNsaXAsXG5cdFx0XHRjbGlwSXRlbSA9ICFjbGlwICYmIHRoaXMuX2dldENsaXBJdGVtKCksXG5cdFx0XHRkcmF3ID0gdHJ1ZTtcblx0XHRwYXJhbSA9IHBhcmFtLmV4dGVuZCh7IGNsaXBJdGVtOiBjbGlwSXRlbSwgY2xpcDogZmFsc2UgfSk7XG5cdFx0aWYgKGNsaXApIHtcblx0XHRcdGlmICh0aGlzLl9jdXJyZW50UGF0aCkge1xuXHRcdFx0XHRjdHguY3VycmVudFBhdGggPSB0aGlzLl9jdXJyZW50UGF0aDtcblx0XHRcdFx0ZHJhdyA9IGZhbHNlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRwYXJhbS5kb250U3RhcnQgPSBwYXJhbS5kb250RmluaXNoID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGNsaXBJdGVtKSB7XG5cdFx0XHRjbGlwSXRlbS5kcmF3KGN0eCwgcGFyYW0uZXh0ZW5kKHsgY2xpcDogdHJ1ZSB9KSk7XG5cdFx0fVxuXHRcdGlmIChkcmF3KSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgaXRlbSA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuXHRcdFx0XHRpZiAoaXRlbSAhPT0gY2xpcEl0ZW0pXG5cdFx0XHRcdFx0aXRlbS5kcmF3KGN0eCwgcGFyYW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoY2xpcCkge1xuXHRcdFx0dGhpcy5fY3VycmVudFBhdGggPSBjdHguY3VycmVudFBhdGg7XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIExheWVyID0gR3JvdXAuZXh0ZW5kKHtcblx0X2NsYXNzOiAnTGF5ZXInLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIExheWVyKGFyZykge1xuXHRcdHZhciBwcm9wcyA9IEJhc2UuaXNQbGFpbk9iamVjdChhcmcpXG5cdFx0XHRcdD8gbmV3IEJhc2UoYXJnKVxuXHRcdFx0XHQ6IHsgY2hpbGRyZW46IEFycmF5LmlzQXJyYXkoYXJnKSA/IGFyZyA6IGFyZ3VtZW50cyB9LFxuXHRcdFx0aW5zZXJ0ID0gcHJvcHMuaW5zZXJ0O1xuXHRcdHByb3BzLmluc2VydCA9IGZhbHNlO1xuXHRcdEdyb3VwLmNhbGwodGhpcywgcHJvcHMpO1xuXHRcdGlmIChpbnNlcnQgfHwgaW5zZXJ0ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuX3Byb2plY3QuYWRkQ2hpbGQodGhpcyk7XG5cdFx0XHR0aGlzLmFjdGl2YXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmU6IGZ1bmN0aW9uIF9yZW1vdmUobm90aWZ5U2VsZiwgbm90aWZ5UGFyZW50KSB7XG5cdFx0aWYgKHRoaXMuX3BhcmVudClcblx0XHRcdHJldHVybiBfcmVtb3ZlLmJhc2UuY2FsbCh0aGlzLCBub3RpZnlTZWxmLCBub3RpZnlQYXJlbnQpO1xuXHRcdGlmICh0aGlzLl9pbmRleCAhPSBudWxsKSB7XG5cdFx0XHR2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3Q7XG5cdFx0XHRpZiAocHJvamVjdC5fYWN0aXZlTGF5ZXIgPT09IHRoaXMpXG5cdFx0XHRcdHByb2plY3QuX2FjdGl2ZUxheWVyID0gdGhpcy5nZXROZXh0U2libGluZygpXG5cdFx0XHRcdFx0XHR8fCB0aGlzLmdldFByZXZpb3VzU2libGluZygpO1xuXHRcdFx0QmFzZS5zcGxpY2UocHJvamVjdC5sYXllcnMsIG51bGwsIHRoaXMuX2luZGV4LCAxKTtcblx0XHRcdHRoaXMuX2luc3RhbGxFdmVudHMoZmFsc2UpO1xuXHRcdFx0aWYgKG5vdGlmeVNlbGYgJiYgcHJvamVjdC5fY2hhbmdlcylcblx0XHRcdFx0dGhpcy5fY2hhbmdlZCg1KTtcblx0XHRcdGlmIChub3RpZnlQYXJlbnQpIHtcblx0XHRcdFx0cHJvamVjdC5fbmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRnZXROZXh0U2libGluZzogZnVuY3Rpb24gZ2V0TmV4dFNpYmxpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCA/IGdldE5leHRTaWJsaW5nLmJhc2UuY2FsbCh0aGlzKVxuXHRcdFx0XHQ6IHRoaXMuX3Byb2plY3QubGF5ZXJzW3RoaXMuX2luZGV4ICsgMV0gfHwgbnVsbDtcblx0fSxcblxuXHRnZXRQcmV2aW91c1NpYmxpbmc6IGZ1bmN0aW9uIGdldFByZXZpb3VzU2libGluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ID8gZ2V0UHJldmlvdXNTaWJsaW5nLmJhc2UuY2FsbCh0aGlzKVxuXHRcdFx0XHQ6IHRoaXMuX3Byb2plY3QubGF5ZXJzW3RoaXMuX2luZGV4IC0gMV0gfHwgbnVsbDtcblx0fSxcblxuXHRpc0luc2VydGVkOiBmdW5jdGlvbiBpc0luc2VydGVkKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQgPyBpc0luc2VydGVkLmJhc2UuY2FsbCh0aGlzKSA6IHRoaXMuX2luZGV4ICE9IG51bGw7XG5cdH0sXG5cblx0YWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3Byb2plY3QuX2FjdGl2ZUxheWVyID0gdGhpcztcblx0fSxcblxuXHRfaW5zZXJ0U2libGluZzogZnVuY3Rpb24gX2luc2VydFNpYmxpbmcoaW5kZXgsIGl0ZW0sIF9wcmVzZXJ2ZSkge1xuXHRcdHJldHVybiAhdGhpcy5fcGFyZW50XG5cdFx0XHRcdD8gdGhpcy5fcHJvamVjdC5pbnNlcnRDaGlsZChpbmRleCwgaXRlbSwgX3ByZXNlcnZlKVxuXHRcdFx0XHQ6IF9pbnNlcnRTaWJsaW5nLmJhc2UuY2FsbCh0aGlzLCBpbmRleCwgaXRlbSwgX3ByZXNlcnZlKTtcblx0fVxufSk7XG5cbnZhciBTaGFwZSA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnU2hhcGUnLFxuXHRfYXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfY2FuQXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfYm91bmRzU2VsZWN0ZWQ6IHRydWUsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHR0eXBlOiBudWxsLFxuXHRcdHNpemU6IG51bGwsXG5cdFx0cmFkaXVzOiBudWxsXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU2hhcGUocHJvcHMpIHtcblx0XHR0aGlzLl9pbml0aWFsaXplKHByb3BzKTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3R5cGUgPT09IGl0ZW0uX3R5cGVcblx0XHRcdCYmIHRoaXMuX3NpemUuZXF1YWxzKGl0ZW0uX3NpemUpXG5cdFx0XHQmJiBCYXNlLmVxdWFscyh0aGlzLl9yYWRpdXMsIGl0ZW0uX3JhZGl1cyk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdHZhciBjb3B5ID0gbmV3IFNoYXBlKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRjb3B5LnNldFR5cGUodGhpcy5fdHlwZSk7XG5cdFx0Y29weS5zZXRTaXplKHRoaXMuX3NpemUpO1xuXHRcdGNvcHkuc2V0UmFkaXVzKHRoaXMuX3JhZGl1cyk7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb25lKGNvcHksIGluc2VydCk7XG5cdH0sXG5cblx0Z2V0VHlwZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3R5cGU7XG5cdH0sXG5cblx0c2V0VHlwZTogZnVuY3Rpb24odHlwZSkge1xuXHRcdHRoaXMuX3R5cGUgPSB0eXBlO1xuXHR9LFxuXG5cdGdldFNoYXBlOiAnI2dldFR5cGUnLFxuXHRzZXRTaGFwZTogJyNzZXRUeXBlJyxcblxuXHRnZXRTaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG5cdFx0cmV0dXJuIG5ldyBMaW5rZWRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCB0aGlzLCAnc2V0U2l6ZScpO1xuXHR9LFxuXG5cdHNldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKCF0aGlzLl9zaXplKSB7XG5cdFx0XHR0aGlzLl9zaXplID0gc2l6ZS5jbG9uZSgpO1xuXHRcdH0gZWxzZSBpZiAoIXRoaXMuX3NpemUuZXF1YWxzKHNpemUpKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG5cdFx0XHRcdHdpZHRoID0gc2l6ZS53aWR0aCxcblx0XHRcdFx0aGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdFx0XHRpZiAodHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcblx0XHRcdFx0dmFyIHJhZGl1cyA9IFNpemUubWluKHRoaXMuX3JhZGl1cywgc2l6ZS5kaXZpZGUoMikpO1xuXHRcdFx0XHR0aGlzLl9yYWRpdXMuc2V0KHJhZGl1cy53aWR0aCwgcmFkaXVzLmhlaWdodCk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdjaXJjbGUnKSB7XG5cdFx0XHRcdHdpZHRoID0gaGVpZ2h0ID0gKHdpZHRoICsgaGVpZ2h0KSAvIDI7XG5cdFx0XHRcdHRoaXMuX3JhZGl1cyA9IHdpZHRoIC8gMjtcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ2VsbGlwc2UnKSB7XG5cdFx0XHRcdHRoaXMuX3JhZGl1cy5zZXQod2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3NpemUuc2V0KHdpZHRoLCBoZWlnaHQpO1xuXHRcdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UmFkaXVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmFkID0gdGhpcy5fcmFkaXVzO1xuXHRcdHJldHVybiB0aGlzLl90eXBlID09PSAnY2lyY2xlJ1xuXHRcdFx0XHQ/IHJhZFxuXHRcdFx0XHQ6IG5ldyBMaW5rZWRTaXplKHJhZC53aWR0aCwgcmFkLmhlaWdodCwgdGhpcywgJ3NldFJhZGl1cycpO1xuXHR9LFxuXG5cdHNldFJhZGl1czogZnVuY3Rpb24ocmFkaXVzKSB7XG5cdFx0dmFyIHR5cGUgPSB0aGlzLl90eXBlO1xuXHRcdGlmICh0eXBlID09PSAnY2lyY2xlJykge1xuXHRcdFx0aWYgKHJhZGl1cyA9PT0gdGhpcy5fcmFkaXVzKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR2YXIgc2l6ZSA9IHJhZGl1cyAqIDI7XG5cdFx0XHR0aGlzLl9yYWRpdXMgPSByYWRpdXM7XG5cdFx0XHR0aGlzLl9zaXplLnNldChzaXplLCBzaXplKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmFkaXVzID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHRpZiAoIXRoaXMuX3JhZGl1cykge1xuXHRcdFx0XHR0aGlzLl9yYWRpdXMgPSByYWRpdXMuY2xvbmUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0aGlzLl9yYWRpdXMuZXF1YWxzKHJhZGl1cykpXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR0aGlzLl9yYWRpdXMuc2V0KHJhZGl1cy53aWR0aCwgcmFkaXVzLmhlaWdodCk7XG5cdFx0XHRcdGlmICh0eXBlID09PSAncmVjdGFuZ2xlJykge1xuXHRcdFx0XHRcdHZhciBzaXplID0gU2l6ZS5tYXgodGhpcy5fc2l6ZSwgcmFkaXVzLm11bHRpcGx5KDIpKTtcblx0XHRcdFx0XHR0aGlzLl9zaXplLnNldChzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ2VsbGlwc2UnKSB7XG5cdFx0XHRcdFx0dGhpcy5fc2l6ZS5zZXQocmFkaXVzLndpZHRoICogMiwgcmFkaXVzLmhlaWdodCAqIDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX2NoYW5nZWQoOSk7XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdHRvUGF0aDogZnVuY3Rpb24oaW5zZXJ0KSB7XG5cdFx0dmFyIHBhdGggPSB0aGlzLl9jbG9uZShuZXcgUGF0aFtCYXNlLmNhcGl0YWxpemUodGhpcy5fdHlwZSldKHtcblx0XHRcdGNlbnRlcjogbmV3IFBvaW50KCksXG5cdFx0XHRzaXplOiB0aGlzLl9zaXplLFxuXHRcdFx0cmFkaXVzOiB0aGlzLl9yYWRpdXMsXG5cdFx0XHRpbnNlcnQ6IGZhbHNlXG5cdFx0fSksIGluc2VydCk7XG5cdFx0aWYgKHBhcGVyLnNldHRpbmdzLmFwcGx5TWF0cml4KVxuXHRcdFx0cGF0aC5zZXRBcHBseU1hdHJpeCh0cnVlKTtcblx0XHRyZXR1cm4gcGF0aDtcblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSwgc3Ryb2tlTWF0cml4KSB7XG5cdFx0dmFyIHN0eWxlID0gdGhpcy5fc3R5bGUsXG5cdFx0XHRoYXNGaWxsID0gc3R5bGUuaGFzRmlsbCgpLFxuXHRcdFx0aGFzU3Ryb2tlID0gc3R5bGUuaGFzU3Ryb2tlKCksXG5cdFx0XHRkb250UGFpbnQgPSBwYXJhbS5kb250RmluaXNoIHx8IHBhcmFtLmNsaXAsXG5cdFx0XHR1bnRyYW5zZm9ybWVkID0gIXN0cm9rZU1hdHJpeDtcblx0XHRpZiAoaGFzRmlsbCB8fCBoYXNTdHJva2UgfHwgZG9udFBhaW50KSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG5cdFx0XHRcdHJhZGl1cyA9IHRoaXMuX3JhZGl1cyxcblx0XHRcdFx0aXNDaXJjbGUgPSB0eXBlID09PSAnY2lyY2xlJztcblx0XHRcdGlmICghcGFyYW0uZG9udFN0YXJ0KVxuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRpZiAodW50cmFuc2Zvcm1lZCAmJiBpc0NpcmNsZSkge1xuXHRcdFx0XHRjdHguYXJjKDAsIDAsIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHJ4ID0gaXNDaXJjbGUgPyByYWRpdXMgOiByYWRpdXMud2lkdGgsXG5cdFx0XHRcdFx0cnkgPSBpc0NpcmNsZSA/IHJhZGl1cyA6IHJhZGl1cy5oZWlnaHQsXG5cdFx0XHRcdFx0c2l6ZSA9IHRoaXMuX3NpemUsXG5cdFx0XHRcdFx0d2lkdGggPSBzaXplLndpZHRoLFxuXHRcdFx0XHRcdGhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdFx0XHRpZiAodW50cmFuc2Zvcm1lZCAmJiB0eXBlID09PSAncmVjdGFuZ2xlJyAmJiByeCA9PT0gMCAmJiByeSA9PT0gMCkge1xuXHRcdFx0XHRcdGN0eC5yZWN0KC13aWR0aCAvIDIsIC1oZWlnaHQgLyAyLCB3aWR0aCwgaGVpZ2h0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgeCA9IHdpZHRoIC8gMixcblx0XHRcdFx0XHRcdHkgPSBoZWlnaHQgLyAyLFxuXHRcdFx0XHRcdFx0a2FwcGEgPSAxIC0gMC41NTIyODQ3NDk4MzA3OTM2LFxuXHRcdFx0XHRcdFx0Y3ggPSByeCAqIGthcHBhLFxuXHRcdFx0XHRcdFx0Y3kgPSByeSAqIGthcHBhLFxuXHRcdFx0XHRcdFx0YyA9IFtcblx0XHRcdFx0XHRcdFx0LXgsIC15ICsgcnksXG5cdFx0XHRcdFx0XHRcdC14LCAteSArIGN5LFxuXHRcdFx0XHRcdFx0XHQteCArIGN4LCAteSxcblx0XHRcdFx0XHRcdFx0LXggKyByeCwgLXksXG5cdFx0XHRcdFx0XHRcdHggLSByeCwgLXksXG5cdFx0XHRcdFx0XHRcdHggLSBjeCwgLXksXG5cdFx0XHRcdFx0XHRcdHgsIC15ICsgY3ksXG5cdFx0XHRcdFx0XHRcdHgsIC15ICsgcnksXG5cdFx0XHRcdFx0XHRcdHgsIHkgLSByeSxcblx0XHRcdFx0XHRcdFx0eCwgeSAtIGN5LFxuXHRcdFx0XHRcdFx0XHR4IC0gY3gsIHksXG5cdFx0XHRcdFx0XHRcdHggLSByeCwgeSxcblx0XHRcdFx0XHRcdFx0LXggKyByeCwgeSxcblx0XHRcdFx0XHRcdFx0LXggKyBjeCwgeSxcblx0XHRcdFx0XHRcdFx0LXgsIHkgLSBjeSxcblx0XHRcdFx0XHRcdFx0LXgsIHkgLSByeVxuXHRcdFx0XHRcdFx0XTtcblx0XHRcdFx0XHRpZiAoc3Ryb2tlTWF0cml4KVxuXHRcdFx0XHRcdFx0c3Ryb2tlTWF0cml4LnRyYW5zZm9ybShjLCBjLCAzMik7XG5cdFx0XHRcdFx0Y3R4Lm1vdmVUbyhjWzBdLCBjWzFdKTtcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhjWzJdLCBjWzNdLCBjWzRdLCBjWzVdLCBjWzZdLCBjWzddKTtcblx0XHRcdFx0XHRpZiAoeCAhPT0gcngpXG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKGNbOF0sIGNbOV0pO1xuXHRcdFx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvKGNbMTBdLCBjWzExXSwgY1sxMl0sIGNbMTNdLCBjWzE0XSwgY1sxNV0pO1xuXHRcdFx0XHRcdGlmICh5ICE9PSByeSlcblx0XHRcdFx0XHRcdGN0eC5saW5lVG8oY1sxNl0sIGNbMTddKTtcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhjWzE4XSwgY1sxOV0sIGNbMjBdLCBjWzIxXSwgY1syMl0sIGNbMjNdKTtcblx0XHRcdFx0XHRpZiAoeCAhPT0gcngpXG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKGNbMjRdLCBjWzI1XSk7XG5cdFx0XHRcdFx0Y3R4LmJlemllckN1cnZlVG8oY1syNl0sIGNbMjddLCBjWzI4XSwgY1syOV0sIGNbMzBdLCBjWzMxXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHR9XG5cdFx0aWYgKCFkb250UGFpbnQgJiYgKGhhc0ZpbGwgfHwgaGFzU3Ryb2tlKSkge1xuXHRcdFx0dGhpcy5fc2V0U3R5bGVzKGN0eCk7XG5cdFx0XHRpZiAoaGFzRmlsbCkge1xuXHRcdFx0XHRjdHguZmlsbChzdHlsZS5nZXRXaW5kaW5nUnVsZSgpKTtcblx0XHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGhhc1N0cm9rZSlcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfY2FuQ29tcG9zaXRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISh0aGlzLmhhc0ZpbGwoKSAmJiB0aGlzLmhhc1N0cm9rZSgpKTtcblx0fSxcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihnZXR0ZXIsIG1hdHJpeCkge1xuXHRcdHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZSh0aGlzLl9zaXplKS5zZXRDZW50ZXIoMCwgMCk7XG5cdFx0aWYgKGdldHRlciAhPT0gJ2dldEJvdW5kcycgJiYgdGhpcy5oYXNTdHJva2UoKSlcblx0XHRcdHJlY3QgPSByZWN0LmV4cGFuZCh0aGlzLmdldFN0cm9rZVdpZHRoKCkpO1xuXHRcdHJldHVybiBtYXRyaXggPyBtYXRyaXguX3RyYW5zZm9ybUJvdW5kcyhyZWN0KSA6IHJlY3Q7XG5cdH1cbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gZ2V0Q29ybmVyQ2VudGVyKHRoYXQsIHBvaW50LCBleHBhbmQpIHtcblx0XHR2YXIgcmFkaXVzID0gdGhhdC5fcmFkaXVzO1xuXHRcdGlmICghcmFkaXVzLmlzWmVybygpKSB7XG5cdFx0XHR2YXIgaGFsZlNpemUgPSB0aGF0Ll9zaXplLmRpdmlkZSgyKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdFx0XHRcdHZhciBkaXIgPSBuZXcgUG9pbnQoaSAmIDEgPyAxIDogLTEsIGkgPiAxID8gMSA6IC0xKSxcblx0XHRcdFx0XHRjb3JuZXIgPSBkaXIubXVsdGlwbHkoaGFsZlNpemUpLFxuXHRcdFx0XHRcdGNlbnRlciA9IGNvcm5lci5zdWJ0cmFjdChkaXIubXVsdGlwbHkocmFkaXVzKSksXG5cdFx0XHRcdFx0cmVjdCA9IG5ldyBSZWN0YW5nbGUoY29ybmVyLCBjZW50ZXIpO1xuXHRcdFx0XHRpZiAoKGV4cGFuZCA/IHJlY3QuZXhwYW5kKGV4cGFuZCkgOiByZWN0KS5jb250YWlucyhwb2ludCkpXG5cdFx0XHRcdFx0cmV0dXJuIGNlbnRlcjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRFbGxpcHNlUmFkaXVzKHBvaW50LCByYWRpdXMpIHtcblx0XHR2YXIgYW5nbGUgPSBwb2ludC5nZXRBbmdsZUluUmFkaWFucygpLFxuXHRcdFx0d2lkdGggPSByYWRpdXMud2lkdGggKiAyLFxuXHRcdFx0aGVpZ2h0ID0gcmFkaXVzLmhlaWdodCAqIDIsXG5cdFx0XHR4ID0gd2lkdGggKiBNYXRoLnNpbihhbmdsZSksXG5cdFx0XHR5ID0gaGVpZ2h0ICogTWF0aC5jb3MoYW5nbGUpO1xuXHRcdHJldHVybiB3aWR0aCAqIGhlaWdodCAvICgyICogTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0X2NvbnRhaW5zOiBmdW5jdGlvbiBfY29udGFpbnMocG9pbnQpIHtcblx0XHRcdGlmICh0aGlzLl90eXBlID09PSAncmVjdGFuZ2xlJykge1xuXHRcdFx0XHR2YXIgY2VudGVyID0gZ2V0Q29ybmVyQ2VudGVyKHRoaXMsIHBvaW50KTtcblx0XHRcdFx0cmV0dXJuIGNlbnRlclxuXHRcdFx0XHRcdFx0PyBwb2ludC5zdWJ0cmFjdChjZW50ZXIpLmRpdmlkZSh0aGlzLl9yYWRpdXMpXG5cdFx0XHRcdFx0XHRcdC5nZXRMZW5ndGgoKSA8PSAxXG5cdFx0XHRcdFx0XHQ6IF9jb250YWlucy5iYXNlLmNhbGwodGhpcywgcG9pbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHBvaW50LmRpdmlkZSh0aGlzLnNpemUpLmdldExlbmd0aCgpIDw9IDAuNTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2hpdFRlc3RTZWxmOiBmdW5jdGlvbiBfaGl0VGVzdFNlbGYocG9pbnQsIG9wdGlvbnMpIHtcblx0XHRcdHZhciBoaXQgPSBmYWxzZTtcblx0XHRcdGlmICh0aGlzLmhhc1N0cm9rZSgpKSB7XG5cdFx0XHRcdHZhciB0eXBlID0gdGhpcy5fdHlwZSxcblx0XHRcdFx0XHRyYWRpdXMgPSB0aGlzLl9yYWRpdXMsXG5cdFx0XHRcdFx0c3Ryb2tlV2lkdGggPSB0aGlzLmdldFN0cm9rZVdpZHRoKCkgKyAyICogb3B0aW9ucy50b2xlcmFuY2U7XG5cdFx0XHRcdGlmICh0eXBlID09PSAncmVjdGFuZ2xlJykge1xuXHRcdFx0XHRcdHZhciBjZW50ZXIgPSBnZXRDb3JuZXJDZW50ZXIodGhpcywgcG9pbnQsIHN0cm9rZVdpZHRoKTtcblx0XHRcdFx0XHRpZiAoY2VudGVyKSB7XG5cdFx0XHRcdFx0XHR2YXIgcHQgPSBwb2ludC5zdWJ0cmFjdChjZW50ZXIpO1xuXHRcdFx0XHRcdFx0aGl0ID0gMiAqIE1hdGguYWJzKHB0LmdldExlbmd0aCgpXG5cdFx0XHRcdFx0XHRcdFx0LSBnZXRFbGxpcHNlUmFkaXVzKHB0LCByYWRpdXMpKSA8PSBzdHJva2VXaWR0aDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFyIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKHRoaXMuX3NpemUpLnNldENlbnRlcigwLCAwKSxcblx0XHRcdFx0XHRcdFx0b3V0ZXIgPSByZWN0LmV4cGFuZChzdHJva2VXaWR0aCksXG5cdFx0XHRcdFx0XHRcdGlubmVyID0gcmVjdC5leHBhbmQoLXN0cm9rZVdpZHRoKTtcblx0XHRcdFx0XHRcdGhpdCA9IG91dGVyLl9jb250YWluc1BvaW50KHBvaW50KVxuXHRcdFx0XHRcdFx0XHRcdCYmICFpbm5lci5fY29udGFpbnNQb2ludChwb2ludCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh0eXBlID09PSAnZWxsaXBzZScpXG5cdFx0XHRcdFx0XHRyYWRpdXMgPSBnZXRFbGxpcHNlUmFkaXVzKHBvaW50LCByYWRpdXMpO1xuXHRcdFx0XHRcdGhpdCA9IDIgKiBNYXRoLmFicyhwb2ludC5nZXRMZW5ndGgoKSAtIHJhZGl1cylcblx0XHRcdFx0XHRcdFx0PD0gc3Ryb2tlV2lkdGg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBoaXRcblx0XHRcdFx0XHQ/IG5ldyBIaXRSZXN1bHQoJ3N0cm9rZScsIHRoaXMpXG5cdFx0XHRcdFx0OiBfaGl0VGVzdFNlbGYuYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH1cblx0fTtcbn0sIHtcblxuc3RhdGljczogbmV3IGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBjcmVhdGVTaGFwZSh0eXBlLCBwb2ludCwgc2l6ZSwgcmFkaXVzLCBhcmdzKSB7XG5cdFx0dmFyIGl0ZW0gPSBuZXcgU2hhcGUoQmFzZS5nZXROYW1lZChhcmdzKSk7XG5cdFx0aXRlbS5fdHlwZSA9IHR5cGU7XG5cdFx0aXRlbS5fc2l6ZSA9IHNpemU7XG5cdFx0aXRlbS5fcmFkaXVzID0gcmFkaXVzO1xuXHRcdHJldHVybiBpdGVtLnRyYW5zbGF0ZShwb2ludCk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdENpcmNsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2VudGVyID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ2NlbnRlcicpLFxuXHRcdFx0XHRyYWRpdXMgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMnKTtcblx0XHRcdHJldHVybiBjcmVhdGVTaGFwZSgnY2lyY2xlJywgY2VudGVyLCBuZXcgU2l6ZShyYWRpdXMgKiAyKSwgcmFkaXVzLFxuXHRcdFx0XHRcdGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdFJlY3RhbmdsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmVjdGFuZ2xlJyksXG5cdFx0XHRcdHJhZGl1cyA9IFNpemUubWluKFNpemUucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JhZGl1cycpLFxuXHRcdFx0XHRcdFx0cmVjdC5nZXRTaXplKHRydWUpLmRpdmlkZSgyKSk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlU2hhcGUoJ3JlY3RhbmdsZScsIHJlY3QuZ2V0Q2VudGVyKHRydWUpLFxuXHRcdFx0XHRcdHJlY3QuZ2V0U2l6ZSh0cnVlKSwgcmFkaXVzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRFbGxpcHNlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBlbGxpcHNlID0gU2hhcGUuX3JlYWRFbGxpcHNlKGFyZ3VtZW50cyksXG5cdFx0XHRcdHJhZGl1cyA9IGVsbGlwc2UucmFkaXVzO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVNoYXBlKCdlbGxpcHNlJywgZWxsaXBzZS5jZW50ZXIsIHJhZGl1cy5tdWx0aXBseSgyKSxcblx0XHRcdFx0XHRyYWRpdXMsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdF9yZWFkRWxsaXBzZTogZnVuY3Rpb24oYXJncykge1xuXHRcdFx0dmFyIGNlbnRlcixcblx0XHRcdFx0cmFkaXVzO1xuXHRcdFx0aWYgKEJhc2UuaGFzTmFtZWQoYXJncywgJ3JhZGl1cycpKSB7XG5cdFx0XHRcdGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmdzLCAnY2VudGVyJyk7XG5cdFx0XHRcdHJhZGl1cyA9IFNpemUucmVhZE5hbWVkKGFyZ3MsICdyYWRpdXMnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWROYW1lZChhcmdzLCAncmVjdGFuZ2xlJyk7XG5cdFx0XHRcdGNlbnRlciA9IHJlY3QuZ2V0Q2VudGVyKHRydWUpO1xuXHRcdFx0XHRyYWRpdXMgPSByZWN0LmdldFNpemUodHJ1ZSkuZGl2aWRlKDIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHsgY2VudGVyOiBjZW50ZXIsIHJhZGl1czogcmFkaXVzIH07XG5cdFx0fVxuXHR9O1xufX0pO1xuXG52YXIgUmFzdGVyID0gSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdSYXN0ZXInLFxuXHRfYXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfY2FuQXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfYm91bmRzR2V0dGVyOiAnZ2V0Qm91bmRzJyxcblx0X2JvdW5kc1NlbGVjdGVkOiB0cnVlLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0Y3Jvc3NPcmlnaW46IG51bGwsXG5cdFx0c291cmNlOiBudWxsXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUmFzdGVyKG9iamVjdCwgcG9zaXRpb24pIHtcblx0XHRpZiAoIXRoaXMuX2luaXRpYWxpemUob2JqZWN0LFxuXHRcdFx0XHRwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICYmIFBvaW50LnJlYWQoYXJndW1lbnRzLCAxKSkpIHtcblx0XHRcdGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHR0aGlzLnNldFNvdXJjZShvYmplY3QpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5zZXRJbWFnZShvYmplY3QpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIXRoaXMuX3NpemUpIHtcblx0XHRcdHRoaXMuX3NpemUgPSBuZXcgU2l6ZSgpO1xuXHRcdFx0dGhpcy5fbG9hZGVkID0gZmFsc2U7XG5cdFx0fVxuXHR9LFxuXG5cdF9lcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTb3VyY2UoKSA9PT0gaXRlbS5nZXRTb3VyY2UoKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oaW5zZXJ0KSB7XG5cdFx0dmFyIGNvcHkgPSBuZXcgUmFzdGVyKEl0ZW0uTk9fSU5TRVJUKSxcblx0XHRcdGltYWdlID0gdGhpcy5faW1hZ2UsXG5cdFx0XHRjYW52YXMgPSB0aGlzLl9jYW52YXM7XG5cdFx0aWYgKGltYWdlKSB7XG5cdFx0XHRjb3B5LnNldEltYWdlKGltYWdlKTtcblx0XHR9IGVsc2UgaWYgKGNhbnZhcykge1xuXHRcdFx0dmFyIGNvcHlDYW52YXMgPSBDYW52YXNQcm92aWRlci5nZXRDYW52YXModGhpcy5fc2l6ZSk7XG5cdFx0XHRjb3B5Q2FudmFzLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKGNhbnZhcywgMCwgMCk7XG5cdFx0XHRjb3B5LnNldEltYWdlKGNvcHlDYW52YXMpO1xuXHRcdH1cblx0XHRjb3B5Ll9jcm9zc09yaWdpbiA9IHRoaXMuX2Nyb3NzT3JpZ2luO1xuXHRcdHJldHVybiB0aGlzLl9jbG9uZShjb3B5LCBpbnNlcnQpO1xuXHR9LFxuXG5cdGdldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gdGhpcy5fc2l6ZTtcblx0XHRyZXR1cm4gbmV3IExpbmtlZFNpemUoc2l6ZSA/IHNpemUud2lkdGggOiAwLCBzaXplID8gc2l6ZS5oZWlnaHQgOiAwLFxuXHRcdFx0XHR0aGlzLCAnc2V0U2l6ZScpO1xuXHR9LFxuXG5cdHNldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKCFzaXplLmVxdWFscyh0aGlzLl9zaXplKSkge1xuXHRcdFx0aWYgKHNpemUud2lkdGggPiAwICYmIHNpemUuaGVpZ2h0ID4gMCkge1xuXHRcdFx0XHR2YXIgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuXHRcdFx0XHR0aGlzLnNldEltYWdlKENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcyhzaXplKSk7XG5cdFx0XHRcdGlmIChlbGVtZW50KVxuXHRcdFx0XHRcdHRoaXMuZ2V0Q29udGV4dCh0cnVlKS5kcmF3SW1hZ2UoZWxlbWVudCwgMCwgMCxcblx0XHRcdFx0XHRcdFx0c2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHRoaXMuX2NhbnZhcylcblx0XHRcdFx0XHRDYW52YXNQcm92aWRlci5yZWxlYXNlKHRoaXMuX2NhbnZhcyk7XG5cdFx0XHRcdHRoaXMuX3NpemUgPSBzaXplLmNsb25lKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGdldFdpZHRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZSA/IHRoaXMuX3NpemUud2lkdGggOiAwO1xuXHR9LFxuXG5cdHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuXHRcdHRoaXMuc2V0U2l6ZSh3aWR0aCwgdGhpcy5nZXRIZWlnaHQoKSk7XG5cdH0sXG5cblx0Z2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZSA/IHRoaXMuX3NpemUuaGVpZ2h0IDogMDtcblx0fSxcblxuXHRzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuXHRcdHRoaXMuc2V0U2l6ZSh0aGlzLmdldFdpZHRoKCksIGhlaWdodCk7XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSB0aGlzLl9zaXplO1xuXHRcdHJldHVybiAhc2l6ZSB8fCBzaXplLndpZHRoID09PSAwICYmIHNpemUuaGVpZ2h0ID09PSAwO1xuXHR9LFxuXG5cdGdldFJlc29sdXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtYXRyaXggPSB0aGlzLl9tYXRyaXgsXG5cdFx0XHRvcmlnID0gbmV3IFBvaW50KDAsIDApLnRyYW5zZm9ybShtYXRyaXgpLFxuXHRcdFx0dSA9IG5ldyBQb2ludCgxLCAwKS50cmFuc2Zvcm0obWF0cml4KS5zdWJ0cmFjdChvcmlnKSxcblx0XHRcdHYgPSBuZXcgUG9pbnQoMCwgMSkudHJhbnNmb3JtKG1hdHJpeCkuc3VidHJhY3Qob3JpZyk7XG5cdFx0cmV0dXJuIG5ldyBTaXplKFxuXHRcdFx0NzIgLyB1LmdldExlbmd0aCgpLFxuXHRcdFx0NzIgLyB2LmdldExlbmd0aCgpXG5cdFx0KTtcblx0fSxcblxuXHRnZXRQcGk6ICcjZ2V0UmVzb2x1dGlvbicsXG5cblx0Z2V0SW1hZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbWFnZTtcblx0fSxcblxuXHRzZXRJbWFnZTogZnVuY3Rpb24oaW1hZ2UpIHtcblx0XHRpZiAodGhpcy5fY2FudmFzKVxuXHRcdFx0Q2FudmFzUHJvdmlkZXIucmVsZWFzZSh0aGlzLl9jYW52YXMpO1xuXHRcdGlmIChpbWFnZSAmJiBpbWFnZS5nZXRDb250ZXh0KSB7XG5cdFx0XHR0aGlzLl9pbWFnZSA9IG51bGw7XG5cdFx0XHR0aGlzLl9jYW52YXMgPSBpbWFnZTtcblx0XHRcdHRoaXMuX2xvYWRlZCA9IHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2ltYWdlID0gaW1hZ2U7XG5cdFx0XHR0aGlzLl9jYW52YXMgPSBudWxsO1xuXHRcdFx0dGhpcy5fbG9hZGVkID0gaW1hZ2UgJiYgaW1hZ2UuY29tcGxldGU7XG5cdFx0fVxuXHRcdHRoaXMuX3NpemUgPSBuZXcgU2l6ZShcblx0XHRcdFx0aW1hZ2UgPyBpbWFnZS5uYXR1cmFsV2lkdGggfHwgaW1hZ2Uud2lkdGggOiAwLFxuXHRcdFx0XHRpbWFnZSA/IGltYWdlLm5hdHVyYWxIZWlnaHQgfHwgaW1hZ2UuaGVpZ2h0IDogMCk7XG5cdFx0dGhpcy5fY29udGV4dCA9IG51bGw7XG5cdFx0dGhpcy5fY2hhbmdlZCg1MjEpO1xuXHR9LFxuXG5cdGdldENhbnZhczogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9jYW52YXMpIHtcblx0XHRcdHZhciBjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KHRoaXMuX3NpemUpO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKHRoaXMuX2ltYWdlKVxuXHRcdFx0XHRcdGN0eC5kcmF3SW1hZ2UodGhpcy5faW1hZ2UsIDAsIDApO1xuXHRcdFx0XHR0aGlzLl9jYW52YXMgPSBjdHguY2FudmFzO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRDYW52YXNQcm92aWRlci5yZWxlYXNlKGN0eCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9jYW52YXM7XG5cdH0sXG5cblx0c2V0Q2FudmFzOiAnI3NldEltYWdlJyxcblxuXHRnZXRDb250ZXh0OiBmdW5jdGlvbihtb2RpZnkpIHtcblx0XHRpZiAoIXRoaXMuX2NvbnRleHQpXG5cdFx0XHR0aGlzLl9jb250ZXh0ID0gdGhpcy5nZXRDYW52YXMoKS5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdGlmIChtb2RpZnkpIHtcblx0XHRcdHRoaXMuX2ltYWdlID0gbnVsbDtcblx0XHRcdHRoaXMuX2NoYW5nZWQoNTEzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRleHQ7XG5cdH0sXG5cblx0c2V0Q29udGV4dDogZnVuY3Rpb24oY29udGV4dCkge1xuXHRcdHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuXHR9LFxuXG5cdGdldFNvdXJjZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ltYWdlICYmIHRoaXMuX2ltYWdlLnNyYyB8fCB0aGlzLnRvRGF0YVVSTCgpO1xuXHR9LFxuXG5cdHNldFNvdXJjZTogZnVuY3Rpb24oc3JjKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0Y3Jvc3NPcmlnaW4gPSB0aGlzLl9jcm9zc09yaWdpbixcblx0XHRcdGltYWdlO1xuXG5cdFx0ZnVuY3Rpb24gbG9hZGVkKCkge1xuXHRcdFx0dmFyIHZpZXcgPSB0aGF0LmdldFZpZXcoKTtcblx0XHRcdGlmICh2aWV3KSB7XG5cdFx0XHRcdHBhcGVyID0gdmlldy5fc2NvcGU7XG5cdFx0XHRcdHRoYXQuc2V0SW1hZ2UoaW1hZ2UpO1xuXHRcdFx0XHR0aGF0LmVtaXQoJ2xvYWQnKTtcblx0XHRcdFx0dmlldy51cGRhdGUoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpbWFnZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNyYykgfHwgbmV3IEltYWdlKCk7XG5cdFx0aWYgKGNyb3NzT3JpZ2luKVxuXHRcdFx0aW1hZ2UuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcblx0XHRpZiAoaW1hZ2UubmF0dXJhbFdpZHRoICYmIGltYWdlLm5hdHVyYWxIZWlnaHQpIHtcblx0XHRcdHNldFRpbWVvdXQobG9hZGVkLCAwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0RG9tRXZlbnQuYWRkKGltYWdlLCB7IGxvYWQ6IGxvYWRlZCB9KTtcblx0XHRcdGlmICghaW1hZ2Uuc3JjKVxuXHRcdFx0XHRpbWFnZS5zcmMgPSBzcmM7XG5cdFx0fVxuXHRcdHRoaXMuc2V0SW1hZ2UoaW1hZ2UpO1xuXHR9LFxuXG5cdGdldENyb3NzT3JpZ2luOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW1hZ2UgJiYgdGhpcy5faW1hZ2UuY3Jvc3NPcmlnaW4gfHwgdGhpcy5fY3Jvc3NPcmlnaW4gfHwgJyc7XG5cdH0sXG5cblx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uKGNyb3NzT3JpZ2luKSB7XG5cdFx0dGhpcy5fY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcblx0XHRpZiAodGhpcy5faW1hZ2UpXG5cdFx0XHR0aGlzLl9pbWFnZS5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuXHR9LFxuXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jYW52YXMgfHwgdGhpcy5fbG9hZGVkICYmIHRoaXMuX2ltYWdlO1xuXHR9XG59LCB7XG5cdGJlYW5zOiBmYWxzZSxcblxuXHRnZXRTdWJDYW52YXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQocmVjdC5nZXRTaXplKCkpO1xuXHRcdGN0eC5kcmF3SW1hZ2UodGhpcy5nZXRDYW52YXMoKSwgcmVjdC54LCByZWN0LnksXG5cdFx0XHRcdHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0LCAwLCAwLCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG5cdFx0cmV0dXJuIGN0eC5jYW52YXM7XG5cdH0sXG5cblx0Z2V0U3ViUmFzdGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRyYXN0ZXIgPSBuZXcgUmFzdGVyKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRyYXN0ZXIuc2V0SW1hZ2UodGhpcy5nZXRTdWJDYW52YXMocmVjdCkpO1xuXHRcdHJhc3Rlci50cmFuc2xhdGUocmVjdC5nZXRDZW50ZXIoKS5zdWJ0cmFjdCh0aGlzLmdldFNpemUoKS5kaXZpZGUoMikpKTtcblx0XHRyYXN0ZXIuX21hdHJpeC5wcmVDb25jYXRlbmF0ZSh0aGlzLl9tYXRyaXgpO1xuXHRcdHJhc3Rlci5pbnNlcnRBYm92ZSh0aGlzKTtcblx0XHRyZXR1cm4gcmFzdGVyO1xuXHR9LFxuXG5cdHRvRGF0YVVSTDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNyYyA9IHRoaXMuX2ltYWdlICYmIHRoaXMuX2ltYWdlLnNyYztcblx0XHRpZiAoL15kYXRhOi8udGVzdChzcmMpKVxuXHRcdFx0cmV0dXJuIHNyYztcblx0XHR2YXIgY2FudmFzID0gdGhpcy5nZXRDYW52YXMoKTtcblx0XHRyZXR1cm4gY2FudmFzID8gY2FudmFzLnRvRGF0YVVSTCgpIDogbnVsbDtcblx0fSxcblxuXHRkcmF3SW1hZ2U6IGZ1bmN0aW9uKGltYWdlICkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAxKTtcblx0XHR0aGlzLmdldENvbnRleHQodHJ1ZSkuZHJhd0ltYWdlKGltYWdlLCBwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRBdmVyYWdlQ29sb3I6IGZ1bmN0aW9uKG9iamVjdCkge1xuXHRcdHZhciBib3VuZHMsIHBhdGg7XG5cdFx0aWYgKCFvYmplY3QpIHtcblx0XHRcdGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCk7XG5cdFx0fSBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBQYXRoSXRlbSkge1xuXHRcdFx0cGF0aCA9IG9iamVjdDtcblx0XHRcdGJvdW5kcyA9IG9iamVjdC5nZXRCb3VuZHMoKTtcblx0XHR9IGVsc2UgaWYgKG9iamVjdC53aWR0aCkge1xuXHRcdFx0Ym91bmRzID0gbmV3IFJlY3RhbmdsZShvYmplY3QpO1xuXHRcdH0gZWxzZSBpZiAob2JqZWN0LngpIHtcblx0XHRcdGJvdW5kcyA9IG5ldyBSZWN0YW5nbGUob2JqZWN0LnggLSAwLjUsIG9iamVjdC55IC0gMC41LCAxLCAxKTtcblx0XHR9XG5cdFx0dmFyIHNhbXBsZVNpemUgPSAzMixcblx0XHRcdHdpZHRoID0gTWF0aC5taW4oYm91bmRzLndpZHRoLCBzYW1wbGVTaXplKSxcblx0XHRcdGhlaWdodCA9IE1hdGgubWluKGJvdW5kcy5oZWlnaHQsIHNhbXBsZVNpemUpO1xuXHRcdHZhciBjdHggPSBSYXN0ZXIuX3NhbXBsZUNvbnRleHQ7XG5cdFx0aWYgKCFjdHgpIHtcblx0XHRcdGN0eCA9IFJhc3Rlci5fc2FtcGxlQ29udGV4dCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQoXG5cdFx0XHRcdFx0bmV3IFNpemUoc2FtcGxlU2l6ZSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIHNhbXBsZVNpemUgKyAxLCBzYW1wbGVTaXplICsgMSk7XG5cdFx0fVxuXHRcdGN0eC5zYXZlKCk7XG5cdFx0dmFyIG1hdHJpeCA9IG5ldyBNYXRyaXgoKVxuXHRcdFx0XHQuc2NhbGUod2lkdGggLyBib3VuZHMud2lkdGgsIGhlaWdodCAvIGJvdW5kcy5oZWlnaHQpXG5cdFx0XHRcdC50cmFuc2xhdGUoLWJvdW5kcy54LCAtYm91bmRzLnkpO1xuXHRcdG1hdHJpeC5hcHBseVRvQ29udGV4dChjdHgpO1xuXHRcdGlmIChwYXRoKVxuXHRcdFx0cGF0aC5kcmF3KGN0eCwgbmV3IEJhc2UoeyBjbGlwOiB0cnVlLCBtYXRyaWNlczogW21hdHJpeF0gfSkpO1xuXHRcdHRoaXMuX21hdHJpeC5hcHBseVRvQ29udGV4dChjdHgpO1xuXHRcdHZhciBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KCksXG5cdFx0XHRzaXplID0gdGhpcy5fc2l6ZTtcblx0XHRpZiAoZWxlbWVudClcblx0XHRcdGN0eC5kcmF3SW1hZ2UoZWxlbWVudCwgLXNpemUud2lkdGggLyAyLCAtc2l6ZS5oZWlnaHQgLyAyKTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdHZhciBwaXhlbHMgPSBjdHguZ2V0SW1hZ2VEYXRhKDAuNSwgMC41LCBNYXRoLmNlaWwod2lkdGgpLFxuXHRcdFx0XHRNYXRoLmNlaWwoaGVpZ2h0KSkuZGF0YSxcblx0XHRcdGNoYW5uZWxzID0gWzAsIDAsIDBdLFxuXHRcdFx0dG90YWwgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGl4ZWxzLmxlbmd0aDsgaSA8IGw7IGkgKz0gNCkge1xuXHRcdFx0dmFyIGFscGhhID0gcGl4ZWxzW2kgKyAzXTtcblx0XHRcdHRvdGFsICs9IGFscGhhO1xuXHRcdFx0YWxwaGEgLz0gMjU1O1xuXHRcdFx0Y2hhbm5lbHNbMF0gKz0gcGl4ZWxzW2ldICogYWxwaGE7XG5cdFx0XHRjaGFubmVsc1sxXSArPSBwaXhlbHNbaSArIDFdICogYWxwaGE7XG5cdFx0XHRjaGFubmVsc1syXSArPSBwaXhlbHNbaSArIDJdICogYWxwaGE7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKVxuXHRcdFx0Y2hhbm5lbHNbaV0gLz0gdG90YWw7XG5cdFx0cmV0dXJuIHRvdGFsID8gQ29sb3IucmVhZChjaGFubmVscykgOiBudWxsO1xuXHR9LFxuXG5cdGdldFBpeGVsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dmFyIGRhdGEgPSB0aGlzLmdldENvbnRleHQoKS5nZXRJbWFnZURhdGEocG9pbnQueCwgcG9pbnQueSwgMSwgMSkuZGF0YTtcblx0XHRyZXR1cm4gbmV3IENvbG9yKCdyZ2InLCBbZGF0YVswXSAvIDI1NSwgZGF0YVsxXSAvIDI1NSwgZGF0YVsyXSAvIDI1NV0sXG5cdFx0XHRcdGRhdGFbM10gLyAyNTUpO1xuXHR9LFxuXG5cdHNldFBpeGVsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjb2xvciA9IENvbG9yLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGNvbXBvbmVudHMgPSBjb2xvci5fY29udmVydCgncmdiJyksXG5cdFx0XHRhbHBoYSA9IGNvbG9yLl9hbHBoYSxcblx0XHRcdGN0eCA9IHRoaXMuZ2V0Q29udGV4dCh0cnVlKSxcblx0XHRcdGltYWdlRGF0YSA9IGN0eC5jcmVhdGVJbWFnZURhdGEoMSwgMSksXG5cdFx0XHRkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG5cdFx0ZGF0YVswXSA9IGNvbXBvbmVudHNbMF0gKiAyNTU7XG5cdFx0ZGF0YVsxXSA9IGNvbXBvbmVudHNbMV0gKiAyNTU7XG5cdFx0ZGF0YVsyXSA9IGNvbXBvbmVudHNbMl0gKiAyNTU7XG5cdFx0ZGF0YVszXSA9IGFscGhhICE9IG51bGwgPyBhbHBoYSAqIDI1NSA6IDI1NTtcblx0XHRjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgcG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0Y3JlYXRlSW1hZ2VEYXRhOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiB0aGlzLmdldENvbnRleHQoKS5jcmVhdGVJbWFnZURhdGEoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdGdldEltYWdlRGF0YTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpO1xuXHRcdGlmIChyZWN0LmlzRW1wdHkoKSlcblx0XHRcdHJlY3QgPSBuZXcgUmVjdGFuZ2xlKHRoaXMuX3NpemUpO1xuXHRcdHJldHVybiB0aGlzLmdldENvbnRleHQoKS5nZXRJbWFnZURhdGEocmVjdC54LCByZWN0LnksXG5cdFx0XHRcdHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcblx0fSxcblxuXHRzZXRJbWFnZURhdGE6IGZ1bmN0aW9uKGRhdGEgKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDEpO1xuXHRcdHRoaXMuZ2V0Q29udGV4dCh0cnVlKS5wdXRJbWFnZURhdGEoZGF0YSwgcG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0X2dldEJvdW5kczogZnVuY3Rpb24oZ2V0dGVyLCBtYXRyaXgpIHtcblx0XHR2YXIgcmVjdCA9IG5ldyBSZWN0YW5nbGUodGhpcy5fc2l6ZSkuc2V0Q2VudGVyKDAsIDApO1xuXHRcdHJldHVybiBtYXRyaXggPyBtYXRyaXguX3RyYW5zZm9ybUJvdW5kcyhyZWN0KSA6IHJlY3Q7XG5cdH0sXG5cblx0X2hpdFRlc3RTZWxmOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdGlmICh0aGlzLl9jb250YWlucyhwb2ludCkpIHtcblx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdHJldHVybiBuZXcgSGl0UmVzdWx0KCdwaXhlbCcsIHRoYXQsIHtcblx0XHRcdFx0b2Zmc2V0OiBwb2ludC5hZGQodGhhdC5fc2l6ZS5kaXZpZGUoMikpLnJvdW5kKCksXG5cdFx0XHRcdGNvbG9yOiB7XG5cdFx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGF0LmdldFBpeGVsKHRoaXMub2Zmc2V0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4KSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoKTtcblx0XHRpZiAoZWxlbWVudCkge1xuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gdGhpcy5fb3BhY2l0eTtcblx0XHRcdGN0eC5kcmF3SW1hZ2UoZWxlbWVudCxcblx0XHRcdFx0XHQtdGhpcy5fc2l6ZS53aWR0aCAvIDIsIC10aGlzLl9zaXplLmhlaWdodCAvIDIpO1xuXHRcdH1cblx0fSxcblxuXHRfY2FuQ29tcG9zaXRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSk7XG5cbnZhciBQbGFjZWRTeW1ib2wgPSBJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BsYWNlZFN5bWJvbCcsXG5cdF9hcHBseU1hdHJpeDogZmFsc2UsXG5cdF9jYW5BcHBseU1hdHJpeDogZmFsc2UsXG5cdF9ib3VuZHNHZXR0ZXI6IHsgZ2V0Qm91bmRzOiAnZ2V0U3Ryb2tlQm91bmRzJyB9LFxuXHRfYm91bmRzU2VsZWN0ZWQ6IHRydWUsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRzeW1ib2w6IG51bGxcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQbGFjZWRTeW1ib2woYXJnMCwgYXJnMSkge1xuXHRcdGlmICghdGhpcy5faW5pdGlhbGl6ZShhcmcwLFxuXHRcdFx0XHRhcmcxICE9PSB1bmRlZmluZWQgJiYgUG9pbnQucmVhZChhcmd1bWVudHMsIDEpKSlcblx0XHRcdHRoaXMuc2V0U3ltYm9sKGFyZzAgaW5zdGFuY2VvZiBTeW1ib2wgPyBhcmcwIDogbmV3IFN5bWJvbChhcmcwKSk7XG5cdH0sXG5cblx0X2VxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLl9zeW1ib2wgPT09IGl0ZW0uX3N5bWJvbDtcblx0fSxcblxuXHRnZXRTeW1ib2w6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zeW1ib2w7XG5cdH0sXG5cblx0c2V0U3ltYm9sOiBmdW5jdGlvbihzeW1ib2wpIHtcblx0XHR0aGlzLl9zeW1ib2wgPSBzeW1ib2w7XG5cdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oaW5zZXJ0KSB7XG5cdFx0dmFyIGNvcHkgPSBuZXcgUGxhY2VkU3ltYm9sKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRjb3B5LnNldFN5bWJvbCh0aGlzLl9zeW1ib2wpO1xuXHRcdHJldHVybiB0aGlzLl9jbG9uZShjb3B5LCBpbnNlcnQpO1xuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zeW1ib2wuX2RlZmluaXRpb24uaXNFbXB0eSgpO1xuXHR9LFxuXG5cdF9nZXRCb3VuZHM6IGZ1bmN0aW9uKGdldHRlciwgbWF0cml4LCBjYWNoZUl0ZW0pIHtcblx0XHR2YXIgZGVmaW5pdGlvbiA9IHRoaXMuc3ltYm9sLl9kZWZpbml0aW9uO1xuXHRcdHJldHVybiBkZWZpbml0aW9uLl9nZXRDYWNoZWRCb3VuZHMoZ2V0dGVyLFxuXHRcdFx0XHRtYXRyaXggJiYgbWF0cml4LmNoYWluKGRlZmluaXRpb24uX21hdHJpeCksIGNhY2hlSXRlbSk7XG5cdH0sXG5cblx0X2hpdFRlc3RTZWxmOiBmdW5jdGlvbihwb2ludCwgb3B0aW9ucykge1xuXHRcdHZhciByZXMgPSB0aGlzLl9zeW1ib2wuX2RlZmluaXRpb24uX2hpdFRlc3QocG9pbnQsIG9wdGlvbnMpO1xuXHRcdGlmIChyZXMpXG5cdFx0XHRyZXMuaXRlbSA9IHRoaXM7XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSkge1xuXHRcdHRoaXMuc3ltYm9sLl9kZWZpbml0aW9uLmRyYXcoY3R4LCBwYXJhbSk7XG5cdH1cblxufSk7XG5cbnZhciBIaXRSZXN1bHQgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0hpdFJlc3VsdCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gSGl0UmVzdWx0KHR5cGUsIGl0ZW0sIHZhbHVlcykge1xuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFx0dGhpcy5pdGVtID0gaXRlbTtcblx0XHRpZiAodmFsdWVzKSB7XG5cdFx0XHR2YWx1ZXMuZW51bWVyYWJsZSA9IHRydWU7XG5cdFx0XHR0aGlzLmluamVjdCh2YWx1ZXMpO1xuXHRcdH1cblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0Z2V0T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdFx0cmV0dXJuIG5ldyBCYXNlKHtcblx0XHRcdFx0dHlwZTogbnVsbCxcblx0XHRcdFx0dG9sZXJhbmNlOiBwYXBlci5zZXR0aW5ncy5oaXRUb2xlcmFuY2UsXG5cdFx0XHRcdGZpbGw6ICFvcHRpb25zLFxuXHRcdFx0XHRzdHJva2U6ICFvcHRpb25zLFxuXHRcdFx0XHRzZWdtZW50czogIW9wdGlvbnMsXG5cdFx0XHRcdGhhbmRsZXM6IGZhbHNlLFxuXHRcdFx0XHRlbmRzOiBmYWxzZSxcblx0XHRcdFx0Y2VudGVyOiBmYWxzZSxcblx0XHRcdFx0Ym91bmRzOiBmYWxzZSxcblx0XHRcdFx0Z3VpZGVzOiBmYWxzZSxcblx0XHRcdFx0c2VsZWN0ZWQ6IGZhbHNlXG5cdFx0XHR9LCBvcHRpb25zKTtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgU2VnbWVudCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnU2VnbWVudCcsXG5cdGJlYW5zOiB0cnVlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFNlZ21lbnQoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSkge1xuXHRcdHZhciBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0XHRwb2ludCwgaGFuZGxlSW4sIGhhbmRsZU91dDtcblx0XHRpZiAoY291bnQgPT09IDApIHtcblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSAxKSB7XG5cdFx0XHRpZiAoYXJnMC5wb2ludCkge1xuXHRcdFx0XHRwb2ludCA9IGFyZzAucG9pbnQ7XG5cdFx0XHRcdGhhbmRsZUluID0gYXJnMC5oYW5kbGVJbjtcblx0XHRcdFx0aGFuZGxlT3V0ID0gYXJnMC5oYW5kbGVPdXQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwb2ludCA9IGFyZzA7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gMiAmJiB0eXBlb2YgYXJnMCA9PT0gJ251bWJlcicpIHtcblx0XHRcdHBvaW50ID0gYXJndW1lbnRzO1xuXHRcdH0gZWxzZSBpZiAoY291bnQgPD0gMykge1xuXHRcdFx0cG9pbnQgPSBhcmcwO1xuXHRcdFx0aGFuZGxlSW4gPSBhcmcxO1xuXHRcdFx0aGFuZGxlT3V0ID0gYXJnMjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cG9pbnQgPSBhcmcwICE9PSB1bmRlZmluZWQgPyBbIGFyZzAsIGFyZzEgXSA6IG51bGw7XG5cdFx0XHRoYW5kbGVJbiA9IGFyZzIgIT09IHVuZGVmaW5lZCA/IFsgYXJnMiwgYXJnMyBdIDogbnVsbDtcblx0XHRcdGhhbmRsZU91dCA9IGFyZzQgIT09IHVuZGVmaW5lZCA/IFsgYXJnNCwgYXJnNSBdIDogbnVsbDtcblx0XHR9XG5cdFx0bmV3IFNlZ21lbnRQb2ludChwb2ludCwgdGhpcywgJ19wb2ludCcpO1xuXHRcdG5ldyBTZWdtZW50UG9pbnQoaGFuZGxlSW4sIHRoaXMsICdfaGFuZGxlSW4nKTtcblx0XHRuZXcgU2VnbWVudFBvaW50KGhhbmRsZU91dCwgdGhpcywgJ19oYW5kbGVPdXQnKTtcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKHRoaXMuaXNTdHJhaWdodCgpID8gdGhpcy5fcG9pbnRcblx0XHRcdFx0OiBbdGhpcy5fcG9pbnQsIHRoaXMuX2hhbmRsZUluLCB0aGlzLl9oYW5kbGVPdXRdLFxuXHRcdFx0XHRvcHRpb25zLCB0cnVlKTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHR2YXIgcGF0aCA9IHRoaXMuX3BhdGg7XG5cdFx0aWYgKCFwYXRoKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHZhciBjdXJ2ZXMgPSBwYXRoLl9jdXJ2ZXMsXG5cdFx0XHRpbmRleCA9IHRoaXMuX2luZGV4LFxuXHRcdFx0Y3VydmU7XG5cdFx0aWYgKGN1cnZlcykge1xuXHRcdFx0aWYgKCghcG9pbnQgfHwgcG9pbnQgPT09IHRoaXMuX3BvaW50IHx8IHBvaW50ID09PSB0aGlzLl9oYW5kbGVJbilcblx0XHRcdFx0XHQmJiAoY3VydmUgPSBpbmRleCA+IDAgPyBjdXJ2ZXNbaW5kZXggLSAxXSA6IHBhdGguX2Nsb3NlZFxuXHRcdFx0XHRcdFx0PyBjdXJ2ZXNbY3VydmVzLmxlbmd0aCAtIDFdIDogbnVsbCkpXG5cdFx0XHRcdGN1cnZlLl9jaGFuZ2VkKCk7XG5cdFx0XHRpZiAoKCFwb2ludCB8fCBwb2ludCA9PT0gdGhpcy5fcG9pbnQgfHwgcG9pbnQgPT09IHRoaXMuX2hhbmRsZU91dClcblx0XHRcdFx0XHQmJiAoY3VydmUgPSBjdXJ2ZXNbaW5kZXhdKSlcblx0XHRcdFx0Y3VydmUuX2NoYW5nZWQoKTtcblx0XHR9XG5cdFx0cGF0aC5fY2hhbmdlZCgyNSk7XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wb2ludDtcblx0fSxcblxuXHRzZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuX3BvaW50LnNldChwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRIYW5kbGVJbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2hhbmRsZUluO1xuXHR9LFxuXG5cdHNldEhhbmRsZUluOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5faGFuZGxlSW4uc2V0KHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGdldEhhbmRsZU91dDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2hhbmRsZU91dDtcblx0fSxcblxuXHRzZXRIYW5kbGVPdXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLl9oYW5kbGVPdXQuc2V0KHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGhhc0hhbmRsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5pc1N0cmFpZ2h0KCk7XG5cdH0sXG5cblx0aXNTdHJhaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2hhbmRsZUluLmlzWmVybygpICYmIHRoaXMuX2hhbmRsZU91dC5pc1plcm8oKTtcblx0fSxcblxuXHRpc0xpbmVhcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFNlZ21lbnQuaXNMaW5lYXIodGhpcywgdGhpcy5nZXROZXh0KCkpO1xuXHR9LFxuXG5cdGlzQ29sbGluZWFyOiBmdW5jdGlvbihzZWdtZW50KSB7XG5cdFx0cmV0dXJuIFNlZ21lbnQuaXNDb2xsaW5lYXIodGhpcywgdGhpcy5nZXROZXh0KCksXG5cdFx0XHRcdHNlZ21lbnQsIHNlZ21lbnQuZ2V0TmV4dCgpKTtcblx0fSxcblxuXHRpc0NvbGluZWFyOiAnI2lzQ29sbGluZWFyJyxcblxuXHRpc09ydGhvZ29uYWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBTZWdtZW50LmlzT3J0aG9nb25hbCh0aGlzLmdldFByZXZpb3VzKCksIHRoaXMsIHRoaXMuZ2V0TmV4dCgpKTtcblx0fSxcblxuXHRpc09ydGhvZ29uYWxBcmM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBTZWdtZW50LmlzT3J0aG9nb25hbEFyYyh0aGlzLCB0aGlzLmdldE5leHQoKSk7XG5cdH0sXG5cblx0aXNBcmM6ICcjaXNPcnRob2dvbmFsQXJjJyxcblxuXHRfc2VsZWN0aW9uU3RhdGU6IDAsXG5cblx0aXNTZWxlY3RlZDogZnVuY3Rpb24oX3BvaW50KSB7XG5cdFx0dmFyIHN0YXRlID0gdGhpcy5fc2VsZWN0aW9uU3RhdGU7XG5cdFx0cmV0dXJuICFfcG9pbnQgPyAhIShzdGF0ZSAmIDcpXG5cdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5fcG9pbnQgPyAhIShzdGF0ZSAmIDQpXG5cdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5faGFuZGxlSW4gPyAhIShzdGF0ZSAmIDEpXG5cdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5faGFuZGxlT3V0ID8gISEoc3RhdGUgJiAyKVxuXHRcdFx0OiBmYWxzZTtcblx0fSxcblxuXHRzZXRTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQsIF9wb2ludCkge1xuXHRcdHZhciBwYXRoID0gdGhpcy5fcGF0aCxcblx0XHRcdHNlbGVjdGVkID0gISFzZWxlY3RlZCxcblx0XHRcdHN0YXRlID0gdGhpcy5fc2VsZWN0aW9uU3RhdGUsXG5cdFx0XHRvbGRTdGF0ZSA9IHN0YXRlLFxuXHRcdFx0ZmxhZyA9ICFfcG9pbnQgPyA3XG5cdFx0XHRcdFx0OiBfcG9pbnQgPT09IHRoaXMuX3BvaW50ID8gNFxuXHRcdFx0XHRcdDogX3BvaW50ID09PSB0aGlzLl9oYW5kbGVJbiA/IDFcblx0XHRcdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5faGFuZGxlT3V0ID8gMlxuXHRcdFx0XHRcdDogMDtcblx0XHRpZiAoc2VsZWN0ZWQpIHtcblx0XHRcdHN0YXRlIHw9IGZsYWc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0YXRlICY9IH5mbGFnO1xuXHRcdH1cblx0XHR0aGlzLl9zZWxlY3Rpb25TdGF0ZSA9IHN0YXRlO1xuXHRcdGlmIChwYXRoICYmIHN0YXRlICE9PSBvbGRTdGF0ZSkge1xuXHRcdFx0cGF0aC5fdXBkYXRlU2VsZWN0aW9uKHRoaXMsIG9sZFN0YXRlLCBzdGF0ZSk7XG5cdFx0XHRwYXRoLl9jaGFuZ2VkKDEyOSk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldEluZGV4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5kZXggIT09IHVuZGVmaW5lZCA/IHRoaXMuX2luZGV4IDogbnVsbDtcblx0fSxcblxuXHRnZXRQYXRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aCB8fCBudWxsO1xuXHR9LFxuXG5cdGdldEN1cnZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGF0aCA9IHRoaXMuX3BhdGgsXG5cdFx0XHRpbmRleCA9IHRoaXMuX2luZGV4O1xuXHRcdGlmIChwYXRoKSB7XG5cdFx0XHRpZiAoaW5kZXggPiAwICYmICFwYXRoLl9jbG9zZWRcblx0XHRcdFx0XHQmJiBpbmRleCA9PT0gcGF0aC5fc2VnbWVudHMubGVuZ3RoIC0gMSlcblx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdHJldHVybiBwYXRoLmdldEN1cnZlcygpW2luZGV4XSB8fCBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRnZXRMb2NhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpO1xuXHRcdHJldHVybiBjdXJ2ZVxuXHRcdFx0XHQ/IG5ldyBDdXJ2ZUxvY2F0aW9uKGN1cnZlLCB0aGlzID09PSBjdXJ2ZS5fc2VnbWVudDEgPyAwIDogMSlcblx0XHRcdFx0OiBudWxsO1xuXHR9LFxuXG5cdGdldE5leHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3BhdGggJiYgdGhpcy5fcGF0aC5fc2VnbWVudHM7XG5cdFx0cmV0dXJuIHNlZ21lbnRzICYmIChzZWdtZW50c1t0aGlzLl9pbmRleCArIDFdXG5cdFx0XHRcdHx8IHRoaXMuX3BhdGguX2Nsb3NlZCAmJiBzZWdtZW50c1swXSkgfHwgbnVsbDtcblx0fSxcblxuXHRnZXRQcmV2aW91czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fcGF0aCAmJiB0aGlzLl9wYXRoLl9zZWdtZW50cztcblx0XHRyZXR1cm4gc2VnbWVudHMgJiYgKHNlZ21lbnRzW3RoaXMuX2luZGV4IC0gMV1cblx0XHRcdFx0fHwgdGhpcy5fcGF0aC5fY2xvc2VkICYmIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdKSB8fCBudWxsO1xuXHR9LFxuXG5cdHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU2VnbWVudCh0aGlzLl9wb2ludCwgdGhpcy5faGFuZGxlT3V0LCB0aGlzLl9oYW5kbGVJbik7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aCA/ICEhdGhpcy5fcGF0aC5yZW1vdmVTZWdtZW50KHRoaXMuX2luZGV4KSA6IGZhbHNlO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFNlZ21lbnQodGhpcy5fcG9pbnQsIHRoaXMuX2hhbmRsZUluLCB0aGlzLl9oYW5kbGVPdXQpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc2VnbWVudCkge1xuXHRcdHJldHVybiBzZWdtZW50ID09PSB0aGlzIHx8IHNlZ21lbnQgJiYgdGhpcy5fY2xhc3MgPT09IHNlZ21lbnQuX2NsYXNzXG5cdFx0XHRcdCYmIHRoaXMuX3BvaW50LmVxdWFscyhzZWdtZW50Ll9wb2ludClcblx0XHRcdFx0JiYgdGhpcy5faGFuZGxlSW4uZXF1YWxzKHNlZ21lbnQuX2hhbmRsZUluKVxuXHRcdFx0XHQmJiB0aGlzLl9oYW5kbGVPdXQuZXF1YWxzKHNlZ21lbnQuX2hhbmRsZU91dClcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJ0cyA9IFsgJ3BvaW50OiAnICsgdGhpcy5fcG9pbnQgXTtcblx0XHRpZiAoIXRoaXMuX2hhbmRsZUluLmlzWmVybygpKVxuXHRcdFx0cGFydHMucHVzaCgnaGFuZGxlSW46ICcgKyB0aGlzLl9oYW5kbGVJbik7XG5cdFx0aWYgKCF0aGlzLl9oYW5kbGVPdXQuaXNaZXJvKCkpXG5cdFx0XHRwYXJ0cy5wdXNoKCdoYW5kbGVPdXQ6ICcgKyB0aGlzLl9oYW5kbGVPdXQpO1xuXHRcdHJldHVybiAneyAnICsgcGFydHMuam9pbignLCAnKSArICcgfSc7XG5cdH0sXG5cblx0dHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR0aGlzLl90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIG5ldyBBcnJheSg2KSwgdHJ1ZSk7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Db29yZGluYXRlczogZnVuY3Rpb24obWF0cml4LCBjb29yZHMsIGNoYW5nZSkge1xuXHRcdHZhciBwb2ludCA9IHRoaXMuX3BvaW50LFxuXHRcdFx0aGFuZGxlSW4gPSAhY2hhbmdlIHx8ICF0aGlzLl9oYW5kbGVJbi5pc1plcm8oKVxuXHRcdFx0XHRcdD8gdGhpcy5faGFuZGxlSW4gOiBudWxsLFxuXHRcdFx0aGFuZGxlT3V0ID0gIWNoYW5nZSB8fCAhdGhpcy5faGFuZGxlT3V0LmlzWmVybygpXG5cdFx0XHRcdFx0PyB0aGlzLl9oYW5kbGVPdXQgOiBudWxsLFxuXHRcdFx0eCA9IHBvaW50Ll94LFxuXHRcdFx0eSA9IHBvaW50Ll95LFxuXHRcdFx0aSA9IDI7XG5cdFx0Y29vcmRzWzBdID0geDtcblx0XHRjb29yZHNbMV0gPSB5O1xuXHRcdGlmIChoYW5kbGVJbikge1xuXHRcdFx0Y29vcmRzW2krK10gPSBoYW5kbGVJbi5feCArIHg7XG5cdFx0XHRjb29yZHNbaSsrXSA9IGhhbmRsZUluLl95ICsgeTtcblx0XHR9XG5cdFx0aWYgKGhhbmRsZU91dCkge1xuXHRcdFx0Y29vcmRzW2krK10gPSBoYW5kbGVPdXQuX3ggKyB4O1xuXHRcdFx0Y29vcmRzW2krK10gPSBoYW5kbGVPdXQuX3kgKyB5O1xuXHRcdH1cblx0XHRpZiAobWF0cml4KSB7XG5cdFx0XHRtYXRyaXguX3RyYW5zZm9ybUNvb3JkaW5hdGVzKGNvb3JkcywgY29vcmRzLCBpIC8gMik7XG5cdFx0XHR4ID0gY29vcmRzWzBdO1xuXHRcdFx0eSA9IGNvb3Jkc1sxXTtcblx0XHRcdGlmIChjaGFuZ2UpIHtcblx0XHRcdFx0cG9pbnQuX3ggPSB4O1xuXHRcdFx0XHRwb2ludC5feSA9IHk7XG5cdFx0XHRcdGkgID0gMjtcblx0XHRcdFx0aWYgKGhhbmRsZUluKSB7XG5cdFx0XHRcdFx0aGFuZGxlSW4uX3ggPSBjb29yZHNbaSsrXSAtIHg7XG5cdFx0XHRcdFx0aGFuZGxlSW4uX3kgPSBjb29yZHNbaSsrXSAtIHk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGhhbmRsZU91dCkge1xuXHRcdFx0XHRcdGhhbmRsZU91dC5feCA9IGNvb3Jkc1tpKytdIC0geDtcblx0XHRcdFx0XHRoYW5kbGVPdXQuX3kgPSBjb29yZHNbaSsrXSAtIHk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICghaGFuZGxlSW4pIHtcblx0XHRcdFx0XHRjb29yZHNbaSsrXSA9IHg7XG5cdFx0XHRcdFx0Y29vcmRzW2krK10gPSB5O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghaGFuZGxlT3V0KSB7XG5cdFx0XHRcdFx0Y29vcmRzW2krK10gPSB4O1xuXHRcdFx0XHRcdGNvb3Jkc1tpKytdID0geTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY29vcmRzO1xuXHR9LFxuXG4gICBzdGF0aWNzOiB7XG5cblx0XHRpc0xpbmVhcjogZnVuY3Rpb24oc2VnMSwgc2VnMikge1xuXHRcdFx0dmFyIGwgPSBzZWcyLl9wb2ludC5zdWJ0cmFjdChzZWcxLl9wb2ludCk7XG5cdFx0XHRyZXR1cm4gbC5pc0NvbGxpbmVhcihzZWcxLl9oYW5kbGVPdXQpXG5cdFx0XHRcdFx0JiYgbC5pc0NvbGxpbmVhcihzZWcyLl9oYW5kbGVJbik7XG5cdFx0fSxcblxuXHRcdGlzQ29sbGluZWFyOiBmdW5jdGlvbihzZWcxLCBzZWcyLCBzZWczLCBzZWc0KSB7XG5cdFx0XHRyZXR1cm4gc2VnMS5faGFuZGxlT3V0LmlzWmVybygpICYmIHNlZzIuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHRcdFx0JiYgc2VnMy5faGFuZGxlT3V0LmlzWmVybygpICYmIHNlZzQuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHRcdFx0JiYgc2VnMi5fcG9pbnQuc3VidHJhY3Qoc2VnMS5fcG9pbnQpLmlzQ29sbGluZWFyKFxuXHRcdFx0XHRcdFx0c2VnNC5fcG9pbnQuc3VidHJhY3Qoc2VnMy5fcG9pbnQpKTtcblx0XHR9LFxuXG5cdFx0aXNPcnRob2dvbmFsOiBmdW5jdGlvbihzZWcxLCBzZWcyLCBzZWczKSB7XG5cdFx0XHRyZXR1cm4gc2VnMS5faGFuZGxlT3V0LmlzWmVybygpICYmIHNlZzIuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHRcdCYmIHNlZzIuX2hhbmRsZU91dC5pc1plcm8oKSAmJiBzZWczLl9oYW5kbGVJbi5pc1plcm8oKVxuXHRcdFx0XHQmJiBzZWcyLl9wb2ludC5zdWJ0cmFjdChzZWcxLl9wb2ludCkuaXNPcnRob2dvbmFsKFxuXHRcdFx0XHRcdFx0c2VnMy5fcG9pbnQuc3VidHJhY3Qoc2VnMi5fcG9pbnQpKTtcblx0XHR9LFxuXG5cdFx0aXNPcnRob2dvbmFsQXJjOiBmdW5jdGlvbihzZWcxLCBzZWcyKSB7XG5cdFx0XHR2YXIgaGFuZGxlMSA9IHNlZzEuX2hhbmRsZU91dCxcblx0XHRcdFx0aGFuZGxlMiA9IHNlZzIuX2hhbmRsZUluLFxuXHRcdFx0XHRrYXBwYSA9IDAuNTUyMjg0NzQ5ODMwNzkzNjtcblx0XHRcdGlmIChoYW5kbGUxLmlzT3J0aG9nb25hbChoYW5kbGUyKSkge1xuXHRcdFx0XHR2YXIgcHQxID0gc2VnMS5fcG9pbnQsXG5cdFx0XHRcdFx0cHQyID0gc2VnMi5fcG9pbnQsXG5cdFx0XHRcdFx0Y29ybmVyID0gbmV3IExpbmUocHQxLCBoYW5kbGUxLCB0cnVlKS5pbnRlcnNlY3QoXG5cdFx0XHRcdFx0XHRcdG5ldyBMaW5lKHB0MiwgaGFuZGxlMiwgdHJ1ZSksIHRydWUpO1xuXHRcdFx0XHRyZXR1cm4gY29ybmVyICYmIE51bWVyaWNhbC5pc1plcm8oaGFuZGxlMS5nZXRMZW5ndGgoKSAvXG5cdFx0XHRcdFx0XHRjb3JuZXIuc3VidHJhY3QocHQxKS5nZXRMZW5ndGgoKSAtIGthcHBhKVxuXHRcdFx0XHRcdCYmIE51bWVyaWNhbC5pc1plcm8oaGFuZGxlMi5nZXRMZW5ndGgoKSAvXG5cdFx0XHRcdFx0XHRjb3JuZXIuc3VidHJhY3QocHQyKS5nZXRMZW5ndGgoKSAtIGthcHBhKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHR9XG59KTtcblxudmFyIFNlZ21lbnRQb2ludCA9IFBvaW50LmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFNlZ21lbnRQb2ludChwb2ludCwgb3duZXIsIGtleSkge1xuXHRcdHZhciB4LCB5LCBzZWxlY3RlZDtcblx0XHRpZiAoIXBvaW50KSB7XG5cdFx0XHR4ID0geSA9IDA7XG5cdFx0fSBlbHNlIGlmICgoeCA9IHBvaW50WzBdKSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR5ID0gcG9pbnRbMV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwdCA9IHBvaW50O1xuXHRcdFx0aWYgKCh4ID0gcHQueCkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRwdCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdFx0eCA9IHB0Lng7XG5cdFx0XHR9XG5cdFx0XHR5ID0gcHQueTtcblx0XHRcdHNlbGVjdGVkID0gcHQuc2VsZWN0ZWQ7XG5cdFx0fVxuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX293bmVyID0gb3duZXI7XG5cdFx0b3duZXJba2V5XSA9IHRoaXM7XG5cdFx0aWYgKHNlbGVjdGVkKVxuXHRcdFx0dGhpcy5zZXRTZWxlY3RlZCh0cnVlKTtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl9vd25lci5fY2hhbmdlZCh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIGYgPSBvcHRpb25zLmZvcm1hdHRlcixcblx0XHRcdHggPSBmLm51bWJlcih0aGlzLl94KSxcblx0XHRcdHkgPSBmLm51bWJlcih0aGlzLl95KTtcblx0XHRyZXR1cm4gdGhpcy5pc1NlbGVjdGVkKClcblx0XHRcdFx0PyB7IHg6IHgsIHk6IHksIHNlbGVjdGVkOiB0cnVlIH1cblx0XHRcdFx0OiBbeCwgeV07XG5cdH0sXG5cblx0Z2V0WDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3g7XG5cdH0sXG5cblx0c2V0WDogZnVuY3Rpb24oeCkge1xuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX293bmVyLl9jaGFuZ2VkKHRoaXMpO1xuXHR9LFxuXG5cdGdldFk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl95O1xuXHR9LFxuXG5cdHNldFk6IGZ1bmN0aW9uKHkpIHtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl9vd25lci5fY2hhbmdlZCh0aGlzKTtcblx0fSxcblxuXHRpc1plcm86IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBOdW1lcmljYWwuaXNaZXJvKHRoaXMuX3gpICYmIE51bWVyaWNhbC5pc1plcm8odGhpcy5feSk7XG5cdH0sXG5cblx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0dGhpcy5fb3duZXIuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQsIHRoaXMpO1xuXHR9LFxuXG5cdGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9vd25lci5pc1NlbGVjdGVkKHRoaXMpO1xuXHR9XG59KTtcblxudmFyIEN1cnZlID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdDdXJ2ZScsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gQ3VydmUoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSwgYXJnNiwgYXJnNykge1xuXHRcdHZhciBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0aWYgKGNvdW50ID09PSAzKSB7XG5cdFx0XHR0aGlzLl9wYXRoID0gYXJnMDtcblx0XHRcdHRoaXMuX3NlZ21lbnQxID0gYXJnMTtcblx0XHRcdHRoaXMuX3NlZ21lbnQyID0gYXJnMjtcblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSAwKSB7XG5cdFx0XHR0aGlzLl9zZWdtZW50MSA9IG5ldyBTZWdtZW50KCk7XG5cdFx0XHR0aGlzLl9zZWdtZW50MiA9IG5ldyBTZWdtZW50KCk7XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gMSkge1xuXHRcdFx0dGhpcy5fc2VnbWVudDEgPSBuZXcgU2VnbWVudChhcmcwLnNlZ21lbnQxKTtcblx0XHRcdHRoaXMuX3NlZ21lbnQyID0gbmV3IFNlZ21lbnQoYXJnMC5zZWdtZW50Mik7XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gMikge1xuXHRcdFx0dGhpcy5fc2VnbWVudDEgPSBuZXcgU2VnbWVudChhcmcwKTtcblx0XHRcdHRoaXMuX3NlZ21lbnQyID0gbmV3IFNlZ21lbnQoYXJnMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwb2ludDEsIGhhbmRsZTEsIGhhbmRsZTIsIHBvaW50Mjtcblx0XHRcdGlmIChjb3VudCA9PT0gNCkge1xuXHRcdFx0XHRwb2ludDEgPSBhcmcwO1xuXHRcdFx0XHRoYW5kbGUxID0gYXJnMTtcblx0XHRcdFx0aGFuZGxlMiA9IGFyZzI7XG5cdFx0XHRcdHBvaW50MiA9IGFyZzM7XG5cdFx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSA4KSB7XG5cdFx0XHRcdHBvaW50MSA9IFthcmcwLCBhcmcxXTtcblx0XHRcdFx0cG9pbnQyID0gW2FyZzYsIGFyZzddO1xuXHRcdFx0XHRoYW5kbGUxID0gW2FyZzIgLSBhcmcwLCBhcmczIC0gYXJnMV07XG5cdFx0XHRcdGhhbmRsZTIgPSBbYXJnNCAtIGFyZzYsIGFyZzUgLSBhcmc3XTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3NlZ21lbnQxID0gbmV3IFNlZ21lbnQocG9pbnQxLCBudWxsLCBoYW5kbGUxKTtcblx0XHRcdHRoaXMuX3NlZ21lbnQyID0gbmV3IFNlZ21lbnQocG9pbnQyLCBoYW5kbGUyLCBudWxsKTtcblx0XHR9XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2xlbmd0aCA9IHRoaXMuX2JvdW5kcyA9IHVuZGVmaW5lZDtcblx0fSxcblxuXHRnZXRQb2ludDE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50MS5fcG9pbnQ7XG5cdH0sXG5cblx0c2V0UG9pbnQxOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5fc2VnbWVudDEuX3BvaW50LnNldChwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRQb2ludDI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50Mi5fcG9pbnQ7XG5cdH0sXG5cblx0c2V0UG9pbnQyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5fc2VnbWVudDIuX3BvaW50LnNldChwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRIYW5kbGUxOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dDtcblx0fSxcblxuXHRzZXRIYW5kbGUxOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5zZXQocG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0Z2V0SGFuZGxlMjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbjtcblx0fSxcblxuXHRzZXRIYW5kbGUyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5fc2VnbWVudDIuX2hhbmRsZUluLnNldChwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRTZWdtZW50MTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQxO1xuXHR9LFxuXG5cdGdldFNlZ21lbnQyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDI7XG5cdH0sXG5cblx0Z2V0UGF0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhdGg7XG5cdH0sXG5cblx0Z2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50MS5faW5kZXg7XG5cdH0sXG5cblx0Z2V0TmV4dDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlcyA9IHRoaXMuX3BhdGggJiYgdGhpcy5fcGF0aC5fY3VydmVzO1xuXHRcdHJldHVybiBjdXJ2ZXMgJiYgKGN1cnZlc1t0aGlzLl9zZWdtZW50MS5faW5kZXggKyAxXVxuXHRcdFx0XHR8fCB0aGlzLl9wYXRoLl9jbG9zZWQgJiYgY3VydmVzWzBdKSB8fCBudWxsO1xuXHR9LFxuXG5cdGdldFByZXZpb3VzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5fcGF0aCAmJiB0aGlzLl9wYXRoLl9jdXJ2ZXM7XG5cdFx0cmV0dXJuIGN1cnZlcyAmJiAoY3VydmVzW3RoaXMuX3NlZ21lbnQxLl9pbmRleCAtIDFdXG5cdFx0XHRcdHx8IHRoaXMuX3BhdGguX2Nsb3NlZCAmJiBjdXJ2ZXNbY3VydmVzLmxlbmd0aCAtIDFdKSB8fCBudWxsO1xuXHR9LFxuXG5cdGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFBvaW50MSgpLmlzU2VsZWN0ZWQoKVxuXHRcdFx0XHQmJiB0aGlzLmdldEhhbmRsZTIoKS5pc1NlbGVjdGVkKClcblx0XHRcdFx0JiYgdGhpcy5nZXRIYW5kbGUyKCkuaXNTZWxlY3RlZCgpXG5cdFx0XHRcdCYmIHRoaXMuZ2V0UG9pbnQyKCkuaXNTZWxlY3RlZCgpO1xuXHR9LFxuXG5cdHNldFNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuXHRcdHRoaXMuZ2V0UG9pbnQxKCkuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuXHRcdHRoaXMuZ2V0SGFuZGxlMSgpLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcblx0XHR0aGlzLmdldEhhbmRsZTIoKS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdFx0dGhpcy5nZXRQb2ludDIoKS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdH0sXG5cblx0Z2V0VmFsdWVzOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRyZXR1cm4gQ3VydmUuZ2V0VmFsdWVzKHRoaXMuX3NlZ21lbnQxLCB0aGlzLl9zZWdtZW50MiwgbWF0cml4KTtcblx0fSxcblxuXHRnZXRQb2ludHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjb29yZHMgPSB0aGlzLmdldFZhbHVlcygpLFxuXHRcdFx0cG9pbnRzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpICs9IDIpXG5cdFx0XHRwb2ludHMucHVzaChuZXcgUG9pbnQoY29vcmRzW2ldLCBjb29yZHNbaSArIDFdKSk7XG5cdFx0cmV0dXJuIHBvaW50cztcblx0fSxcblxuXHRnZXRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9sZW5ndGggPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fbGVuZ3RoID0gdGhpcy5pc0xpbmVhcigpXG5cdFx0XHRcdD8gdGhpcy5fc2VnbWVudDIuX3BvaW50LmdldERpc3RhbmNlKHRoaXMuX3NlZ21lbnQxLl9wb2ludClcblx0XHRcdFx0OiBDdXJ2ZS5nZXRMZW5ndGgodGhpcy5nZXRWYWx1ZXMoKSwgMCwgMSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9sZW5ndGg7XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIEN1cnZlLmdldEFyZWEodGhpcy5nZXRWYWx1ZXMoKSk7XG5cdH0sXG5cblx0Z2V0UGFydDogZnVuY3Rpb24oZnJvbSwgdG8pIHtcblx0XHRyZXR1cm4gbmV3IEN1cnZlKEN1cnZlLmdldFBhcnQodGhpcy5nZXRWYWx1ZXMoKSwgZnJvbSwgdG8pKTtcblx0fSxcblxuXHRnZXRQYXJ0TGVuZ3RoOiBmdW5jdGlvbihmcm9tLCB0bykge1xuXHRcdHJldHVybiBDdXJ2ZS5nZXRMZW5ndGgodGhpcy5nZXRWYWx1ZXMoKSwgZnJvbSwgdG8pO1xuXHR9LFxuXG5cdGhhc0hhbmRsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5pc1plcm8oKVxuXHRcdFx0XHR8fCAhdGhpcy5fc2VnbWVudDIuX2hhbmRsZUluLmlzWmVybygpO1xuXHR9LFxuXG5cdGlzTGluZWFyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gU2VnbWVudC5pc0xpbmVhcih0aGlzLl9zZWdtZW50MSwgdGhpcy5fc2VnbWVudDIpO1xuXHR9LFxuXG5cdGlzQ29sbGluZWFyOiBmdW5jdGlvbihjdXJ2ZSkge1xuXHRcdHJldHVybiBTc2VnbWVudC5pc0NvbGxpbmVhcih0aGlzLl9zZWdtZW50MSwgdGhpcy5fc2VnbWVudDIsXG5cdFx0XHRcdGN1cnZlLl9zZWdtZW50MSwgY3VydmUuX3NlZ21lbnQyKTtcblx0fSxcblxuXHRpc09ydGhvZ29uYWxBcmM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBTZWdtZW50LmlzT3J0aG9nb25hbEFyYyh0aGlzLl9zZWdtZW50MSwgdGhpcy5fc2VnbWVudDIpO1xuXHR9LFxuXG5cdGdldEludGVyc2VjdGlvbnM6IGZ1bmN0aW9uKGN1cnZlKSB7XG5cdFx0cmV0dXJuIEN1cnZlLmZpbHRlckludGVyc2VjdGlvbnMoQ3VydmUuZ2V0SW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0dGhpcy5nZXRWYWx1ZXMoKSwgY3VydmUuZ2V0VmFsdWVzKCksIHRoaXMsIGN1cnZlLCBbXSkpO1xuXHR9LFxuXG5cdF9nZXRQYXJhbWV0ZXI6IGZ1bmN0aW9uKG9mZnNldCwgaXNQYXJhbWV0ZXIpIHtcblx0XHRyZXR1cm4gaXNQYXJhbWV0ZXJcblx0XHRcdFx0PyBvZmZzZXRcblx0XHRcdFx0OiBvZmZzZXQgJiYgb2Zmc2V0LmN1cnZlID09PSB0aGlzXG5cdFx0XHRcdFx0PyBvZmZzZXQucGFyYW1ldGVyXG5cdFx0XHRcdFx0OiBvZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBpc1BhcmFtZXRlciA9PT0gdW5kZWZpbmVkXG5cdFx0XHRcdFx0XHQ/IDAuNVxuXHRcdFx0XHRcdFx0OiB0aGlzLmdldFBhcmFtZXRlckF0KG9mZnNldCwgMCk7XG5cdH0sXG5cblx0ZGl2aWRlOiBmdW5jdGlvbihvZmZzZXQsIGlzUGFyYW1ldGVyLCBpZ25vcmVMaW5lYXIpIHtcblx0XHR2YXIgcGFyYW1ldGVyID0gdGhpcy5fZ2V0UGFyYW1ldGVyKG9mZnNldCwgaXNQYXJhbWV0ZXIpLFxuXHRcdFx0dG9sZXJhbmNlID0gMC4wMDAwMDEsXG5cdFx0XHRyZXMgPSBudWxsO1xuXHRcdGlmIChwYXJhbWV0ZXIgPiB0b2xlcmFuY2UgJiYgcGFyYW1ldGVyIDwgMSAtIHRvbGVyYW5jZSkge1xuXHRcdFx0dmFyIHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHRoaXMuZ2V0VmFsdWVzKCksIHBhcmFtZXRlciksXG5cdFx0XHRcdGlzTGluZWFyID0gaWdub3JlTGluZWFyID8gZmFsc2UgOiB0aGlzLmlzTGluZWFyKCksXG5cdFx0XHRcdGxlZnQgPSBwYXJ0c1swXSxcblx0XHRcdFx0cmlnaHQgPSBwYXJ0c1sxXTtcblxuXHRcdFx0aWYgKCFpc0xpbmVhcikge1xuXHRcdFx0XHR0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0LnNldChsZWZ0WzJdIC0gbGVmdFswXSxcblx0XHRcdFx0XHRcdGxlZnRbM10gLSBsZWZ0WzFdKTtcblx0XHRcdFx0dGhpcy5fc2VnbWVudDIuX2hhbmRsZUluLnNldChyaWdodFs0XSAtIHJpZ2h0WzZdLFxuXHRcdFx0XHRcdFx0cmlnaHRbNV0gLSByaWdodFs3XSk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciB4ID0gbGVmdFs2XSwgeSA9IGxlZnRbN10sXG5cdFx0XHRcdHNlZ21lbnQgPSBuZXcgU2VnbWVudChuZXcgUG9pbnQoeCwgeSksXG5cdFx0XHRcdFx0XHQhaXNMaW5lYXIgJiYgbmV3IFBvaW50KGxlZnRbNF0gLSB4LCBsZWZ0WzVdIC0geSksXG5cdFx0XHRcdFx0XHQhaXNMaW5lYXIgJiYgbmV3IFBvaW50KHJpZ2h0WzJdIC0geCwgcmlnaHRbM10gLSB5KSk7XG5cblx0XHRcdGlmICh0aGlzLl9wYXRoKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9zZWdtZW50MS5faW5kZXggPiAwICYmIHRoaXMuX3NlZ21lbnQyLl9pbmRleCA9PT0gMCkge1xuXHRcdFx0XHRcdHRoaXMuX3BhdGguYWRkKHNlZ21lbnQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3BhdGguaW5zZXJ0KHRoaXMuX3NlZ21lbnQyLl9pbmRleCwgc2VnbWVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVzID0gdGhpcztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBlbmQgPSB0aGlzLl9zZWdtZW50Mjtcblx0XHRcdFx0dGhpcy5fc2VnbWVudDIgPSBzZWdtZW50O1xuXHRcdFx0XHRyZXMgPSBuZXcgQ3VydmUoc2VnbWVudCwgZW5kKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRzcGxpdDogZnVuY3Rpb24ob2Zmc2V0LCBpc1BhcmFtZXRlcikge1xuXHRcdHJldHVybiB0aGlzLl9wYXRoXG5cdFx0XHQ/IHRoaXMuX3BhdGguc3BsaXQodGhpcy5fc2VnbWVudDEuX2luZGV4LFxuXHRcdFx0XHRcdHRoaXMuX2dldFBhcmFtZXRlcihvZmZzZXQsIGlzUGFyYW1ldGVyKSlcblx0XHRcdDogbnVsbDtcblx0fSxcblxuXHRyZXZlcnNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IEN1cnZlKHRoaXMuX3NlZ21lbnQyLnJldmVyc2UoKSwgdGhpcy5fc2VnbWVudDEucmV2ZXJzZSgpKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZW1vdmVkID0gZmFsc2U7XG5cdFx0aWYgKHRoaXMuX3BhdGgpIHtcblx0XHRcdHZhciBzZWdtZW50MiA9IHRoaXMuX3NlZ21lbnQyLFxuXHRcdFx0XHRoYW5kbGVPdXQgPSBzZWdtZW50Mi5faGFuZGxlT3V0O1xuXHRcdFx0cmVtb3ZlZCA9IHNlZ21lbnQyLnJlbW92ZSgpO1xuXHRcdFx0aWYgKHJlbW92ZWQpXG5cdFx0XHRcdHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuc2V0KGhhbmRsZU91dC54LCBoYW5kbGVPdXQueSk7XG5cdFx0fVxuXHRcdHJldHVybiByZW1vdmVkO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IEN1cnZlKHRoaXMuX3NlZ21lbnQxLCB0aGlzLl9zZWdtZW50Mik7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJ0cyA9IFsgJ3BvaW50MTogJyArIHRoaXMuX3NlZ21lbnQxLl9wb2ludCBdO1xuXHRcdGlmICghdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5pc1plcm8oKSlcblx0XHRcdHBhcnRzLnB1c2goJ2hhbmRsZTE6ICcgKyB0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0KTtcblx0XHRpZiAoIXRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbi5pc1plcm8oKSlcblx0XHRcdHBhcnRzLnB1c2goJ2hhbmRsZTI6ICcgKyB0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW4pO1xuXHRcdHBhcnRzLnB1c2goJ3BvaW50MjogJyArIHRoaXMuX3NlZ21lbnQyLl9wb2ludCk7XG5cdFx0cmV0dXJuICd7ICcgKyBwYXJ0cy5qb2luKCcsICcpICsgJyB9Jztcblx0fSxcblxuc3RhdGljczoge1xuXHRnZXRWYWx1ZXM6IGZ1bmN0aW9uKHNlZ21lbnQxLCBzZWdtZW50MiwgbWF0cml4KSB7XG5cdFx0dmFyIHAxID0gc2VnbWVudDEuX3BvaW50LFxuXHRcdFx0aDEgPSBzZWdtZW50MS5faGFuZGxlT3V0LFxuXHRcdFx0aDIgPSBzZWdtZW50Mi5faGFuZGxlSW4sXG5cdFx0XHRwMiA9IHNlZ21lbnQyLl9wb2ludCxcblx0XHRcdHZhbHVlcyA9IFtcblx0XHRcdFx0cDEuX3gsIHAxLl95LFxuXHRcdFx0XHRwMS5feCArIGgxLl94LCBwMS5feSArIGgxLl95LFxuXHRcdFx0XHRwMi5feCArIGgyLl94LCBwMi5feSArIGgyLl95LFxuXHRcdFx0XHRwMi5feCwgcDIuX3lcblx0XHRcdF07XG5cdFx0aWYgKG1hdHJpeClcblx0XHRcdG1hdHJpeC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXModmFsdWVzLCB2YWx1ZXMsIDQpO1xuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH0sXG5cblx0c3ViZGl2aWRlOiBmdW5jdGlvbih2LCB0KSB7XG5cdFx0dmFyIHAxeCA9IHZbMF0sIHAxeSA9IHZbMV0sXG5cdFx0XHRjMXggPSB2WzJdLCBjMXkgPSB2WzNdLFxuXHRcdFx0YzJ4ID0gdls0XSwgYzJ5ID0gdls1XSxcblx0XHRcdHAyeCA9IHZbNl0sIHAyeSA9IHZbN107XG5cdFx0aWYgKHQgPT09IHVuZGVmaW5lZClcblx0XHRcdHQgPSAwLjU7XG5cdFx0dmFyIHUgPSAxIC0gdCxcblx0XHRcdHAzeCA9IHUgKiBwMXggKyB0ICogYzF4LCBwM3kgPSB1ICogcDF5ICsgdCAqIGMxeSxcblx0XHRcdHA0eCA9IHUgKiBjMXggKyB0ICogYzJ4LCBwNHkgPSB1ICogYzF5ICsgdCAqIGMyeSxcblx0XHRcdHA1eCA9IHUgKiBjMnggKyB0ICogcDJ4LCBwNXkgPSB1ICogYzJ5ICsgdCAqIHAyeSxcblx0XHRcdHA2eCA9IHUgKiBwM3ggKyB0ICogcDR4LCBwNnkgPSB1ICogcDN5ICsgdCAqIHA0eSxcblx0XHRcdHA3eCA9IHUgKiBwNHggKyB0ICogcDV4LCBwN3kgPSB1ICogcDR5ICsgdCAqIHA1eSxcblx0XHRcdHA4eCA9IHUgKiBwNnggKyB0ICogcDd4LCBwOHkgPSB1ICogcDZ5ICsgdCAqIHA3eTtcblx0XHRyZXR1cm4gW1xuXHRcdFx0W3AxeCwgcDF5LCBwM3gsIHAzeSwgcDZ4LCBwNnksIHA4eCwgcDh5XSxcblx0XHRcdFtwOHgsIHA4eSwgcDd4LCBwN3ksIHA1eCwgcDV5LCBwMngsIHAyeV1cblx0XHRdO1xuXHR9LFxuXG5cdHNvbHZlQ3ViaWM6IGZ1bmN0aW9uICh2LCBjb29yZCwgdmFsLCByb290cywgbWluLCBtYXgpIHtcblx0XHR2YXIgcDEgPSB2W2Nvb3JkXSxcblx0XHRcdGMxID0gdltjb29yZCArIDJdLFxuXHRcdFx0YzIgPSB2W2Nvb3JkICsgNF0sXG5cdFx0XHRwMiA9IHZbY29vcmQgKyA2XSxcblx0XHRcdGMgPSAzICogKGMxIC0gcDEpLFxuXHRcdFx0YiA9IDMgKiAoYzIgLSBjMSkgLSBjLFxuXHRcdFx0YSA9IHAyIC0gcDEgLSBjIC0gYjtcblx0XHRyZXR1cm4gTnVtZXJpY2FsLnNvbHZlQ3ViaWMoYSwgYiwgYywgcDEgLSB2YWwsIHJvb3RzLCBtaW4sIG1heCk7XG5cdH0sXG5cblx0Z2V0UGFyYW1ldGVyT2Y6IGZ1bmN0aW9uKHYsIHgsIHkpIHtcblx0XHR2YXIgdG9sZXJhbmNlID0gMC4wMDAwMDE7XG5cdFx0aWYgKE1hdGguYWJzKHZbMF0gLSB4KSA8IHRvbGVyYW5jZSAmJiBNYXRoLmFicyh2WzFdIC0geSkgPCB0b2xlcmFuY2UpXG5cdFx0XHRyZXR1cm4gMDtcblx0XHRpZiAoTWF0aC5hYnModls2XSAtIHgpIDwgdG9sZXJhbmNlICYmIE1hdGguYWJzKHZbN10gLSB5KSA8IHRvbGVyYW5jZSlcblx0XHRcdHJldHVybiAxO1xuXHRcdHZhciB0eHMgPSBbXSxcblx0XHRcdHR5cyA9IFtdLFxuXHRcdFx0c3ggPSBDdXJ2ZS5zb2x2ZUN1YmljKHYsIDAsIHgsIHR4cywgMCwgMSksXG5cdFx0XHRzeSA9IEN1cnZlLnNvbHZlQ3ViaWModiwgMSwgeSwgdHlzLCAwLCAxKSxcblx0XHRcdHR4LCB0eTtcblx0XHRmb3IgKHZhciBjeCA9IDA7ICBzeCA9PT0gLTEgfHwgY3ggPCBzeDspIHtcblx0XHRcdGlmIChzeCA9PT0gLTEgfHwgKHR4ID0gdHhzW2N4KytdKSA+IDAgJiYgdHggPCAxKSB7XG5cdFx0XHRcdGZvciAodmFyIGN5ID0gMDsgc3kgPT09IC0xIHx8IGN5IDwgc3k7KSB7XG5cdFx0XHRcdFx0aWYgKHN5ID09PSAtMSB8fCAodHkgPSB0eXNbY3krK10pID4gMCAmJiB0eSA8IDEpIHtcblx0XHRcdFx0XHRcdGlmIChzeCA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0dHggPSB0eTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoc3kgPT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdHR5ID0gdHg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoTWF0aC5hYnModHggLSB0eSkgPCB0b2xlcmFuY2UpXG5cdFx0XHRcdFx0XHRcdHJldHVybiAodHggKyB0eSkgKiAwLjU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzeCA9PT0gLTEpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdGdldFBhcnQ6IGZ1bmN0aW9uKHYsIGZyb20sIHRvKSB7XG5cdFx0aWYgKGZyb20gPiAwKVxuXHRcdFx0diA9IEN1cnZlLnN1YmRpdmlkZSh2LCBmcm9tKVsxXTtcblx0XHRpZiAodG8gPCAxKVxuXHRcdFx0diA9IEN1cnZlLnN1YmRpdmlkZSh2LCAodG8gLSBmcm9tKSAvICgxIC0gZnJvbSkpWzBdO1xuXHRcdHJldHVybiB2O1xuXHR9LFxuXG5cdGhhc0hhbmRsZXM6IGZ1bmN0aW9uKHYpIHtcblx0XHR2YXIgaXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybztcblx0XHRyZXR1cm4gIShpc1plcm8odlswXSAtIHZbMl0pICYmIGlzWmVybyh2WzFdIC0gdlszXSlcblx0XHRcdFx0JiYgaXNaZXJvKHZbNF0gLSB2WzZdKSAmJiBpc1plcm8odls1XSAtIHZbN10pKTtcblx0fSxcblxuXHRpc0xpbmVhcjogZnVuY3Rpb24odikge1xuXHRcdHZhciBwMXggPSB2WzBdLCBwMXkgPSB2WzFdLFxuXHRcdFx0cDJ4ID0gdls2XSwgcDJ5ID0gdls3XSxcblx0XHRcdGwgPSBuZXcgUG9pbnQocDJ4IC0gcDF4LCBwMnkgLSBwMXkpO1xuXHRcdHJldHVybiBsLmlzQ29sbGluZWFyKG5ldyBQb2ludCh2WzJdIC0gcDF4LCB2WzNdIC0gcDF5KSlcblx0XHRcdFx0JiYgbC5pc0NvbGxpbmVhcihuZXcgUG9pbnQodls0XSAtIHAyeCwgdls1XSAtIHAyeSkpO1xuXHR9LFxuXG5cdGlzRmxhdEVub3VnaDogZnVuY3Rpb24odiwgdG9sZXJhbmNlKSB7XG5cdFx0dmFyIHAxeCA9IHZbMF0sIHAxeSA9IHZbMV0sXG5cdFx0XHRjMXggPSB2WzJdLCBjMXkgPSB2WzNdLFxuXHRcdFx0YzJ4ID0gdls0XSwgYzJ5ID0gdls1XSxcblx0XHRcdHAyeCA9IHZbNl0sIHAyeSA9IHZbN10sXG5cdFx0XHR1eCA9IDMgKiBjMXggLSAyICogcDF4IC0gcDJ4LFxuXHRcdFx0dXkgPSAzICogYzF5IC0gMiAqIHAxeSAtIHAyeSxcblx0XHRcdHZ4ID0gMyAqIGMyeCAtIDIgKiBwMnggLSBwMXgsXG5cdFx0XHR2eSA9IDMgKiBjMnkgLSAyICogcDJ5IC0gcDF5O1xuXHRcdHJldHVybiBNYXRoLm1heCh1eCAqIHV4LCB2eCAqIHZ4KSArIE1hdGgubWF4KHV5ICogdXksIHZ5ICogdnkpXG5cdFx0XHRcdDwgMTAgKiB0b2xlcmFuY2UgKiB0b2xlcmFuY2U7XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24odikge1xuXHRcdHZhciBwMXggPSB2WzBdLCBwMXkgPSB2WzFdLFxuXHRcdFx0YzF4ID0gdlsyXSwgYzF5ID0gdlszXSxcblx0XHRcdGMyeCA9IHZbNF0sIGMyeSA9IHZbNV0sXG5cdFx0XHRwMnggPSB2WzZdLCBwMnkgPSB2WzddO1xuXHRcdHJldHVybiAoICAzLjAgKiBjMXkgKiBwMXggLSAxLjUgKiBjMXkgKiBjMnhcblx0XHRcdFx0LSAxLjUgKiBjMXkgKiBwMnggLSAzLjAgKiBwMXkgKiBjMXhcblx0XHRcdFx0LSAxLjUgKiBwMXkgKiBjMnggLSAwLjUgKiBwMXkgKiBwMnhcblx0XHRcdFx0KyAxLjUgKiBjMnkgKiBwMXggKyAxLjUgKiBjMnkgKiBjMXhcblx0XHRcdFx0LSAzLjAgKiBjMnkgKiBwMnggKyAwLjUgKiBwMnkgKiBwMXhcblx0XHRcdFx0KyAxLjUgKiBwMnkgKiBjMXggKyAzLjAgKiBwMnkgKiBjMngpIC8gMTA7XG5cdH0sXG5cblx0Z2V0RWRnZVN1bTogZnVuY3Rpb24odikge1xuXHRcdHJldHVyblx0ICAodlswXSAtIHZbMl0pICogKHZbM10gKyB2WzFdKVxuXHRcdFx0XHQrICh2WzJdIC0gdls0XSkgKiAodls1XSArIHZbM10pXG5cdFx0XHRcdCsgKHZbNF0gLSB2WzZdKSAqICh2WzddICsgdls1XSk7XG5cdH0sXG5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbih2KSB7XG5cdFx0dmFyIG1pbiA9IHYuc2xpY2UoMCwgMiksXG5cdFx0XHRtYXggPSBtaW4uc2xpY2UoKSxcblx0XHRcdHJvb3RzID0gWzAsIDBdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKVxuXHRcdFx0Q3VydmUuX2FkZEJvdW5kcyh2W2ldLCB2W2kgKyAyXSwgdltpICsgNF0sIHZbaSArIDZdLFxuXHRcdFx0XHRcdGksIDAsIG1pbiwgbWF4LCByb290cyk7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUobWluWzBdLCBtaW5bMV0sIG1heFswXSAtIG1pblswXSwgbWF4WzFdIC0gbWluWzFdKTtcblx0fSxcblxuXHRfYWRkQm91bmRzOiBmdW5jdGlvbih2MCwgdjEsIHYyLCB2MywgY29vcmQsIHBhZGRpbmcsIG1pbiwgbWF4LCByb290cykge1xuXHRcdGZ1bmN0aW9uIGFkZCh2YWx1ZSwgcGFkZGluZykge1xuXHRcdFx0dmFyIGxlZnQgPSB2YWx1ZSAtIHBhZGRpbmcsXG5cdFx0XHRcdHJpZ2h0ID0gdmFsdWUgKyBwYWRkaW5nO1xuXHRcdFx0aWYgKGxlZnQgPCBtaW5bY29vcmRdKVxuXHRcdFx0XHRtaW5bY29vcmRdID0gbGVmdDtcblx0XHRcdGlmIChyaWdodCA+IG1heFtjb29yZF0pXG5cdFx0XHRcdG1heFtjb29yZF0gPSByaWdodDtcblx0XHR9XG5cdFx0dmFyIGEgPSAzICogKHYxIC0gdjIpIC0gdjAgKyB2Myxcblx0XHRcdGIgPSAyICogKHYwICsgdjIpIC0gNCAqIHYxLFxuXHRcdFx0YyA9IHYxIC0gdjAsXG5cdFx0XHRjb3VudCA9IE51bWVyaWNhbC5zb2x2ZVF1YWRyYXRpYyhhLCBiLCBjLCByb290cyksXG5cdFx0XHR0TWluID0gMC4wMDAwMDEsXG5cdFx0XHR0TWF4ID0gMSAtIHRNaW47XG5cdFx0YWRkKHYzLCAwKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0XHRcdHZhciB0ID0gcm9vdHNbaV0sXG5cdFx0XHRcdHUgPSAxIC0gdDtcblx0XHRcdGlmICh0TWluIDwgdCAmJiB0IDwgdE1heClcblx0XHRcdFx0YWRkKHUgKiB1ICogdSAqIHYwXG5cdFx0XHRcdFx0KyAzICogdSAqIHUgKiB0ICogdjFcblx0XHRcdFx0XHQrIDMgKiB1ICogdCAqIHQgKiB2MlxuXHRcdFx0XHRcdCsgdCAqIHQgKiB0ICogdjMsXG5cdFx0XHRcdFx0cGFkZGluZyk7XG5cdFx0fVxuXHR9XG59fSwgQmFzZS5lYWNoKFxuXHRbJ2dldEJvdW5kcycsICdnZXRTdHJva2VCb3VuZHMnLCAnZ2V0SGFuZGxlQm91bmRzJywgJ2dldFJvdWdoQm91bmRzJ10sXG5cdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR0aGlzW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIXRoaXMuX2JvdW5kcylcblx0XHRcdFx0dGhpcy5fYm91bmRzID0ge307XG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzW25hbWVdO1xuXHRcdFx0aWYgKCFib3VuZHMpIHtcblx0XHRcdFx0Ym91bmRzID0gdGhpcy5fYm91bmRzW25hbWVdID0gUGF0aFtuYW1lXShbdGhpcy5fc2VnbWVudDEsXG5cdFx0XHRcdFx0XHR0aGlzLl9zZWdtZW50Ml0sIGZhbHNlLCB0aGlzLl9wYXRoLmdldFN0eWxlKCkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGJvdW5kcy5jbG9uZSgpO1xuXHRcdH07XG5cdH0sXG57XG5cbn0pLCB7XG5cdGJlYW5zOiBmYWxzZSxcblxuXHRnZXRQYXJhbWV0ZXJBdDogZnVuY3Rpb24ob2Zmc2V0LCBzdGFydCkge1xuXHRcdHJldHVybiBDdXJ2ZS5nZXRQYXJhbWV0ZXJBdCh0aGlzLmdldFZhbHVlcygpLCBvZmZzZXQsIHN0YXJ0KTtcblx0fSxcblxuXHRnZXRQYXJhbWV0ZXJPZjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBDdXJ2ZS5nZXRQYXJhbWV0ZXJPZih0aGlzLmdldFZhbHVlcygpLCBwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRMb2NhdGlvbkF0OiBmdW5jdGlvbihvZmZzZXQsIGlzUGFyYW1ldGVyKSB7XG5cdFx0dmFyIHQgPSBpc1BhcmFtZXRlciA/IG9mZnNldCA6IHRoaXMuZ2V0UGFyYW1ldGVyQXQob2Zmc2V0KTtcblx0XHRyZXR1cm4gdCAhPSBudWxsICYmIHQgPj0gMCAmJiB0IDw9IDFcblx0XHRcdFx0PyBuZXcgQ3VydmVMb2NhdGlvbih0aGlzLCB0KVxuXHRcdFx0XHQ6IG51bGw7XG5cdH0sXG5cblx0Z2V0TG9jYXRpb25PZjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TG9jYXRpb25BdCh0aGlzLmdldFBhcmFtZXRlck9mKFBvaW50LnJlYWQoYXJndW1lbnRzKSksXG5cdFx0XHRcdHRydWUpO1xuXHR9LFxuXG5cdGdldE9mZnNldE9mOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbG9jID0gdGhpcy5nZXRMb2NhdGlvbk9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIGxvYyA/IGxvYy5nZXRPZmZzZXQoKSA6IG51bGw7XG5cdH0sXG5cblx0Z2V0TmVhcmVzdExvY2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHR2YWx1ZXMgPSB0aGlzLmdldFZhbHVlcygpLFxuXHRcdFx0Y291bnQgPSAxMDAsXG5cdFx0XHRtaW5EaXN0ID0gSW5maW5pdHksXG5cdFx0XHRtaW5UID0gMDtcblxuXHRcdGZ1bmN0aW9uIHJlZmluZSh0KSB7XG5cdFx0XHRpZiAodCA+PSAwICYmIHQgPD0gMSkge1xuXHRcdFx0XHR2YXIgZGlzdCA9IHBvaW50LmdldERpc3RhbmNlKEN1cnZlLmdldFBvaW50KHZhbHVlcywgdCksIHRydWUpO1xuXHRcdFx0XHRpZiAoZGlzdCA8IG1pbkRpc3QpIHtcblx0XHRcdFx0XHRtaW5EaXN0ID0gZGlzdDtcblx0XHRcdFx0XHRtaW5UID0gdDtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDw9IGNvdW50OyBpKyspXG5cdFx0XHRyZWZpbmUoaSAvIGNvdW50KTtcblxuXHRcdHZhciBzdGVwID0gMSAvIChjb3VudCAqIDIpO1xuXHRcdHdoaWxlIChzdGVwID4gMC4wMDAwMDEpIHtcblx0XHRcdGlmICghcmVmaW5lKG1pblQgLSBzdGVwKSAmJiAhcmVmaW5lKG1pblQgKyBzdGVwKSlcblx0XHRcdFx0c3RlcCAvPSAyO1xuXHRcdH1cblx0XHR2YXIgcHQgPSBDdXJ2ZS5nZXRQb2ludCh2YWx1ZXMsIG1pblQpO1xuXHRcdHJldHVybiBuZXcgQ3VydmVMb2NhdGlvbih0aGlzLCBtaW5ULCBwdCwgbnVsbCwgbnVsbCwgbnVsbCxcblx0XHRcdFx0cG9pbnQuZ2V0RGlzdGFuY2UocHQpKTtcblx0fSxcblxuXHRnZXROZWFyZXN0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldE5lYXJlc3RMb2NhdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpLmdldFBvaW50KCk7XG5cdH1cblxufSxcbm5ldyBmdW5jdGlvbigpIHtcblx0dmFyIG1ldGhvZHMgPSBbJ2dldFBvaW50JywgJ2dldFRhbmdlbnQnLCAnZ2V0Tm9ybWFsJywgJ2dldFdlaWdodGVkVGFuZ2VudCcsXG5cdFx0J2dldFdlaWdodGVkTm9ybWFsJywgJ2dldEN1cnZhdHVyZSddO1xuXHRyZXR1cm4gQmFzZS5lYWNoKG1ldGhvZHMsXG5cdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR0aGlzW25hbWUgKyAnQXQnXSA9IGZ1bmN0aW9uKG9mZnNldCwgaXNQYXJhbWV0ZXIpIHtcblx0XHRcdHZhciB2YWx1ZXMgPSB0aGlzLmdldFZhbHVlcygpO1xuXHRcdFx0cmV0dXJuIEN1cnZlW25hbWVdKHZhbHVlcywgaXNQYXJhbWV0ZXIgPyBvZmZzZXRcblx0XHRcdFx0XHQ6IEN1cnZlLmdldFBhcmFtZXRlckF0KHZhbHVlcywgb2Zmc2V0LCAwKSk7XG5cdFx0fTtcblx0fSwge1xuXHRcdHN0YXRpY3M6IHtcblx0XHRcdGV2YWx1YXRlTWV0aG9kczogbWV0aG9kc1xuXHRcdH1cblx0fSlcbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gZ2V0TGVuZ3RoSW50ZWdyYW5kKHYpIHtcblx0XHR2YXIgcDF4ID0gdlswXSwgcDF5ID0gdlsxXSxcblx0XHRcdGMxeCA9IHZbMl0sIGMxeSA9IHZbM10sXG5cdFx0XHRjMnggPSB2WzRdLCBjMnkgPSB2WzVdLFxuXHRcdFx0cDJ4ID0gdls2XSwgcDJ5ID0gdls3XSxcblxuXHRcdFx0YXggPSA5ICogKGMxeCAtIGMyeCkgKyAzICogKHAyeCAtIHAxeCksXG5cdFx0XHRieCA9IDYgKiAocDF4ICsgYzJ4KSAtIDEyICogYzF4LFxuXHRcdFx0Y3ggPSAzICogKGMxeCAtIHAxeCksXG5cblx0XHRcdGF5ID0gOSAqIChjMXkgLSBjMnkpICsgMyAqIChwMnkgLSBwMXkpLFxuXHRcdFx0YnkgPSA2ICogKHAxeSArIGMyeSkgLSAxMiAqIGMxeSxcblx0XHRcdGN5ID0gMyAqIChjMXkgLSBwMXkpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcblx0XHRcdHZhciBkeCA9IChheCAqIHQgKyBieCkgKiB0ICsgY3gsXG5cdFx0XHRcdGR5ID0gKGF5ICogdCArIGJ5KSAqIHQgKyBjeTtcblx0XHRcdHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRJdGVyYXRpb25zKGEsIGIpIHtcblx0XHRyZXR1cm4gTWF0aC5tYXgoMiwgTWF0aC5taW4oMTYsIE1hdGguY2VpbChNYXRoLmFicyhiIC0gYSkgKiAzMikpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV2YWx1YXRlKHYsIHQsIHR5cGUsIG5vcm1hbGl6ZWQpIHtcblx0XHRpZiAodCA9PSBudWxsIHx8IHQgPCAwIHx8IHQgPiAxKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0dmFyIHAxeCA9IHZbMF0sIHAxeSA9IHZbMV0sXG5cdFx0XHRjMXggPSB2WzJdLCBjMXkgPSB2WzNdLFxuXHRcdFx0YzJ4ID0gdls0XSwgYzJ5ID0gdls1XSxcblx0XHRcdHAyeCA9IHZbNl0sIHAyeSA9IHZbN10sXG5cdFx0XHR0b2xlcmFuY2UgPSAwLjAwMDAwMSxcblx0XHRcdHgsIHk7XG5cblx0XHRpZiAodHlwZSA9PT0gMCAmJiAodCA8IHRvbGVyYW5jZSB8fCB0ID4gMSAtIHRvbGVyYW5jZSkpIHtcblx0XHRcdHZhciBpc1plcm8gPSB0IDwgdG9sZXJhbmNlO1xuXHRcdFx0eCA9IGlzWmVybyA/IHAxeCA6IHAyeDtcblx0XHRcdHkgPSBpc1plcm8gPyBwMXkgOiBwMnk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBjeCA9IDMgKiAoYzF4IC0gcDF4KSxcblx0XHRcdFx0YnggPSAzICogKGMyeCAtIGMxeCkgLSBjeCxcblx0XHRcdFx0YXggPSBwMnggLSBwMXggLSBjeCAtIGJ4LFxuXG5cdFx0XHRcdGN5ID0gMyAqIChjMXkgLSBwMXkpLFxuXHRcdFx0XHRieSA9IDMgKiAoYzJ5IC0gYzF5KSAtIGN5LFxuXHRcdFx0XHRheSA9IHAyeSAtIHAxeSAtIGN5IC0gYnk7XG5cdFx0XHRpZiAodHlwZSA9PT0gMCkge1xuXHRcdFx0XHR4ID0gKChheCAqIHQgKyBieCkgKiB0ICsgY3gpICogdCArIHAxeDtcblx0XHRcdFx0eSA9ICgoYXkgKiB0ICsgYnkpICogdCArIGN5KSAqIHQgKyBwMXk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodCA8IHRvbGVyYW5jZSkge1xuXHRcdFx0XHRcdHggPSBjeDtcblx0XHRcdFx0XHR5ID0gY3k7XG5cdFx0XHRcdH0gZWxzZSBpZiAodCA+IDEgLSB0b2xlcmFuY2UpIHtcblx0XHRcdFx0XHR4ID0gMyAqIChwMnggLSBjMngpO1xuXHRcdFx0XHRcdHkgPSAzICogKHAyeSAtIGMyeSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eCA9ICgzICogYXggKiB0ICsgMiAqIGJ4KSAqIHQgKyBjeDtcblx0XHRcdFx0XHR5ID0gKDMgKiBheSAqIHQgKyAyICogYnkpICogdCArIGN5O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChub3JtYWxpemVkKSB7XG5cdFx0XHRcdFx0aWYgKHggPT09IDAgJiYgeSA9PT0gMFxuXHRcdFx0XHRcdFx0XHQmJiAodCA8IHRvbGVyYW5jZSB8fCB0ID4gMSAtIHRvbGVyYW5jZSkpIHtcblx0XHRcdFx0XHRcdHggPSBjMnggLSBjMXg7XG5cdFx0XHRcdFx0XHR5ID0gYzJ5IC0gYzF5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YXIgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXHRcdFx0XHRcdHggLz0gbGVuO1xuXHRcdFx0XHRcdHkgLz0gbGVuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0eXBlID09PSAzKSB7XG5cdFx0XHRcdFx0dmFyIHgyID0gNiAqIGF4ICogdCArIDIgKiBieCxcblx0XHRcdFx0XHRcdHkyID0gNiAqIGF5ICogdCArIDIgKiBieSxcblx0XHRcdFx0XHRcdGQgPSBNYXRoLnBvdyh4ICogeCArIHkgKiB5LCAzIC8gMik7XG5cdFx0XHRcdFx0eCA9IGQgIT09IDAgPyAoeCAqIHkyIC0geSAqIHgyKSAvIGQgOiAwO1xuXHRcdFx0XHRcdHkgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0eXBlID09PSAyID8gbmV3IFBvaW50KHksIC14KSA6IG5ldyBQb2ludCh4LCB5KTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0c3RhdGljczogdHJ1ZSxcblxuXHRcdGdldExlbmd0aDogZnVuY3Rpb24odiwgYSwgYikge1xuXHRcdFx0aWYgKGEgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0YSA9IDA7XG5cdFx0XHRpZiAoYiA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRiID0gMTtcblx0XHRcdHZhciBpc1plcm8gPSBOdW1lcmljYWwuaXNaZXJvO1xuXHRcdFx0aWYgKGEgPT09IDAgJiYgYiA9PT0gMVxuXHRcdFx0XHRcdCYmIGlzWmVybyh2WzBdIC0gdlsyXSkgJiYgaXNaZXJvKHZbMV0gLSB2WzNdKVxuXHRcdFx0XHRcdCYmIGlzWmVybyh2WzZdIC0gdls0XSkgJiYgaXNaZXJvKHZbN10gLSB2WzVdKSkge1xuXHRcdFx0XHR2YXIgZHggPSB2WzZdIC0gdlswXSxcblx0XHRcdFx0XHRkeSA9IHZbN10gLSB2WzFdO1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblx0XHRcdH1cblx0XHRcdHZhciBkcyA9IGdldExlbmd0aEludGVncmFuZCh2KTtcblx0XHRcdHJldHVybiBOdW1lcmljYWwuaW50ZWdyYXRlKGRzLCBhLCBiLCBnZXRJdGVyYXRpb25zKGEsIGIpKTtcblx0XHR9LFxuXG5cdFx0Z2V0UGFyYW1ldGVyQXQ6IGZ1bmN0aW9uKHYsIG9mZnNldCwgc3RhcnQpIHtcblx0XHRcdGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRzdGFydCA9IG9mZnNldCA8IDAgPyAxIDogMFxuXHRcdFx0aWYgKG9mZnNldCA9PT0gMClcblx0XHRcdFx0cmV0dXJuIHN0YXJ0O1xuXHRcdFx0dmFyIHRvbGVyYW5jZSA9IDAuMDAwMDAxLFxuXHRcdFx0XHRhYnMgPSBNYXRoLmFicyxcblx0XHRcdFx0Zm9yd2FyZCA9IG9mZnNldCA+IDAsXG5cdFx0XHRcdGEgPSBmb3J3YXJkID8gc3RhcnQgOiAwLFxuXHRcdFx0XHRiID0gZm9yd2FyZCA/IDEgOiBzdGFydCxcblx0XHRcdFx0ZHMgPSBnZXRMZW5ndGhJbnRlZ3JhbmQodiksXG5cdFx0XHRcdHJhbmdlTGVuZ3RoID0gTnVtZXJpY2FsLmludGVncmF0ZShkcywgYSwgYixcblx0XHRcdFx0XHRcdGdldEl0ZXJhdGlvbnMoYSwgYikpO1xuXHRcdFx0aWYgKGFicyhvZmZzZXQgLSByYW5nZUxlbmd0aCkgPCB0b2xlcmFuY2UpIHtcblx0XHRcdFx0cmV0dXJuIGZvcndhcmQgPyBiIDogYTtcblx0XHRcdH0gZWxzZSBpZiAoYWJzKG9mZnNldCkgPiByYW5nZUxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHZhciBndWVzcyA9IG9mZnNldCAvIHJhbmdlTGVuZ3RoLFxuXHRcdFx0XHRsZW5ndGggPSAwO1xuXHRcdFx0ZnVuY3Rpb24gZih0KSB7XG5cdFx0XHRcdGxlbmd0aCArPSBOdW1lcmljYWwuaW50ZWdyYXRlKGRzLCBzdGFydCwgdCxcblx0XHRcdFx0XHRcdGdldEl0ZXJhdGlvbnMoc3RhcnQsIHQpKTtcblx0XHRcdFx0c3RhcnQgPSB0O1xuXHRcdFx0XHRyZXR1cm4gbGVuZ3RoIC0gb2Zmc2V0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIE51bWVyaWNhbC5maW5kUm9vdChmLCBkcywgc3RhcnQgKyBndWVzcywgYSwgYiwgMTYsXG5cdFx0XHRcdFx0dG9sZXJhbmNlKTtcblx0XHR9LFxuXG5cdFx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKHYsIHQpIHtcblx0XHRcdHJldHVybiBldmFsdWF0ZSh2LCB0LCAwLCBmYWxzZSk7XG5cdFx0fSxcblxuXHRcdGdldFRhbmdlbnQ6IGZ1bmN0aW9uKHYsIHQpIHtcblx0XHRcdHJldHVybiBldmFsdWF0ZSh2LCB0LCAxLCB0cnVlKTtcblx0XHR9LFxuXG5cdFx0Z2V0V2VpZ2h0ZWRUYW5nZW50OiBmdW5jdGlvbih2LCB0KSB7XG5cdFx0XHRyZXR1cm4gZXZhbHVhdGUodiwgdCwgMSwgZmFsc2UpO1xuXHRcdH0sXG5cblx0XHRnZXROb3JtYWw6IGZ1bmN0aW9uKHYsIHQpIHtcblx0XHRcdHJldHVybiBldmFsdWF0ZSh2LCB0LCAyLCB0cnVlKTtcblx0XHR9LFxuXG5cdFx0Z2V0V2VpZ2h0ZWROb3JtYWw6IGZ1bmN0aW9uKHYsIHQpIHtcblx0XHRcdHJldHVybiBldmFsdWF0ZSh2LCB0LCAyLCBmYWxzZSk7XG5cdFx0fSxcblxuXHRcdGdldEN1cnZhdHVyZTogZnVuY3Rpb24odiwgdCkge1xuXHRcdFx0cmV0dXJuIGV2YWx1YXRlKHYsIHQsIDMsIGZhbHNlKS54O1xuXHRcdH1cblx0fTtcbn0sIG5ldyBmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gYWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLCBjdXJ2ZTEsIHQxLCBwb2ludDEsIGN1cnZlMiwgdDIsXG5cdFx0XHRwb2ludDIpIHtcblx0XHR2YXIgbG9jID0gbmV3IEN1cnZlTG9jYXRpb24oY3VydmUxLCB0MSwgcG9pbnQxLCBjdXJ2ZTIsIHQyLCBwb2ludDIpO1xuXHRcdGlmICghaW5jbHVkZSB8fCBpbmNsdWRlKGxvYykpXG5cdFx0XHRsb2NhdGlvbnMucHVzaChsb2MpO1xuXHR9XG5cblx0ZnVuY3Rpb24gYWRkQ3VydmVJbnRlcnNlY3Rpb25zKHYxLCB2MiwgY3VydmUxLCBjdXJ2ZTIsIGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdHRNaW4sIHRNYXgsIHVNaW4sIHVNYXgsIG9sZFREaWZmLCByZXZlcnNlLCByZWN1cnNpb24pIHtcblx0XHRpZiAocmVjdXJzaW9uID4gMzIpXG5cdFx0XHRyZXR1cm47XG5cdFx0dmFyIHEweCA9IHYyWzBdLCBxMHkgPSB2MlsxXSwgcTN4ID0gdjJbNl0sIHEzeSA9IHYyWzddLFxuXHRcdFx0dG9sZXJhbmNlID0gMC4wMDAwMDEsXG5cdFx0XHRnZXRTaWduZWREaXN0YW5jZSA9IExpbmUuZ2V0U2lnbmVkRGlzdGFuY2UsXG5cdFx0XHRkMSA9IGdldFNpZ25lZERpc3RhbmNlKHEweCwgcTB5LCBxM3gsIHEzeSwgdjJbMl0sIHYyWzNdKSB8fCAwLFxuXHRcdFx0ZDIgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYyWzRdLCB2Mls1XSkgfHwgMCxcblx0XHRcdGZhY3RvciA9IGQxICogZDIgPiAwID8gMyAvIDQgOiA0IC8gOSxcblx0XHRcdGRNaW4gPSBmYWN0b3IgKiBNYXRoLm1pbigwLCBkMSwgZDIpLFxuXHRcdFx0ZE1heCA9IGZhY3RvciAqIE1hdGgubWF4KDAsIGQxLCBkMiksXG5cdFx0XHRkcDAgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYxWzBdLCB2MVsxXSksXG5cdFx0XHRkcDEgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYxWzJdLCB2MVszXSksXG5cdFx0XHRkcDIgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYxWzRdLCB2MVs1XSksXG5cdFx0XHRkcDMgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYxWzZdLCB2MVs3XSksXG5cdFx0XHR0TWluTmV3LCB0TWF4TmV3LCB0RGlmZjtcblx0XHRpZiAocTB4ID09PSBxM3ggJiYgdU1heCAtIHVNaW4gPCB0b2xlcmFuY2UgJiYgcmVjdXJzaW9uID4gMykge1xuXHRcdFx0dE1heE5ldyA9IHRNaW5OZXcgPSAodE1heCArIHRNaW4pIC8gMjtcblx0XHRcdHREaWZmID0gMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGh1bGwgPSBnZXRDb252ZXhIdWxsKGRwMCwgZHAxLCBkcDIsIGRwMyksXG5cdFx0XHRcdHRvcCA9IGh1bGxbMF0sXG5cdFx0XHRcdGJvdHRvbSA9IGh1bGxbMV0sXG5cdFx0XHRcdHRNaW5DbGlwLCB0TWF4Q2xpcDtcblx0XHRcdHRNaW5DbGlwID0gY2xpcENvbnZleEh1bGwodG9wLCBib3R0b20sIGRNaW4sIGRNYXgpO1xuXHRcdFx0dG9wLnJldmVyc2UoKTtcblx0XHRcdGJvdHRvbS5yZXZlcnNlKCk7XG5cdFx0XHR0TWF4Q2xpcCA9IGNsaXBDb252ZXhIdWxsKHRvcCwgYm90dG9tLCBkTWluLCBkTWF4KTtcblx0XHRcdGlmICh0TWluQ2xpcCA9PSBudWxsIHx8IHRNYXhDbGlwID09IG51bGwpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHYxID0gQ3VydmUuZ2V0UGFydCh2MSwgdE1pbkNsaXAsIHRNYXhDbGlwKTtcblx0XHRcdHREaWZmID0gdE1heENsaXAgLSB0TWluQ2xpcDtcblx0XHRcdHRNaW5OZXcgPSB0TWF4ICogdE1pbkNsaXAgKyB0TWluICogKDEgLSB0TWluQ2xpcCk7XG5cdFx0XHR0TWF4TmV3ID0gdE1heCAqIHRNYXhDbGlwICsgdE1pbiAqICgxIC0gdE1heENsaXApO1xuXHRcdH1cblx0XHRpZiAob2xkVERpZmYgPiAwLjUgJiYgdERpZmYgPiAwLjUpIHtcblx0XHRcdGlmICh0TWF4TmV3IC0gdE1pbk5ldyA+IHVNYXggLSB1TWluKSB7XG5cdFx0XHRcdHZhciBwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh2MSwgMC41KSxcblx0XHRcdFx0XHR0ID0gdE1pbk5ldyArICh0TWF4TmV3IC0gdE1pbk5ldykgLyAyO1xuXHRcdFx0XHRhZGRDdXJ2ZUludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0djIsIHBhcnRzWzBdLCBjdXJ2ZTIsIGN1cnZlMSwgbG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdHVNaW4sIHVNYXgsIHRNaW5OZXcsIHQsIHREaWZmLCAhcmV2ZXJzZSwgKytyZWN1cnNpb24pO1xuXHRcdFx0XHRhZGRDdXJ2ZUludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0djIsIHBhcnRzWzFdLCBjdXJ2ZTIsIGN1cnZlMSwgbG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdHVNaW4sIHVNYXgsIHQsIHRNYXhOZXcsIHREaWZmLCAhcmV2ZXJzZSwgcmVjdXJzaW9uKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh2MiwgMC41KSxcblx0XHRcdFx0XHR0ID0gdU1pbiArICh1TWF4IC0gdU1pbikgLyAyO1xuXHRcdFx0XHRhZGRDdXJ2ZUludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0cGFydHNbMF0sIHYxLCBjdXJ2ZTIsIGN1cnZlMSwgbG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdHVNaW4sIHQsIHRNaW5OZXcsIHRNYXhOZXcsIHREaWZmLCAhcmV2ZXJzZSwgKytyZWN1cnNpb24pO1xuXHRcdFx0XHRhZGRDdXJ2ZUludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0cGFydHNbMV0sIHYxLCBjdXJ2ZTIsIGN1cnZlMSwgbG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdHQsIHVNYXgsIHRNaW5OZXcsIHRNYXhOZXcsIHREaWZmLCAhcmV2ZXJzZSwgcmVjdXJzaW9uKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKE1hdGgubWF4KHVNYXggLSB1TWluLCB0TWF4TmV3IC0gdE1pbk5ldykgPCB0b2xlcmFuY2UpIHtcblx0XHRcdHZhciB0MSA9IHRNaW5OZXcgKyAodE1heE5ldyAtIHRNaW5OZXcpIC8gMixcblx0XHRcdFx0dDIgPSB1TWluICsgKHVNYXggLSB1TWluKSAvIDI7XG5cdFx0XHRpZiAocmV2ZXJzZSkge1xuXHRcdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0XHRjdXJ2ZTIsIHQyLCBDdXJ2ZS5nZXRQb2ludCh2MiwgdDIpLFxuXHRcdFx0XHRcdFx0Y3VydmUxLCB0MSwgQ3VydmUuZ2V0UG9pbnQodjEsIHQxKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0XHRjdXJ2ZTEsIHQxLCBDdXJ2ZS5nZXRQb2ludCh2MSwgdDEpLFxuXHRcdFx0XHRcdFx0Y3VydmUyLCB0MiwgQ3VydmUuZ2V0UG9pbnQodjIsIHQyKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0RGlmZiA+IDApIHtcblx0XHRcdGFkZEN1cnZlSW50ZXJzZWN0aW9ucyh2MiwgdjEsIGN1cnZlMiwgY3VydmUxLCBsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0dU1pbiwgdU1heCwgdE1pbk5ldywgdE1heE5ldywgdERpZmYsICFyZXZlcnNlLCArK3JlY3Vyc2lvbik7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q29udmV4SHVsbChkcTAsIGRxMSwgZHEyLCBkcTMpIHtcblx0XHR2YXIgcDAgPSBbIDAsIGRxMCBdLFxuXHRcdFx0cDEgPSBbIDEgLyAzLCBkcTEgXSxcblx0XHRcdHAyID0gWyAyIC8gMywgZHEyIF0sXG5cdFx0XHRwMyA9IFsgMSwgZHEzIF0sXG5cdFx0XHRnZXRTaWduZWREaXN0YW5jZSA9IExpbmUuZ2V0U2lnbmVkRGlzdGFuY2UsXG5cdFx0XHRkaXN0MSA9IGdldFNpZ25lZERpc3RhbmNlKDAsIGRxMCwgMSwgZHEzLCAxIC8gMywgZHExKSxcblx0XHRcdGRpc3QyID0gZ2V0U2lnbmVkRGlzdGFuY2UoMCwgZHEwLCAxLCBkcTMsIDIgLyAzLCBkcTIpLFxuXHRcdFx0ZmxpcCA9IGZhbHNlLFxuXHRcdFx0aHVsbDtcblx0XHRpZiAoZGlzdDEgKiBkaXN0MiA8IDApIHtcblx0XHRcdGh1bGwgPSBbW3AwLCBwMSwgcDNdLCBbcDAsIHAyLCBwM11dO1xuXHRcdFx0ZmxpcCA9IGRpc3QxIDwgMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBtYXgsIGNyb3NzID0gMCxcblx0XHRcdFx0ZGlzdFplcm8gPSBkaXN0MSA9PT0gMCB8fCBkaXN0MiA9PT0gMDtcblx0XHRcdGlmIChNYXRoLmFicyhkaXN0MSkgPiBNYXRoLmFicyhkaXN0MikpIHtcblx0XHRcdFx0cG1heCA9IHAxO1xuXHRcdFx0XHRjcm9zcyA9IChkcTMgLSBkcTIgLSAoZHEzIC0gZHEwKSAvIDMpXG5cdFx0XHRcdFx0XHQqICgyICogKGRxMyAtIGRxMikgLSBkcTMgKyBkcTEpIC8gMztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBtYXggPSBwMjtcblx0XHRcdFx0Y3Jvc3MgPSAoZHExIC0gZHEwICsgKGRxMCAtIGRxMykgLyAzKVxuXHRcdFx0XHRcdFx0KiAoLTIgKiAoZHEwIC0gZHExKSArIGRxMCAtIGRxMikgLyAzO1xuXHRcdFx0fVxuXHRcdFx0aHVsbCA9IGNyb3NzIDwgMCB8fCBkaXN0WmVyb1xuXHRcdFx0XHRcdD8gW1twMCwgcG1heCwgcDNdLCBbcDAsIHAzXV1cblx0XHRcdFx0XHQ6IFtbcDAsIHAxLCBwMiwgcDNdLCBbcDAsIHAzXV07XG5cdFx0XHRmbGlwID0gZGlzdDEgPyBkaXN0MSA8IDAgOiBkaXN0MiA8IDA7XG5cdFx0fVxuXHRcdHJldHVybiBmbGlwID8gaHVsbC5yZXZlcnNlKCkgOiBodWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2xpcENvbnZleEh1bGwoaHVsbFRvcCwgaHVsbEJvdHRvbSwgZE1pbiwgZE1heCkge1xuXHRcdGlmIChodWxsVG9wWzBdWzFdIDwgZE1pbikge1xuXHRcdFx0cmV0dXJuIGNsaXBDb252ZXhIdWxsUGFydChodWxsVG9wLCB0cnVlLCBkTWluKTtcblx0XHR9IGVsc2UgaWYgKGh1bGxCb3R0b21bMF1bMV0gPiBkTWF4KSB7XG5cdFx0XHRyZXR1cm4gY2xpcENvbnZleEh1bGxQYXJ0KGh1bGxCb3R0b20sIGZhbHNlLCBkTWF4KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGh1bGxUb3BbMF1bMF07XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gY2xpcENvbnZleEh1bGxQYXJ0KHBhcnQsIHRvcCwgdGhyZXNob2xkKSB7XG5cdFx0dmFyIHB4ID0gcGFydFswXVswXSxcblx0XHRcdHB5ID0gcGFydFswXVsxXTtcblx0XHRmb3IgKHZhciBpID0gMSwgbCA9IHBhcnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgcXggPSBwYXJ0W2ldWzBdLFxuXHRcdFx0XHRxeSA9IHBhcnRbaV1bMV07XG5cdFx0XHRpZiAodG9wID8gcXkgPj0gdGhyZXNob2xkIDogcXkgPD0gdGhyZXNob2xkKVxuXHRcdFx0XHRyZXR1cm4gcHggKyAodGhyZXNob2xkIC0gcHkpICogKHF4IC0gcHgpIC8gKHF5IC0gcHkpO1xuXHRcdFx0cHggPSBxeDtcblx0XHRcdHB5ID0gcXk7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gYWRkQ3VydmVMaW5lSW50ZXJzZWN0aW9ucyh2MSwgdjIsIGN1cnZlMSwgY3VydmUyLCBsb2NhdGlvbnMsXG5cdFx0XHRpbmNsdWRlKSB7XG5cdFx0dmFyIGZsaXAgPSBDdXJ2ZS5pc0xpbmVhcih2MSksXG5cdFx0XHR2YyA9IGZsaXAgPyB2MiA6IHYxLFxuXHRcdFx0dmwgPSBmbGlwID8gdjEgOiB2Mixcblx0XHRcdGx4MSA9IHZsWzBdLCBseTEgPSB2bFsxXSxcblx0XHRcdGx4MiA9IHZsWzZdLCBseTIgPSB2bFs3XSxcblx0XHRcdGxkeCA9IGx4MiAtIGx4MSxcblx0XHRcdGxkeSA9IGx5MiAtIGx5MSxcblx0XHRcdGFuZ2xlID0gTWF0aC5hdGFuMigtbGR5LCBsZHgpLFxuXHRcdFx0c2luID0gTWF0aC5zaW4oYW5nbGUpLFxuXHRcdFx0Y29zID0gTWF0aC5jb3MoYW5nbGUpLFxuXHRcdFx0cmx4MiA9IGxkeCAqIGNvcyAtIGxkeSAqIHNpbixcblx0XHRcdHJ2bCA9IFswLCAwLCAwLCAwLCBybHgyLCAwLCBybHgyLCAwXSxcblx0XHRcdHJ2YyA9IFtdO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCA4OyBpICs9IDIpIHtcblx0XHRcdHZhciB4ID0gdmNbaV0gLSBseDEsXG5cdFx0XHRcdHkgPSB2Y1tpICsgMV0gLSBseTE7XG5cdFx0XHRydmMucHVzaChcblx0XHRcdFx0eCAqIGNvcyAtIHkgKiBzaW4sXG5cdFx0XHRcdHkgKiBjb3MgKyB4ICogc2luKTtcblx0XHR9XG5cdFx0dmFyIHJvb3RzID0gW10sXG5cdFx0XHRjb3VudCA9IEN1cnZlLnNvbHZlQ3ViaWMocnZjLCAxLCAwLCByb290cywgMCwgMSk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdFx0XHR2YXIgdGMgPSByb290c1tpXSxcblx0XHRcdFx0eCA9IEN1cnZlLmdldFBvaW50KHJ2YywgdGMpLng7XG5cdFx0XHRpZiAoeCA+PSAwICYmIHggPD0gcmx4Mikge1xuXHRcdFx0XHR2YXIgdGwgPSBDdXJ2ZS5nZXRQYXJhbWV0ZXJPZihydmwsIHgsIDApLFxuXHRcdFx0XHRcdHQxID0gZmxpcCA/IHRsIDogdGMsXG5cdFx0XHRcdFx0dDIgPSBmbGlwID8gdGMgOiB0bDtcblx0XHRcdFx0YWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdFx0Y3VydmUxLCB0MSwgQ3VydmUuZ2V0UG9pbnQodjEsIHQxKSxcblx0XHRcdFx0XHRcdGN1cnZlMiwgdDIsIEN1cnZlLmdldFBvaW50KHYyLCB0MikpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGFkZExpbmVJbnRlcnNlY3Rpb24odjEsIHYyLCBjdXJ2ZTEsIGN1cnZlMiwgbG9jYXRpb25zLCBpbmNsdWRlKSB7XG5cdFx0dmFyIHBvaW50ID0gTGluZS5pbnRlcnNlY3QoXG5cdFx0XHRcdHYxWzBdLCB2MVsxXSwgdjFbNl0sIHYxWzddLFxuXHRcdFx0XHR2MlswXSwgdjJbMV0sIHYyWzZdLCB2Mls3XSk7XG5cdFx0aWYgKHBvaW50KSB7XG5cdFx0XHR2YXIgeCA9IHBvaW50LngsXG5cdFx0XHRcdHkgPSBwb2ludC55O1xuXHRcdFx0YWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdGN1cnZlMSwgQ3VydmUuZ2V0UGFyYW1ldGVyT2YodjEsIHgsIHkpLCBwb2ludCxcblx0XHRcdFx0XHRjdXJ2ZTIsIEN1cnZlLmdldFBhcmFtZXRlck9mKHYyLCB4LCB5KSwgcG9pbnQpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7IHN0YXRpY3M6IHtcblx0XHRnZXRJbnRlcnNlY3Rpb25zOiBmdW5jdGlvbih2MSwgdjIsIGMxLCBjMiwgbG9jYXRpb25zLCBpbmNsdWRlKSB7XG5cdFx0XHR2YXIgbGluZWFyMSA9IEN1cnZlLmlzTGluZWFyKHYxKSxcblx0XHRcdFx0bGluZWFyMiA9IEN1cnZlLmlzTGluZWFyKHYyKSxcblx0XHRcdFx0YzFwMSA9IGMxLmdldFBvaW50MSgpLFxuXHRcdFx0XHRjMXAyID0gYzEuZ2V0UG9pbnQyKCksXG5cdFx0XHRcdGMycDEgPSBjMi5nZXRQb2ludDEoKSxcblx0XHRcdFx0YzJwMiA9IGMyLmdldFBvaW50MigpLFxuXHRcdFx0XHR0b2xlcmFuY2UgPSAwLjAwMDAwMTtcblx0XHRcdGlmIChjMXAxLmlzQ2xvc2UoYzJwMSwgdG9sZXJhbmNlKSlcblx0XHRcdFx0YWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLCBjMSwgMCwgYzFwMSwgYzIsIDAsIGMxcDEpO1xuXHRcdFx0aWYgKGMxcDEuaXNDbG9zZShjMnAyLCB0b2xlcmFuY2UpKVxuXHRcdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsIGMxLCAwLCBjMXAxLCBjMiwgMSwgYzFwMSk7XG5cdFx0XHQobGluZWFyMSAmJiBsaW5lYXIyXG5cdFx0XHRcdD8gYWRkTGluZUludGVyc2VjdGlvblxuXHRcdFx0XHQ6IGxpbmVhcjEgfHwgbGluZWFyMlxuXHRcdFx0XHRcdD8gYWRkQ3VydmVMaW5lSW50ZXJzZWN0aW9uc1xuXHRcdFx0XHRcdDogYWRkQ3VydmVJbnRlcnNlY3Rpb25zKShcblx0XHRcdFx0XHRcdHYxLCB2MiwgYzEsIGMyLCBsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0XHQwLCAxLCAwLCAxLCAwLCBmYWxzZSwgMCk7XG5cdFx0XHRpZiAoYzFwMi5pc0Nsb3NlKGMycDEsIHRvbGVyYW5jZSkpXG5cdFx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSwgYzEsIDEsIGMxcDIsIGMyLCAwLCBjMXAyKTtcblx0XHRcdGlmIChjMXAyLmlzQ2xvc2UoYzJwMiwgdG9sZXJhbmNlKSlcblx0XHRcdFx0YWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLCBjMSwgMSwgYzFwMiwgYzIsIDEsIGMxcDIpO1xuXHRcdFx0cmV0dXJuIGxvY2F0aW9ucztcblx0XHR9LFxuXG5cdFx0ZmlsdGVySW50ZXJzZWN0aW9uczogZnVuY3Rpb24obG9jYXRpb25zLCBfZXhwYW5kKSB7XG5cdFx0XHR2YXIgbGFzdCA9IGxvY2F0aW9ucy5sZW5ndGggLSAxLFxuXHRcdFx0XHR0TWF4ID0gMSAtIDAuMDAwMDAxO1xuXHRcdFx0Zm9yICh2YXIgaSA9IGxhc3Q7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdHZhciBsb2MgPSBsb2NhdGlvbnNbaV0sXG5cdFx0XHRcdFx0bmV4dCA9IGxvYy5fY3VydmUuZ2V0TmV4dCgpLFxuXHRcdFx0XHRcdG5leHQyID0gbG9jLl9jdXJ2ZTIuZ2V0TmV4dCgpO1xuXHRcdFx0XHRpZiAobmV4dCAmJiBsb2MuX3BhcmFtZXRlciA+PSB0TWF4KSB7XG5cdFx0XHRcdFx0bG9jLl9wYXJhbWV0ZXIgPSAwO1xuXHRcdFx0XHRcdGxvYy5fY3VydmUgPSBuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChuZXh0MiAmJiBsb2MuX3BhcmFtZXRlcjIgPj0gdE1heCkge1xuXHRcdFx0XHRcdGxvYy5fcGFyYW1ldGVyMiA9IDA7XG5cdFx0XHRcdFx0bG9jLl9jdXJ2ZTIgPSBuZXh0Mjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBjb21wYXJlKGxvYzEsIGxvYzIpIHtcblx0XHRcdFx0dmFyIHBhdGgxID0gbG9jMS5nZXRQYXRoKCksXG5cdFx0XHRcdFx0cGF0aDIgPSBsb2MyLmdldFBhdGgoKTtcblx0XHRcdFx0cmV0dXJuIHBhdGgxID09PSBwYXRoMlxuXHRcdFx0XHRcdFx0PyAobG9jMS5nZXRJbmRleCgpICsgbG9jMS5nZXRQYXJhbWV0ZXIoKSlcblx0XHRcdFx0XHRcdFx0XHQtIChsb2MyLmdldEluZGV4KCkgKyBsb2MyLmdldFBhcmFtZXRlcigpKVxuXHRcdFx0XHRcdFx0OiBwYXRoMS5faWQgLSBwYXRoMi5faWQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChsYXN0ID4gMCkge1xuXHRcdFx0XHRsb2NhdGlvbnMuc29ydChjb21wYXJlKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IGxhc3Q7IGkgPiAwOyBpLS0pIHtcblx0XHRcdFx0XHRpZiAobG9jYXRpb25zW2ldLmVxdWFscyhsb2NhdGlvbnNbaSAtIDFdKSkge1xuXHRcdFx0XHRcdFx0bG9jYXRpb25zLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdGxhc3QtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChfZXhwYW5kKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSBsYXN0OyBpID49IDA7IGktLSlcblx0XHRcdFx0XHRsb2NhdGlvbnMucHVzaChsb2NhdGlvbnNbaV0uZ2V0SW50ZXJzZWN0aW9uKCkpO1xuXHRcdFx0XHRsb2NhdGlvbnMuc29ydChjb21wYXJlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBsb2NhdGlvbnM7XG5cdFx0fVxuXHR9fTtcbn0pO1xuXG52YXIgQ3VydmVMb2NhdGlvbiA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnQ3VydmVMb2NhdGlvbicsXG5cdGJlYW5zOiB0cnVlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEN1cnZlTG9jYXRpb24oY3VydmUsIHBhcmFtZXRlciwgcG9pbnQsIF9jdXJ2ZTIsXG5cdFx0XHRfcGFyYW1ldGVyMiwgX3BvaW50MiwgX2Rpc3RhbmNlKSB7XG5cdFx0dGhpcy5faWQgPSBVSUQuZ2V0KEN1cnZlTG9jYXRpb24pO1xuXHRcdHZhciBwYXRoID0gY3VydmUuX3BhdGg7XG5cdFx0dGhpcy5fdmVyc2lvbiA9IHBhdGggPyBwYXRoLl92ZXJzaW9uIDogMDtcblx0XHR0aGlzLl9jdXJ2ZSA9IGN1cnZlO1xuXHRcdHRoaXMuX3BhcmFtZXRlciA9IHBhcmFtZXRlcjtcblx0XHR0aGlzLl9wb2ludCA9IHBvaW50IHx8IGN1cnZlLmdldFBvaW50QXQocGFyYW1ldGVyLCB0cnVlKTtcblx0XHR0aGlzLl9jdXJ2ZTIgPSBfY3VydmUyO1xuXHRcdHRoaXMuX3BhcmFtZXRlcjIgPSBfcGFyYW1ldGVyMjtcblx0XHR0aGlzLl9wb2ludDIgPSBfcG9pbnQyO1xuXHRcdHRoaXMuX2Rpc3RhbmNlID0gX2Rpc3RhbmNlO1xuXHRcdHRoaXMuX3NlZ21lbnQxID0gY3VydmUuX3NlZ21lbnQxO1xuXHRcdHRoaXMuX3NlZ21lbnQyID0gY3VydmUuX3NlZ21lbnQyO1xuXHR9LFxuXG5cdGdldFNlZ21lbnQ6IGZ1bmN0aW9uKF9wcmVmZXJGaXJzdCkge1xuXHRcdGlmICghdGhpcy5fc2VnbWVudCkge1xuXHRcdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpLFxuXHRcdFx0XHRwYXJhbWV0ZXIgPSB0aGlzLmdldFBhcmFtZXRlcigpO1xuXHRcdFx0aWYgKHBhcmFtZXRlciA9PT0gMSkge1xuXHRcdFx0XHR0aGlzLl9zZWdtZW50ID0gY3VydmUuX3NlZ21lbnQyO1xuXHRcdFx0fSBlbHNlIGlmIChwYXJhbWV0ZXIgPT09IDAgfHwgX3ByZWZlckZpcnN0KSB7XG5cdFx0XHRcdHRoaXMuX3NlZ21lbnQgPSBjdXJ2ZS5fc2VnbWVudDE7XG5cdFx0XHR9IGVsc2UgaWYgKHBhcmFtZXRlciA9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fc2VnbWVudCA9IGN1cnZlLmdldFBhcnRMZW5ndGgoMCwgcGFyYW1ldGVyKVxuXHRcdFx0XHRcdDwgY3VydmUuZ2V0UGFydExlbmd0aChwYXJhbWV0ZXIsIDEpXG5cdFx0XHRcdFx0XHQ/IGN1cnZlLl9zZWdtZW50MVxuXHRcdFx0XHRcdFx0OiBjdXJ2ZS5fc2VnbWVudDI7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50O1xuXHR9LFxuXG5cdGdldEN1cnZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLl9jdXJ2ZSxcblx0XHRcdHBhdGggPSBjdXJ2ZSAmJiBjdXJ2ZS5fcGF0aDtcblx0XHRpZiAocGF0aCAmJiBwYXRoLl92ZXJzaW9uICE9PSB0aGlzLl92ZXJzaW9uKSB7XG5cdFx0XHRjdXJ2ZSA9IG51bGw7XG5cdFx0XHR0aGlzLl9wYXJhbWV0ZXIgPSBudWxsO1xuXHRcdH1cblx0XHRpZiAoIWN1cnZlKSB7XG5cdFx0XHRjdXJ2ZSA9IHRoaXMuX3NlZ21lbnQxLmdldEN1cnZlKCk7XG5cdFx0XHRpZiAoY3VydmUuZ2V0UGFyYW1ldGVyT2YodGhpcy5fcG9pbnQpID09IG51bGwpXG5cdFx0XHRcdGN1cnZlID0gdGhpcy5fc2VnbWVudDIuZ2V0UHJldmlvdXMoKS5nZXRDdXJ2ZSgpO1xuXHRcdFx0dGhpcy5fY3VydmUgPSBjdXJ2ZTtcblx0XHRcdHBhdGggPSBjdXJ2ZS5fcGF0aDtcblx0XHRcdHRoaXMuX3ZlcnNpb24gPSBwYXRoID8gcGF0aC5fdmVyc2lvbiA6IDA7XG5cdFx0fVxuXHRcdHJldHVybiBjdXJ2ZTtcblx0fSxcblxuXHRnZXRQYXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCk7XG5cdFx0cmV0dXJuIGN1cnZlICYmIGN1cnZlLl9wYXRoO1xuXHR9LFxuXG5cdGdldEluZGV4OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCk7XG5cdFx0cmV0dXJuIGN1cnZlICYmIGN1cnZlLmdldEluZGV4KCk7XG5cdH0sXG5cblx0Z2V0UGFyYW1ldGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCksXG5cdFx0XHRwYXJhbWV0ZXIgPSB0aGlzLl9wYXJhbWV0ZXI7XG5cdFx0cmV0dXJuIGN1cnZlICYmIHBhcmFtZXRlciA9PSBudWxsXG5cdFx0XHQ/IHRoaXMuX3BhcmFtZXRlciA9IGN1cnZlLmdldFBhcmFtZXRlck9mKHRoaXMuX3BvaW50KVxuXHRcdFx0OiBwYXJhbWV0ZXI7XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wb2ludDtcblx0fSxcblxuXHRnZXRPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXRoID0gdGhpcy5nZXRQYXRoKCk7XG5cdFx0cmV0dXJuIHBhdGggPyBwYXRoLl9nZXRPZmZzZXQodGhpcykgOiB0aGlzLmdldEN1cnZlT2Zmc2V0KCk7XG5cdH0sXG5cblx0Z2V0Q3VydmVPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKSxcblx0XHRcdHBhcmFtZXRlciA9IHRoaXMuZ2V0UGFyYW1ldGVyKCk7XG5cdFx0cmV0dXJuIHBhcmFtZXRlciAhPSBudWxsICYmIGN1cnZlICYmIGN1cnZlLmdldFBhcnRMZW5ndGgoMCwgcGFyYW1ldGVyKTtcblx0fSxcblxuXHRnZXRJbnRlcnNlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpbnRlcnNlY3Rpb24gPSB0aGlzLl9pbnRlcnNlY3Rpb247XG5cdFx0aWYgKCFpbnRlcnNlY3Rpb24gJiYgdGhpcy5fY3VydmUyKSB7XG5cdFx0XHR0aGlzLl9pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb24gPSBuZXcgQ3VydmVMb2NhdGlvbih0aGlzLl9jdXJ2ZTIsXG5cdFx0XHRcdFx0dGhpcy5fcGFyYW1ldGVyMiwgdGhpcy5fcG9pbnQyIHx8IHRoaXMuX3BvaW50LCB0aGlzKTtcblx0XHRcdGludGVyc2VjdGlvbi5faW50ZXJzZWN0aW9uID0gdGhpcztcblx0XHR9XG5cdFx0cmV0dXJuIGludGVyc2VjdGlvbjtcblx0fSxcblxuXHRnZXREaXN0YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Rpc3RhbmNlO1xuXHR9LFxuXG5cdGRpdmlkZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpO1xuXHRcdHJldHVybiBjdXJ2ZSAmJiBjdXJ2ZS5kaXZpZGUodGhpcy5nZXRQYXJhbWV0ZXIoKSwgdHJ1ZSk7XG5cdH0sXG5cblx0c3BsaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKTtcblx0XHRyZXR1cm4gY3VydmUgJiYgY3VydmUuc3BsaXQodGhpcy5nZXRQYXJhbWV0ZXIoKSwgdHJ1ZSk7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihsb2MpIHtcblx0XHR2YXIgYWJzID0gTWF0aC5hYnMsXG5cdFx0XHR0b2xlcmFuY2UgPSAwLjAwMDAwMTtcblx0XHRyZXR1cm4gdGhpcyA9PT0gbG9jXG5cdFx0XHRcdHx8IGxvYyBpbnN0YW5jZW9mIEN1cnZlTG9jYXRpb25cblx0XHRcdFx0XHQmJiB0aGlzLmdldEN1cnZlKCkgPT09IGxvYy5nZXRDdXJ2ZSgpXG5cdFx0XHRcdFx0JiYgYWJzKHRoaXMuZ2V0UGFyYW1ldGVyKCkgLSBsb2MuZ2V0UGFyYW1ldGVyKCkpIDwgdG9sZXJhbmNlXG5cdFx0XHRcdFx0JiYgdGhpcy5fY3VydmUyID09PSBsb2MuX2N1cnZlMlxuXHRcdFx0XHRcdCYmIGFicyh0aGlzLl9wYXJhbWV0ZXIyIC0gbG9jLl9wYXJhbWV0ZXIyKSA8IHRvbGVyYW5jZVxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhcnRzID0gW10sXG5cdFx0XHRwb2ludCA9IHRoaXMuZ2V0UG9pbnQoKSxcblx0XHRcdGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG5cdFx0aWYgKHBvaW50KVxuXHRcdFx0cGFydHMucHVzaCgncG9pbnQ6ICcgKyBwb2ludCk7XG5cdFx0dmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xuXHRcdGlmIChpbmRleCAhPSBudWxsKVxuXHRcdFx0cGFydHMucHVzaCgnaW5kZXg6ICcgKyBpbmRleCk7XG5cdFx0dmFyIHBhcmFtZXRlciA9IHRoaXMuZ2V0UGFyYW1ldGVyKCk7XG5cdFx0aWYgKHBhcmFtZXRlciAhPSBudWxsKVxuXHRcdFx0cGFydHMucHVzaCgncGFyYW1ldGVyOiAnICsgZi5udW1iZXIocGFyYW1ldGVyKSk7XG5cdFx0aWYgKHRoaXMuX2Rpc3RhbmNlICE9IG51bGwpXG5cdFx0XHRwYXJ0cy5wdXNoKCdkaXN0YW5jZTogJyArIGYubnVtYmVyKHRoaXMuX2Rpc3RhbmNlKSk7XG5cdFx0cmV0dXJuICd7ICcgKyBwYXJ0cy5qb2luKCcsICcpICsgJyB9Jztcblx0fVxufSwgQmFzZS5lYWNoKEN1cnZlLmV2YWx1YXRlTWV0aG9kcywgZnVuY3Rpb24obmFtZSkge1xuXHRpZiAobmFtZSAhPT0gJ2dldFBvaW50Jykge1xuXHRcdHZhciBnZXQgPSBuYW1lICsgJ0F0Jztcblx0XHR0aGlzW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcGFyYW1ldGVyID0gdGhpcy5nZXRQYXJhbWV0ZXIoKSxcblx0XHRcdFx0Y3VydmUgPSB0aGlzLmdldEN1cnZlKCk7XG5cdFx0XHRyZXR1cm4gcGFyYW1ldGVyICE9IG51bGwgJiYgY3VydmUgJiYgY3VydmVbZ2V0XShwYXJhbWV0ZXIsIHRydWUpO1xuXHRcdH07XG5cdH1cbn0sIHt9KSk7XG5cbnZhciBQYXRoSXRlbSA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnUGF0aEl0ZW0nLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBhdGhJdGVtKCkge1xuXHR9LFxuXG5cdGdldEludGVyc2VjdGlvbnM6IGZ1bmN0aW9uKHBhdGgsIF9tYXRyaXgsIF9leHBhbmQpIHtcblx0XHRpZiAodGhpcyA9PT0gcGF0aClcblx0XHRcdHBhdGggPSBudWxsO1xuXHRcdHZhciBsb2NhdGlvbnMgPSBbXSxcblx0XHRcdGN1cnZlczEgPSB0aGlzLmdldEN1cnZlcygpLFxuXHRcdFx0Y3VydmVzMiA9IHBhdGggPyBwYXRoLmdldEN1cnZlcygpIDogY3VydmVzMSxcblx0XHRcdG1hdHJpeDEgPSB0aGlzLl9tYXRyaXgub3JOdWxsSWZJZGVudGl0eSgpLFxuXHRcdFx0bWF0cml4MiA9IHBhdGggPyAoX21hdHJpeCB8fCBwYXRoLl9tYXRyaXgpLm9yTnVsbElmSWRlbnRpdHkoKVxuXHRcdFx0XHQ6IG1hdHJpeDEsXG5cdFx0XHRsZW5ndGgxID0gY3VydmVzMS5sZW5ndGgsXG5cdFx0XHRsZW5ndGgyID0gcGF0aCA/IGN1cnZlczIubGVuZ3RoIDogbGVuZ3RoMSxcblx0XHRcdHZhbHVlczIgPSBbXSxcblx0XHRcdHRNaW4gPSAwLjAwMDAwMSxcblx0XHRcdHRNYXggPSAxIC0gdE1pbjtcblx0XHRpZiAocGF0aCAmJiAhdGhpcy5nZXRCb3VuZHMobWF0cml4MSkudG91Y2hlcyhwYXRoLmdldEJvdW5kcyhtYXRyaXgyKSkpXG5cdFx0XHRyZXR1cm4gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspXG5cdFx0XHR2YWx1ZXMyW2ldID0gY3VydmVzMltpXS5nZXRWYWx1ZXMobWF0cml4Mik7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcblx0XHRcdHZhciBjdXJ2ZTEgPSBjdXJ2ZXMxW2ldLFxuXHRcdFx0XHR2YWx1ZXMxID0gcGF0aCA/IGN1cnZlMS5nZXRWYWx1ZXMobWF0cml4MSkgOiB2YWx1ZXMyW2ldO1xuXHRcdFx0aWYgKCFwYXRoKSB7XG5cdFx0XHRcdHZhciBzZWcxID0gY3VydmUxLmdldFNlZ21lbnQxKCksXG5cdFx0XHRcdFx0c2VnMiA9IGN1cnZlMS5nZXRTZWdtZW50MigpLFxuXHRcdFx0XHRcdGgxID0gc2VnMS5faGFuZGxlT3V0LFxuXHRcdFx0XHRcdGgyID0gc2VnMi5faGFuZGxlSW47XG5cdFx0XHRcdGlmIChuZXcgTGluZShzZWcxLl9wb2ludC5zdWJ0cmFjdChoMSksIGgxLm11bHRpcGx5KDIpLCB0cnVlKVxuXHRcdFx0XHRcdFx0LmludGVyc2VjdChuZXcgTGluZShzZWcyLl9wb2ludC5zdWJ0cmFjdChoMiksXG5cdFx0XHRcdFx0XHRoMi5tdWx0aXBseSgyKSwgdHJ1ZSksIGZhbHNlKSkge1xuXHRcdFx0XHRcdHZhciBwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh2YWx1ZXMxKTtcblx0XHRcdFx0XHRDdXJ2ZS5nZXRJbnRlcnNlY3Rpb25zKFxuXHRcdFx0XHRcdFx0cGFydHNbMF0sIHBhcnRzWzFdLCBjdXJ2ZTEsIGN1cnZlMSwgbG9jYXRpb25zLFxuXHRcdFx0XHRcdFx0ZnVuY3Rpb24obG9jKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChsb2MuX3BhcmFtZXRlciA8PSB0TWF4KSB7XG5cdFx0XHRcdFx0XHRcdFx0bG9jLl9wYXJhbWV0ZXIgLz0gMjtcblx0XHRcdFx0XHRcdFx0XHRsb2MuX3BhcmFtZXRlcjIgPSAwLjUgKyBsb2MuX3BhcmFtZXRlcjIgLyAyO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaiA9IHBhdGggPyAwIDogaSArIDE7IGogPCBsZW5ndGgyOyBqKyspIHtcblx0XHRcdFx0Q3VydmUuZ2V0SW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0XHR2YWx1ZXMxLCB2YWx1ZXMyW2pdLCBjdXJ2ZTEsIGN1cnZlczJbal0sIGxvY2F0aW9ucyxcblx0XHRcdFx0XHQhcGF0aCAmJiAoaiA9PT0gaSArIDEgfHwgaiA9PT0gbGVuZ3RoMiAtIDEgJiYgaSA9PT0gMClcblx0XHRcdFx0XHRcdCYmIGZ1bmN0aW9uKGxvYykge1xuXHRcdFx0XHRcdFx0XHR2YXIgdCA9IGxvYy5fcGFyYW1ldGVyO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdCA+PSB0TWluICYmIHQgPD0gdE1heDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIEN1cnZlLmZpbHRlckludGVyc2VjdGlvbnMobG9jYXRpb25zLCBfZXhwYW5kKTtcblx0fSxcblxuXHRfYXNQYXRoSXRlbTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2V0UGF0aERhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcblxuXHRcdHZhciBwYXJ0cyA9IGRhdGEubWF0Y2goL1ttbGh2Y3NxdGF6XVtebWxodmNzcXRhel0qL2lnKSxcblx0XHRcdGNvb3Jkcyxcblx0XHRcdHJlbGF0aXZlID0gZmFsc2UsXG5cdFx0XHRwcmV2aW91cyxcblx0XHRcdGNvbnRyb2wsXG5cdFx0XHRjdXJyZW50ID0gbmV3IFBvaW50KCksXG5cdFx0XHRzdGFydCA9IG5ldyBQb2ludCgpO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0Q29vcmQoaW5kZXgsIGNvb3JkKSB7XG5cdFx0XHR2YXIgdmFsID0gK2Nvb3Jkc1tpbmRleF07XG5cdFx0XHRpZiAocmVsYXRpdmUpXG5cdFx0XHRcdHZhbCArPSBjdXJyZW50W2Nvb3JkXTtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0UG9pbnQoaW5kZXgpIHtcblx0XHRcdHJldHVybiBuZXcgUG9pbnQoXG5cdFx0XHRcdGdldENvb3JkKGluZGV4LCAneCcpLFxuXHRcdFx0XHRnZXRDb29yZChpbmRleCArIDEsICd5Jylcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5jbGVhcigpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwYXJ0cyAmJiBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBwYXJ0ID0gcGFydHNbaV0sXG5cdFx0XHRcdGNvbW1hbmQgPSBwYXJ0WzBdLFxuXHRcdFx0XHRsb3dlciA9IGNvbW1hbmQudG9Mb3dlckNhc2UoKTtcblx0XHRcdGNvb3JkcyA9IHBhcnQubWF0Y2goL1srLV0/KD86XFxkKlxcLlxcZCt8XFxkK1xcLj8pKD86W2VFXVsrLV0/XFxkKyk/L2cpO1xuXHRcdFx0dmFyIGxlbmd0aCA9IGNvb3JkcyAmJiBjb29yZHMubGVuZ3RoO1xuXHRcdFx0cmVsYXRpdmUgPSBjb21tYW5kID09PSBsb3dlcjtcblx0XHRcdGlmIChwcmV2aW91cyA9PT0gJ3onICYmICEvW216XS8udGVzdChsb3dlcikpXG5cdFx0XHRcdHRoaXMubW92ZVRvKGN1cnJlbnQgPSBzdGFydCk7XG5cdFx0XHRzd2l0Y2ggKGxvd2VyKSB7XG5cdFx0XHRjYXNlICdtJzpcblx0XHRcdGNhc2UgJ2wnOlxuXHRcdFx0XHR2YXIgbW92ZSA9IGxvd2VyID09PSAnbSc7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDIpXG5cdFx0XHRcdFx0dGhpc1tqID09PSAwICYmIG1vdmUgPyAnbW92ZVRvJyA6ICdsaW5lVG8nXShcblx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IGdldFBvaW50KGopKTtcblx0XHRcdFx0Y29udHJvbCA9IGN1cnJlbnQ7XG5cdFx0XHRcdGlmIChtb3ZlKVxuXHRcdFx0XHRcdHN0YXJ0ID0gY3VycmVudDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdoJzpcblx0XHRcdGNhc2UgJ3YnOlxuXHRcdFx0XHR2YXIgY29vcmQgPSBsb3dlciA9PT0gJ2gnID8gJ3gnIDogJ3knO1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0Y3VycmVudFtjb29yZF0gPSBnZXRDb29yZChqLCBjb29yZCk7XG5cdFx0XHRcdFx0dGhpcy5saW5lVG8oY3VycmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udHJvbCA9IGN1cnJlbnQ7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnYyc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDYpIHtcblx0XHRcdFx0XHR0aGlzLmN1YmljQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0Z2V0UG9pbnQoaiksXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wgPSBnZXRQb2ludChqICsgMiksXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSBnZXRQb2ludChqICsgNCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAncyc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDQpIHtcblx0XHRcdFx0XHR0aGlzLmN1YmljQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0L1tjc10vLnRlc3QocHJldmlvdXMpXG5cdFx0XHRcdFx0XHRcdFx0XHQ/IGN1cnJlbnQubXVsdGlwbHkoMikuc3VidHJhY3QoY29udHJvbClcblx0XHRcdFx0XHRcdFx0XHRcdDogY3VycmVudCxcblx0XHRcdFx0XHRcdFx0Y29udHJvbCA9IGdldFBvaW50KGopLFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gZ2V0UG9pbnQoaiArIDIpKTtcblx0XHRcdFx0XHRwcmV2aW91cyA9IGxvd2VyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAncSc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDQpIHtcblx0XHRcdFx0XHR0aGlzLnF1YWRyYXRpY0N1cnZlVG8oXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wgPSBnZXRQb2ludChqKSxcblx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IGdldFBvaW50KGogKyAyKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd0Jzpcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gMikge1xuXHRcdFx0XHRcdHRoaXMucXVhZHJhdGljQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0Y29udHJvbCA9ICgvW3F0XS8udGVzdChwcmV2aW91cylcblx0XHRcdFx0XHRcdFx0XHRcdD8gY3VycmVudC5tdWx0aXBseSgyKS5zdWJ0cmFjdChjb250cm9sKVxuXHRcdFx0XHRcdFx0XHRcdFx0OiBjdXJyZW50KSxcblx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IGdldFBvaW50KGopKTtcblx0XHRcdFx0XHRwcmV2aW91cyA9IGxvd2VyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnYSc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDcpIHtcblx0XHRcdFx0XHR0aGlzLmFyY1RvKGN1cnJlbnQgPSBnZXRQb2ludChqICsgNSksXG5cdFx0XHRcdFx0XHRcdG5ldyBTaXplKCtjb29yZHNbal0sICtjb29yZHNbaiArIDFdKSxcblx0XHRcdFx0XHRcdFx0K2Nvb3Jkc1tqICsgMl0sICtjb29yZHNbaiArIDRdLCArY29vcmRzW2ogKyAzXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd6Jzpcblx0XHRcdFx0dGhpcy5jbG9zZVBhdGgodHJ1ZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0cHJldmlvdXMgPSBsb3dlcjtcblx0XHR9XG5cdH0sXG5cblx0X2NhbkNvbXBvc2l0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEodGhpcy5oYXNGaWxsKCkgJiYgdGhpcy5oYXNTdHJva2UoKSk7XG5cdH0sXG5cblx0X2NvbnRhaW5zOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHZhciB3aW5kaW5nID0gdGhpcy5fZ2V0V2luZGluZyhwb2ludCwgZmFsc2UsIHRydWUpO1xuXHRcdHJldHVybiAhISh0aGlzLmdldFdpbmRpbmdSdWxlKCkgPT09ICdldmVub2RkJyA/IHdpbmRpbmcgJiAxIDogd2luZGluZyk7XG5cdH1cblxufSk7XG5cbnZhciBQYXRoID0gUGF0aEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnUGF0aCcsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRzZWdtZW50czogW10sXG5cdFx0Y2xvc2VkOiBmYWxzZVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBhdGgoYXJnKSB7XG5cdFx0dGhpcy5fY2xvc2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fc2VnbWVudHMgPSBbXTtcblx0XHR0aGlzLl92ZXJzaW9uID0gMDtcblx0XHR2YXIgc2VnbWVudHMgPSBBcnJheS5pc0FycmF5KGFyZylcblx0XHRcdD8gdHlwZW9mIGFyZ1swXSA9PT0gJ29iamVjdCdcblx0XHRcdFx0PyBhcmdcblx0XHRcdFx0OiBhcmd1bWVudHNcblx0XHRcdDogYXJnICYmIChhcmcuc2l6ZSA9PT0gdW5kZWZpbmVkICYmIChhcmcueCAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdFx0fHwgYXJnLnBvaW50ICE9PSB1bmRlZmluZWQpKVxuXHRcdFx0XHQ/IGFyZ3VtZW50c1xuXHRcdFx0XHQ6IG51bGw7XG5cdFx0aWYgKHNlZ21lbnRzICYmIHNlZ21lbnRzLmxlbmd0aCA+IDApIHtcblx0XHRcdHRoaXMuc2V0U2VnbWVudHMoc2VnbWVudHMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9jdXJ2ZXMgPSB1bmRlZmluZWQ7XG5cdFx0XHR0aGlzLl9zZWxlY3RlZFNlZ21lbnRTdGF0ZSA9IDA7XG5cdFx0XHRpZiAoIXNlZ21lbnRzICYmIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHRoaXMuc2V0UGF0aERhdGEoYXJnKTtcblx0XHRcdFx0YXJnID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5faW5pdGlhbGl6ZSghc2VnbWVudHMgJiYgYXJnKTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb3NlZCA9PT0gaXRlbS5fY2xvc2VkXG5cdFx0XHRcdCYmIEJhc2UuZXF1YWxzKHRoaXMuX3NlZ21lbnRzLCBpdGVtLl9zZWdtZW50cyk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdHZhciBjb3B5ID0gbmV3IFBhdGgoSXRlbS5OT19JTlNFUlQpO1xuXHRcdGNvcHkuc2V0U2VnbWVudHModGhpcy5fc2VnbWVudHMpO1xuXHRcdGNvcHkuX2Nsb3NlZCA9IHRoaXMuX2Nsb3NlZDtcblx0XHRpZiAodGhpcy5fY2xvY2t3aXNlICE9PSB1bmRlZmluZWQpXG5cdFx0XHRjb3B5Ll9jbG9ja3dpc2UgPSB0aGlzLl9jbG9ja3dpc2U7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb25lKGNvcHksIGluc2VydCk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uIF9jaGFuZ2VkKGZsYWdzKSB7XG5cdFx0X2NoYW5nZWQuYmFzZS5jYWxsKHRoaXMsIGZsYWdzKTtcblx0XHRpZiAoZmxhZ3MgJiA4KSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdFx0aWYgKHBhcmVudClcblx0XHRcdFx0cGFyZW50Ll9jdXJyZW50UGF0aCA9IHVuZGVmaW5lZDtcblx0XHRcdHRoaXMuX2xlbmd0aCA9IHRoaXMuX2Nsb2Nrd2lzZSA9IHVuZGVmaW5lZDtcblx0XHRcdGlmIChmbGFncyAmIDE2KSB7XG5cdFx0XHRcdHRoaXMuX3ZlcnNpb24rKztcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5fY3VydmVzKSB7XG5cdFx0XHQgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2N1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdFx0dGhpcy5fY3VydmVzW2ldLl9jaGFuZ2VkKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9tb25vQ3VydmVzID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSBpZiAoZmxhZ3MgJiAzMikge1xuXHRcdFx0dGhpcy5fYm91bmRzID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fSxcblxuXHRnZXRTdHlsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHRyZXR1cm4gKHBhcmVudCBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aCA/IHBhcmVudCA6IHRoaXMpLl9zdHlsZTtcblx0fSxcblxuXHRnZXRTZWdtZW50czogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnRzO1xuXHR9LFxuXG5cdHNldFNlZ21lbnRzOiBmdW5jdGlvbihzZWdtZW50cykge1xuXHRcdHZhciBmdWxseVNlbGVjdGVkID0gdGhpcy5pc0Z1bGx5U2VsZWN0ZWQoKTtcblx0XHR0aGlzLl9zZWdtZW50cy5sZW5ndGggPSAwO1xuXHRcdHRoaXMuX3NlbGVjdGVkU2VnbWVudFN0YXRlID0gMDtcblx0XHR0aGlzLl9jdXJ2ZXMgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKHNlZ21lbnRzICYmIHNlZ21lbnRzLmxlbmd0aCA+IDApXG5cdFx0XHR0aGlzLl9hZGQoU2VnbWVudC5yZWFkQWxsKHNlZ21lbnRzKSk7XG5cdFx0aWYgKGZ1bGx5U2VsZWN0ZWQpXG5cdFx0XHR0aGlzLnNldEZ1bGx5U2VsZWN0ZWQodHJ1ZSk7XG5cdH0sXG5cblx0Z2V0Rmlyc3RTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudHNbMF07XG5cdH0sXG5cblx0Z2V0TGFzdFNlZ21lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50c1t0aGlzLl9zZWdtZW50cy5sZW5ndGggLSAxXTtcblx0fSxcblxuXHRnZXRDdXJ2ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMsXG5cdFx0XHRzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzO1xuXHRcdGlmICghY3VydmVzKSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gdGhpcy5fY291bnRDdXJ2ZXMoKTtcblx0XHRcdGN1cnZlcyA9IHRoaXMuX2N1cnZlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcblx0XHRcdFx0Y3VydmVzW2ldID0gbmV3IEN1cnZlKHRoaXMsIHNlZ21lbnRzW2ldLFxuXHRcdFx0XHRcdHNlZ21lbnRzW2kgKyAxXSB8fCBzZWdtZW50c1swXSk7XG5cdFx0fVxuXHRcdHJldHVybiBjdXJ2ZXM7XG5cdH0sXG5cblx0Z2V0Rmlyc3RDdXJ2ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q3VydmVzKClbMF07XG5cdH0sXG5cblx0Z2V0TGFzdEN1cnZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblx0XHRyZXR1cm4gY3VydmVzW2N1cnZlcy5sZW5ndGggLSAxXTtcblx0fSxcblxuXHRpc0Nsb3NlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb3NlZDtcblx0fSxcblxuXHRzZXRDbG9zZWQ6IGZ1bmN0aW9uKGNsb3NlZCkge1xuXHRcdGlmICh0aGlzLl9jbG9zZWQgIT0gKGNsb3NlZCA9ICEhY2xvc2VkKSkge1xuXHRcdFx0dGhpcy5fY2xvc2VkID0gY2xvc2VkO1xuXHRcdFx0aWYgKHRoaXMuX2N1cnZlcykge1xuXHRcdFx0XHR2YXIgbGVuZ3RoID0gdGhpcy5fY3VydmVzLmxlbmd0aCA9IHRoaXMuX2NvdW50Q3VydmVzKCk7XG5cdFx0XHRcdGlmIChjbG9zZWQpXG5cdFx0XHRcdFx0dGhpcy5fY3VydmVzW2xlbmd0aCAtIDFdID0gbmV3IEN1cnZlKHRoaXMsXG5cdFx0XHRcdFx0XHR0aGlzLl9zZWdtZW50c1tsZW5ndGggLSAxXSwgdGhpcy5fc2VnbWVudHNbMF0pO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY2hhbmdlZCgyNSk7XG5cdFx0fVxuXHR9XG59LCB7XG5cdGJlYW5zOiB0cnVlLFxuXG5cdGdldFBhdGhEYXRhOiBmdW5jdGlvbihfbWF0cml4LCBfcHJlY2lzaW9uKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRsZW5ndGggPSBzZWdtZW50cy5sZW5ndGgsXG5cdFx0XHRmID0gbmV3IEZvcm1hdHRlcihfcHJlY2lzaW9uKSxcblx0XHRcdGNvb3JkcyA9IG5ldyBBcnJheSg2KSxcblx0XHRcdGZpcnN0ID0gdHJ1ZSxcblx0XHRcdGN1clgsIGN1clksXG5cdFx0XHRwcmV2WCwgcHJldlksXG5cdFx0XHRpblgsIGluWSxcblx0XHRcdG91dFgsIG91dFksXG5cdFx0XHRwYXJ0cyA9IFtdO1xuXG5cdFx0ZnVuY3Rpb24gYWRkU2VnbWVudChzZWdtZW50LCBza2lwTGluZSkge1xuXHRcdFx0c2VnbWVudC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMoX21hdHJpeCwgY29vcmRzLCBmYWxzZSk7XG5cdFx0XHRjdXJYID0gY29vcmRzWzBdO1xuXHRcdFx0Y3VyWSA9IGNvb3Jkc1sxXTtcblx0XHRcdGlmIChmaXJzdCkge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKCdNJyArIGYucGFpcihjdXJYLCBjdXJZKSk7XG5cdFx0XHRcdGZpcnN0ID0gZmFsc2U7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpblggPSBjb29yZHNbMl07XG5cdFx0XHRcdGluWSA9IGNvb3Jkc1szXTtcblx0XHRcdFx0aWYgKGluWCA9PT0gY3VyWCAmJiBpblkgPT09IGN1cllcblx0XHRcdFx0XHRcdCYmIG91dFggPT09IHByZXZYICYmIG91dFkgPT09IHByZXZZKSB7XG5cdFx0XHRcdFx0aWYgKCFza2lwTGluZSlcblx0XHRcdFx0XHRcdHBhcnRzLnB1c2goJ2wnICsgZi5wYWlyKGN1clggLSBwcmV2WCwgY3VyWSAtIHByZXZZKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGFydHMucHVzaCgnYycgKyBmLnBhaXIob3V0WCAtIHByZXZYLCBvdXRZIC0gcHJldlkpXG5cdFx0XHRcdFx0XHRcdCsgJyAnICsgZi5wYWlyKGluWCAtIHByZXZYLCBpblkgLSBwcmV2WSlcblx0XHRcdFx0XHRcdFx0KyAnICcgKyBmLnBhaXIoY3VyWCAtIHByZXZYLCBjdXJZIC0gcHJldlkpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cHJldlggPSBjdXJYO1xuXHRcdFx0cHJldlkgPSBjdXJZO1xuXHRcdFx0b3V0WCA9IGNvb3Jkc1s0XTtcblx0XHRcdG91dFkgPSBjb29yZHNbNV07XG5cdFx0fVxuXG5cdFx0aWYgKGxlbmd0aCA9PT0gMClcblx0XHRcdHJldHVybiAnJztcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0XHRhZGRTZWdtZW50KHNlZ21lbnRzW2ldKTtcblx0XHRpZiAodGhpcy5fY2xvc2VkICYmIGxlbmd0aCA+IDApIHtcblx0XHRcdGFkZFNlZ21lbnQoc2VnbWVudHNbMF0sIHRydWUpO1xuXHRcdFx0cGFydHMucHVzaCgneicpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGFydHMuam9pbignJyk7XG5cdH1cbn0sIHtcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudHMubGVuZ3RoID09PSAwO1xuXHR9LFxuXG5cdGlzTGluZWFyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cztcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0aWYgKCFzZWdtZW50c1tpXS5pc0xpbmVhcigpKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdGhhc0hhbmRsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAoc2VnbWVudHNbaV0uaGFzSGFuZGxlcygpKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Db250ZW50OiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR2YXIgY29vcmRzID0gbmV3IEFycmF5KDYpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0dGhpcy5fc2VnbWVudHNbaV0uX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzLCB0cnVlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfYWRkOiBmdW5jdGlvbihzZWdzLCBpbmRleCkge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0Y3VydmVzID0gdGhpcy5fY3VydmVzLFxuXHRcdFx0YW1vdW50ID0gc2Vncy5sZW5ndGgsXG5cdFx0XHRhcHBlbmQgPSBpbmRleCA9PSBudWxsLFxuXHRcdFx0aW5kZXggPSBhcHBlbmQgPyBzZWdtZW50cy5sZW5ndGggOiBpbmRleDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IHNlZ3NbaV07XG5cdFx0XHRpZiAoc2VnbWVudC5fcGF0aClcblx0XHRcdFx0c2VnbWVudCA9IHNlZ3NbaV0gPSBzZWdtZW50LmNsb25lKCk7XG5cdFx0XHRzZWdtZW50Ll9wYXRoID0gdGhpcztcblx0XHRcdHNlZ21lbnQuX2luZGV4ID0gaW5kZXggKyBpO1xuXHRcdFx0aWYgKHNlZ21lbnQuX3NlbGVjdGlvblN0YXRlKVxuXHRcdFx0XHR0aGlzLl91cGRhdGVTZWxlY3Rpb24oc2VnbWVudCwgMCwgc2VnbWVudC5fc2VsZWN0aW9uU3RhdGUpO1xuXHRcdH1cblx0XHRpZiAoYXBwZW5kKSB7XG5cdFx0XHRzZWdtZW50cy5wdXNoLmFwcGx5KHNlZ21lbnRzLCBzZWdzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c2VnbWVudHMuc3BsaWNlLmFwcGx5KHNlZ21lbnRzLCBbaW5kZXgsIDBdLmNvbmNhdChzZWdzKSk7XG5cdFx0XHRmb3IgKHZhciBpID0gaW5kZXggKyBhbW91bnQsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHNlZ21lbnRzW2ldLl9pbmRleCA9IGk7XG5cdFx0fVxuXHRcdGlmIChjdXJ2ZXMgfHwgc2Vncy5fY3VydmVzKSB7XG5cdFx0XHRpZiAoIWN1cnZlcylcblx0XHRcdFx0Y3VydmVzID0gdGhpcy5fY3VydmVzID0gW107XG5cdFx0XHR2YXIgZnJvbSA9IGluZGV4ID4gMCA/IGluZGV4IC0gMSA6IGluZGV4LFxuXHRcdFx0XHRzdGFydCA9IGZyb20sXG5cdFx0XHRcdHRvID0gTWF0aC5taW4oZnJvbSArIGFtb3VudCwgdGhpcy5fY291bnRDdXJ2ZXMoKSk7XG5cdFx0XHRpZiAoc2Vncy5fY3VydmVzKSB7XG5cdFx0XHRcdGN1cnZlcy5zcGxpY2UuYXBwbHkoY3VydmVzLCBbZnJvbSwgMF0uY29uY2F0KHNlZ3MuX2N1cnZlcykpO1xuXHRcdFx0XHRzdGFydCArPSBzZWdzLl9jdXJ2ZXMubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgdG87IGkrKylcblx0XHRcdFx0Y3VydmVzLnNwbGljZShpLCAwLCBuZXcgQ3VydmUodGhpcywgbnVsbCwgbnVsbCkpO1xuXHRcdFx0dGhpcy5fYWRqdXN0Q3VydmVzKGZyb20sIHRvKTtcblx0XHR9XG5cdFx0dGhpcy5fY2hhbmdlZCgyNSk7XG5cdFx0cmV0dXJuIHNlZ3M7XG5cdH0sXG5cblx0X2FkanVzdEN1cnZlczogZnVuY3Rpb24oZnJvbSwgdG8pIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdGN1cnZlcyA9IHRoaXMuX2N1cnZlcyxcblx0XHRcdGN1cnZlO1xuXHRcdGZvciAodmFyIGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuXHRcdFx0Y3VydmUgPSBjdXJ2ZXNbaV07XG5cdFx0XHRjdXJ2ZS5fcGF0aCA9IHRoaXM7XG5cdFx0XHRjdXJ2ZS5fc2VnbWVudDEgPSBzZWdtZW50c1tpXTtcblx0XHRcdGN1cnZlLl9zZWdtZW50MiA9IHNlZ21lbnRzW2kgKyAxXSB8fCBzZWdtZW50c1swXTtcblx0XHRcdGN1cnZlLl9jaGFuZ2VkKCk7XG5cdFx0fVxuXHRcdGlmIChjdXJ2ZSA9IGN1cnZlc1t0aGlzLl9jbG9zZWQgJiYgZnJvbSA9PT0gMCA/IHNlZ21lbnRzLmxlbmd0aCAtIDFcblx0XHRcdFx0OiBmcm9tIC0gMV0pIHtcblx0XHRcdGN1cnZlLl9zZWdtZW50MiA9IHNlZ21lbnRzW2Zyb21dIHx8IHNlZ21lbnRzWzBdO1xuXHRcdFx0Y3VydmUuX2NoYW5nZWQoKTtcblx0XHR9XG5cdFx0aWYgKGN1cnZlID0gY3VydmVzW3RvXSkge1xuXHRcdFx0Y3VydmUuX3NlZ21lbnQxID0gc2VnbWVudHNbdG9dO1xuXHRcdFx0Y3VydmUuX2NoYW5nZWQoKTtcblx0XHR9XG5cdH0sXG5cblx0X2NvdW50Q3VydmVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGVuZ3RoID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoO1xuXHRcdHJldHVybiAhdGhpcy5fY2xvc2VkICYmIGxlbmd0aCA+IDAgPyBsZW5ndGggLSAxIDogbGVuZ3RoO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oc2VnbWVudDEgKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBzZWdtZW50MSAhPT0gJ251bWJlcidcblx0XHRcdD8gdGhpcy5fYWRkKFNlZ21lbnQucmVhZEFsbChhcmd1bWVudHMpKVxuXHRcdFx0OiB0aGlzLl9hZGQoWyBTZWdtZW50LnJlYWQoYXJndW1lbnRzKSBdKVswXTtcblx0fSxcblxuXHRpbnNlcnQ6IGZ1bmN0aW9uKGluZGV4LCBzZWdtZW50MSApIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgdHlwZW9mIHNlZ21lbnQxICE9PSAnbnVtYmVyJ1xuXHRcdFx0PyB0aGlzLl9hZGQoU2VnbWVudC5yZWFkQWxsKGFyZ3VtZW50cywgMSksIGluZGV4KVxuXHRcdFx0OiB0aGlzLl9hZGQoWyBTZWdtZW50LnJlYWQoYXJndW1lbnRzLCAxKSBdLCBpbmRleClbMF07XG5cdH0sXG5cblx0YWRkU2VnbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FkZChbIFNlZ21lbnQucmVhZChhcmd1bWVudHMpIF0pWzBdO1xuXHR9LFxuXG5cdGluc2VydFNlZ21lbnQ6IGZ1bmN0aW9uKGluZGV4ICkge1xuXHRcdHJldHVybiB0aGlzLl9hZGQoWyBTZWdtZW50LnJlYWQoYXJndW1lbnRzLCAxKSBdLCBpbmRleClbMF07XG5cdH0sXG5cblx0YWRkU2VnbWVudHM6IGZ1bmN0aW9uKHNlZ21lbnRzKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FkZChTZWdtZW50LnJlYWRBbGwoc2VnbWVudHMpKTtcblx0fSxcblxuXHRpbnNlcnRTZWdtZW50czogZnVuY3Rpb24oaW5kZXgsIHNlZ21lbnRzKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FkZChTZWdtZW50LnJlYWRBbGwoc2VnbWVudHMpLCBpbmRleCk7XG5cdH0sXG5cblx0cmVtb3ZlU2VnbWVudDogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRyZXR1cm4gdGhpcy5yZW1vdmVTZWdtZW50cyhpbmRleCwgaW5kZXggKyAxKVswXSB8fCBudWxsO1xuXHR9LFxuXG5cdHJlbW92ZVNlZ21lbnRzOiBmdW5jdGlvbihmcm9tLCB0bywgX2luY2x1ZGVDdXJ2ZXMpIHtcblx0XHRmcm9tID0gZnJvbSB8fCAwO1xuXHRcdHRvID0gQmFzZS5waWNrKHRvLCB0aGlzLl9zZWdtZW50cy5sZW5ndGgpO1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0Y3VydmVzID0gdGhpcy5fY3VydmVzLFxuXHRcdFx0Y291bnQgPSBzZWdtZW50cy5sZW5ndGgsXG5cdFx0XHRyZW1vdmVkID0gc2VnbWVudHMuc3BsaWNlKGZyb20sIHRvIC0gZnJvbSksXG5cdFx0XHRhbW91bnQgPSByZW1vdmVkLmxlbmd0aDtcblx0XHRpZiAoIWFtb3VudClcblx0XHRcdHJldHVybiByZW1vdmVkO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gcmVtb3ZlZFtpXTtcblx0XHRcdGlmIChzZWdtZW50Ll9zZWxlY3Rpb25TdGF0ZSlcblx0XHRcdFx0dGhpcy5fdXBkYXRlU2VsZWN0aW9uKHNlZ21lbnQsIHNlZ21lbnQuX3NlbGVjdGlvblN0YXRlLCAwKTtcblx0XHRcdHNlZ21lbnQuX2luZGV4ID0gc2VnbWVudC5fcGF0aCA9IG51bGw7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSBmcm9tLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0c2VnbWVudHNbaV0uX2luZGV4ID0gaTtcblx0XHRpZiAoY3VydmVzKSB7XG5cdFx0XHR2YXIgaW5kZXggPSBmcm9tID4gMCAmJiB0byA9PT0gY291bnQgKyAodGhpcy5fY2xvc2VkID8gMSA6IDApXG5cdFx0XHRcdFx0PyBmcm9tIC0gMVxuXHRcdFx0XHRcdDogZnJvbSxcblx0XHRcdFx0Y3VydmVzID0gY3VydmVzLnNwbGljZShpbmRleCwgYW1vdW50KTtcblx0XHRcdGlmIChfaW5jbHVkZUN1cnZlcylcblx0XHRcdFx0cmVtb3ZlZC5fY3VydmVzID0gY3VydmVzLnNsaWNlKDEpO1xuXHRcdFx0dGhpcy5fYWRqdXN0Q3VydmVzKGluZGV4LCBpbmRleCk7XG5cdFx0fVxuXHRcdHRoaXMuX2NoYW5nZWQoMjUpO1xuXHRcdHJldHVybiByZW1vdmVkO1xuXHR9LFxuXG5cdGNsZWFyOiAnI3JlbW92ZVNlZ21lbnRzJyxcblxuXHRnZXRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9sZW5ndGggPT0gbnVsbCkge1xuXHRcdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCk7XG5cdFx0XHR0aGlzLl9sZW5ndGggPSAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHR0aGlzLl9sZW5ndGggKz0gY3VydmVzW2ldLmdldExlbmd0aCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fbGVuZ3RoO1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpO1xuXHRcdHZhciBhcmVhID0gMDtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRhcmVhICs9IGN1cnZlc1tpXS5nZXRBcmVhKCk7XG5cdFx0cmV0dXJuIGFyZWE7XG5cdH0sXG5cblx0aXNGdWxseVNlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGVuZ3RoID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoO1xuXHRcdHJldHVybiB0aGlzLl9zZWxlY3RlZCAmJiBsZW5ndGggPiAwICYmIHRoaXMuX3NlbGVjdGVkU2VnbWVudFN0YXRlXG5cdFx0XHRcdD09PSBsZW5ndGggKiA3O1xuXHR9LFxuXG5cdHNldEZ1bGx5U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0aWYgKHNlbGVjdGVkKVxuXHRcdFx0dGhpcy5fc2VsZWN0U2VnbWVudHModHJ1ZSk7XG5cdFx0dGhpcy5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdH0sXG5cblx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uIHNldFNlbGVjdGVkKHNlbGVjdGVkKSB7XG5cdFx0aWYgKCFzZWxlY3RlZClcblx0XHRcdHRoaXMuX3NlbGVjdFNlZ21lbnRzKGZhbHNlKTtcblx0XHRzZXRTZWxlY3RlZC5iYXNlLmNhbGwodGhpcywgc2VsZWN0ZWQpO1xuXHR9LFxuXG5cdF9zZWxlY3RTZWdtZW50czogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHR2YXIgbGVuZ3RoID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoO1xuXHRcdHRoaXMuX3NlbGVjdGVkU2VnbWVudFN0YXRlID0gc2VsZWN0ZWRcblx0XHRcdFx0PyBsZW5ndGggKiA3IDogMDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuXHRcdFx0dGhpcy5fc2VnbWVudHNbaV0uX3NlbGVjdGlvblN0YXRlID0gc2VsZWN0ZWRcblx0XHRcdFx0XHQ/IDcgOiAwO1xuXHR9LFxuXG5cdF91cGRhdGVTZWxlY3Rpb246IGZ1bmN0aW9uKHNlZ21lbnQsIG9sZFN0YXRlLCBuZXdTdGF0ZSkge1xuXHRcdHNlZ21lbnQuX3NlbGVjdGlvblN0YXRlID0gbmV3U3RhdGU7XG5cdFx0dmFyIHRvdGFsID0gdGhpcy5fc2VsZWN0ZWRTZWdtZW50U3RhdGUgKz0gbmV3U3RhdGUgLSBvbGRTdGF0ZTtcblx0XHRpZiAodG90YWwgPiAwKVxuXHRcdFx0dGhpcy5zZXRTZWxlY3RlZCh0cnVlKTtcblx0fSxcblxuXHRmbGF0dGVuOiBmdW5jdGlvbihtYXhEaXN0YW5jZSkge1xuXHRcdHZhciBpdGVyYXRvciA9IG5ldyBQYXRoSXRlcmF0b3IodGhpcywgNjQsIDAuMSksXG5cdFx0XHRwb3MgPSAwLFxuXHRcdFx0c3RlcCA9IGl0ZXJhdG9yLmxlbmd0aCAvIE1hdGguY2VpbChpdGVyYXRvci5sZW5ndGggLyBtYXhEaXN0YW5jZSksXG5cdFx0XHRlbmQgPSBpdGVyYXRvci5sZW5ndGggKyAodGhpcy5fY2xvc2VkID8gLXN0ZXAgOiBzdGVwKSAvIDI7XG5cdFx0dmFyIHNlZ21lbnRzID0gW107XG5cdFx0d2hpbGUgKHBvcyA8PSBlbmQpIHtcblx0XHRcdHNlZ21lbnRzLnB1c2gobmV3IFNlZ21lbnQoaXRlcmF0b3IuZ2V0UG9pbnRBdChwb3MpKSk7XG5cdFx0XHRwb3MgKz0gc3RlcDtcblx0XHR9XG5cdFx0dGhpcy5zZXRTZWdtZW50cyhzZWdtZW50cyk7XG5cdH0sXG5cblx0cmVkdWNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblx0XHRmb3IgKHZhciBpID0gY3VydmVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgY3VydmUgPSBjdXJ2ZXNbaV07XG5cdFx0XHRpZiAoY3VydmUuaXNMaW5lYXIoKSAmJiBjdXJ2ZS5nZXRMZW5ndGgoKSA9PT0gMClcblx0XHRcdFx0Y3VydmUucmVtb3ZlKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNpbXBsaWZ5OiBmdW5jdGlvbih0b2xlcmFuY2UpIHtcblx0XHRpZiAodGhpcy5fc2VnbWVudHMubGVuZ3RoID4gMikge1xuXHRcdFx0dmFyIGZpdHRlciA9IG5ldyBQYXRoRml0dGVyKHRoaXMsIHRvbGVyYW5jZSB8fCAyLjUpO1xuXHRcdFx0dGhpcy5zZXRTZWdtZW50cyhmaXR0ZXIuZml0KCkpO1xuXHRcdH1cblx0fSxcblxuXHRzcGxpdDogZnVuY3Rpb24oaW5kZXgsIHBhcmFtZXRlcikge1xuXHRcdGlmIChwYXJhbWV0ZXIgPT09IG51bGwpXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0dmFyIGFyZyA9IGluZGV4O1xuXHRcdFx0aWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKVxuXHRcdFx0XHRhcmcgPSB0aGlzLmdldExvY2F0aW9uQXQoYXJnKTtcblx0XHRcdGlmICghYXJnKVxuXHRcdFx0XHRyZXR1cm4gbnVsbFxuXHRcdFx0aW5kZXggPSBhcmcuaW5kZXg7XG5cdFx0XHRwYXJhbWV0ZXIgPSBhcmcucGFyYW1ldGVyO1xuXHRcdH1cblx0XHR2YXIgdG9sZXJhbmNlID0gMC4wMDAwMDE7XG5cdFx0aWYgKHBhcmFtZXRlciA+PSAxIC0gdG9sZXJhbmNlKSB7XG5cdFx0XHRpbmRleCsrO1xuXHRcdFx0cGFyYW1ldGVyLS07XG5cdFx0fVxuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpO1xuXHRcdGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgY3VydmVzLmxlbmd0aCkge1xuXHRcdFx0aWYgKHBhcmFtZXRlciA+IHRvbGVyYW5jZSkge1xuXHRcdFx0XHRjdXJ2ZXNbaW5kZXgrK10uZGl2aWRlKHBhcmFtZXRlciwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgc2VncyA9IHRoaXMucmVtb3ZlU2VnbWVudHMoaW5kZXgsIHRoaXMuX3NlZ21lbnRzLmxlbmd0aCwgdHJ1ZSksXG5cdFx0XHRcdHBhdGg7XG5cdFx0XHRpZiAodGhpcy5fY2xvc2VkKSB7XG5cdFx0XHRcdHRoaXMuc2V0Q2xvc2VkKGZhbHNlKTtcblx0XHRcdFx0cGF0aCA9IHRoaXM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXRoID0gdGhpcy5fY2xvbmUobmV3IFBhdGgoKS5pbnNlcnRBYm92ZSh0aGlzLCB0cnVlKSk7XG5cdFx0XHR9XG5cdFx0XHRwYXRoLl9hZGQoc2VncywgMCk7XG5cdFx0XHR0aGlzLmFkZFNlZ21lbnQoc2Vnc1swXSk7XG5cdFx0XHRyZXR1cm4gcGF0aDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0aXNDbG9ja3dpc2U6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9jbG9ja3dpc2UgIT09IHVuZGVmaW5lZClcblx0XHRcdHJldHVybiB0aGlzLl9jbG9ja3dpc2U7XG5cdFx0cmV0dXJuIFBhdGguaXNDbG9ja3dpc2UodGhpcy5fc2VnbWVudHMpO1xuXHR9LFxuXG5cdHNldENsb2Nrd2lzZTogZnVuY3Rpb24oY2xvY2t3aXNlKSB7XG5cdFx0aWYgKHRoaXMuaXNDbG9ja3dpc2UoKSAhPSAoY2xvY2t3aXNlID0gISFjbG9ja3dpc2UpKVxuXHRcdFx0dGhpcy5yZXZlcnNlKCk7XG5cdFx0dGhpcy5fY2xvY2t3aXNlID0gY2xvY2t3aXNlO1xuXHR9LFxuXG5cdHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3NlZ21lbnRzLnJldmVyc2UoKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3NlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSB0aGlzLl9zZWdtZW50c1tpXTtcblx0XHRcdHZhciBoYW5kbGVJbiA9IHNlZ21lbnQuX2hhbmRsZUluO1xuXHRcdFx0c2VnbWVudC5faGFuZGxlSW4gPSBzZWdtZW50Ll9oYW5kbGVPdXQ7XG5cdFx0XHRzZWdtZW50Ll9oYW5kbGVPdXQgPSBoYW5kbGVJbjtcblx0XHRcdHNlZ21lbnQuX2luZGV4ID0gaTtcblx0XHR9XG5cdFx0dGhpcy5fY3VydmVzID0gbnVsbDtcblx0XHRpZiAodGhpcy5fY2xvY2t3aXNlICE9PSB1bmRlZmluZWQpXG5cdFx0XHR0aGlzLl9jbG9ja3dpc2UgPSAhdGhpcy5fY2xvY2t3aXNlO1xuXHRcdHRoaXMuX2NoYW5nZWQoOSk7XG5cdH0sXG5cblx0am9pbjogZnVuY3Rpb24ocGF0aCkge1xuXHRcdGlmIChwYXRoKSB7XG5cdFx0XHR2YXIgc2VnbWVudHMgPSBwYXRoLl9zZWdtZW50cyxcblx0XHRcdFx0bGFzdDEgPSB0aGlzLmdldExhc3RTZWdtZW50KCksXG5cdFx0XHRcdGxhc3QyID0gcGF0aC5nZXRMYXN0U2VnbWVudCgpO1xuXHRcdFx0aWYgKCFsYXN0Milcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRpZiAobGFzdDEgJiYgbGFzdDEuX3BvaW50LmVxdWFscyhsYXN0Mi5fcG9pbnQpKVxuXHRcdFx0XHRwYXRoLnJldmVyc2UoKTtcblx0XHRcdHZhciBmaXJzdDIgPSBwYXRoLmdldEZpcnN0U2VnbWVudCgpO1xuXHRcdFx0aWYgKGxhc3QxICYmIGxhc3QxLl9wb2ludC5lcXVhbHMoZmlyc3QyLl9wb2ludCkpIHtcblx0XHRcdFx0bGFzdDEuc2V0SGFuZGxlT3V0KGZpcnN0Mi5faGFuZGxlT3V0KTtcblx0XHRcdFx0dGhpcy5fYWRkKHNlZ21lbnRzLnNsaWNlKDEpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBmaXJzdDEgPSB0aGlzLmdldEZpcnN0U2VnbWVudCgpO1xuXHRcdFx0XHRpZiAoZmlyc3QxICYmIGZpcnN0MS5fcG9pbnQuZXF1YWxzKGZpcnN0Mi5fcG9pbnQpKVxuXHRcdFx0XHRcdHBhdGgucmV2ZXJzZSgpO1xuXHRcdFx0XHRsYXN0MiA9IHBhdGguZ2V0TGFzdFNlZ21lbnQoKTtcblx0XHRcdFx0aWYgKGZpcnN0MSAmJiBmaXJzdDEuX3BvaW50LmVxdWFscyhsYXN0Mi5fcG9pbnQpKSB7XG5cdFx0XHRcdFx0Zmlyc3QxLnNldEhhbmRsZUluKGxhc3QyLl9oYW5kbGVJbik7XG5cdFx0XHRcdFx0dGhpcy5fYWRkKHNlZ21lbnRzLnNsaWNlKDAsIHNlZ21lbnRzLmxlbmd0aCAtIDEpLCAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9hZGQoc2VnbWVudHMuc2xpY2UoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChwYXRoLmNsb3NlZClcblx0XHRcdFx0dGhpcy5fYWRkKFtzZWdtZW50c1swXV0pO1xuXHRcdFx0cGF0aC5yZW1vdmUoKTtcblx0XHR9XG5cdFx0dmFyIGZpcnN0ID0gdGhpcy5nZXRGaXJzdFNlZ21lbnQoKSxcblx0XHRcdGxhc3QgPSB0aGlzLmdldExhc3RTZWdtZW50KCk7XG5cdFx0aWYgKGZpcnN0ICE9PSBsYXN0ICYmIGZpcnN0Ll9wb2ludC5lcXVhbHMobGFzdC5fcG9pbnQpKSB7XG5cdFx0XHRmaXJzdC5zZXRIYW5kbGVJbihsYXN0Ll9oYW5kbGVJbik7XG5cdFx0XHRsYXN0LnJlbW92ZSgpO1xuXHRcdFx0dGhpcy5zZXRDbG9zZWQodHJ1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvU2hhcGU6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdGlmICghdGhpcy5fY2xvc2VkKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdHR5cGUsXG5cdFx0XHRzaXplLFxuXHRcdFx0cmFkaXVzLFxuXHRcdFx0dG9wQ2VudGVyO1xuXG5cdFx0ZnVuY3Rpb24gaXNDb2xsaW5lYXIoaSwgaikge1xuXHRcdFx0cmV0dXJuIHNlZ21lbnRzW2ldLmlzQ29sbGluZWFyKHNlZ21lbnRzW2pdKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc09ydGhvZ29uYWwoaSkge1xuXHRcdFx0cmV0dXJuIHNlZ21lbnRzW2ldLmlzT3J0aG9nb25hbCgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzQXJjKGkpIHtcblx0XHRcdHJldHVybiBzZWdtZW50c1tpXS5pc09ydGhvZ29uYWxBcmMoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXREaXN0YW5jZShpLCBqKSB7XG5cdFx0XHRyZXR1cm4gc2VnbWVudHNbaV0uX3BvaW50LmdldERpc3RhbmNlKHNlZ21lbnRzW2pdLl9wb2ludCk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmhhc0hhbmRsZXMoKSAmJiBzZWdtZW50cy5sZW5ndGggPT09IDRcblx0XHRcdFx0JiYgaXNDb2xsaW5lYXIoMCwgMikgJiYgaXNDb2xsaW5lYXIoMSwgMykgJiYgaXNPcnRob2dvbmFsKDEpKSB7XG5cdFx0XHR0eXBlID0gU2hhcGUuUmVjdGFuZ2xlO1xuXHRcdFx0c2l6ZSA9IG5ldyBTaXplKGdldERpc3RhbmNlKDAsIDMpLCBnZXREaXN0YW5jZSgwLCAxKSk7XG5cdFx0XHR0b3BDZW50ZXIgPSBzZWdtZW50c1sxXS5fcG9pbnQuYWRkKHNlZ21lbnRzWzJdLl9wb2ludCkuZGl2aWRlKDIpO1xuXHRcdH0gZWxzZSBpZiAoc2VnbWVudHMubGVuZ3RoID09PSA4ICYmIGlzQXJjKDApICYmIGlzQXJjKDIpICYmIGlzQXJjKDQpXG5cdFx0XHRcdCYmIGlzQXJjKDYpICYmIGlzQ29sbGluZWFyKDEsIDUpICYmIGlzQ29sbGluZWFyKDMsIDcpKSB7XG5cdFx0XHR0eXBlID0gU2hhcGUuUmVjdGFuZ2xlO1xuXHRcdFx0c2l6ZSA9IG5ldyBTaXplKGdldERpc3RhbmNlKDEsIDYpLCBnZXREaXN0YW5jZSgwLCAzKSk7XG5cdFx0XHRyYWRpdXMgPSBzaXplLnN1YnRyYWN0KG5ldyBTaXplKGdldERpc3RhbmNlKDAsIDcpLFxuXHRcdFx0XHRcdGdldERpc3RhbmNlKDEsIDIpKSkuZGl2aWRlKDIpO1xuXHRcdFx0dG9wQ2VudGVyID0gc2VnbWVudHNbM10uX3BvaW50LmFkZChzZWdtZW50c1s0XS5fcG9pbnQpLmRpdmlkZSgyKTtcblx0XHR9IGVsc2UgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gNFxuXHRcdFx0XHQmJiBpc0FyYygwKSAmJiBpc0FyYygxKSAmJiBpc0FyYygyKSAmJiBpc0FyYygzKSkge1xuXHRcdFx0aWYgKE51bWVyaWNhbC5pc1plcm8oZ2V0RGlzdGFuY2UoMCwgMikgLSBnZXREaXN0YW5jZSgxLCAzKSkpIHtcblx0XHRcdFx0dHlwZSA9IFNoYXBlLkNpcmNsZTtcblx0XHRcdFx0cmFkaXVzID0gZ2V0RGlzdGFuY2UoMCwgMikgLyAyO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHlwZSA9IFNoYXBlLkVsbGlwc2U7XG5cdFx0XHRcdHJhZGl1cyA9IG5ldyBTaXplKGdldERpc3RhbmNlKDIsIDApIC8gMiwgZ2V0RGlzdGFuY2UoMywgMSkgLyAyKTtcblx0XHRcdH1cblx0XHRcdHRvcENlbnRlciA9IHNlZ21lbnRzWzFdLl9wb2ludDtcblx0XHR9XG5cblx0XHRpZiAodHlwZSkge1xuXHRcdFx0dmFyIGNlbnRlciA9IHRoaXMuZ2V0UG9zaXRpb24odHJ1ZSksXG5cdFx0XHRcdHNoYXBlID0gdGhpcy5fY2xvbmUobmV3IHR5cGUoe1xuXHRcdFx0XHRcdGNlbnRlcjogY2VudGVyLFxuXHRcdFx0XHRcdHNpemU6IHNpemUsXG5cdFx0XHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRcdFx0aW5zZXJ0OiBmYWxzZVxuXHRcdFx0XHR9KSwgaW5zZXJ0LCBmYWxzZSk7XG5cdFx0XHRzaGFwZS5yb3RhdGUodG9wQ2VudGVyLnN1YnRyYWN0KGNlbnRlcikuZ2V0QW5nbGUoKSArIDkwKTtcblx0XHRcdHJldHVybiBzaGFwZTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0X2hpdFRlc3RTZWxmOiBmdW5jdGlvbihwb2ludCwgb3B0aW9ucykge1xuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdHN0eWxlID0gdGhpcy5nZXRTdHlsZSgpLFxuXHRcdFx0c2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoLFxuXHRcdFx0Y2xvc2VkID0gdGhpcy5fY2xvc2VkLFxuXHRcdFx0dG9sZXJhbmNlUGFkZGluZyA9IG9wdGlvbnMuX3RvbGVyYW5jZVBhZGRpbmcsXG5cdFx0XHRzdHJva2VQYWRkaW5nID0gdG9sZXJhbmNlUGFkZGluZyxcblx0XHRcdGpvaW4sIGNhcCwgbWl0ZXJMaW1pdCxcblx0XHRcdGFyZWEsIGxvYywgcmVzLFxuXHRcdFx0aGl0U3Ryb2tlID0gb3B0aW9ucy5zdHJva2UgJiYgc3R5bGUuaGFzU3Ryb2tlKCksXG5cdFx0XHRoaXRGaWxsID0gb3B0aW9ucy5maWxsICYmIHN0eWxlLmhhc0ZpbGwoKSxcblx0XHRcdGhpdEN1cnZlcyA9IG9wdGlvbnMuY3VydmVzLFxuXHRcdFx0cmFkaXVzID0gaGl0U3Ryb2tlXG5cdFx0XHRcdFx0PyBzdHlsZS5nZXRTdHJva2VXaWR0aCgpIC8gMlxuXHRcdFx0XHRcdDogaGl0RmlsbCAmJiBvcHRpb25zLnRvbGVyYW5jZSA+IDAgfHwgaGl0Q3VydmVzXG5cdFx0XHRcdFx0XHQ/IDAgOiBudWxsO1xuXHRcdGlmIChyYWRpdXMgIT09IG51bGwpIHtcblx0XHRcdGlmIChyYWRpdXMgPiAwKSB7XG5cdFx0XHRcdGpvaW4gPSBzdHlsZS5nZXRTdHJva2VKb2luKCk7XG5cdFx0XHRcdGNhcCA9IHN0eWxlLmdldFN0cm9rZUNhcCgpO1xuXHRcdFx0XHRtaXRlckxpbWl0ID0gcmFkaXVzICogc3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuXHRcdFx0XHRzdHJva2VQYWRkaW5nID0gdG9sZXJhbmNlUGFkZGluZy5hZGQobmV3IFBvaW50KHJhZGl1cywgcmFkaXVzKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqb2luID0gY2FwID0gJ3JvdW5kJztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc0Nsb3NlRW5vdWdoKHB0LCBwYWRkaW5nKSB7XG5cdFx0XHRyZXR1cm4gcG9pbnQuc3VidHJhY3QocHQpLmRpdmlkZShwYWRkaW5nKS5sZW5ndGggPD0gMTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjaGVja1NlZ21lbnRQb2ludChzZWcsIHB0LCBuYW1lKSB7XG5cdFx0XHRpZiAoIW9wdGlvbnMuc2VsZWN0ZWQgfHwgcHQuaXNTZWxlY3RlZCgpKSB7XG5cdFx0XHRcdHZhciBhbmNob3IgPSBzZWcuX3BvaW50O1xuXHRcdFx0XHRpZiAocHQgIT09IGFuY2hvcilcblx0XHRcdFx0XHRwdCA9IHB0LmFkZChhbmNob3IpO1xuXHRcdFx0XHRpZiAoaXNDbG9zZUVub3VnaChwdCwgc3Ryb2tlUGFkZGluZykpIHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IEhpdFJlc3VsdChuYW1lLCB0aGF0LCB7XG5cdFx0XHRcdFx0XHRzZWdtZW50OiBzZWcsXG5cdFx0XHRcdFx0XHRwb2ludDogcHRcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNoZWNrU2VnbWVudFBvaW50cyhzZWcsIGVuZHMpIHtcblx0XHRcdHJldHVybiAoZW5kcyB8fCBvcHRpb25zLnNlZ21lbnRzKVxuXHRcdFx0XHQmJiBjaGVja1NlZ21lbnRQb2ludChzZWcsIHNlZy5fcG9pbnQsICdzZWdtZW50Jylcblx0XHRcdFx0fHwgKCFlbmRzICYmIG9wdGlvbnMuaGFuZGxlcykgJiYgKFxuXHRcdFx0XHRcdGNoZWNrU2VnbWVudFBvaW50KHNlZywgc2VnLl9oYW5kbGVJbiwgJ2hhbmRsZS1pbicpIHx8XG5cdFx0XHRcdFx0Y2hlY2tTZWdtZW50UG9pbnQoc2VnLCBzZWcuX2hhbmRsZU91dCwgJ2hhbmRsZS1vdXQnKSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYWRkVG9BcmVhKHBvaW50KSB7XG5cdFx0XHRhcmVhLmFkZChwb2ludCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2hlY2tTZWdtZW50U3Ryb2tlKHNlZ21lbnQpIHtcblx0XHRcdGlmIChqb2luICE9PSAncm91bmQnIHx8IGNhcCAhPT0gJ3JvdW5kJykge1xuXHRcdFx0XHRhcmVhID0gbmV3IFBhdGgoeyBpbnRlcm5hbDogdHJ1ZSwgY2xvc2VkOiB0cnVlIH0pO1xuXHRcdFx0XHRpZiAoY2xvc2VkIHx8IHNlZ21lbnQuX2luZGV4ID4gMFxuXHRcdFx0XHRcdFx0JiYgc2VnbWVudC5faW5kZXggPCBudW1TZWdtZW50cyAtIDEpIHtcblx0XHRcdFx0XHRpZiAoam9pbiAhPT0gJ3JvdW5kJyAmJiAoc2VnbWVudC5faGFuZGxlSW4uaXNaZXJvKClcblx0XHRcdFx0XHRcdFx0fHwgc2VnbWVudC5faGFuZGxlT3V0LmlzWmVybygpKSlcblx0XHRcdFx0XHRcdFBhdGguX2FkZEJldmVsSm9pbihzZWdtZW50LCBqb2luLCByYWRpdXMsIG1pdGVyTGltaXQsXG5cdFx0XHRcdFx0XHRcdFx0YWRkVG9BcmVhLCB0cnVlKTtcblx0XHRcdFx0fSBlbHNlIGlmIChjYXAgIT09ICdyb3VuZCcpIHtcblx0XHRcdFx0XHRQYXRoLl9hZGRTcXVhcmVDYXAoc2VnbWVudCwgY2FwLCByYWRpdXMsIGFkZFRvQXJlYSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFhcmVhLmlzRW1wdHkoKSkge1xuXHRcdFx0XHRcdHZhciBsb2M7XG5cdFx0XHRcdFx0cmV0dXJuIGFyZWEuY29udGFpbnMocG9pbnQpXG5cdFx0XHRcdFx0XHR8fCAobG9jID0gYXJlYS5nZXROZWFyZXN0TG9jYXRpb24ocG9pbnQpKVxuXHRcdFx0XHRcdFx0XHQmJiBpc0Nsb3NlRW5vdWdoKGxvYy5nZXRQb2ludCgpLCB0b2xlcmFuY2VQYWRkaW5nKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGlzQ2xvc2VFbm91Z2goc2VnbWVudC5fcG9pbnQsIHN0cm9rZVBhZGRpbmcpO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmVuZHMgJiYgIW9wdGlvbnMuc2VnbWVudHMgJiYgIWNsb3NlZCkge1xuXHRcdFx0aWYgKHJlcyA9IGNoZWNrU2VnbWVudFBvaW50cyhzZWdtZW50c1swXSwgdHJ1ZSlcblx0XHRcdFx0XHR8fCBjaGVja1NlZ21lbnRQb2ludHMoc2VnbWVudHNbbnVtU2VnbWVudHMgLSAxXSwgdHJ1ZSkpXG5cdFx0XHRcdHJldHVybiByZXM7XG5cdFx0fSBlbHNlIGlmIChvcHRpb25zLnNlZ21lbnRzIHx8IG9wdGlvbnMuaGFuZGxlcykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKVxuXHRcdFx0XHRpZiAocmVzID0gY2hlY2tTZWdtZW50UG9pbnRzKHNlZ21lbnRzW2ldKSlcblx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH1cblx0XHRpZiAocmFkaXVzICE9PSBudWxsKSB7XG5cdFx0XHRsb2MgPSB0aGlzLmdldE5lYXJlc3RMb2NhdGlvbihwb2ludCk7XG5cdFx0XHRpZiAobG9jKSB7XG5cdFx0XHRcdHZhciBwYXJhbWV0ZXIgPSBsb2MuZ2V0UGFyYW1ldGVyKCk7XG5cdFx0XHRcdGlmIChwYXJhbWV0ZXIgPT09IDAgfHwgcGFyYW1ldGVyID09PSAxICYmIG51bVNlZ21lbnRzID4gMSkge1xuXHRcdFx0XHRcdGlmICghY2hlY2tTZWdtZW50U3Ryb2tlKGxvYy5nZXRTZWdtZW50KCkpKVxuXHRcdFx0XHRcdFx0bG9jID0gbnVsbDtcblx0XHRcdFx0fSBlbHNlIGlmICghaXNDbG9zZUVub3VnaChsb2MuZ2V0UG9pbnQoKSwgc3Ryb2tlUGFkZGluZykpIHtcblx0XHRcdFx0XHRsb2MgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWxvYyAmJiBqb2luID09PSAnbWl0ZXInICYmIG51bVNlZ21lbnRzID4gMSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuXHRcdFx0XHRcdGlmIChwb2ludC5nZXREaXN0YW5jZShzZWdtZW50Ll9wb2ludCkgPD0gbWl0ZXJMaW1pdFxuXHRcdFx0XHRcdFx0XHQmJiBjaGVja1NlZ21lbnRTdHJva2Uoc2VnbWVudCkpIHtcblx0XHRcdFx0XHRcdGxvYyA9IHNlZ21lbnQuZ2V0TG9jYXRpb24oKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gIWxvYyAmJiBoaXRGaWxsICYmIHRoaXMuX2NvbnRhaW5zKHBvaW50KVxuXHRcdFx0XHR8fCBsb2MgJiYgIWhpdFN0cm9rZSAmJiAhaGl0Q3VydmVzXG5cdFx0XHRcdFx0PyBuZXcgSGl0UmVzdWx0KCdmaWxsJywgdGhpcylcblx0XHRcdFx0XHQ6IGxvY1xuXHRcdFx0XHRcdFx0PyBuZXcgSGl0UmVzdWx0KGhpdFN0cm9rZSA/ICdzdHJva2UnIDogJ2N1cnZlJywgdGhpcywge1xuXHRcdFx0XHRcdFx0XHRsb2NhdGlvbjogbG9jLFxuXHRcdFx0XHRcdFx0XHRwb2ludDogbG9jLmdldFBvaW50KClcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHQ6IG51bGw7XG5cdH1cblxufSwgQmFzZS5lYWNoKEN1cnZlLmV2YWx1YXRlTWV0aG9kcyxcblx0ZnVuY3Rpb24obmFtZSkge1xuXHRcdHRoaXNbbmFtZSArICdBdCddID0gZnVuY3Rpb24ob2Zmc2V0LCBpc1BhcmFtZXRlcikge1xuXHRcdFx0dmFyIGxvYyA9IHRoaXMuZ2V0TG9jYXRpb25BdChvZmZzZXQsIGlzUGFyYW1ldGVyKTtcblx0XHRcdHJldHVybiBsb2MgJiYgbG9jW25hbWVdKCk7XG5cdFx0fTtcblx0fSxcbntcblx0YmVhbnM6IGZhbHNlLFxuXG5cdF9nZXRPZmZzZXQ6IGZ1bmN0aW9uKGxvY2F0aW9uKSB7XG5cdFx0dmFyIGluZGV4ID0gbG9jYXRpb24gJiYgbG9jYXRpb24uZ2V0SW5kZXgoKTtcblx0XHRpZiAoaW5kZXggIT0gbnVsbCkge1xuXHRcdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCksXG5cdFx0XHRcdG9mZnNldCA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGluZGV4OyBpKyspXG5cdFx0XHRcdG9mZnNldCArPSBjdXJ2ZXNbaV0uZ2V0TGVuZ3RoKCk7XG5cdFx0XHR2YXIgY3VydmUgPSBjdXJ2ZXNbaW5kZXhdLFxuXHRcdFx0XHRwYXJhbWV0ZXIgPSBsb2NhdGlvbi5nZXRQYXJhbWV0ZXIoKTtcblx0XHRcdGlmIChwYXJhbWV0ZXIgPiAwKVxuXHRcdFx0XHRvZmZzZXQgKz0gY3VydmUuZ2V0UGFydExlbmd0aCgwLCBwYXJhbWV0ZXIpO1xuXHRcdFx0cmV0dXJuIG9mZnNldDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0TG9jYXRpb25PZjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBsb2MgPSBjdXJ2ZXNbaV0uZ2V0TG9jYXRpb25PZihwb2ludCk7XG5cdFx0XHRpZiAobG9jKVxuXHRcdFx0XHRyZXR1cm4gbG9jO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRnZXRPZmZzZXRPZjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxvYyA9IHRoaXMuZ2V0TG9jYXRpb25PZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBsb2MgPyBsb2MuZ2V0T2Zmc2V0KCkgOiBudWxsO1xuXHR9LFxuXG5cdGdldExvY2F0aW9uQXQ6IGZ1bmN0aW9uKG9mZnNldCwgaXNQYXJhbWV0ZXIpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKSxcblx0XHRcdGxlbmd0aCA9IDA7XG5cdFx0aWYgKGlzUGFyYW1ldGVyKSB7XG5cdFx0XHR2YXIgaW5kZXggPSB+fm9mZnNldCxcblx0XHRcdFx0Y3VydmUgPSBjdXJ2ZXNbaW5kZXhdO1xuXHRcdFx0cmV0dXJuIGN1cnZlID8gY3VydmUuZ2V0TG9jYXRpb25BdChvZmZzZXQgLSBpbmRleCwgdHJ1ZSkgOiBudWxsO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBzdGFydCA9IGxlbmd0aCxcblx0XHRcdFx0Y3VydmUgPSBjdXJ2ZXNbaV07XG5cdFx0XHRsZW5ndGggKz0gY3VydmUuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRpZiAobGVuZ3RoID4gb2Zmc2V0KSB7XG5cdFx0XHRcdHJldHVybiBjdXJ2ZS5nZXRMb2NhdGlvbkF0KG9mZnNldCAtIHN0YXJ0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG9mZnNldCA8PSB0aGlzLmdldExlbmd0aCgpKVxuXHRcdFx0cmV0dXJuIG5ldyBDdXJ2ZUxvY2F0aW9uKGN1cnZlc1tjdXJ2ZXMubGVuZ3RoIC0gMV0sIDEpO1xuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdGdldE5lYXJlc3RMb2NhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKSxcblx0XHRcdG1pbkRpc3QgPSBJbmZpbml0eSxcblx0XHRcdG1pbkxvYyA9IG51bGw7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgbG9jID0gY3VydmVzW2ldLmdldE5lYXJlc3RMb2NhdGlvbihwb2ludCk7XG5cdFx0XHRpZiAobG9jLl9kaXN0YW5jZSA8IG1pbkRpc3QpIHtcblx0XHRcdFx0bWluRGlzdCA9IGxvYy5fZGlzdGFuY2U7XG5cdFx0XHRcdG1pbkxvYyA9IGxvYztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1pbkxvYztcblx0fSxcblxuXHRnZXROZWFyZXN0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldE5lYXJlc3RMb2NhdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpLmdldFBvaW50KCk7XG5cdH1cbn0pLCBuZXcgZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gZHJhd0hhbmRsZXMoY3R4LCBzZWdtZW50cywgbWF0cml4LCBzaXplKSB7XG5cdFx0dmFyIGhhbGYgPSBzaXplIC8gMjtcblxuXHRcdGZ1bmN0aW9uIGRyYXdIYW5kbGUoaW5kZXgpIHtcblx0XHRcdHZhciBoWCA9IGNvb3Jkc1tpbmRleF0sXG5cdFx0XHRcdGhZID0gY29vcmRzW2luZGV4ICsgMV07XG5cdFx0XHRpZiAocFggIT0gaFggfHwgcFkgIT0gaFkpIHtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRjdHgubW92ZVRvKHBYLCBwWSk7XG5cdFx0XHRcdGN0eC5saW5lVG8oaFgsIGhZKTtcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdGN0eC5hcmMoaFgsIGhZLCBoYWxmLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG5cdFx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGNvb3JkcyA9IG5ldyBBcnJheSg2KTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcblx0XHRcdHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzLCBmYWxzZSk7XG5cdFx0XHR2YXIgc3RhdGUgPSBzZWdtZW50Ll9zZWxlY3Rpb25TdGF0ZSxcblx0XHRcdFx0cFggPSBjb29yZHNbMF0sXG5cdFx0XHRcdHBZID0gY29vcmRzWzFdO1xuXHRcdFx0aWYgKHN0YXRlICYgMSlcblx0XHRcdFx0ZHJhd0hhbmRsZSgyKTtcblx0XHRcdGlmIChzdGF0ZSAmIDIpXG5cdFx0XHRcdGRyYXdIYW5kbGUoNCk7XG5cdFx0XHRjdHguZmlsbFJlY3QocFggLSBoYWxmLCBwWSAtIGhhbGYsIHNpemUsIHNpemUpO1xuXHRcdFx0aWYgKCEoc3RhdGUgJiA0KSkge1xuXHRcdFx0XHR2YXIgZmlsbFN0eWxlID0gY3R4LmZpbGxTdHlsZTtcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9ICcjZmZmZmZmJztcblx0XHRcdFx0Y3R4LmZpbGxSZWN0KHBYIC0gaGFsZiArIDEsIHBZIC0gaGFsZiArIDEsIHNpemUgLSAyLCBzaXplIC0gMik7XG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZHJhd1NlZ21lbnRzKGN0eCwgcGF0aCwgbWF0cml4KSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gcGF0aC5fc2VnbWVudHMsXG5cdFx0XHRsZW5ndGggPSBzZWdtZW50cy5sZW5ndGgsXG5cdFx0XHRjb29yZHMgPSBuZXcgQXJyYXkoNiksXG5cdFx0XHRmaXJzdCA9IHRydWUsXG5cdFx0XHRjdXJYLCBjdXJZLFxuXHRcdFx0cHJldlgsIHByZXZZLFxuXHRcdFx0aW5YLCBpblksXG5cdFx0XHRvdXRYLCBvdXRZO1xuXG5cdFx0ZnVuY3Rpb24gZHJhd1NlZ21lbnQoc2VnbWVudCkge1xuXHRcdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0XHRzZWdtZW50Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIGNvb3JkcywgZmFsc2UpO1xuXHRcdFx0XHRjdXJYID0gY29vcmRzWzBdO1xuXHRcdFx0XHRjdXJZID0gY29vcmRzWzFdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHBvaW50ID0gc2VnbWVudC5fcG9pbnQ7XG5cdFx0XHRcdGN1clggPSBwb2ludC5feDtcblx0XHRcdFx0Y3VyWSA9IHBvaW50Ll95O1xuXHRcdFx0fVxuXHRcdFx0aWYgKGZpcnN0KSB7XG5cdFx0XHRcdGN0eC5tb3ZlVG8oY3VyWCwgY3VyWSk7XG5cdFx0XHRcdGZpcnN0ID0gZmFsc2U7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAobWF0cml4KSB7XG5cdFx0XHRcdFx0aW5YID0gY29vcmRzWzJdO1xuXHRcdFx0XHRcdGluWSA9IGNvb3Jkc1szXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgaGFuZGxlID0gc2VnbWVudC5faGFuZGxlSW47XG5cdFx0XHRcdFx0aW5YID0gY3VyWCArIGhhbmRsZS5feDtcblx0XHRcdFx0XHRpblkgPSBjdXJZICsgaGFuZGxlLl95O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpblggPT09IGN1clggJiYgaW5ZID09PSBjdXJZXG5cdFx0XHRcdFx0XHQmJiBvdXRYID09PSBwcmV2WCAmJiBvdXRZID09PSBwcmV2WSkge1xuXHRcdFx0XHRcdGN0eC5saW5lVG8oY3VyWCwgY3VyWSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y3R4LmJlemllckN1cnZlVG8ob3V0WCwgb3V0WSwgaW5YLCBpblksIGN1clgsIGN1clkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRwcmV2WCA9IGN1clg7XG5cdFx0XHRwcmV2WSA9IGN1clk7XG5cdFx0XHRpZiAobWF0cml4KSB7XG5cdFx0XHRcdG91dFggPSBjb29yZHNbNF07XG5cdFx0XHRcdG91dFkgPSBjb29yZHNbNV07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgaGFuZGxlID0gc2VnbWVudC5faGFuZGxlT3V0O1xuXHRcdFx0XHRvdXRYID0gcHJldlggKyBoYW5kbGUuX3g7XG5cdFx0XHRcdG91dFkgPSBwcmV2WSArIGhhbmRsZS5feTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuXHRcdFx0ZHJhd1NlZ21lbnQoc2VnbWVudHNbaV0pO1xuXHRcdGlmIChwYXRoLl9jbG9zZWQgJiYgbGVuZ3RoID4gMClcblx0XHRcdGRyYXdTZWdtZW50KHNlZ21lbnRzWzBdKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0X2RyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0sIHN0cm9rZU1hdHJpeCkge1xuXHRcdFx0dmFyIGRvbnRTdGFydCA9IHBhcmFtLmRvbnRTdGFydCxcblx0XHRcdFx0ZG9udFBhaW50ID0gcGFyYW0uZG9udEZpbmlzaCB8fCBwYXJhbS5jbGlwLFxuXHRcdFx0XHRzdHlsZSA9IHRoaXMuZ2V0U3R5bGUoKSxcblx0XHRcdFx0aGFzRmlsbCA9IHN0eWxlLmhhc0ZpbGwoKSxcblx0XHRcdFx0aGFzU3Ryb2tlID0gc3R5bGUuaGFzU3Ryb2tlKCksXG5cdFx0XHRcdGRhc2hBcnJheSA9IHN0eWxlLmdldERhc2hBcnJheSgpLFxuXHRcdFx0XHRkYXNoTGVuZ3RoID0gIXBhcGVyLnN1cHBvcnQubmF0aXZlRGFzaCAmJiBoYXNTdHJva2Vcblx0XHRcdFx0XHRcdCYmIGRhc2hBcnJheSAmJiBkYXNoQXJyYXkubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIWRvbnRTdGFydClcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdFx0XHRpZiAoIWRvbnRTdGFydCAmJiB0aGlzLl9jdXJyZW50UGF0aCkge1xuXHRcdFx0XHRjdHguY3VycmVudFBhdGggPSB0aGlzLl9jdXJyZW50UGF0aDtcblx0XHRcdH0gZWxzZSBpZiAoaGFzRmlsbCB8fCBoYXNTdHJva2UgJiYgIWRhc2hMZW5ndGggfHwgZG9udFBhaW50KSB7XG5cdFx0XHRcdGRyYXdTZWdtZW50cyhjdHgsIHRoaXMsIHN0cm9rZU1hdHJpeCk7XG5cdFx0XHRcdGlmICh0aGlzLl9jbG9zZWQpXG5cdFx0XHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0XHRpZiAoIWRvbnRTdGFydClcblx0XHRcdFx0XHR0aGlzLl9jdXJyZW50UGF0aCA9IGN0eC5jdXJyZW50UGF0aDtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZ2V0T2Zmc2V0KGkpIHtcblx0XHRcdFx0cmV0dXJuIGRhc2hBcnJheVsoKGkgJSBkYXNoTGVuZ3RoKSArIGRhc2hMZW5ndGgpICUgZGFzaExlbmd0aF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICghZG9udFBhaW50ICYmIChoYXNGaWxsIHx8IGhhc1N0cm9rZSkpIHtcblx0XHRcdFx0dGhpcy5fc2V0U3R5bGVzKGN0eCk7XG5cdFx0XHRcdGlmIChoYXNGaWxsKSB7XG5cdFx0XHRcdFx0Y3R4LmZpbGwoc3R5bGUuZ2V0V2luZGluZ1J1bGUoKSk7XG5cdFx0XHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChoYXNTdHJva2UpIHtcblx0XHRcdFx0XHRpZiAoZGFzaExlbmd0aCkge1xuXHRcdFx0XHRcdFx0aWYgKCFkb250U3RhcnQpXG5cdFx0XHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0XHRcdHZhciBpdGVyYXRvciA9IG5ldyBQYXRoSXRlcmF0b3IodGhpcywgMzIsIDAuMjUsXG5cdFx0XHRcdFx0XHRcdFx0c3Ryb2tlTWF0cml4KSxcblx0XHRcdFx0XHRcdFx0bGVuZ3RoID0gaXRlcmF0b3IubGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHRmcm9tID0gLXN0eWxlLmdldERhc2hPZmZzZXQoKSwgdG8sXG5cdFx0XHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdFx0ZnJvbSA9IGZyb20gJSBsZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoZnJvbSA+IDApIHtcblx0XHRcdFx0XHRcdFx0ZnJvbSAtPSBnZXRPZmZzZXQoaS0tKSArIGdldE9mZnNldChpLS0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0d2hpbGUgKGZyb20gPCBsZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0dG8gPSBmcm9tICsgZ2V0T2Zmc2V0KGkrKyk7XG5cdFx0XHRcdFx0XHRcdGlmIChmcm9tID4gMCB8fCB0byA+IDApXG5cdFx0XHRcdFx0XHRcdFx0aXRlcmF0b3IuZHJhd1BhcnQoY3R4LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRNYXRoLm1heChmcm9tLCAwKSwgTWF0aC5tYXgodG8sIDApKTtcblx0XHRcdFx0XHRcdFx0ZnJvbSA9IHRvICsgZ2V0T2Zmc2V0KGkrKyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfZHJhd1NlbGVjdGVkOiBmdW5jdGlvbihjdHgsIG1hdHJpeCkge1xuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0ZHJhd1NlZ21lbnRzKGN0eCwgdGhpcywgbWF0cml4KTtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdGRyYXdIYW5kbGVzKGN0eCwgdGhpcy5fc2VnbWVudHMsIG1hdHJpeCwgcGFwZXIuc2V0dGluZ3MuaGFuZGxlU2l6ZSk7XG5cdFx0fVxuXHR9O1xufSwgbmV3IGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIGdldEZpcnN0Q29udHJvbFBvaW50cyhyaHMpIHtcblx0XHR2YXIgbiA9IHJocy5sZW5ndGgsXG5cdFx0XHR4ID0gW10sXG5cdFx0XHR0bXAgPSBbXSxcblx0XHRcdGIgPSAyO1xuXHRcdHhbMF0gPSByaHNbMF0gLyBiO1xuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHR0bXBbaV0gPSAxIC8gYjtcblx0XHRcdGIgPSAoaSA8IG4gLSAxID8gNCA6IDIpIC0gdG1wW2ldO1xuXHRcdFx0eFtpXSA9IChyaHNbaV0gLSB4W2kgLSAxXSkgLyBiO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMTsgaSA8IG47IGkrKykge1xuXHRcdFx0eFtuIC0gaSAtIDFdIC09IHRtcFtuIC0gaV0gKiB4W24gLSBpXTtcblx0XHR9XG5cdFx0cmV0dXJuIHg7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHNtb290aDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdFx0c2l6ZSA9IHNlZ21lbnRzLmxlbmd0aCxcblx0XHRcdFx0Y2xvc2VkID0gdGhpcy5fY2xvc2VkLFxuXHRcdFx0XHRuID0gc2l6ZSxcblx0XHRcdFx0b3ZlcmxhcCA9IDA7XG5cdFx0XHRpZiAoc2l6ZSA8PSAyKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdG92ZXJsYXAgPSBNYXRoLm1pbihzaXplLCA0KTtcblx0XHRcdFx0biArPSBNYXRoLm1pbihzaXplLCBvdmVybGFwKSAqIDI7XG5cdFx0XHR9XG5cdFx0XHR2YXIga25vdHMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKVxuXHRcdFx0XHRrbm90c1tpICsgb3ZlcmxhcF0gPSBzZWdtZW50c1tpXS5fcG9pbnQ7XG5cdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb3ZlcmxhcDsgaSsrKSB7XG5cdFx0XHRcdFx0a25vdHNbaV0gPSBzZWdtZW50c1tpICsgc2l6ZSAtIG92ZXJsYXBdLl9wb2ludDtcblx0XHRcdFx0XHRrbm90c1tpICsgc2l6ZSArIG92ZXJsYXBdID0gc2VnbWVudHNbaV0uX3BvaW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuLS07XG5cdFx0XHR9XG5cdFx0XHR2YXIgcmhzID0gW107XG5cblx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgbiAtIDE7IGkrKylcblx0XHRcdFx0cmhzW2ldID0gNCAqIGtub3RzW2ldLl94ICsgMiAqIGtub3RzW2kgKyAxXS5feDtcblx0XHRcdHJoc1swXSA9IGtub3RzWzBdLl94ICsgMiAqIGtub3RzWzFdLl94O1xuXHRcdFx0cmhzW24gLSAxXSA9IDMgKiBrbm90c1tuIC0gMV0uX3g7XG5cdFx0XHR2YXIgeCA9IGdldEZpcnN0Q29udHJvbFBvaW50cyhyaHMpO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMTsgaSA8IG4gLSAxOyBpKyspXG5cdFx0XHRcdHJoc1tpXSA9IDQgKiBrbm90c1tpXS5feSArIDIgKiBrbm90c1tpICsgMV0uX3k7XG5cdFx0XHRyaHNbMF0gPSBrbm90c1swXS5feSArIDIgKiBrbm90c1sxXS5feTtcblx0XHRcdHJoc1tuIC0gMV0gPSAzICoga25vdHNbbiAtIDFdLl95O1xuXHRcdFx0dmFyIHkgPSBnZXRGaXJzdENvbnRyb2xQb2ludHMocmhzKTtcblxuXHRcdFx0aWYgKGNsb3NlZCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgaiA9IHNpemU7IGkgPCBvdmVybGFwOyBpKyssIGorKykge1xuXHRcdFx0XHRcdHZhciBmMSA9IGkgLyBvdmVybGFwLFxuXHRcdFx0XHRcdFx0ZjIgPSAxIC0gZjEsXG5cdFx0XHRcdFx0XHRpZSA9IGkgKyBvdmVybGFwLFxuXHRcdFx0XHRcdFx0amUgPSBqICsgb3ZlcmxhcDtcblx0XHRcdFx0XHR4W2pdID0geFtpXSAqIGYxICsgeFtqXSAqIGYyO1xuXHRcdFx0XHRcdHlbal0gPSB5W2ldICogZjEgKyB5W2pdICogZjI7XG5cdFx0XHRcdFx0eFtqZV0gPSB4W2llXSAqIGYyICsgeFtqZV0gKiBmMTtcblx0XHRcdFx0XHR5W2plXSA9IHlbaWVdICogZjIgKyB5W2plXSAqIGYxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG4tLTtcblx0XHRcdH1cblx0XHRcdHZhciBoYW5kbGVJbiA9IG51bGw7XG5cdFx0XHRmb3IgKHZhciBpID0gb3ZlcmxhcDsgaSA8PSBuIC0gb3ZlcmxhcDsgaSsrKSB7XG5cdFx0XHRcdHZhciBzZWdtZW50ID0gc2VnbWVudHNbaSAtIG92ZXJsYXBdO1xuXHRcdFx0XHRpZiAoaGFuZGxlSW4pXG5cdFx0XHRcdFx0c2VnbWVudC5zZXRIYW5kbGVJbihoYW5kbGVJbi5zdWJ0cmFjdChzZWdtZW50Ll9wb2ludCkpO1xuXHRcdFx0XHRpZiAoaSA8IG4pIHtcblx0XHRcdFx0XHRzZWdtZW50LnNldEhhbmRsZU91dChcblx0XHRcdFx0XHRcdFx0bmV3IFBvaW50KHhbaV0sIHlbaV0pLnN1YnRyYWN0KHNlZ21lbnQuX3BvaW50KSk7XG5cdFx0XHRcdFx0aGFuZGxlSW4gPSBpIDwgbiAtIDFcblx0XHRcdFx0XHRcdFx0PyBuZXcgUG9pbnQoXG5cdFx0XHRcdFx0XHRcdFx0MiAqIGtub3RzW2kgKyAxXS5feCAtIHhbaSArIDFdLFxuXHRcdFx0XHRcdFx0XHRcdDIgKiBrbm90c1tpICsgMV0uX3kgLSB5W2kgKyAxXSlcblx0XHRcdFx0XHRcdFx0OiBuZXcgUG9pbnQoXG5cdFx0XHRcdFx0XHRcdFx0KGtub3RzW25dLl94ICsgeFtuIC0gMV0pIC8gMixcblx0XHRcdFx0XHRcdFx0XHQoa25vdHNbbl0uX3kgKyB5W24gLSAxXSkgLyAyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGNsb3NlZCAmJiBoYW5kbGVJbikge1xuXHRcdFx0XHR2YXIgc2VnbWVudCA9IHRoaXMuX3NlZ21lbnRzWzBdO1xuXHRcdFx0XHRzZWdtZW50LnNldEhhbmRsZUluKGhhbmRsZUluLnN1YnRyYWN0KHNlZ21lbnQuX3BvaW50KSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufSwgbmV3IGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBnZXRDdXJyZW50U2VnbWVudCh0aGF0KSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhhdC5fc2VnbWVudHM7XG5cdFx0aWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMClcblx0XHRcdHRocm93IG5ldyBFcnJvcignVXNlIGEgbW92ZVRvKCkgY29tbWFuZCBmaXJzdCcpO1xuXHRcdHJldHVybiBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0bW92ZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzO1xuXHRcdFx0aWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMSlcblx0XHRcdFx0dGhpcy5yZW1vdmVTZWdtZW50KDApO1xuXHRcdFx0aWYgKCFzZWdtZW50cy5sZW5ndGgpXG5cdFx0XHRcdHRoaXMuX2FkZChbIG5ldyBTZWdtZW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSkgXSk7XG5cdFx0fSxcblxuXHRcdG1vdmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ21vdmVCeSgpIGlzIHVuc3VwcG9ydGVkIG9uIFBhdGggaXRlbXMuJyk7XG5cdFx0fSxcblxuXHRcdGxpbmVUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9hZGQoWyBuZXcgU2VnbWVudChQb2ludC5yZWFkKGFyZ3VtZW50cykpIF0pO1xuXHRcdH0sXG5cblx0XHRjdWJpY0N1cnZlVG86IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGhhbmRsZTEgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGhhbmRsZTIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcyk7XG5cdFx0XHRjdXJyZW50LnNldEhhbmRsZU91dChoYW5kbGUxLnN1YnRyYWN0KGN1cnJlbnQuX3BvaW50KSk7XG5cdFx0XHR0aGlzLl9hZGQoWyBuZXcgU2VnbWVudCh0bywgaGFuZGxlMi5zdWJ0cmFjdCh0bykpIF0pO1xuXHRcdH0sXG5cblx0XHRxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBoYW5kbGUgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXHRcdFx0dGhpcy5jdWJpY0N1cnZlVG8oXG5cdFx0XHRcdGhhbmRsZS5hZGQoY3VycmVudC5zdWJ0cmFjdChoYW5kbGUpLm11bHRpcGx5KDEgLyAzKSksXG5cdFx0XHRcdGhhbmRsZS5hZGQodG8uc3VidHJhY3QoaGFuZGxlKS5tdWx0aXBseSgxIC8gMykpLFxuXHRcdFx0XHR0b1xuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0Y3VydmVUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGhyb3VnaCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHQgPSBCYXNlLnBpY2soQmFzZS5yZWFkKGFyZ3VtZW50cyksIDAuNSksXG5cdFx0XHRcdHQxID0gMSAtIHQsXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQsXG5cdFx0XHRcdGhhbmRsZSA9IHRocm91Z2guc3VidHJhY3QoY3VycmVudC5tdWx0aXBseSh0MSAqIHQxKSlcblx0XHRcdFx0XHQuc3VidHJhY3QodG8ubXVsdGlwbHkodCAqIHQpKS5kaXZpZGUoMiAqIHQgKiB0MSk7XG5cdFx0XHRpZiAoaGFuZGxlLmlzTmFOKCkpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHQnQ2Fubm90IHB1dCBhIGN1cnZlIHRocm91Z2ggcG9pbnRzIHdpdGggcGFyYW1ldGVyID0gJyArIHQpO1xuXHRcdFx0dGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKGhhbmRsZSwgdG8pO1xuXHRcdH0sXG5cblx0XHRhcmNUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLFxuXHRcdFx0XHRmcm9tID0gY3VycmVudC5fcG9pbnQsXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHR0aHJvdWdoLFxuXHRcdFx0XHRwZWVrID0gQmFzZS5wZWVrKGFyZ3VtZW50cyksXG5cdFx0XHRcdGNsb2Nrd2lzZSA9IEJhc2UucGljayhwZWVrLCB0cnVlKSxcblx0XHRcdFx0Y2VudGVyLCBleHRlbnQsIHZlY3RvciwgbWF0cml4O1xuXHRcdFx0aWYgKHR5cGVvZiBjbG9ja3dpc2UgPT09ICdib29sZWFuJykge1xuXHRcdFx0XHR2YXIgbWlkZGxlID0gZnJvbS5hZGQodG8pLmRpdmlkZSgyKSxcblx0XHRcdFx0dGhyb3VnaCA9IG1pZGRsZS5hZGQobWlkZGxlLnN1YnRyYWN0KGZyb20pLnJvdGF0ZShcblx0XHRcdFx0XHRcdGNsb2Nrd2lzZSA/IC05MCA6IDkwKSk7XG5cdFx0XHR9IGVsc2UgaWYgKEJhc2UucmVtYWluKGFyZ3VtZW50cykgPD0gMikge1xuXHRcdFx0XHR0aHJvdWdoID0gdG87XG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHJhZGl1cyA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0XHRpZiAocmFkaXVzLmlzWmVybygpKVxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmxpbmVUbyh0byk7XG5cdFx0XHRcdHZhciByb3RhdGlvbiA9IEJhc2UucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRcdGNsb2Nrd2lzZSA9ICEhQmFzZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdFx0bGFyZ2UgPSAhIUJhc2UucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRcdG1pZGRsZSA9IGZyb20uYWRkKHRvKS5kaXZpZGUoMiksXG5cdFx0XHRcdFx0cHQgPSBmcm9tLnN1YnRyYWN0KG1pZGRsZSkucm90YXRlKC1yb3RhdGlvbiksXG5cdFx0XHRcdFx0eCA9IHB0LngsXG5cdFx0XHRcdFx0eSA9IHB0LnksXG5cdFx0XHRcdFx0YWJzID0gTWF0aC5hYnMsXG5cdFx0XHRcdFx0ZXBzaWxvbiA9IDFlLTEyLFxuXHRcdFx0XHRcdHJ4ID0gYWJzKHJhZGl1cy53aWR0aCksXG5cdFx0XHRcdFx0cnkgPSBhYnMocmFkaXVzLmhlaWdodCksXG5cdFx0XHRcdFx0cnhTcSA9IHJ4ICogcngsXG5cdFx0XHRcdFx0cnlTcSA9IHJ5ICogcnksXG5cdFx0XHRcdFx0eFNxID0gIHggKiB4LFxuXHRcdFx0XHRcdHlTcSA9ICB5ICogeTtcblx0XHRcdFx0dmFyIGZhY3RvciA9IE1hdGguc3FydCh4U3EgLyByeFNxICsgeVNxIC8gcnlTcSk7XG5cdFx0XHRcdGlmIChmYWN0b3IgPiAxKSB7XG5cdFx0XHRcdFx0cnggKj0gZmFjdG9yO1xuXHRcdFx0XHRcdHJ5ICo9IGZhY3Rvcjtcblx0XHRcdFx0XHRyeFNxID0gcnggKiByeDtcblx0XHRcdFx0XHRyeVNxID0gcnkgKiByeTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmYWN0b3IgPSAocnhTcSAqIHJ5U3EgLSByeFNxICogeVNxIC0gcnlTcSAqIHhTcSkgL1xuXHRcdFx0XHRcdFx0KHJ4U3EgKiB5U3EgKyByeVNxICogeFNxKTtcblx0XHRcdFx0aWYgKGFicyhmYWN0b3IpIDwgZXBzaWxvbilcblx0XHRcdFx0XHRmYWN0b3IgPSAwO1xuXHRcdFx0XHRpZiAoZmFjdG9yIDwgMClcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0XHRcdCdDYW5ub3QgY3JlYXRlIGFuIGFyYyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHMnKTtcblx0XHRcdFx0Y2VudGVyID0gbmV3IFBvaW50KHJ4ICogeSAvIHJ5LCAtcnkgKiB4IC8gcngpXG5cdFx0XHRcdFx0XHQubXVsdGlwbHkoKGxhcmdlID09PSBjbG9ja3dpc2UgPyAtMSA6IDEpXG5cdFx0XHRcdFx0XHRcdCogTWF0aC5zcXJ0KGZhY3RvcikpXG5cdFx0XHRcdFx0XHQucm90YXRlKHJvdGF0aW9uKS5hZGQobWlkZGxlKTtcblx0XHRcdFx0bWF0cml4ID0gbmV3IE1hdHJpeCgpLnRyYW5zbGF0ZShjZW50ZXIpLnJvdGF0ZShyb3RhdGlvbilcblx0XHRcdFx0XHRcdC5zY2FsZShyeCwgcnkpO1xuXHRcdFx0XHR2ZWN0b3IgPSBtYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0oZnJvbSk7XG5cdFx0XHRcdGV4dGVudCA9IHZlY3Rvci5nZXREaXJlY3RlZEFuZ2xlKG1hdHJpeC5faW52ZXJzZVRyYW5zZm9ybSh0bykpO1xuXHRcdFx0XHRpZiAoIWNsb2Nrd2lzZSAmJiBleHRlbnQgPiAwKVxuXHRcdFx0XHRcdGV4dGVudCAtPSAzNjA7XG5cdFx0XHRcdGVsc2UgaWYgKGNsb2Nrd2lzZSAmJiBleHRlbnQgPCAwKVxuXHRcdFx0XHRcdGV4dGVudCArPSAzNjA7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhyb3VnaCkge1xuXHRcdFx0XHR2YXIgbDEgPSBuZXcgTGluZShmcm9tLmFkZCh0aHJvdWdoKS5kaXZpZGUoMiksXG5cdFx0XHRcdFx0XHRcdHRocm91Z2guc3VidHJhY3QoZnJvbSkucm90YXRlKDkwKSwgdHJ1ZSksXG5cdFx0XHRcdFx0bDIgPSBuZXcgTGluZSh0aHJvdWdoLmFkZCh0bykuZGl2aWRlKDIpLFxuXHRcdFx0XHRcdFx0XHR0by5zdWJ0cmFjdCh0aHJvdWdoKS5yb3RhdGUoOTApLCB0cnVlKSxcblx0XHRcdFx0XHRsaW5lID0gbmV3IExpbmUoZnJvbSwgdG8pLFxuXHRcdFx0XHRcdHRocm91Z2hTaWRlID0gbGluZS5nZXRTaWRlKHRocm91Z2gpO1xuXHRcdFx0XHRjZW50ZXIgPSBsMS5pbnRlcnNlY3QobDIsIHRydWUpO1xuXHRcdFx0XHRpZiAoIWNlbnRlcikge1xuXHRcdFx0XHRcdGlmICghdGhyb3VnaFNpZGUpXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5saW5lVG8odG8pO1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdFx0J0Nhbm5vdCBjcmVhdGUgYW4gYXJjIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50cycpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZlY3RvciA9IGZyb20uc3VidHJhY3QoY2VudGVyKTtcblx0XHRcdFx0ZXh0ZW50ID0gdmVjdG9yLmdldERpcmVjdGVkQW5nbGUodG8uc3VidHJhY3QoY2VudGVyKSk7XG5cdFx0XHRcdHZhciBjZW50ZXJTaWRlID0gbGluZS5nZXRTaWRlKGNlbnRlcik7XG5cdFx0XHRcdGlmIChjZW50ZXJTaWRlID09PSAwKSB7XG5cdFx0XHRcdFx0ZXh0ZW50ID0gdGhyb3VnaFNpZGUgKiBNYXRoLmFicyhleHRlbnQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRocm91Z2hTaWRlID09PSBjZW50ZXJTaWRlKSB7XG5cdFx0XHRcdFx0ZXh0ZW50ICs9IGV4dGVudCA8IDAgPyAzNjAgOiAtMzYwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR2YXIgZXh0ID0gTWF0aC5hYnMoZXh0ZW50KSxcblx0XHRcdFx0Y291bnQgPSBleHQgPj0gMzYwID8gNCA6IE1hdGguY2VpbChleHQgLyA5MCksXG5cdFx0XHRcdGluYyA9IGV4dGVudCAvIGNvdW50LFxuXHRcdFx0XHRoYWxmID0gaW5jICogTWF0aC5QSSAvIDM2MCxcblx0XHRcdFx0eiA9IDQgLyAzICogTWF0aC5zaW4oaGFsZikgLyAoMSArIE1hdGguY29zKGhhbGYpKSxcblx0XHRcdFx0c2VnbWVudHMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDw9IGNvdW50OyBpKyspIHtcblx0XHRcdFx0dmFyIHB0ID0gdG8sXG5cdFx0XHRcdFx0b3V0ID0gbnVsbDtcblx0XHRcdFx0aWYgKGkgPCBjb3VudCkge1xuXHRcdFx0XHRcdG91dCA9IHZlY3Rvci5yb3RhdGUoOTApLm11bHRpcGx5KHopO1xuXHRcdFx0XHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdFx0XHRcdHB0ID0gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludCh2ZWN0b3IpO1xuXHRcdFx0XHRcdFx0b3V0ID0gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludCh2ZWN0b3IuYWRkKG91dCkpXG5cdFx0XHRcdFx0XHRcdFx0LnN1YnRyYWN0KHB0KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cHQgPSBjZW50ZXIuYWRkKHZlY3Rvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpID09PSAwKSB7XG5cdFx0XHRcdFx0Y3VycmVudC5zZXRIYW5kbGVPdXQob3V0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgX2luID0gdmVjdG9yLnJvdGF0ZSgtOTApLm11bHRpcGx5KHopO1xuXHRcdFx0XHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdFx0XHRcdF9pbiA9IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQodmVjdG9yLmFkZChfaW4pKVxuXHRcdFx0XHRcdFx0XHRcdC5zdWJ0cmFjdChwdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNlZ21lbnRzLnB1c2gobmV3IFNlZ21lbnQocHQsIF9pbiwgb3V0KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmVjdG9yID0gdmVjdG9yLnJvdGF0ZShpbmMpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fYWRkKHNlZ21lbnRzKTtcblx0XHR9LFxuXG5cdFx0bGluZUJ5OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludDtcblx0XHRcdHRoaXMubGluZVRvKGN1cnJlbnQuYWRkKHRvKSk7XG5cdFx0fSxcblxuXHRcdGN1cnZlQnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRocm91Z2ggPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRwYXJhbWV0ZXIgPSBCYXNlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludDtcblx0XHRcdHRoaXMuY3VydmVUbyhjdXJyZW50LmFkZCh0aHJvdWdoKSwgY3VycmVudC5hZGQodG8pLCBwYXJhbWV0ZXIpO1xuXHRcdH0sXG5cblx0XHRjdWJpY0N1cnZlQnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGhhbmRsZTEgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGhhbmRsZTIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXHRcdFx0dGhpcy5jdWJpY0N1cnZlVG8oY3VycmVudC5hZGQoaGFuZGxlMSksIGN1cnJlbnQuYWRkKGhhbmRsZTIpLFxuXHRcdFx0XHRcdGN1cnJlbnQuYWRkKHRvKSk7XG5cdFx0fSxcblxuXHRcdHF1YWRyYXRpY0N1cnZlQnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGhhbmRsZSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQ7XG5cdFx0XHR0aGlzLnF1YWRyYXRpY0N1cnZlVG8oY3VycmVudC5hZGQoaGFuZGxlKSwgY3VycmVudC5hZGQodG8pKTtcblx0XHR9LFxuXG5cdFx0YXJjQnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQsXG5cdFx0XHRcdHBvaW50ID0gY3VycmVudC5hZGQoUG9pbnQucmVhZChhcmd1bWVudHMpKSxcblx0XHRcdFx0Y2xvY2t3aXNlID0gQmFzZS5waWNrKEJhc2UucGVlayhhcmd1bWVudHMpLCB0cnVlKTtcblx0XHRcdGlmICh0eXBlb2YgY2xvY2t3aXNlID09PSAnYm9vbGVhbicpIHtcblx0XHRcdFx0dGhpcy5hcmNUbyhwb2ludCwgY2xvY2t3aXNlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuYXJjVG8ocG9pbnQsIGN1cnJlbnQuYWRkKFBvaW50LnJlYWQoYXJndW1lbnRzKSkpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRjbG9zZVBhdGg6IGZ1bmN0aW9uKGpvaW4pIHtcblx0XHRcdHRoaXMuc2V0Q2xvc2VkKHRydWUpO1xuXHRcdFx0aWYgKGpvaW4pXG5cdFx0XHRcdHRoaXMuam9pbigpO1xuXHRcdH1cblx0fTtcbn0sIHtcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihnZXR0ZXIsIG1hdHJpeCkge1xuXHRcdHJldHVybiBQYXRoW2dldHRlcl0odGhpcy5fc2VnbWVudHMsIHRoaXMuX2Nsb3NlZCwgdGhpcy5nZXRTdHlsZSgpLFxuXHRcdFx0XHRtYXRyaXgpO1xuXHR9LFxuXG5zdGF0aWNzOiB7XG5cdGlzQ2xvY2t3aXNlOiBmdW5jdGlvbihzZWdtZW50cykge1xuXHRcdHZhciBzdW0gPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0c3VtICs9IEN1cnZlLmdldEVkZ2VTdW0oQ3VydmUuZ2V0VmFsdWVzKFxuXHRcdFx0XHRcdHNlZ21lbnRzW2ldLCBzZWdtZW50c1tpICsgMSA8IGwgPyBpICsgMSA6IDBdKSk7XG5cdFx0cmV0dXJuIHN1bSA+IDA7XG5cdH0sXG5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbihzZWdtZW50cywgY2xvc2VkLCBzdHlsZSwgbWF0cml4LCBzdHJva2VQYWRkaW5nKSB7XG5cdFx0dmFyIGZpcnN0ID0gc2VnbWVudHNbMF07XG5cdFx0aWYgKCFmaXJzdClcblx0XHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKCk7XG5cdFx0dmFyIGNvb3JkcyA9IG5ldyBBcnJheSg2KSxcblx0XHRcdHByZXZDb29yZHMgPSBmaXJzdC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBuZXcgQXJyYXkoNiksIGZhbHNlKSxcblx0XHRcdG1pbiA9IHByZXZDb29yZHMuc2xpY2UoMCwgMiksXG5cdFx0XHRtYXggPSBtaW4uc2xpY2UoKSxcblx0XHRcdHJvb3RzID0gbmV3IEFycmF5KDIpO1xuXG5cdFx0ZnVuY3Rpb24gcHJvY2Vzc1NlZ21lbnQoc2VnbWVudCkge1xuXHRcdFx0c2VnbWVudC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBjb29yZHMsIGZhbHNlKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG5cdFx0XHRcdEN1cnZlLl9hZGRCb3VuZHMoXG5cdFx0XHRcdFx0cHJldkNvb3Jkc1tpXSxcblx0XHRcdFx0XHRwcmV2Q29vcmRzW2kgKyA0XSxcblx0XHRcdFx0XHRjb29yZHNbaSArIDJdLFxuXHRcdFx0XHRcdGNvb3Jkc1tpXSxcblx0XHRcdFx0XHRpLCBzdHJva2VQYWRkaW5nID8gc3Ryb2tlUGFkZGluZ1tpXSA6IDAsIG1pbiwgbWF4LCByb290cyk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdG1wID0gcHJldkNvb3Jkcztcblx0XHRcdHByZXZDb29yZHMgPSBjb29yZHM7XG5cdFx0XHRjb29yZHMgPSB0bXA7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRwcm9jZXNzU2VnbWVudChzZWdtZW50c1tpXSk7XG5cdFx0aWYgKGNsb3NlZClcblx0XHRcdHByb2Nlc3NTZWdtZW50KGZpcnN0KTtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZShtaW5bMF0sIG1pblsxXSwgbWF4WzBdIC0gbWluWzBdLCBtYXhbMV0gLSBtaW5bMV0pO1xuXHR9LFxuXG5cdGdldFN0cm9rZUJvdW5kczogZnVuY3Rpb24oc2VnbWVudHMsIGNsb3NlZCwgc3R5bGUsIG1hdHJpeCkge1xuXHRcdGlmICghc3R5bGUuaGFzU3Ryb2tlKCkpXG5cdFx0XHRyZXR1cm4gUGF0aC5nZXRCb3VuZHMoc2VnbWVudHMsIGNsb3NlZCwgc3R5bGUsIG1hdHJpeCk7XG5cdFx0dmFyIGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aCAtIChjbG9zZWQgPyAwIDogMSksXG5cdFx0XHRyYWRpdXMgPSBzdHlsZS5nZXRTdHJva2VXaWR0aCgpIC8gMixcblx0XHRcdHBhZGRpbmcgPSBQYXRoLl9nZXRQZW5QYWRkaW5nKHJhZGl1cywgbWF0cml4KSxcblx0XHRcdGJvdW5kcyA9IFBhdGguZ2V0Qm91bmRzKHNlZ21lbnRzLCBjbG9zZWQsIHN0eWxlLCBtYXRyaXgsIHBhZGRpbmcpLFxuXHRcdFx0am9pbiA9IHN0eWxlLmdldFN0cm9rZUpvaW4oKSxcblx0XHRcdGNhcCA9IHN0eWxlLmdldFN0cm9rZUNhcCgpLFxuXHRcdFx0bWl0ZXJMaW1pdCA9IHJhZGl1cyAqIHN0eWxlLmdldE1pdGVyTGltaXQoKTtcblx0XHR2YXIgam9pbkJvdW5kcyA9IG5ldyBSZWN0YW5nbGUobmV3IFNpemUocGFkZGluZykubXVsdGlwbHkoMikpO1xuXG5cdFx0ZnVuY3Rpb24gYWRkKHBvaW50KSB7XG5cdFx0XHRib3VuZHMgPSBib3VuZHMuaW5jbHVkZShtYXRyaXhcblx0XHRcdFx0PyBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHBvaW50LCBwb2ludCkgOiBwb2ludCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYWRkUm91bmQoc2VnbWVudCkge1xuXHRcdFx0Ym91bmRzID0gYm91bmRzLnVuaXRlKGpvaW5Cb3VuZHMuc2V0Q2VudGVyKG1hdHJpeFxuXHRcdFx0XHQ/IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQoc2VnbWVudC5fcG9pbnQpIDogc2VnbWVudC5fcG9pbnQpKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRKb2luKHNlZ21lbnQsIGpvaW4pIHtcblx0XHRcdHZhciBoYW5kbGVJbiA9IHNlZ21lbnQuX2hhbmRsZUluLFxuXHRcdFx0XHRoYW5kbGVPdXQgPSBzZWdtZW50Ll9oYW5kbGVPdXQ7XG5cdFx0XHRpZiAoam9pbiA9PT0gJ3JvdW5kJyB8fCAhaGFuZGxlSW4uaXNaZXJvKCkgJiYgIWhhbmRsZU91dC5pc1plcm8oKVxuXHRcdFx0XHRcdCYmIGhhbmRsZUluLmlzQ29sbGluZWFyKGhhbmRsZU91dCkpIHtcblx0XHRcdFx0YWRkUm91bmQoc2VnbWVudCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRQYXRoLl9hZGRCZXZlbEpvaW4oc2VnbWVudCwgam9pbiwgcmFkaXVzLCBtaXRlckxpbWl0LCBhZGQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZENhcChzZWdtZW50LCBjYXApIHtcblx0XHRcdGlmIChjYXAgPT09ICdyb3VuZCcpIHtcblx0XHRcdFx0YWRkUm91bmQoc2VnbWVudCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRQYXRoLl9hZGRTcXVhcmVDYXAoc2VnbWVudCwgY2FwLCByYWRpdXMsIGFkZCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKylcblx0XHRcdGFkZEpvaW4oc2VnbWVudHNbaV0sIGpvaW4pO1xuXHRcdGlmIChjbG9zZWQpIHtcblx0XHRcdGFkZEpvaW4oc2VnbWVudHNbMF0sIGpvaW4pO1xuXHRcdH0gZWxzZSBpZiAobGVuZ3RoID4gMCkge1xuXHRcdFx0YWRkQ2FwKHNlZ21lbnRzWzBdLCBjYXApO1xuXHRcdFx0YWRkQ2FwKHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdLCBjYXApO1xuXHRcdH1cblx0XHRyZXR1cm4gYm91bmRzO1xuXHR9LFxuXG5cdF9nZXRQZW5QYWRkaW5nOiBmdW5jdGlvbihyYWRpdXMsIG1hdHJpeCkge1xuXHRcdGlmICghbWF0cml4KVxuXHRcdFx0cmV0dXJuIFtyYWRpdXMsIHJhZGl1c107XG5cdFx0dmFyIG14ID0gbWF0cml4LnNoaWZ0bGVzcygpLFxuXHRcdFx0aG9yID0gbXgudHJhbnNmb3JtKG5ldyBQb2ludChyYWRpdXMsIDApKSxcblx0XHRcdHZlciA9IG14LnRyYW5zZm9ybShuZXcgUG9pbnQoMCwgcmFkaXVzKSksXG5cdFx0XHRwaGkgPSBob3IuZ2V0QW5nbGVJblJhZGlhbnMoKSxcblx0XHRcdGEgPSBob3IuZ2V0TGVuZ3RoKCksXG5cdFx0XHRiID0gdmVyLmdldExlbmd0aCgpO1xuXHRcdHZhciBzaW4gPSBNYXRoLnNpbihwaGkpLFxuXHRcdFx0Y29zID0gTWF0aC5jb3MocGhpKSxcblx0XHRcdHRhbiA9IE1hdGgudGFuKHBoaSksXG5cdFx0XHR0eCA9IC1NYXRoLmF0YW4oYiAqIHRhbiAvIGEpLFxuXHRcdFx0dHkgPSBNYXRoLmF0YW4oYiAvICh0YW4gKiBhKSk7XG5cdFx0cmV0dXJuIFtNYXRoLmFicyhhICogTWF0aC5jb3ModHgpICogY29zIC0gYiAqIE1hdGguc2luKHR4KSAqIHNpbiksXG5cdFx0XHRcdE1hdGguYWJzKGIgKiBNYXRoLnNpbih0eSkgKiBjb3MgKyBhICogTWF0aC5jb3ModHkpICogc2luKV07XG5cdH0sXG5cblx0X2FkZEJldmVsSm9pbjogZnVuY3Rpb24oc2VnbWVudCwgam9pbiwgcmFkaXVzLCBtaXRlckxpbWl0LCBhZGRQb2ludCwgYXJlYSkge1xuXHRcdHZhciBjdXJ2ZTIgPSBzZWdtZW50LmdldEN1cnZlKCksXG5cdFx0XHRjdXJ2ZTEgPSBjdXJ2ZTIuZ2V0UHJldmlvdXMoKSxcblx0XHRcdHBvaW50ID0gY3VydmUyLmdldFBvaW50QXQoMCwgdHJ1ZSksXG5cdFx0XHRub3JtYWwxID0gY3VydmUxLmdldE5vcm1hbEF0KDEsIHRydWUpLFxuXHRcdFx0bm9ybWFsMiA9IGN1cnZlMi5nZXROb3JtYWxBdCgwLCB0cnVlKSxcblx0XHRcdHN0ZXAgPSBub3JtYWwxLmdldERpcmVjdGVkQW5nbGUobm9ybWFsMikgPCAwID8gLXJhZGl1cyA6IHJhZGl1cztcblx0XHRub3JtYWwxLnNldExlbmd0aChzdGVwKTtcblx0XHRub3JtYWwyLnNldExlbmd0aChzdGVwKTtcblx0XHRpZiAoYXJlYSkge1xuXHRcdFx0YWRkUG9pbnQocG9pbnQpO1xuXHRcdFx0YWRkUG9pbnQocG9pbnQuYWRkKG5vcm1hbDEpKTtcblx0XHR9XG5cdFx0aWYgKGpvaW4gPT09ICdtaXRlcicpIHtcblx0XHRcdHZhciBjb3JuZXIgPSBuZXcgTGluZShcblx0XHRcdFx0XHRwb2ludC5hZGQobm9ybWFsMSksXG5cdFx0XHRcdFx0bmV3IFBvaW50KC1ub3JtYWwxLnksIG5vcm1hbDEueCksIHRydWVcblx0XHRcdFx0KS5pbnRlcnNlY3QobmV3IExpbmUoXG5cdFx0XHRcdFx0cG9pbnQuYWRkKG5vcm1hbDIpLFxuXHRcdFx0XHRcdG5ldyBQb2ludCgtbm9ybWFsMi55LCBub3JtYWwyLngpLCB0cnVlXG5cdFx0XHRcdCksIHRydWUpO1xuXHRcdFx0aWYgKGNvcm5lciAmJiBwb2ludC5nZXREaXN0YW5jZShjb3JuZXIpIDw9IG1pdGVyTGltaXQpIHtcblx0XHRcdFx0YWRkUG9pbnQoY29ybmVyKTtcblx0XHRcdFx0aWYgKCFhcmVhKVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFhcmVhKVxuXHRcdFx0YWRkUG9pbnQocG9pbnQuYWRkKG5vcm1hbDEpKTtcblx0XHRhZGRQb2ludChwb2ludC5hZGQobm9ybWFsMikpO1xuXHR9LFxuXG5cdF9hZGRTcXVhcmVDYXA6IGZ1bmN0aW9uKHNlZ21lbnQsIGNhcCwgcmFkaXVzLCBhZGRQb2ludCwgYXJlYSkge1xuXHRcdHZhciBwb2ludCA9IHNlZ21lbnQuX3BvaW50LFxuXHRcdFx0bG9jID0gc2VnbWVudC5nZXRMb2NhdGlvbigpLFxuXHRcdFx0bm9ybWFsID0gbG9jLmdldE5vcm1hbCgpLm11bHRpcGx5KHJhZGl1cyk7XG5cdFx0aWYgKGFyZWEpIHtcblx0XHRcdGFkZFBvaW50KHBvaW50LnN1YnRyYWN0KG5vcm1hbCkpO1xuXHRcdFx0YWRkUG9pbnQocG9pbnQuYWRkKG5vcm1hbCkpO1xuXHRcdH1cblx0XHRpZiAoY2FwID09PSAnc3F1YXJlJylcblx0XHRcdHBvaW50ID0gcG9pbnQuYWRkKG5vcm1hbC5yb3RhdGUobG9jLmdldFBhcmFtZXRlcigpID09PSAwID8gLTkwIDogOTApKTtcblx0XHRhZGRQb2ludChwb2ludC5hZGQobm9ybWFsKSk7XG5cdFx0YWRkUG9pbnQocG9pbnQuc3VidHJhY3Qobm9ybWFsKSk7XG5cdH0sXG5cblx0Z2V0SGFuZGxlQm91bmRzOiBmdW5jdGlvbihzZWdtZW50cywgY2xvc2VkLCBzdHlsZSwgbWF0cml4LCBzdHJva2VQYWRkaW5nLFxuXHRcdFx0am9pblBhZGRpbmcpIHtcblx0XHR2YXIgY29vcmRzID0gbmV3IEFycmF5KDYpLFxuXHRcdFx0eDEgPSBJbmZpbml0eSxcblx0XHRcdHgyID0gLXgxLFxuXHRcdFx0eTEgPSB4MSxcblx0XHRcdHkyID0geDI7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG5cdFx0XHRzZWdtZW50Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIGNvb3JkcywgZmFsc2UpO1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCA2OyBqICs9IDIpIHtcblx0XHRcdFx0dmFyIHBhZGRpbmcgPSBqID09PSAwID8gam9pblBhZGRpbmcgOiBzdHJva2VQYWRkaW5nLFxuXHRcdFx0XHRcdHBhZGRpbmdYID0gcGFkZGluZyA/IHBhZGRpbmdbMF0gOiAwLFxuXHRcdFx0XHRcdHBhZGRpbmdZID0gcGFkZGluZyA/IHBhZGRpbmdbMV0gOiAwLFxuXHRcdFx0XHRcdHggPSBjb29yZHNbal0sXG5cdFx0XHRcdFx0eSA9IGNvb3Jkc1tqICsgMV0sXG5cdFx0XHRcdFx0eG4gPSB4IC0gcGFkZGluZ1gsXG5cdFx0XHRcdFx0eHggPSB4ICsgcGFkZGluZ1gsXG5cdFx0XHRcdFx0eW4gPSB5IC0gcGFkZGluZ1ksXG5cdFx0XHRcdFx0eXggPSB5ICsgcGFkZGluZ1k7XG5cdFx0XHRcdGlmICh4biA8IHgxKSB4MSA9IHhuO1xuXHRcdFx0XHRpZiAoeHggPiB4MikgeDIgPSB4eDtcblx0XHRcdFx0aWYgKHluIDwgeTEpIHkxID0geW47XG5cdFx0XHRcdGlmICh5eCA+IHkyKSB5MiA9IHl4O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuXHR9LFxuXG5cdGdldFJvdWdoQm91bmRzOiBmdW5jdGlvbihzZWdtZW50cywgY2xvc2VkLCBzdHlsZSwgbWF0cml4KSB7XG5cdFx0dmFyIHN0cm9rZVJhZGl1cyA9IHN0eWxlLmhhc1N0cm9rZSgpID8gc3R5bGUuZ2V0U3Ryb2tlV2lkdGgoKSAvIDIgOiAwLFxuXHRcdFx0am9pblJhZGl1cyA9IHN0cm9rZVJhZGl1cztcblx0XHRpZiAoc3Ryb2tlUmFkaXVzID4gMCkge1xuXHRcdFx0aWYgKHN0eWxlLmdldFN0cm9rZUpvaW4oKSA9PT0gJ21pdGVyJylcblx0XHRcdFx0am9pblJhZGl1cyA9IHN0cm9rZVJhZGl1cyAqIHN0eWxlLmdldE1pdGVyTGltaXQoKTtcblx0XHRcdGlmIChzdHlsZS5nZXRTdHJva2VDYXAoKSA9PT0gJ3NxdWFyZScpXG5cdFx0XHRcdGpvaW5SYWRpdXMgPSBNYXRoLm1heChqb2luUmFkaXVzLCBzdHJva2VSYWRpdXMgKiBNYXRoLnNxcnQoMikpO1xuXHRcdH1cblx0XHRyZXR1cm4gUGF0aC5nZXRIYW5kbGVCb3VuZHMoc2VnbWVudHMsIGNsb3NlZCwgc3R5bGUsIG1hdHJpeCxcblx0XHRcdFx0UGF0aC5fZ2V0UGVuUGFkZGluZyhzdHJva2VSYWRpdXMsIG1hdHJpeCksXG5cdFx0XHRcdFBhdGguX2dldFBlblBhZGRpbmcoam9pblJhZGl1cywgbWF0cml4KSk7XG5cdH1cbn19KTtcblxuUGF0aC5pbmplY3QoeyBzdGF0aWNzOiBuZXcgZnVuY3Rpb24oKSB7XG5cblx0dmFyIGthcHBhID0gMC41NTIyODQ3NDk4MzA3OTM2LFxuXHRcdGVsbGlwc2VTZWdtZW50cyA9IFtcblx0XHRcdG5ldyBTZWdtZW50KFstMSwgMF0sIFswLCBrYXBwYSBdLCBbMCwgLWthcHBhXSksXG5cdFx0XHRuZXcgU2VnbWVudChbMCwgLTFdLCBbLWthcHBhLCAwXSwgW2thcHBhLCAwIF0pLFxuXHRcdFx0bmV3IFNlZ21lbnQoWzEsIDBdLCBbMCwgLWthcHBhXSwgWzAsIGthcHBhIF0pLFxuXHRcdFx0bmV3IFNlZ21lbnQoWzAsIDFdLCBba2FwcGEsIDAgXSwgWy1rYXBwYSwgMF0pXG5cdFx0XTtcblxuXHRmdW5jdGlvbiBjcmVhdGVQYXRoKHNlZ21lbnRzLCBjbG9zZWQsIGFyZ3MpIHtcblx0XHR2YXIgcHJvcHMgPSBCYXNlLmdldE5hbWVkKGFyZ3MpLFxuXHRcdFx0cGF0aCA9IG5ldyBQYXRoKHByb3BzICYmIHByb3BzLmluc2VydCA9PT0gZmFsc2UgJiYgSXRlbS5OT19JTlNFUlQpO1xuXHRcdHBhdGguX2FkZChzZWdtZW50cyk7XG5cdFx0cGF0aC5fY2xvc2VkID0gY2xvc2VkO1xuXHRcdHJldHVybiBwYXRoLnNldChwcm9wcyk7XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVFbGxpcHNlKGNlbnRlciwgcmFkaXVzLCBhcmdzKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gbmV3IEFycmF5KDQpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IGVsbGlwc2VTZWdtZW50c1tpXTtcblx0XHRcdHNlZ21lbnRzW2ldID0gbmV3IFNlZ21lbnQoXG5cdFx0XHRcdHNlZ21lbnQuX3BvaW50Lm11bHRpcGx5KHJhZGl1cykuYWRkKGNlbnRlciksXG5cdFx0XHRcdHNlZ21lbnQuX2hhbmRsZUluLm11bHRpcGx5KHJhZGl1cyksXG5cdFx0XHRcdHNlZ21lbnQuX2hhbmRsZU91dC5tdWx0aXBseShyYWRpdXMpXG5cdFx0XHQpO1xuXHRcdH1cblx0XHRyZXR1cm4gY3JlYXRlUGF0aChzZWdtZW50cywgdHJ1ZSwgYXJncyk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdExpbmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVBhdGgoW1xuXHRcdFx0XHRuZXcgU2VnbWVudChQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAnZnJvbScpKSxcblx0XHRcdFx0bmV3IFNlZ21lbnQoUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3RvJykpXG5cdFx0XHRdLCBmYWxzZSwgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0Q2lyY2xlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjZW50ZXIgPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAnY2VudGVyJyksXG5cdFx0XHRcdHJhZGl1cyA9IEJhc2UucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JhZGl1cycpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZUVsbGlwc2UoY2VudGVyLCBuZXcgU2l6ZShyYWRpdXMpLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRSZWN0YW5nbGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JlY3RhbmdsZScpLFxuXHRcdFx0XHRyYWRpdXMgPSBTaXplLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMnLCAwLFxuXHRcdFx0XHRcdFx0eyByZWFkTnVsbDogdHJ1ZSB9KSxcblx0XHRcdFx0YmwgPSByZWN0LmdldEJvdHRvbUxlZnQodHJ1ZSksXG5cdFx0XHRcdHRsID0gcmVjdC5nZXRUb3BMZWZ0KHRydWUpLFxuXHRcdFx0XHR0ciA9IHJlY3QuZ2V0VG9wUmlnaHQodHJ1ZSksXG5cdFx0XHRcdGJyID0gcmVjdC5nZXRCb3R0b21SaWdodCh0cnVlKSxcblx0XHRcdFx0c2VnbWVudHM7XG5cdFx0XHRpZiAoIXJhZGl1cyB8fCByYWRpdXMuaXNaZXJvKCkpIHtcblx0XHRcdFx0c2VnbWVudHMgPSBbXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQoYmwpLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRsKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudCh0ciksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQoYnIpXG5cdFx0XHRcdF07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyYWRpdXMgPSBTaXplLm1pbihyYWRpdXMsIHJlY3QuZ2V0U2l6ZSh0cnVlKS5kaXZpZGUoMikpO1xuXHRcdFx0XHR2YXIgcnggPSByYWRpdXMud2lkdGgsXG5cdFx0XHRcdFx0cnkgPSByYWRpdXMuaGVpZ2h0LFxuXHRcdFx0XHRcdGh4ID0gcnggKiBrYXBwYSxcblx0XHRcdFx0XHRoeSA9IHJ5ICoga2FwcGE7XG5cdFx0XHRcdHNlZ21lbnRzID0gW1xuXHRcdFx0XHRcdG5ldyBTZWdtZW50KGJsLmFkZChyeCwgMCksIG51bGwsIFstaHgsIDBdKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudChibC5zdWJ0cmFjdCgwLCByeSksIFswLCBoeV0pLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRsLmFkZCgwLCByeSksIG51bGwsIFswLCAtaHldKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudCh0bC5hZGQocngsIDApLCBbLWh4LCAwXSwgbnVsbCksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQodHIuc3VidHJhY3QocngsIDApLCBudWxsLCBbaHgsIDBdKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudCh0ci5hZGQoMCwgcnkpLCBbMCwgLWh5XSwgbnVsbCksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQoYnIuc3VidHJhY3QoMCwgcnkpLCBudWxsLCBbMCwgaHldKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudChici5zdWJ0cmFjdChyeCwgMCksIFtoeCwgMF0pXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY3JlYXRlUGF0aChzZWdtZW50cywgdHJ1ZSwgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0Um91bmRSZWN0YW5nbGU6ICcjUmVjdGFuZ2xlJyxcblxuXHRcdEVsbGlwc2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGVsbGlwc2UgPSBTaGFwZS5fcmVhZEVsbGlwc2UoYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBjcmVhdGVFbGxpcHNlKGVsbGlwc2UuY2VudGVyLCBlbGxpcHNlLnJhZGl1cywgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0T3ZhbDogJyNFbGxpcHNlJyxcblxuXHRcdEFyYzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZnJvbSA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdmcm9tJyksXG5cdFx0XHRcdHRocm91Z2ggPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAndGhyb3VnaCcpLFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICd0bycpLFxuXHRcdFx0XHRwcm9wcyA9IEJhc2UuZ2V0TmFtZWQoYXJndW1lbnRzKSxcblx0XHRcdFx0cGF0aCA9IG5ldyBQYXRoKHByb3BzICYmIHByb3BzLmluc2VydCA9PT0gZmFsc2Vcblx0XHRcdFx0XHRcdCYmIEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRcdHBhdGgubW92ZVRvKGZyb20pO1xuXHRcdFx0cGF0aC5hcmNUbyh0aHJvdWdoLCB0byk7XG5cdFx0XHRyZXR1cm4gcGF0aC5zZXQocHJvcHMpO1xuXHRcdH0sXG5cblx0XHRSZWd1bGFyUG9seWdvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2VudGVyID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ2NlbnRlcicpLFxuXHRcdFx0XHRzaWRlcyA9IEJhc2UucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3NpZGVzJyksXG5cdFx0XHRcdHJhZGl1cyA9IEJhc2UucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JhZGl1cycpLFxuXHRcdFx0XHRzdGVwID0gMzYwIC8gc2lkZXMsXG5cdFx0XHRcdHRocmVlID0gIShzaWRlcyAlIDMpLFxuXHRcdFx0XHR2ZWN0b3IgPSBuZXcgUG9pbnQoMCwgdGhyZWUgPyAtcmFkaXVzIDogcmFkaXVzKSxcblx0XHRcdFx0b2Zmc2V0ID0gdGhyZWUgPyAtMSA6IDAuNSxcblx0XHRcdFx0c2VnbWVudHMgPSBuZXcgQXJyYXkoc2lkZXMpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrKVxuXHRcdFx0XHRzZWdtZW50c1tpXSA9IG5ldyBTZWdtZW50KGNlbnRlci5hZGQoXG5cdFx0XHRcdFx0dmVjdG9yLnJvdGF0ZSgoaSArIG9mZnNldCkgKiBzdGVwKSkpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVBhdGgoc2VnbWVudHMsIHRydWUsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdFN0YXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdjZW50ZXInKSxcblx0XHRcdFx0cG9pbnRzID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncG9pbnRzJykgKiAyLFxuXHRcdFx0XHRyYWRpdXMxID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmFkaXVzMScpLFxuXHRcdFx0XHRyYWRpdXMyID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmFkaXVzMicpLFxuXHRcdFx0XHRzdGVwID0gMzYwIC8gcG9pbnRzLFxuXHRcdFx0XHR2ZWN0b3IgPSBuZXcgUG9pbnQoMCwgLTEpLFxuXHRcdFx0XHRzZWdtZW50cyA9IG5ldyBBcnJheShwb2ludHMpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHM7IGkrKylcblx0XHRcdFx0c2VnbWVudHNbaV0gPSBuZXcgU2VnbWVudChjZW50ZXIuYWRkKHZlY3Rvci5yb3RhdGUoc3RlcCAqIGkpXG5cdFx0XHRcdFx0XHQubXVsdGlwbHkoaSAlIDIgPyByYWRpdXMyIDogcmFkaXVzMSkpKTtcblx0XHRcdHJldHVybiBjcmVhdGVQYXRoKHNlZ21lbnRzLCB0cnVlLCBhcmd1bWVudHMpO1xuXHRcdH1cblx0fTtcbn19KTtcblxudmFyIENvbXBvdW5kUGF0aCA9IFBhdGhJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ0NvbXBvdW5kUGF0aCcsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRjaGlsZHJlbjogW11cblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBDb21wb3VuZFBhdGgoYXJnKSB7XG5cdFx0dGhpcy5fY2hpbGRyZW4gPSBbXTtcblx0XHR0aGlzLl9uYW1lZENoaWxkcmVuID0ge307XG5cdFx0aWYgKCF0aGlzLl9pbml0aWFsaXplKGFyZykpIHtcblx0XHRcdGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHR0aGlzLnNldFBhdGhEYXRhKGFyZyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmFkZENoaWxkcmVuKEFycmF5LmlzQXJyYXkoYXJnKSA/IGFyZyA6IGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGluc2VydENoaWxkcmVuOiBmdW5jdGlvbiBpbnNlcnRDaGlsZHJlbihpbmRleCwgaXRlbXMsIF9wcmVzZXJ2ZSkge1xuXHRcdGl0ZW1zID0gaW5zZXJ0Q2hpbGRyZW4uYmFzZS5jYWxsKHRoaXMsIGluZGV4LCBpdGVtcywgX3ByZXNlcnZlLCBQYXRoKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9ICFfcHJlc2VydmUgJiYgaXRlbXMgJiYgaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuXHRcdFx0aWYgKGl0ZW0uX2Nsb2Nrd2lzZSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRpdGVtLnNldENsb2Nrd2lzZShpdGVtLl9pbmRleCA9PT0gMCk7XG5cdFx0fVxuXHRcdHJldHVybiBpdGVtcztcblx0fSxcblxuXHRyZXZlcnNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdGNoaWxkcmVuW2ldLnJldmVyc2UoKTtcblx0fSxcblxuXHRzbW9vdGg6IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0dGhpcy5fY2hpbGRyZW5baV0uc21vb3RoKCk7XG5cdH0sXG5cblx0cmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoKSB7XG5cdFx0aWYgKHRoaXMuX2NoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0dmFyIHBhdGggPSBuZXcgUGF0aChJdGVtLk5PX0lOU0VSVCk7XG5cdFx0XHRwYXRoLmluc2VydEFib3ZlKHRoaXMpO1xuXHRcdFx0cGF0aC5zZXRTdHlsZSh0aGlzLl9zdHlsZSk7XG5cdFx0XHR0aGlzLnJlbW92ZSgpO1xuXHRcdFx0cmV0dXJuIHBhdGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiByZWR1Y2UuYmFzZS5jYWxsKHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRpc0Nsb2Nrd2lzZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cdFx0cmV0dXJuIGNoaWxkICYmIGNoaWxkLmlzQ2xvY2t3aXNlKCk7XG5cdH0sXG5cblx0c2V0Q2xvY2t3aXNlOiBmdW5jdGlvbihjbG9ja3dpc2UpIHtcblx0XHRpZiAodGhpcy5pc0Nsb2Nrd2lzZSgpICE9PSAhIWNsb2Nrd2lzZSlcblx0XHRcdHRoaXMucmV2ZXJzZSgpO1xuXHR9LFxuXG5cdGdldEZpcnN0U2VnbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGZpcnN0ID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cdFx0cmV0dXJuIGZpcnN0ICYmIGZpcnN0LmdldEZpcnN0U2VnbWVudCgpO1xuXHR9LFxuXG5cdGdldExhc3RTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGFzdCA9IHRoaXMuZ2V0TGFzdENoaWxkKCk7XG5cdFx0cmV0dXJuIGxhc3QgJiYgbGFzdC5nZXRMYXN0U2VnbWVudCgpO1xuXHR9LFxuXG5cdGdldEN1cnZlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG5cdFx0XHRjdXJ2ZXMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdGN1cnZlcy5wdXNoLmFwcGx5KGN1cnZlcywgY2hpbGRyZW5baV0uZ2V0Q3VydmVzKCkpO1xuXHRcdHJldHVybiBjdXJ2ZXM7XG5cdH0sXG5cblx0Z2V0Rmlyc3RDdXJ2ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGZpcnN0ID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cdFx0cmV0dXJuIGZpcnN0ICYmIGZpcnN0LmdldEZpcnN0Q3VydmUoKTtcblx0fSxcblxuXHRnZXRMYXN0Q3VydmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsYXN0ID0gdGhpcy5nZXRMYXN0Q2hpbGQoKTtcblx0XHRyZXR1cm4gbGFzdCAmJiBsYXN0LmdldEZpcnN0Q3VydmUoKTtcblx0fSxcblxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdGFyZWEgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0YXJlYSArPSBjaGlsZHJlbltpXS5nZXRBcmVhKCk7XG5cdFx0cmV0dXJuIGFyZWE7XG5cdH1cbn0sIHtcblx0YmVhbnM6IHRydWUsXG5cblx0Z2V0UGF0aERhdGE6IGZ1bmN0aW9uKF9tYXRyaXgsIF9wcmVjaXNpb24pIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdHBhdGhzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldLFxuXHRcdFx0XHRteCA9IGNoaWxkLl9tYXRyaXg7XG5cdFx0XHRwYXRocy5wdXNoKGNoaWxkLmdldFBhdGhEYXRhKF9tYXRyaXggJiYgIW14LmlzSWRlbnRpdHkoKVxuXHRcdFx0XHRcdD8gX21hdHJpeC5jaGFpbihteCkgOiBteCwgX3ByZWNpc2lvbikpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGF0aHMuam9pbignICcpO1xuXHR9XG59LCB7XG5cdF9nZXRDaGlsZEhpdFRlc3RPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIG9wdGlvbnMuY2xhc3MgPT09IFBhdGggfHwgb3B0aW9ucy50eXBlID09PSAncGF0aCdcblx0XHRcdFx0PyBvcHRpb25zXG5cdFx0XHRcdDogbmV3IEJhc2Uob3B0aW9ucywgeyBmaWxsOiBmYWxzZSB9KTtcblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSwgc3Ryb2tlTWF0cml4KSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMClcblx0XHRcdHJldHVybjtcblxuXHRcdGlmICh0aGlzLl9jdXJyZW50UGF0aCkge1xuXHRcdFx0Y3R4LmN1cnJlbnRQYXRoID0gdGhpcy5fY3VycmVudFBhdGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhcmFtID0gcGFyYW0uZXh0ZW5kKHsgZG9udFN0YXJ0OiB0cnVlLCBkb250RmluaXNoOiB0cnVlIH0pO1xuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGNoaWxkcmVuW2ldLmRyYXcoY3R4LCBwYXJhbSwgc3Ryb2tlTWF0cml4KTtcblx0XHRcdHRoaXMuX2N1cnJlbnRQYXRoID0gY3R4LmN1cnJlbnRQYXRoO1xuXHRcdH1cblxuXHRcdGlmICghcGFyYW0uY2xpcCkge1xuXHRcdFx0dGhpcy5fc2V0U3R5bGVzKGN0eCk7XG5cdFx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZTtcblx0XHRcdGlmIChzdHlsZS5oYXNGaWxsKCkpIHtcblx0XHRcdFx0Y3R4LmZpbGwoc3R5bGUuZ2V0V2luZGluZ1J1bGUoKSk7XG5cdFx0XHRcdGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdH1cblx0XHRcdGlmIChzdHlsZS5oYXNTdHJva2UoKSlcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfZHJhd1NlbGVjdGVkOiBmdW5jdGlvbihjdHgsIG1hdHJpeCwgc2VsZWN0ZWRJdGVtcykge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXSxcblx0XHRcdFx0bXggPSBjaGlsZC5fbWF0cml4O1xuXHRcdFx0aWYgKCFzZWxlY3RlZEl0ZW1zW2NoaWxkLl9pZF0pXG5cdFx0XHRcdGNoaWxkLl9kcmF3U2VsZWN0ZWQoY3R4LCBteC5pc0lkZW50aXR5KCkgPyBtYXRyaXhcblx0XHRcdFx0XHRcdDogbWF0cml4LmNoYWluKG14KSk7XG5cdFx0fVxuXHR9XG59LCBuZXcgZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIGdldEN1cnJlbnRQYXRoKHRoYXQsIGNoZWNrKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhhdC5fY2hpbGRyZW47XG5cdFx0aWYgKGNoZWNrICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMClcblx0XHRcdHRocm93IG5ldyBFcnJvcignVXNlIGEgbW92ZVRvKCkgY29tbWFuZCBmaXJzdCcpO1xuXHRcdHJldHVybiBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXTtcblx0fVxuXG5cdHZhciBmaWVsZHMgPSB7XG5cdFx0bW92ZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjdXJyZW50ID0gZ2V0Q3VycmVudFBhdGgodGhpcyksXG5cdFx0XHRcdHBhdGggPSBjdXJyZW50ICYmIGN1cnJlbnQuaXNFbXB0eSgpID8gY3VycmVudCA6IG5ldyBQYXRoKCk7XG5cdFx0XHRpZiAocGF0aCAhPT0gY3VycmVudClcblx0XHRcdFx0dGhpcy5hZGRDaGlsZChwYXRoKTtcblx0XHRcdHBhdGgubW92ZVRvLmFwcGx5KHBhdGgsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdG1vdmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY3VycmVudCA9IGdldEN1cnJlbnRQYXRoKHRoaXMsIHRydWUpLFxuXHRcdFx0XHRsYXN0ID0gY3VycmVudCAmJiBjdXJyZW50LmdldExhc3RTZWdtZW50KCksXG5cdFx0XHRcdHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy5tb3ZlVG8obGFzdCA/IHBvaW50LmFkZChsYXN0Ll9wb2ludCkgOiBwb2ludCk7XG5cdFx0fSxcblxuXHRcdGNsb3NlUGF0aDogZnVuY3Rpb24oam9pbikge1xuXHRcdFx0Z2V0Q3VycmVudFBhdGgodGhpcywgdHJ1ZSkuY2xvc2VQYXRoKGpvaW4pO1xuXHRcdH1cblx0fTtcblxuXHRCYXNlLmVhY2goWydsaW5lVG8nLCAnY3ViaWNDdXJ2ZVRvJywgJ3F1YWRyYXRpY0N1cnZlVG8nLCAnY3VydmVUbycsICdhcmNUbycsXG5cdFx0XHQnbGluZUJ5JywgJ2N1YmljQ3VydmVCeScsICdxdWFkcmF0aWNDdXJ2ZUJ5JywgJ2N1cnZlQnknLCAnYXJjQnknXSxcblx0XHRcdGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0XHRmaWVsZHNba2V5XSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBwYXRoID0gZ2V0Q3VycmVudFBhdGgodGhpcywgdHJ1ZSk7XG5cdFx0XHRcdFx0cGF0aFtrZXldLmFwcGx5KHBhdGgsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdCk7XG5cblx0cmV0dXJuIGZpZWxkcztcbn0pO1xuXG5QYXRoSXRlbS5pbmplY3QobmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3BlcmF0b3JzID0ge1xuXHRcdHVuaXRlOiBmdW5jdGlvbih3KSB7XG5cdFx0XHRyZXR1cm4gdyA9PT0gMSB8fCB3ID09PSAwO1xuXHRcdH0sXG5cblx0XHRpbnRlcnNlY3Q6IGZ1bmN0aW9uKHcpIHtcblx0XHRcdHJldHVybiB3ID09PSAyO1xuXHRcdH0sXG5cblx0XHRzdWJ0cmFjdDogZnVuY3Rpb24odykge1xuXHRcdFx0cmV0dXJuIHcgPT09IDE7XG5cdFx0fSxcblxuXHRcdGV4Y2x1ZGU6IGZ1bmN0aW9uKHcpIHtcblx0XHRcdHJldHVybiB3ID09PSAxO1xuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiBjb21wdXRlQm9vbGVhbihwYXRoMSwgcGF0aDIsIG9wZXJhdGlvbikge1xuXHRcdHZhciBvcGVyYXRvciA9IG9wZXJhdG9yc1tvcGVyYXRpb25dO1xuXHRcdGZ1bmN0aW9uIHByZXBhcmVQYXRoKHBhdGgpIHtcblx0XHRcdHJldHVybiBwYXRoLmNsb25lKGZhbHNlKS5yZWR1Y2UoKS5yZW9yaWVudCgpLnRyYW5zZm9ybShudWxsLCB0cnVlLFxuXHRcdFx0XHRcdHRydWUpO1xuXHRcdH1cblxuXHRcdHZhciBfcGF0aDEgPSBwcmVwYXJlUGF0aChwYXRoMSksXG5cdFx0XHRfcGF0aDIgPSBwYXRoMiAmJiBwYXRoMSAhPT0gcGF0aDIgJiYgcHJlcGFyZVBhdGgocGF0aDIpO1xuXHRcdGlmIChfcGF0aDIgJiYgL14oc3VidHJhY3R8ZXhjbHVkZSkkLy50ZXN0KG9wZXJhdGlvbilcblx0XHRcdFx0XiAoX3BhdGgyLmlzQ2xvY2t3aXNlKCkgIT09IF9wYXRoMS5pc0Nsb2Nrd2lzZSgpKSlcblx0XHRcdF9wYXRoMi5yZXZlcnNlKCk7XG5cdFx0c3BsaXRQYXRoKF9wYXRoMS5nZXRJbnRlcnNlY3Rpb25zKF9wYXRoMiwgbnVsbCwgdHJ1ZSkpO1xuXG5cdFx0dmFyIGNoYWluID0gW10sXG5cdFx0XHRzZWdtZW50cyA9IFtdLFxuXHRcdFx0bW9ub0N1cnZlcyA9IFtdLFxuXHRcdFx0dG9sZXJhbmNlID0gMC4wMDAwMDE7XG5cblx0XHRmdW5jdGlvbiBjb2xsZWN0KHBhdGhzKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBhdGhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgcGF0aCA9IHBhdGhzW2ldO1xuXHRcdFx0XHRzZWdtZW50cy5wdXNoLmFwcGx5KHNlZ21lbnRzLCBwYXRoLl9zZWdtZW50cyk7XG5cdFx0XHRcdG1vbm9DdXJ2ZXMucHVzaC5hcHBseShtb25vQ3VydmVzLCBwYXRoLl9nZXRNb25vQ3VydmVzKCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbGxlY3QoX3BhdGgxLl9jaGlsZHJlbiB8fCBbX3BhdGgxXSk7XG5cdFx0aWYgKF9wYXRoMilcblx0XHRcdGNvbGxlY3QoX3BhdGgyLl9jaGlsZHJlbiB8fCBbX3BhdGgyXSk7XG5cdFx0c2VnbWVudHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIgX2EgPSBhLl9pbnRlcnNlY3Rpb24sXG5cdFx0XHRcdF9iID0gYi5faW50ZXJzZWN0aW9uO1xuXHRcdFx0cmV0dXJuICFfYSAmJiAhX2IgfHwgX2EgJiYgX2IgPyAwIDogX2EgPyAtMSA6IDE7XG5cdFx0fSk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG5cdFx0XHRpZiAoc2VnbWVudC5fd2luZGluZyAhPSBudWxsKVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdGNoYWluLmxlbmd0aCA9IDA7XG5cdFx0XHR2YXIgc3RhcnRTZWcgPSBzZWdtZW50LFxuXHRcdFx0XHR0b3RhbExlbmd0aCA9IDAsXG5cdFx0XHRcdHdpbmRpbmdTdW0gPSAwO1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHR2YXIgbGVuZ3RoID0gc2VnbWVudC5nZXRDdXJ2ZSgpLmdldExlbmd0aCgpO1xuXHRcdFx0XHRjaGFpbi5wdXNoKHsgc2VnbWVudDogc2VnbWVudCwgbGVuZ3RoOiBsZW5ndGggfSk7XG5cdFx0XHRcdHRvdGFsTGVuZ3RoICs9IGxlbmd0aDtcblx0XHRcdFx0c2VnbWVudCA9IHNlZ21lbnQuZ2V0TmV4dCgpO1xuXHRcdFx0fSB3aGlsZSAoc2VnbWVudCAmJiAhc2VnbWVudC5faW50ZXJzZWN0aW9uICYmIHNlZ21lbnQgIT09IHN0YXJ0U2VnKTtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgMzsgaisrKSB7XG5cdFx0XHRcdHZhciBsZW5ndGggPSB0b3RhbExlbmd0aCAqIChqICsgMSkgLyA0O1xuXHRcdFx0XHRmb3IgKHZhciBrID0gMCwgbSA9IGNoYWluLmxlbmd0aDsgayA8IG07IGsrKykge1xuXHRcdFx0XHRcdHZhciBub2RlID0gY2hhaW5ba10sXG5cdFx0XHRcdFx0XHRjdXJ2ZUxlbmd0aCA9IG5vZGUubGVuZ3RoO1xuXHRcdFx0XHRcdGlmIChsZW5ndGggPD0gY3VydmVMZW5ndGgpIHtcblx0XHRcdFx0XHRcdGlmIChsZW5ndGggPCB0b2xlcmFuY2Vcblx0XHRcdFx0XHRcdFx0XHR8fCBjdXJ2ZUxlbmd0aCAtIGxlbmd0aCA8IHRvbGVyYW5jZSlcblx0XHRcdFx0XHRcdFx0bGVuZ3RoID0gY3VydmVMZW5ndGggLyAyO1xuXHRcdFx0XHRcdFx0dmFyIGN1cnZlID0gbm9kZS5zZWdtZW50LmdldEN1cnZlKCksXG5cdFx0XHRcdFx0XHRcdHB0ID0gY3VydmUuZ2V0UG9pbnRBdChsZW5ndGgpLFxuXHRcdFx0XHRcdFx0XHRob3IgPSBjdXJ2ZS5pc0xpbmVhcigpICYmIE1hdGguYWJzKGN1cnZlXG5cdFx0XHRcdFx0XHRcdFx0XHQuZ2V0VGFuZ2VudEF0KDAuNSwgdHJ1ZSkueSkgPCB0b2xlcmFuY2UsXG5cdFx0XHRcdFx0XHRcdHBhdGggPSBjdXJ2ZS5fcGF0aDtcblx0XHRcdFx0XHRcdGlmIChwYXRoLl9wYXJlbnQgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGgpXG5cdFx0XHRcdFx0XHRcdHBhdGggPSBwYXRoLl9wYXJlbnQ7XG5cdFx0XHRcdFx0XHR3aW5kaW5nU3VtICs9IG9wZXJhdGlvbiA9PT0gJ3N1YnRyYWN0JyAmJiBfcGF0aDJcblx0XHRcdFx0XHRcdFx0JiYgKHBhdGggPT09IF9wYXRoMSAmJiBfcGF0aDIuX2dldFdpbmRpbmcocHQsIGhvcilcblx0XHRcdFx0XHRcdFx0fHwgcGF0aCA9PT0gX3BhdGgyICYmICFfcGF0aDEuX2dldFdpbmRpbmcocHQsIGhvcikpXG5cdFx0XHRcdFx0XHRcdD8gMFxuXHRcdFx0XHRcdFx0XHQ6IGdldFdpbmRpbmcocHQsIG1vbm9DdXJ2ZXMsIGhvcik7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGVuZ3RoIC09IGN1cnZlTGVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR2YXIgd2luZGluZyA9IE1hdGgucm91bmQod2luZGluZ1N1bSAvIDMpO1xuXHRcdFx0Zm9yICh2YXIgaiA9IGNoYWluLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKVxuXHRcdFx0XHRjaGFpbltqXS5zZWdtZW50Ll93aW5kaW5nID0gd2luZGluZztcblx0XHR9XG5cdFx0dmFyIHJlc3VsdCA9IG5ldyBDb21wb3VuZFBhdGgoSXRlbS5OT19JTlNFUlQpO1xuXHRcdHJlc3VsdC5pbnNlcnRBYm92ZShwYXRoMSk7XG5cdFx0cmVzdWx0LmFkZENoaWxkcmVuKHRyYWNlUGF0aHMoc2VnbWVudHMsIG9wZXJhdG9yKSwgdHJ1ZSk7XG5cdFx0cmVzdWx0ID0gcmVzdWx0LnJlZHVjZSgpO1xuXHRcdHJlc3VsdC5zZXRTdHlsZShwYXRoMS5fc3R5bGUpO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHRmdW5jdGlvbiBzcGxpdFBhdGgoaW50ZXJzZWN0aW9ucykge1xuXHRcdHZhciB0TWluID0gMC4wMDAwMDEsXG5cdFx0XHR0TWF4ID0gMSAtIHRNaW4sXG5cdFx0XHRsaW5lYXJIYW5kbGVzO1xuXG5cdFx0ZnVuY3Rpb24gcmVzZXRMaW5lYXIoKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGxpbmVhckhhbmRsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRsaW5lYXJIYW5kbGVzW2ldLnNldCgwLCAwKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gaW50ZXJzZWN0aW9ucy5sZW5ndGggLSAxLCBjdXJ2ZSwgcHJldjsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHZhciBsb2MgPSBpbnRlcnNlY3Rpb25zW2ldLFxuXHRcdFx0XHR0ID0gbG9jLl9wYXJhbWV0ZXI7XG5cdFx0XHRpZiAocHJldiAmJiBwcmV2Ll9jdXJ2ZSA9PT0gbG9jLl9jdXJ2ZSAmJiBwcmV2Ll9wYXJhbWV0ZXIgPiAwKSB7XG5cdFx0XHRcdHQgLz0gcHJldi5fcGFyYW1ldGVyO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3VydmUgPSBsb2MuX2N1cnZlO1xuXHRcdFx0XHRpZiAobGluZWFySGFuZGxlcylcblx0XHRcdFx0XHRyZXNldExpbmVhcigpO1xuXHRcdFx0XHRsaW5lYXJIYW5kbGVzID0gY3VydmUuaXNMaW5lYXIoKSA/IFtcblx0XHRcdFx0XHRcdGN1cnZlLl9zZWdtZW50MS5faGFuZGxlT3V0LFxuXHRcdFx0XHRcdFx0Y3VydmUuX3NlZ21lbnQyLl9oYW5kbGVJblxuXHRcdFx0XHRcdF0gOiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG5ld0N1cnZlLFxuXHRcdFx0XHRzZWdtZW50O1xuXHRcdFx0aWYgKG5ld0N1cnZlID0gY3VydmUuZGl2aWRlKHQsIHRydWUsIHRydWUpKSB7XG5cdFx0XHRcdHNlZ21lbnQgPSBuZXdDdXJ2ZS5fc2VnbWVudDE7XG5cdFx0XHRcdGN1cnZlID0gbmV3Q3VydmUuZ2V0UHJldmlvdXMoKTtcblx0XHRcdFx0aWYgKGxpbmVhckhhbmRsZXMpXG5cdFx0XHRcdFx0bGluZWFySGFuZGxlcy5wdXNoKHNlZ21lbnQuX2hhbmRsZU91dCwgc2VnbWVudC5faGFuZGxlSW4pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VnbWVudCA9IHQgPCB0TWluXG5cdFx0XHRcdFx0PyBjdXJ2ZS5fc2VnbWVudDFcblx0XHRcdFx0XHQ6IHQgPiB0TWF4XG5cdFx0XHRcdFx0XHQ/IGN1cnZlLl9zZWdtZW50MlxuXHRcdFx0XHRcdFx0OiBjdXJ2ZS5nZXRQYXJ0TGVuZ3RoKDAsIHQpIDwgY3VydmUuZ2V0UGFydExlbmd0aCh0LCAxKVxuXHRcdFx0XHRcdFx0XHQ/IGN1cnZlLl9zZWdtZW50MVxuXHRcdFx0XHRcdFx0XHQ6IGN1cnZlLl9zZWdtZW50Mjtcblx0XHRcdH1cblx0XHRcdHNlZ21lbnQuX2ludGVyc2VjdGlvbiA9IGxvYy5nZXRJbnRlcnNlY3Rpb24oKTtcblx0XHRcdGxvYy5fc2VnbWVudCA9IHNlZ21lbnQ7XG5cdFx0XHRwcmV2ID0gbG9jO1xuXHRcdH1cblx0XHRpZiAobGluZWFySGFuZGxlcylcblx0XHRcdHJlc2V0TGluZWFyKCk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRXaW5kaW5nKHBvaW50LCBjdXJ2ZXMsIGhvcml6b250YWwsIHRlc3RDb250YWlucykge1xuXHRcdHZhciB0b2xlcmFuY2UgPSAwLjAwMDAwMSxcblx0XHRcdHRNaW4gPSB0b2xlcmFuY2UsXG5cdFx0XHR0TWF4ID0gMSAtIHRNaW4sXG5cdFx0XHRweCA9IHBvaW50LngsXG5cdFx0XHRweSA9IHBvaW50LnksXG5cdFx0XHR3aW5kTGVmdCA9IDAsXG5cdFx0XHR3aW5kUmlnaHQgPSAwLFxuXHRcdFx0cm9vdHMgPSBbXSxcblx0XHRcdGFicyA9IE1hdGguYWJzO1xuXHRcdGlmIChob3Jpem9udGFsKSB7XG5cdFx0XHR2YXIgeVRvcCA9IC1JbmZpbml0eSxcblx0XHRcdFx0eUJvdHRvbSA9IEluZmluaXR5LFxuXHRcdFx0XHR5QmVmb3JlID0gcHkgLSB0b2xlcmFuY2UsXG5cdFx0XHRcdHlBZnRlciA9IHB5ICsgdG9sZXJhbmNlO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciB2YWx1ZXMgPSBjdXJ2ZXNbaV0udmFsdWVzO1xuXHRcdFx0XHRpZiAoQ3VydmUuc29sdmVDdWJpYyh2YWx1ZXMsIDAsIHB4LCByb290cywgMCwgMSkgPiAwKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaiA9IHJvb3RzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG5cdFx0XHRcdFx0XHR2YXIgeSA9IEN1cnZlLmdldFBvaW50KHZhbHVlcywgcm9vdHNbal0pLnk7XG5cdFx0XHRcdFx0XHRpZiAoeSA8IHlCZWZvcmUgJiYgeSA+IHlUb3ApIHtcblx0XHRcdFx0XHRcdFx0eVRvcCA9IHk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHkgPiB5QWZ0ZXIgJiYgeSA8IHlCb3R0b20pIHtcblx0XHRcdFx0XHRcdFx0eUJvdHRvbSA9IHk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR5VG9wID0gKHlUb3AgKyBweSkgLyAyO1xuXHRcdFx0eUJvdHRvbSA9ICh5Qm90dG9tICsgcHkpIC8gMjtcblx0XHRcdGlmICh5VG9wID4gLUluZmluaXR5KVxuXHRcdFx0XHR3aW5kTGVmdCA9IGdldFdpbmRpbmcobmV3IFBvaW50KHB4LCB5VG9wKSwgY3VydmVzKTtcblx0XHRcdGlmICh5Qm90dG9tIDwgSW5maW5pdHkpXG5cdFx0XHRcdHdpbmRSaWdodCA9IGdldFdpbmRpbmcobmV3IFBvaW50KHB4LCB5Qm90dG9tKSwgY3VydmVzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHhCZWZvcmUgPSBweCAtIHRvbGVyYW5jZSxcblx0XHRcdFx0eEFmdGVyID0gcHggKyB0b2xlcmFuY2U7XG5cdFx0XHR2YXIgc3RhcnRDb3VudGVkID0gZmFsc2UsXG5cdFx0XHRcdHByZXZDdXJ2ZSxcblx0XHRcdFx0cHJldlQ7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGN1cnZlID0gY3VydmVzW2ldLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGN1cnZlLnZhbHVlcyxcblx0XHRcdFx0XHR3aW5kaW5nID0gY3VydmUud2luZGluZztcblx0XHRcdFx0aWYgKHdpbmRpbmcgJiYgKHdpbmRpbmcgPT09IDFcblx0XHRcdFx0XHRcdCYmIHB5ID49IHZhbHVlc1sxXSAmJiBweSA8PSB2YWx1ZXNbN11cblx0XHRcdFx0XHRcdHx8IHB5ID49IHZhbHVlc1s3XSAmJiBweSA8PSB2YWx1ZXNbMV0pXG5cdFx0XHRcdFx0JiYgQ3VydmUuc29sdmVDdWJpYyh2YWx1ZXMsIDEsIHB5LCByb290cywgMCwgMSkgPT09IDEpIHtcblx0XHRcdFx0XHR2YXIgdCA9IHJvb3RzWzBdO1xuXHRcdFx0XHRcdGlmICghKFxuXHRcdFx0XHRcdFx0dCA+IHRNYXggJiYgc3RhcnRDb3VudGVkICYmIGN1cnZlLm5leHQgIT09IGN1cnZlc1tpICsgMV1cblx0XHRcdFx0XHRcdHx8IHQgPCB0TWluICYmIHByZXZUID4gdE1heFxuXHRcdFx0XHRcdFx0XHQmJiBjdXJ2ZS5wcmV2aW91cyA9PT0gcHJldkN1cnZlKSkge1xuXHRcdFx0XHRcdFx0dmFyIHggPSBDdXJ2ZS5nZXRQb2ludCh2YWx1ZXMsIHQpLngsXG5cdFx0XHRcdFx0XHRcdHNsb3BlID0gQ3VydmUuZ2V0VGFuZ2VudCh2YWx1ZXMsIHQpLnksXG5cdFx0XHRcdFx0XHRcdGNvdW50ZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGlmIChOdW1lcmljYWwuaXNaZXJvKHNsb3BlKSAmJiAhQ3VydmUuaXNMaW5lYXIodmFsdWVzKVxuXHRcdFx0XHRcdFx0XHRcdHx8IHQgPCB0TWluICYmIHNsb3BlICogQ3VydmUuZ2V0VGFuZ2VudChcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnZlLnByZXZpb3VzLnZhbHVlcywgMSkueSA8IDBcblx0XHRcdFx0XHRcdFx0XHR8fCB0ID4gdE1heCAmJiBzbG9wZSAqIEN1cnZlLmdldFRhbmdlbnQoXG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJ2ZS5uZXh0LnZhbHVlcywgMCkueSA8IDApIHtcblx0XHRcdFx0XHRcdFx0aWYgKHRlc3RDb250YWlucyAmJiB4ID49IHhCZWZvcmUgJiYgeCA8PSB4QWZ0ZXIpIHtcblx0XHRcdFx0XHRcdFx0XHQrK3dpbmRMZWZ0O1xuXHRcdFx0XHRcdFx0XHRcdCsrd2luZFJpZ2h0O1xuXHRcdFx0XHRcdFx0XHRcdGNvdW50ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHggPD0geEJlZm9yZSkge1xuXHRcdFx0XHRcdFx0XHR3aW5kTGVmdCArPSB3aW5kaW5nO1xuXHRcdFx0XHRcdFx0XHRjb3VudGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoeCA+PSB4QWZ0ZXIpIHtcblx0XHRcdFx0XHRcdFx0d2luZFJpZ2h0ICs9IHdpbmRpbmc7XG5cdFx0XHRcdFx0XHRcdGNvdW50ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGN1cnZlLnByZXZpb3VzICE9PSBjdXJ2ZXNbaSAtIDFdKVxuXHRcdFx0XHRcdFx0XHRzdGFydENvdW50ZWQgPSB0IDwgdE1pbiAmJiBjb3VudGVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwcmV2Q3VydmUgPSBjdXJ2ZTtcblx0XHRcdFx0XHRwcmV2VCA9IHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIE1hdGgubWF4KGFicyh3aW5kTGVmdCksIGFicyh3aW5kUmlnaHQpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHRyYWNlUGF0aHMoc2VnbWVudHMsIG9wZXJhdG9yLCBzZWxmT3ApIHtcblx0XHR2YXIgcGF0aHMgPSBbXSxcblx0XHRcdHRNaW4gPSAwLjAwMDAwMSxcblx0XHRcdHRNYXggPSAxIC0gdE1pbjtcblx0XHRmb3IgKHZhciBpID0gMCwgc2VnLCBzdGFydFNlZywgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0c2VnID0gc3RhcnRTZWcgPSBzZWdtZW50c1tpXTtcblx0XHRcdGlmIChzZWcuX3Zpc2l0ZWQgfHwgIW9wZXJhdG9yKHNlZy5fd2luZGluZykpXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0dmFyIHBhdGggPSBuZXcgUGF0aChJdGVtLk5PX0lOU0VSVCksXG5cdFx0XHRcdGludGVyID0gc2VnLl9pbnRlcnNlY3Rpb24sXG5cdFx0XHRcdHN0YXJ0SW50ZXJTZWcgPSBpbnRlciAmJiBpbnRlci5fc2VnbWVudCxcblx0XHRcdFx0YWRkZWQgPSBmYWxzZSxcblx0XHRcdFx0ZGlyID0gMTtcblx0XHRcdGRvIHtcblx0XHRcdFx0dmFyIGhhbmRsZUluID0gZGlyID4gMCA/IHNlZy5faGFuZGxlSW4gOiBzZWcuX2hhbmRsZU91dCxcblx0XHRcdFx0XHRoYW5kbGVPdXQgPSBkaXIgPiAwID8gc2VnLl9oYW5kbGVPdXQgOiBzZWcuX2hhbmRsZUluLFxuXHRcdFx0XHRcdGludGVyU2VnO1xuXHRcdFx0XHRpZiAoYWRkZWQgJiYgKCFvcGVyYXRvcihzZWcuX3dpbmRpbmcpIHx8IHNlbGZPcClcblx0XHRcdFx0XHRcdCYmIChpbnRlciA9IHNlZy5faW50ZXJzZWN0aW9uKVxuXHRcdFx0XHRcdFx0JiYgKGludGVyU2VnID0gaW50ZXIuX3NlZ21lbnQpXG5cdFx0XHRcdFx0XHQmJiBpbnRlclNlZyAhPT0gc3RhcnRTZWcpIHtcblx0XHRcdFx0XHRpZiAoc2VsZk9wKSB7XG5cdFx0XHRcdFx0XHRzZWcuX3Zpc2l0ZWQgPSBpbnRlclNlZy5fdmlzaXRlZDtcblx0XHRcdFx0XHRcdHNlZyA9IGludGVyU2VnO1xuXHRcdFx0XHRcdFx0ZGlyID0gMTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFyIGMxID0gc2VnLmdldEN1cnZlKCk7XG5cdFx0XHRcdFx0XHRpZiAoZGlyID4gMClcblx0XHRcdFx0XHRcdFx0YzEgPSBjMS5nZXRQcmV2aW91cygpO1xuXHRcdFx0XHRcdFx0dmFyIHQxID0gYzEuZ2V0VGFuZ2VudEF0KGRpciA8IDEgPyB0TWluIDogdE1heCwgdHJ1ZSksXG5cdFx0XHRcdFx0XHRcdGM0ID0gaW50ZXJTZWcuZ2V0Q3VydmUoKSxcblx0XHRcdFx0XHRcdFx0YzMgPSBjNC5nZXRQcmV2aW91cygpLFxuXHRcdFx0XHRcdFx0XHR0MyA9IGMzLmdldFRhbmdlbnRBdCh0TWF4LCB0cnVlKSxcblx0XHRcdFx0XHRcdFx0dDQgPSBjNC5nZXRUYW5nZW50QXQodE1pbiwgdHJ1ZSksXG5cdFx0XHRcdFx0XHRcdHczID0gdDEuY3Jvc3ModDMpLFxuXHRcdFx0XHRcdFx0XHR3NCA9IHQxLmNyb3NzKHQ0KTtcblx0XHRcdFx0XHRcdGlmICh3MyAqIHc0ICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBjdXJ2ZSA9IHczIDwgdzQgPyBjMyA6IGM0LFxuXHRcdFx0XHRcdFx0XHRcdG5leHRDdXJ2ZSA9IG9wZXJhdG9yKGN1cnZlLl9zZWdtZW50MS5fd2luZGluZylcblx0XHRcdFx0XHRcdFx0XHRcdD8gY3VydmVcblx0XHRcdFx0XHRcdFx0XHRcdDogdzMgPCB3NCA/IGM0IDogYzMsXG5cdFx0XHRcdFx0XHRcdFx0bmV4dFNlZyA9IG5leHRDdXJ2ZS5fc2VnbWVudDE7XG5cdFx0XHRcdFx0XHRcdGRpciA9IG5leHRDdXJ2ZSA9PT0gYzMgPyAtMSA6IDE7XG5cdFx0XHRcdFx0XHRcdGlmIChuZXh0U2VnLl92aXNpdGVkICYmIHNlZy5fcGF0aCAhPT0gbmV4dFNlZy5fcGF0aFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR8fCAhb3BlcmF0b3IobmV4dFNlZy5fd2luZGluZykpIHtcblx0XHRcdFx0XHRcdFx0XHRkaXIgPSAxO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHNlZy5fdmlzaXRlZCA9IGludGVyU2VnLl92aXNpdGVkO1xuXHRcdFx0XHRcdFx0XHRcdHNlZyA9IGludGVyU2VnO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChuZXh0U2VnLl92aXNpdGVkKVxuXHRcdFx0XHRcdFx0XHRcdFx0ZGlyID0gMTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZGlyID0gMTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aGFuZGxlT3V0ID0gZGlyID4gMCA/IHNlZy5faGFuZGxlT3V0IDogc2VnLl9oYW5kbGVJbjtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYXRoLmFkZChuZXcgU2VnbWVudChzZWcuX3BvaW50LCBhZGRlZCAmJiBoYW5kbGVJbiwgaGFuZGxlT3V0KSk7XG5cdFx0XHRcdGFkZGVkID0gdHJ1ZTtcblx0XHRcdFx0c2VnLl92aXNpdGVkID0gdHJ1ZTtcblx0XHRcdFx0c2VnID0gZGlyID4gMCA/IHNlZy5nZXROZXh0KCkgOiBzZWcuIGdldFByZXZpb3VzKCk7XG5cdFx0XHR9IHdoaWxlIChzZWcgJiYgIXNlZy5fdmlzaXRlZFxuXHRcdFx0XHRcdCYmIHNlZyAhPT0gc3RhcnRTZWcgJiYgc2VnICE9PSBzdGFydEludGVyU2VnXG5cdFx0XHRcdFx0JiYgKHNlZy5faW50ZXJzZWN0aW9uIHx8IG9wZXJhdG9yKHNlZy5fd2luZGluZykpKTtcblx0XHRcdGlmIChzZWcgJiYgKHNlZyA9PT0gc3RhcnRTZWcgfHwgc2VnID09PSBzdGFydEludGVyU2VnKSkge1xuXHRcdFx0XHRwYXRoLmZpcnN0U2VnbWVudC5zZXRIYW5kbGVJbigoc2VnID09PSBzdGFydEludGVyU2VnXG5cdFx0XHRcdFx0XHQ/IHN0YXJ0SW50ZXJTZWcgOiBzZWcpLl9oYW5kbGVJbik7XG5cdFx0XHRcdHBhdGguc2V0Q2xvc2VkKHRydWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGF0aC5sYXN0U2VnbWVudC5faGFuZGxlT3V0LnNldCgwLCAwKTtcblx0XHRcdH1cblx0XHRcdGlmIChwYXRoLl9zZWdtZW50cy5sZW5ndGggPlxuXHRcdFx0XHRcdChwYXRoLl9jbG9zZWQgPyBwYXRoLmlzTGluZWFyKCkgPyAyIDogMCA6IDEpKVxuXHRcdFx0XHRwYXRocy5wdXNoKHBhdGgpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGF0aHM7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdF9nZXRXaW5kaW5nOiBmdW5jdGlvbihwb2ludCwgaG9yaXpvbnRhbCwgdGVzdENvbnRhaW5zKSB7XG5cdFx0XHRyZXR1cm4gZ2V0V2luZGluZyhwb2ludCwgdGhpcy5fZ2V0TW9ub0N1cnZlcygpLFxuXHRcdFx0XHRcdGhvcml6b250YWwsIHRlc3RDb250YWlucyk7XG5cdFx0fSxcblxuXHRcdHVuaXRlOiBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRyZXR1cm4gY29tcHV0ZUJvb2xlYW4odGhpcywgcGF0aCwgJ3VuaXRlJyk7XG5cdFx0fSxcblxuXHRcdGludGVyc2VjdDogZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0cmV0dXJuIGNvbXB1dGVCb29sZWFuKHRoaXMsIHBhdGgsICdpbnRlcnNlY3QnKTtcblx0XHR9LFxuXG5cdFx0c3VidHJhY3Q6IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHRcdHJldHVybiBjb21wdXRlQm9vbGVhbih0aGlzLCBwYXRoLCAnc3VidHJhY3QnKTtcblx0XHR9LFxuXG5cdFx0ZXhjbHVkZTogZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0cmV0dXJuIGNvbXB1dGVCb29sZWFuKHRoaXMsIHBhdGgsICdleGNsdWRlJyk7XG5cdFx0fSxcblxuXHRcdGRpdmlkZTogZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0cmV0dXJuIG5ldyBHcm91cChbdGhpcy5zdWJ0cmFjdChwYXRoKSwgdGhpcy5pbnRlcnNlY3QocGF0aCldKTtcblx0XHR9XG5cdH07XG59KTtcblxuUGF0aC5pbmplY3Qoe1xuXHRfZ2V0TW9ub0N1cnZlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1vbm9DdXJ2ZXMgPSB0aGlzLl9tb25vQ3VydmVzLFxuXHRcdFx0cHJldkN1cnZlO1xuXG5cdFx0ZnVuY3Rpb24gaW5zZXJ0Q3VydmUodikge1xuXHRcdFx0dmFyIHkwID0gdlsxXSxcblx0XHRcdFx0eTEgPSB2WzddLFxuXHRcdFx0XHRjdXJ2ZSA9IHtcblx0XHRcdFx0XHR2YWx1ZXM6IHYsXG5cdFx0XHRcdFx0d2luZGluZzogeTAgPT09IHkxXG5cdFx0XHRcdFx0XHQ/IDBcblx0XHRcdFx0XHRcdDogeTAgPiB5MVxuXHRcdFx0XHRcdFx0XHQ/IC0xXG5cdFx0XHRcdFx0XHRcdDogMSxcblx0XHRcdFx0XHRwcmV2aW91czogcHJldkN1cnZlLFxuXHRcdFx0XHRcdG5leHQ6IG51bGxcblx0XHRcdFx0fTtcblx0XHRcdGlmIChwcmV2Q3VydmUpXG5cdFx0XHRcdHByZXZDdXJ2ZS5uZXh0ID0gY3VydmU7XG5cdFx0XHRtb25vQ3VydmVzLnB1c2goY3VydmUpO1xuXHRcdFx0cHJldkN1cnZlID0gY3VydmU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlQ3VydmUodikge1xuXHRcdFx0aWYgKEN1cnZlLmdldExlbmd0aCh2KSA9PT0gMClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dmFyIHkwID0gdlsxXSxcblx0XHRcdFx0eTEgPSB2WzNdLFxuXHRcdFx0XHR5MiA9IHZbNV0sXG5cdFx0XHRcdHkzID0gdls3XTtcblx0XHRcdGlmIChDdXJ2ZS5pc0xpbmVhcih2KSkge1xuXHRcdFx0XHRpbnNlcnRDdXJ2ZSh2KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBhID0gMyAqICh5MSAtIHkyKSAtIHkwICsgeTMsXG5cdFx0XHRcdFx0YiA9IDIgKiAoeTAgKyB5MikgLSA0ICogeTEsXG5cdFx0XHRcdFx0YyA9IHkxIC0geTAsXG5cdFx0XHRcdFx0dG9sZXJhbmNlID0gMC4wMDAwMDEsXG5cdFx0XHRcdFx0cm9vdHMgPSBbXTtcblx0XHRcdFx0dmFyIGNvdW50ID0gTnVtZXJpY2FsLnNvbHZlUXVhZHJhdGljKGEsIGIsIGMsIHJvb3RzLCB0b2xlcmFuY2UsXG5cdFx0XHRcdFx0XHQxIC0gdG9sZXJhbmNlKTtcblx0XHRcdFx0aWYgKGNvdW50ID09PSAwKSB7XG5cdFx0XHRcdFx0aW5zZXJ0Q3VydmUodik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cm9vdHMuc29ydCgpO1xuXHRcdFx0XHRcdHZhciB0ID0gcm9vdHNbMF0sXG5cdFx0XHRcdFx0XHRwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh2LCB0KTtcblx0XHRcdFx0XHRpbnNlcnRDdXJ2ZShwYXJ0c1swXSk7XG5cdFx0XHRcdFx0aWYgKGNvdW50ID4gMSkge1xuXHRcdFx0XHRcdFx0dCA9IChyb290c1sxXSAtIHQpIC8gKDEgLSB0KTtcblx0XHRcdFx0XHRcdHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHBhcnRzWzFdLCB0KTtcblx0XHRcdFx0XHRcdGluc2VydEN1cnZlKHBhcnRzWzBdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aW5zZXJ0Q3VydmUocGFydHNbMV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFtb25vQ3VydmVzKSB7XG5cdFx0XHRtb25vQ3VydmVzID0gdGhpcy5fbW9ub0N1cnZlcyA9IFtdO1xuXHRcdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCksXG5cdFx0XHRcdHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGhhbmRsZUN1cnZlKGN1cnZlc1tpXS5nZXRWYWx1ZXMoKSk7XG5cdFx0XHRpZiAoIXRoaXMuX2Nsb3NlZCAmJiBzZWdtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdHZhciBwMSA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdLl9wb2ludCxcblx0XHRcdFx0XHRwMiA9IHNlZ21lbnRzWzBdLl9wb2ludCxcblx0XHRcdFx0XHRwMXggPSBwMS5feCwgcDF5ID0gcDEuX3ksXG5cdFx0XHRcdFx0cDJ4ID0gcDIuX3gsIHAyeSA9IHAyLl95O1xuXHRcdFx0XHRoYW5kbGVDdXJ2ZShbcDF4LCBwMXksIHAxeCwgcDF5LCBwMngsIHAyeSwgcDJ4LCBwMnldKTtcblx0XHRcdH1cblx0XHRcdGlmIChtb25vQ3VydmVzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0dmFyIGZpcnN0ID0gbW9ub0N1cnZlc1swXSxcblx0XHRcdFx0XHRsYXN0ID0gbW9ub0N1cnZlc1ttb25vQ3VydmVzLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRmaXJzdC5wcmV2aW91cyA9IGxhc3Q7XG5cdFx0XHRcdGxhc3QubmV4dCA9IGZpcnN0O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbW9ub0N1cnZlcztcblx0fSxcblxuXHRnZXRJbnRlcmlvclBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKSxcblx0XHRcdHBvaW50ID0gYm91bmRzLmdldENlbnRlcih0cnVlKTtcblx0XHRpZiAoIXRoaXMuY29udGFpbnMocG9pbnQpKSB7XG5cdFx0XHR2YXIgY3VydmVzID0gdGhpcy5fZ2V0TW9ub0N1cnZlcygpLFxuXHRcdFx0XHRyb290cyA9IFtdLFxuXHRcdFx0XHR5ID0gcG9pbnQueSxcblx0XHRcdFx0eEludGVyY2VwdHMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgdmFsdWVzID0gY3VydmVzW2ldLnZhbHVlcztcblx0XHRcdFx0aWYgKChjdXJ2ZXNbaV0ud2luZGluZyA9PT0gMVxuXHRcdFx0XHRcdFx0JiYgeSA+PSB2YWx1ZXNbMV0gJiYgeSA8PSB2YWx1ZXNbN11cblx0XHRcdFx0XHRcdHx8IHkgPj0gdmFsdWVzWzddICYmIHkgPD0gdmFsdWVzWzFdKVxuXHRcdFx0XHRcdFx0JiYgQ3VydmUuc29sdmVDdWJpYyh2YWx1ZXMsIDEsIHksIHJvb3RzLCAwLCAxKSA+IDApIHtcblx0XHRcdFx0XHRmb3IgKHZhciBqID0gcm9vdHMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pXG5cdFx0XHRcdFx0XHR4SW50ZXJjZXB0cy5wdXNoKEN1cnZlLmdldFBvaW50KHZhbHVlcywgcm9vdHNbal0pLngpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh4SW50ZXJjZXB0cy5sZW5ndGggPiAxKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0cG9pbnQueCA9ICh4SW50ZXJjZXB0c1swXSArIHhJbnRlcmNlcHRzWzFdKSAvIDI7XG5cdFx0fVxuXHRcdHJldHVybiBwb2ludDtcblx0fSxcblxuXHRyZW9yaWVudDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zZXRDbG9ja3dpc2UodHJ1ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pO1xuXG5Db21wb3VuZFBhdGguaW5qZWN0KHtcblx0X2dldE1vbm9DdXJ2ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuXHRcdFx0bW9ub0N1cnZlcyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0bW9ub0N1cnZlcy5wdXNoLmFwcGx5KG1vbm9DdXJ2ZXMsIGNoaWxkcmVuW2ldLl9nZXRNb25vQ3VydmVzKCkpO1xuXHRcdHJldHVybiBtb25vQ3VydmVzO1xuXHR9LFxuXG5cdHJlb3JpZW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLnJlbW92ZUNoaWxkcmVuKCkuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYi5nZXRCb3VuZHMoKS5nZXRBcmVhKCkgLSBhLmdldEJvdW5kcygpLmdldEFyZWEoKTtcblx0XHR9KTtcblx0XHRpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuXHRcdFx0dGhpcy5hZGRDaGlsZHJlbihjaGlsZHJlbik7XG5cdFx0XHR2YXIgY2xvY2t3aXNlID0gY2hpbGRyZW5bMF0uaXNDbG9ja3dpc2UoKTtcblx0XHRcdGZvciAodmFyIGkgPSAxLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBwb2ludCA9IGNoaWxkcmVuW2ldLmdldEludGVyaW9yUG9pbnQoKSxcblx0XHRcdFx0XHRjb3VudGVycyA9IDA7XG5cdFx0XHRcdGZvciAodmFyIGogPSBpIC0gMTsgaiA+PSAwOyBqLS0pIHtcblx0XHRcdFx0XHRpZiAoY2hpbGRyZW5bal0uY29udGFpbnMocG9pbnQpKVxuXHRcdFx0XHRcdFx0Y291bnRlcnMrKztcblx0XHRcdFx0fVxuXHRcdFx0XHRjaGlsZHJlbltpXS5zZXRDbG9ja3dpc2UoY291bnRlcnMgJSAyID09PSAwICYmIGNsb2Nrd2lzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59KTtcblxudmFyIFBhdGhJdGVyYXRvciA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnUGF0aEl0ZXJhdG9yJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbihwYXRoLCBtYXhSZWN1cnNpb24sIHRvbGVyYW5jZSwgbWF0cml4KSB7XG5cdFx0dmFyIGN1cnZlcyA9IFtdLFxuXHRcdFx0cGFydHMgPSBbXSxcblx0XHRcdGxlbmd0aCA9IDAsXG5cdFx0XHRtaW5EaWZmZXJlbmNlID0gMSAvIChtYXhSZWN1cnNpb24gfHwgMzIpLFxuXHRcdFx0c2VnbWVudHMgPSBwYXRoLl9zZWdtZW50cyxcblx0XHRcdHNlZ21lbnQxID0gc2VnbWVudHNbMF0sXG5cdFx0XHRzZWdtZW50MjtcblxuXHRcdGZ1bmN0aW9uIGFkZEN1cnZlKHNlZ21lbnQxLCBzZWdtZW50Mikge1xuXHRcdFx0dmFyIGN1cnZlID0gQ3VydmUuZ2V0VmFsdWVzKHNlZ21lbnQxLCBzZWdtZW50MiwgbWF0cml4KTtcblx0XHRcdGN1cnZlcy5wdXNoKGN1cnZlKTtcblx0XHRcdGNvbXB1dGVQYXJ0cyhjdXJ2ZSwgc2VnbWVudDEuX2luZGV4LCAwLCAxKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjb21wdXRlUGFydHMoY3VydmUsIGluZGV4LCBtaW5ULCBtYXhUKSB7XG5cdFx0XHRpZiAoKG1heFQgLSBtaW5UKSA+IG1pbkRpZmZlcmVuY2Vcblx0XHRcdFx0XHQmJiAhQ3VydmUuaXNGbGF0RW5vdWdoKGN1cnZlLCB0b2xlcmFuY2UgfHwgMC4yNSkpIHtcblx0XHRcdFx0dmFyIHNwbGl0ID0gQ3VydmUuc3ViZGl2aWRlKGN1cnZlKSxcblx0XHRcdFx0XHRoYWxmVCA9IChtaW5UICsgbWF4VCkgLyAyO1xuXHRcdFx0XHRjb21wdXRlUGFydHMoc3BsaXRbMF0sIGluZGV4LCBtaW5ULCBoYWxmVCk7XG5cdFx0XHRcdGNvbXB1dGVQYXJ0cyhzcGxpdFsxXSwgaW5kZXgsIGhhbGZULCBtYXhUKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciB4ID0gY3VydmVbNl0gLSBjdXJ2ZVswXSxcblx0XHRcdFx0XHR5ID0gY3VydmVbN10gLSBjdXJ2ZVsxXSxcblx0XHRcdFx0XHRkaXN0ID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXHRcdFx0XHRpZiAoZGlzdCA+IDAuMDAwMDAxKSB7XG5cdFx0XHRcdFx0bGVuZ3RoICs9IGRpc3Q7XG5cdFx0XHRcdFx0cGFydHMucHVzaCh7XG5cdFx0XHRcdFx0XHRvZmZzZXQ6IGxlbmd0aCxcblx0XHRcdFx0XHRcdHZhbHVlOiBtYXhULFxuXHRcdFx0XHRcdFx0aW5kZXg6IGluZGV4XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMSwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0c2VnbWVudDIgPSBzZWdtZW50c1tpXTtcblx0XHRcdGFkZEN1cnZlKHNlZ21lbnQxLCBzZWdtZW50Mik7XG5cdFx0XHRzZWdtZW50MSA9IHNlZ21lbnQyO1xuXHRcdH1cblx0XHRpZiAocGF0aC5fY2xvc2VkKVxuXHRcdFx0YWRkQ3VydmUoc2VnbWVudDIsIHNlZ21lbnRzWzBdKTtcblxuXHRcdHRoaXMuY3VydmVzID0gY3VydmVzO1xuXHRcdHRoaXMucGFydHMgPSBwYXJ0cztcblx0XHR0aGlzLmxlbmd0aCA9IGxlbmd0aDtcblx0XHR0aGlzLmluZGV4ID0gMDtcblx0fSxcblxuXHRnZXRQYXJhbWV0ZXJBdDogZnVuY3Rpb24ob2Zmc2V0KSB7XG5cdFx0dmFyIGksIGogPSB0aGlzLmluZGV4O1xuXHRcdGZvciAoOzspIHtcblx0XHRcdGkgPSBqO1xuXHRcdFx0aWYgKGogPT0gMCB8fCB0aGlzLnBhcnRzWy0tal0ub2Zmc2V0IDwgb2Zmc2V0KVxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdFx0Zm9yICh2YXIgbCA9IHRoaXMucGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgcGFydCA9IHRoaXMucGFydHNbaV07XG5cdFx0XHRpZiAocGFydC5vZmZzZXQgPj0gb2Zmc2V0KSB7XG5cdFx0XHRcdHRoaXMuaW5kZXggPSBpO1xuXHRcdFx0XHR2YXIgcHJldiA9IHRoaXMucGFydHNbaSAtIDFdO1xuXHRcdFx0XHR2YXIgcHJldlZhbCA9IHByZXYgJiYgcHJldi5pbmRleCA9PSBwYXJ0LmluZGV4ID8gcHJldi52YWx1ZSA6IDAsXG5cdFx0XHRcdFx0cHJldkxlbiA9IHByZXYgPyBwcmV2Lm9mZnNldCA6IDA7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dmFsdWU6IHByZXZWYWwgKyAocGFydC52YWx1ZSAtIHByZXZWYWwpXG5cdFx0XHRcdFx0XHQqIChvZmZzZXQgLSBwcmV2TGVuKSAvIChwYXJ0Lm9mZnNldCAtIHByZXZMZW4pLFxuXHRcdFx0XHRcdGluZGV4OiBwYXJ0LmluZGV4XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBwYXJ0ID0gdGhpcy5wYXJ0c1t0aGlzLnBhcnRzLmxlbmd0aCAtIDFdO1xuXHRcdHJldHVybiB7XG5cdFx0XHR2YWx1ZTogMSxcblx0XHRcdGluZGV4OiBwYXJ0LmluZGV4XG5cdFx0fTtcblx0fSxcblxuXHRkcmF3UGFydDogZnVuY3Rpb24oY3R4LCBmcm9tLCB0bykge1xuXHRcdGZyb20gPSB0aGlzLmdldFBhcmFtZXRlckF0KGZyb20pO1xuXHRcdHRvID0gdGhpcy5nZXRQYXJhbWV0ZXJBdCh0byk7XG5cdFx0Zm9yICh2YXIgaSA9IGZyb20uaW5kZXg7IGkgPD0gdG8uaW5kZXg7IGkrKykge1xuXHRcdFx0dmFyIGN1cnZlID0gQ3VydmUuZ2V0UGFydCh0aGlzLmN1cnZlc1tpXSxcblx0XHRcdFx0XHRpID09IGZyb20uaW5kZXggPyBmcm9tLnZhbHVlIDogMCxcblx0XHRcdFx0XHRpID09IHRvLmluZGV4ID8gdG8udmFsdWUgOiAxKTtcblx0XHRcdGlmIChpID09IGZyb20uaW5kZXgpXG5cdFx0XHRcdGN0eC5tb3ZlVG8oY3VydmVbMF0sIGN1cnZlWzFdKTtcblx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvLmFwcGx5KGN0eCwgY3VydmUuc2xpY2UoMikpO1xuXHRcdH1cblx0fVxufSwgQmFzZS5lYWNoKEN1cnZlLmV2YWx1YXRlTWV0aG9kcyxcblx0ZnVuY3Rpb24obmFtZSkge1xuXHRcdHRoaXNbbmFtZSArICdBdCddID0gZnVuY3Rpb24ob2Zmc2V0LCB3ZWlnaHRlZCkge1xuXHRcdFx0dmFyIHBhcmFtID0gdGhpcy5nZXRQYXJhbWV0ZXJBdChvZmZzZXQpO1xuXHRcdFx0cmV0dXJuIEN1cnZlW25hbWVdKHRoaXMuY3VydmVzW3BhcmFtLmluZGV4XSwgcGFyYW0udmFsdWUsIHdlaWdodGVkKTtcblx0XHR9O1xuXHR9LCB7fSlcbik7XG5cbnZhciBQYXRoRml0dGVyID0gQmFzZS5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbihwYXRoLCBlcnJvcikge1xuXHRcdHZhciBwb2ludHMgPSB0aGlzLnBvaW50cyA9IFtdLFxuXHRcdFx0c2VnbWVudHMgPSBwYXRoLl9zZWdtZW50cyxcblx0XHRcdHByZXY7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBwb2ludCA9IHNlZ21lbnRzW2ldLnBvaW50LmNsb25lKCk7XG5cdFx0XHRpZiAoIXByZXYgfHwgIXByZXYuZXF1YWxzKHBvaW50KSkge1xuXHRcdFx0XHRwb2ludHMucHVzaChwb2ludCk7XG5cdFx0XHRcdHByZXYgPSBwb2ludDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAocGF0aC5fY2xvc2VkKSB7XG5cdFx0XHR0aGlzLmNsb3NlZCA9IHRydWU7XG5cdFx0XHRwb2ludHMudW5zaGlmdChwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdKTtcblx0XHRcdHBvaW50cy5wdXNoKHBvaW50c1sxXSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5lcnJvciA9IGVycm9yO1xuXHR9LFxuXG5cdGZpdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzLFxuXHRcdFx0bGVuZ3RoID0gcG9pbnRzLmxlbmd0aCxcblx0XHRcdHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cyA9IGxlbmd0aCA+IDBcblx0XHRcdFx0XHQ/IFtuZXcgU2VnbWVudChwb2ludHNbMF0pXSA6IFtdO1xuXHRcdGlmIChsZW5ndGggPiAxKVxuXHRcdFx0dGhpcy5maXRDdWJpYygwLCBsZW5ndGggLSAxLFxuXHRcdFx0XHRwb2ludHNbMV0uc3VidHJhY3QocG9pbnRzWzBdKS5ub3JtYWxpemUoKSxcblx0XHRcdFx0cG9pbnRzW2xlbmd0aCAtIDJdLnN1YnRyYWN0KHBvaW50c1tsZW5ndGggLSAxXSkubm9ybWFsaXplKCkpO1xuXG5cdFx0aWYgKHRoaXMuY2xvc2VkKSB7XG5cdFx0XHRzZWdtZW50cy5zaGlmdCgpO1xuXHRcdFx0c2VnbWVudHMucG9wKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNlZ21lbnRzO1xuXHR9LFxuXG5cdGZpdEN1YmljOiBmdW5jdGlvbihmaXJzdCwgbGFzdCwgdGFuMSwgdGFuMikge1xuXHRcdGlmIChsYXN0IC0gZmlyc3QgPT0gMSkge1xuXHRcdFx0dmFyIHB0MSA9IHRoaXMucG9pbnRzW2ZpcnN0XSxcblx0XHRcdFx0cHQyID0gdGhpcy5wb2ludHNbbGFzdF0sXG5cdFx0XHRcdGRpc3QgPSBwdDEuZ2V0RGlzdGFuY2UocHQyKSAvIDM7XG5cdFx0XHR0aGlzLmFkZEN1cnZlKFtwdDEsIHB0MS5hZGQodGFuMS5ub3JtYWxpemUoZGlzdCkpLFxuXHRcdFx0XHRcdHB0Mi5hZGQodGFuMi5ub3JtYWxpemUoZGlzdCkpLCBwdDJdKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIHVQcmltZSA9IHRoaXMuY2hvcmRMZW5ndGhQYXJhbWV0ZXJpemUoZmlyc3QsIGxhc3QpLFxuXHRcdFx0bWF4RXJyb3IgPSBNYXRoLm1heCh0aGlzLmVycm9yLCB0aGlzLmVycm9yICogdGhpcy5lcnJvciksXG5cdFx0XHRzcGxpdCxcblx0XHRcdHBhcmFtZXRlcnNJbk9yZGVyID0gdHJ1ZTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8PSA0OyBpKyspIHtcblx0XHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2VuZXJhdGVCZXppZXIoZmlyc3QsIGxhc3QsIHVQcmltZSwgdGFuMSwgdGFuMik7XG5cdFx0XHR2YXIgbWF4ID0gdGhpcy5maW5kTWF4RXJyb3IoZmlyc3QsIGxhc3QsIGN1cnZlLCB1UHJpbWUpO1xuXHRcdFx0aWYgKG1heC5lcnJvciA8IHRoaXMuZXJyb3IgJiYgcGFyYW1ldGVyc0luT3JkZXIpIHtcblx0XHRcdFx0dGhpcy5hZGRDdXJ2ZShjdXJ2ZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHNwbGl0ID0gbWF4LmluZGV4O1xuXHRcdFx0aWYgKG1heC5lcnJvciA+PSBtYXhFcnJvcilcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRwYXJhbWV0ZXJzSW5PcmRlciA9IHRoaXMucmVwYXJhbWV0ZXJpemUoZmlyc3QsIGxhc3QsIHVQcmltZSwgY3VydmUpO1xuXHRcdFx0bWF4RXJyb3IgPSBtYXguZXJyb3I7XG5cdFx0fVxuXHRcdHZhciBWMSA9IHRoaXMucG9pbnRzW3NwbGl0IC0gMV0uc3VidHJhY3QodGhpcy5wb2ludHNbc3BsaXRdKSxcblx0XHRcdFYyID0gdGhpcy5wb2ludHNbc3BsaXRdLnN1YnRyYWN0KHRoaXMucG9pbnRzW3NwbGl0ICsgMV0pLFxuXHRcdFx0dGFuQ2VudGVyID0gVjEuYWRkKFYyKS5kaXZpZGUoMikubm9ybWFsaXplKCk7XG5cdFx0dGhpcy5maXRDdWJpYyhmaXJzdCwgc3BsaXQsIHRhbjEsIHRhbkNlbnRlcik7XG5cdFx0dGhpcy5maXRDdWJpYyhzcGxpdCwgbGFzdCwgdGFuQ2VudGVyLm5lZ2F0ZSgpLCB0YW4yKTtcblx0fSxcblxuXHRhZGRDdXJ2ZTogZnVuY3Rpb24oY3VydmUpIHtcblx0XHR2YXIgcHJldiA9IHRoaXMuc2VnbWVudHNbdGhpcy5zZWdtZW50cy5sZW5ndGggLSAxXTtcblx0XHRwcmV2LnNldEhhbmRsZU91dChjdXJ2ZVsxXS5zdWJ0cmFjdChjdXJ2ZVswXSkpO1xuXHRcdHRoaXMuc2VnbWVudHMucHVzaChcblx0XHRcdFx0bmV3IFNlZ21lbnQoY3VydmVbM10sIGN1cnZlWzJdLnN1YnRyYWN0KGN1cnZlWzNdKSkpO1xuXHR9LFxuXG5cdGdlbmVyYXRlQmV6aWVyOiBmdW5jdGlvbihmaXJzdCwgbGFzdCwgdVByaW1lLCB0YW4xLCB0YW4yKSB7XG5cdFx0dmFyIGVwc2lsb24gPSAxZS0xMixcblx0XHRcdHB0MSA9IHRoaXMucG9pbnRzW2ZpcnN0XSxcblx0XHRcdHB0MiA9IHRoaXMucG9pbnRzW2xhc3RdLFxuXHRcdFx0QyA9IFtbMCwgMF0sIFswLCAwXV0sXG5cdFx0XHRYID0gWzAsIDBdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsYXN0IC0gZmlyc3QgKyAxOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgdSA9IHVQcmltZVtpXSxcblx0XHRcdFx0dCA9IDEgLSB1LFxuXHRcdFx0XHRiID0gMyAqIHUgKiB0LFxuXHRcdFx0XHRiMCA9IHQgKiB0ICogdCxcblx0XHRcdFx0YjEgPSBiICogdCxcblx0XHRcdFx0YjIgPSBiICogdSxcblx0XHRcdFx0YjMgPSB1ICogdSAqIHUsXG5cdFx0XHRcdGExID0gdGFuMS5ub3JtYWxpemUoYjEpLFxuXHRcdFx0XHRhMiA9IHRhbjIubm9ybWFsaXplKGIyKSxcblx0XHRcdFx0dG1wID0gdGhpcy5wb2ludHNbZmlyc3QgKyBpXVxuXHRcdFx0XHRcdC5zdWJ0cmFjdChwdDEubXVsdGlwbHkoYjAgKyBiMSkpXG5cdFx0XHRcdFx0LnN1YnRyYWN0KHB0Mi5tdWx0aXBseShiMiArIGIzKSk7XG5cdFx0XHRDWzBdWzBdICs9IGExLmRvdChhMSk7XG5cdFx0XHRDWzBdWzFdICs9IGExLmRvdChhMik7XG5cdFx0XHRDWzFdWzBdID0gQ1swXVsxXTtcblx0XHRcdENbMV1bMV0gKz0gYTIuZG90KGEyKTtcblx0XHRcdFhbMF0gKz0gYTEuZG90KHRtcCk7XG5cdFx0XHRYWzFdICs9IGEyLmRvdCh0bXApO1xuXHRcdH1cblxuXHRcdHZhciBkZXRDMEMxID0gQ1swXVswXSAqIENbMV1bMV0gLSBDWzFdWzBdICogQ1swXVsxXSxcblx0XHRcdGFscGhhMSwgYWxwaGEyO1xuXHRcdGlmIChNYXRoLmFicyhkZXRDMEMxKSA+IGVwc2lsb24pIHtcblx0XHRcdHZhciBkZXRDMFhcdD0gQ1swXVswXSAqIFhbMV1cdC0gQ1sxXVswXSAqIFhbMF0sXG5cdFx0XHRcdGRldFhDMVx0PSBYWzBdXHQgICogQ1sxXVsxXSAtIFhbMV1cdCAgKiBDWzBdWzFdO1xuXHRcdFx0YWxwaGExID0gZGV0WEMxIC8gZGV0QzBDMTtcblx0XHRcdGFscGhhMiA9IGRldEMwWCAvIGRldEMwQzE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBjMCA9IENbMF1bMF0gKyBDWzBdWzFdLFxuXHRcdFx0XHRjMSA9IENbMV1bMF0gKyBDWzFdWzFdO1xuXHRcdFx0aWYgKE1hdGguYWJzKGMwKSA+IGVwc2lsb24pIHtcblx0XHRcdFx0YWxwaGExID0gYWxwaGEyID0gWFswXSAvIGMwO1xuXHRcdFx0fSBlbHNlIGlmIChNYXRoLmFicyhjMSkgPiBlcHNpbG9uKSB7XG5cdFx0XHRcdGFscGhhMSA9IGFscGhhMiA9IFhbMV0gLyBjMTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFscGhhMSA9IGFscGhhMiA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIHNlZ0xlbmd0aCA9IHB0Mi5nZXREaXN0YW5jZShwdDEpLFxuXHRcdFx0ZXBzID0gZXBzaWxvbiAqIHNlZ0xlbmd0aCxcblx0XHRcdGhhbmRsZTEsXG5cdFx0XHRoYW5kbGUyO1xuXHRcdGlmIChhbHBoYTEgPCBlcHMgfHwgYWxwaGEyIDwgZXBzKSB7XG5cdFx0XHRhbHBoYTEgPSBhbHBoYTIgPSBzZWdMZW5ndGggLyAzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgbGluZSA9IHB0Mi5zdWJ0cmFjdChwdDEpO1xuXHRcdFx0aGFuZGxlMSA9IHRhbjEubm9ybWFsaXplKGFscGhhMSk7XG5cdFx0XHRoYW5kbGUyID0gdGFuMi5ub3JtYWxpemUoYWxwaGEyKTtcblx0XHRcdGlmIChoYW5kbGUxLmRvdChsaW5lKSAtIGhhbmRsZTIuZG90KGxpbmUpID4gc2VnTGVuZ3RoICogc2VnTGVuZ3RoKSB7XG5cdFx0XHRcdGFscGhhMSA9IGFscGhhMiA9IHNlZ0xlbmd0aCAvIDM7XG5cdFx0XHRcdGhhbmRsZTEgPSBoYW5kbGUyID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gW3B0MSwgcHQxLmFkZChoYW5kbGUxIHx8IHRhbjEubm9ybWFsaXplKGFscGhhMSkpLFxuXHRcdFx0XHRwdDIuYWRkKGhhbmRsZTIgfHwgdGFuMi5ub3JtYWxpemUoYWxwaGEyKSksIHB0Ml07XG5cdH0sXG5cblx0cmVwYXJhbWV0ZXJpemU6IGZ1bmN0aW9uKGZpcnN0LCBsYXN0LCB1LCBjdXJ2ZSkge1xuXHRcdGZvciAodmFyIGkgPSBmaXJzdDsgaSA8PSBsYXN0OyBpKyspIHtcblx0XHRcdHVbaSAtIGZpcnN0XSA9IHRoaXMuZmluZFJvb3QoY3VydmUsIHRoaXMucG9pbnRzW2ldLCB1W2kgLSBmaXJzdF0pO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMSwgbCA9IHUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAodVtpXSA8PSB1W2kgLSAxXSlcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRmaW5kUm9vdDogZnVuY3Rpb24oY3VydmUsIHBvaW50LCB1KSB7XG5cdFx0dmFyIGN1cnZlMSA9IFtdLFxuXHRcdFx0Y3VydmUyID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gMjsgaSsrKSB7XG5cdFx0XHRjdXJ2ZTFbaV0gPSBjdXJ2ZVtpICsgMV0uc3VidHJhY3QoY3VydmVbaV0pLm11bHRpcGx5KDMpO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8PSAxOyBpKyspIHtcblx0XHRcdGN1cnZlMltpXSA9IGN1cnZlMVtpICsgMV0uc3VidHJhY3QoY3VydmUxW2ldKS5tdWx0aXBseSgyKTtcblx0XHR9XG5cdFx0dmFyIHB0ID0gdGhpcy5ldmFsdWF0ZSgzLCBjdXJ2ZSwgdSksXG5cdFx0XHRwdDEgPSB0aGlzLmV2YWx1YXRlKDIsIGN1cnZlMSwgdSksXG5cdFx0XHRwdDIgPSB0aGlzLmV2YWx1YXRlKDEsIGN1cnZlMiwgdSksXG5cdFx0XHRkaWZmID0gcHQuc3VidHJhY3QocG9pbnQpLFxuXHRcdFx0ZGYgPSBwdDEuZG90KHB0MSkgKyBkaWZmLmRvdChwdDIpO1xuXHRcdGlmIChNYXRoLmFicyhkZikgPCAwLjAwMDAwMSlcblx0XHRcdHJldHVybiB1O1xuXHRcdHJldHVybiB1IC0gZGlmZi5kb3QocHQxKSAvIGRmO1xuXHR9LFxuXG5cdGV2YWx1YXRlOiBmdW5jdGlvbihkZWdyZWUsIGN1cnZlLCB0KSB7XG5cdFx0dmFyIHRtcCA9IGN1cnZlLnNsaWNlKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPD0gZGVncmVlOyBpKyspIHtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDw9IGRlZ3JlZSAtIGk7IGorKykge1xuXHRcdFx0XHR0bXBbal0gPSB0bXBbal0ubXVsdGlwbHkoMSAtIHQpLmFkZCh0bXBbaiArIDFdLm11bHRpcGx5KHQpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRtcFswXTtcblx0fSxcblxuXHRjaG9yZExlbmd0aFBhcmFtZXRlcml6ZTogZnVuY3Rpb24oZmlyc3QsIGxhc3QpIHtcblx0XHR2YXIgdSA9IFswXTtcblx0XHRmb3IgKHZhciBpID0gZmlyc3QgKyAxOyBpIDw9IGxhc3Q7IGkrKykge1xuXHRcdFx0dVtpIC0gZmlyc3RdID0gdVtpIC0gZmlyc3QgLSAxXVxuXHRcdFx0XHRcdCsgdGhpcy5wb2ludHNbaV0uZ2V0RGlzdGFuY2UodGhpcy5wb2ludHNbaSAtIDFdKTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDEsIG0gPSBsYXN0IC0gZmlyc3Q7IGkgPD0gbTsgaSsrKSB7XG5cdFx0XHR1W2ldIC89IHVbbV07XG5cdFx0fVxuXHRcdHJldHVybiB1O1xuXHR9LFxuXG5cdGZpbmRNYXhFcnJvcjogZnVuY3Rpb24oZmlyc3QsIGxhc3QsIGN1cnZlLCB1KSB7XG5cdFx0dmFyIGluZGV4ID0gTWF0aC5mbG9vcigobGFzdCAtIGZpcnN0ICsgMSkgLyAyKSxcblx0XHRcdG1heERpc3QgPSAwO1xuXHRcdGZvciAodmFyIGkgPSBmaXJzdCArIDE7IGkgPCBsYXN0OyBpKyspIHtcblx0XHRcdHZhciBQID0gdGhpcy5ldmFsdWF0ZSgzLCBjdXJ2ZSwgdVtpIC0gZmlyc3RdKTtcblx0XHRcdHZhciB2ID0gUC5zdWJ0cmFjdCh0aGlzLnBvaW50c1tpXSk7XG5cdFx0XHR2YXIgZGlzdCA9IHYueCAqIHYueCArIHYueSAqIHYueTtcblx0XHRcdGlmIChkaXN0ID49IG1heERpc3QpIHtcblx0XHRcdFx0bWF4RGlzdCA9IGRpc3Q7XG5cdFx0XHRcdGluZGV4ID0gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdGVycm9yOiBtYXhEaXN0LFxuXHRcdFx0aW5kZXg6IGluZGV4XG5cdFx0fTtcblx0fVxufSk7XG5cbnZhciBUZXh0SXRlbSA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnVGV4dEl0ZW0nLFxuXHRfYm91bmRzU2VsZWN0ZWQ6IHRydWUsXG5cdF9hcHBseU1hdHJpeDogZmFsc2UsXG5cdF9jYW5BcHBseU1hdHJpeDogZmFsc2UsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRjb250ZW50OiBudWxsXG5cdH0sXG5cdF9ib3VuZHNHZXR0ZXI6ICdnZXRCb3VuZHMnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFRleHRJdGVtKGFyZykge1xuXHRcdHRoaXMuX2NvbnRlbnQgPSAnJztcblx0XHR0aGlzLl9saW5lcyA9IFtdO1xuXHRcdHZhciBoYXNQcm9wcyA9IGFyZyAmJiBCYXNlLmlzUGxhaW5PYmplY3QoYXJnKVxuXHRcdFx0XHQmJiBhcmcueCA9PT0gdW5kZWZpbmVkICYmIGFyZy55ID09PSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5faW5pdGlhbGl6ZShoYXNQcm9wcyAmJiBhcmcsICFoYXNQcm9wcyAmJiBQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdF9lcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fY29udGVudCA9PT0gaXRlbS5fY29udGVudDtcblx0fSxcblxuXHRfY2xvbmU6IGZ1bmN0aW9uIF9jbG9uZShjb3B5LCBpbnNlcnQsIGluY2x1ZGVNYXRyaXgpIHtcblx0XHRjb3B5LnNldENvbnRlbnQodGhpcy5fY29udGVudCk7XG5cdFx0cmV0dXJuIF9jbG9uZS5iYXNlLmNhbGwodGhpcywgY29weSwgaW5zZXJ0LCBpbmNsdWRlTWF0cml4KTtcblx0fSxcblxuXHRnZXRDb250ZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY29udGVudDtcblx0fSxcblxuXHRzZXRDb250ZW50OiBmdW5jdGlvbihjb250ZW50KSB7XG5cdFx0dGhpcy5fY29udGVudCA9ICcnICsgY29udGVudDtcblx0XHR0aGlzLl9saW5lcyA9IHRoaXMuX2NvbnRlbnQuc3BsaXQoL1xcclxcbnxcXG58XFxyL21nKTtcblx0XHR0aGlzLl9jaGFuZ2VkKDI2NSk7XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9jb250ZW50O1xuXHR9LFxuXG5cdGdldENoYXJhY3RlclN0eWxlOiAnI2dldFN0eWxlJyxcblx0c2V0Q2hhcmFjdGVyU3R5bGU6ICcjc2V0U3R5bGUnLFxuXG5cdGdldFBhcmFncmFwaFN0eWxlOiAnI2dldFN0eWxlJyxcblx0c2V0UGFyYWdyYXBoU3R5bGU6ICcjc2V0U3R5bGUnXG59KTtcblxudmFyIFBvaW50VGV4dCA9IFRleHRJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BvaW50VGV4dCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUG9pbnRUZXh0KCkge1xuXHRcdFRleHRJdGVtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdHJldHVybiB0aGlzLl9jbG9uZShuZXcgUG9pbnRUZXh0KEl0ZW0uTk9fSU5TRVJUKSwgaW5zZXJ0KTtcblx0fSxcblxuXHRnZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcy5fbWF0cml4LmdldFRyYW5zbGF0aW9uKCk7XG5cdFx0cmV0dXJuIG5ldyBMaW5rZWRQb2ludChwb2ludC54LCBwb2ludC55LCB0aGlzLCAnc2V0UG9pbnQnKTtcblx0fSxcblxuXHRzZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMudHJhbnNsYXRlKHBvaW50LnN1YnRyYWN0KHRoaXMuX21hdHJpeC5nZXRUcmFuc2xhdGlvbigpKSk7XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdGlmICghdGhpcy5fY29udGVudClcblx0XHRcdHJldHVybjtcblx0XHR0aGlzLl9zZXRTdHlsZXMoY3R4KTtcblx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdGxpbmVzID0gdGhpcy5fbGluZXMsXG5cdFx0XHRsZWFkaW5nID0gc3R5bGUuZ2V0TGVhZGluZygpLFxuXHRcdFx0c2hhZG93Q29sb3IgPSBjdHguc2hhZG93Q29sb3I7XG5cdFx0Y3R4LmZvbnQgPSBzdHlsZS5nZXRGb250U3R5bGUoKTtcblx0XHRjdHgudGV4dEFsaWduID0gc3R5bGUuZ2V0SnVzdGlmaWNhdGlvbigpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbGluZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjdHguc2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvcjtcblx0XHRcdHZhciBsaW5lID0gbGluZXNbaV07XG5cdFx0XHRpZiAoc3R5bGUuaGFzRmlsbCgpKSB7XG5cdFx0XHRcdGN0eC5maWxsVGV4dChsaW5lLCAwLCAwKTtcblx0XHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHN0eWxlLmhhc1N0cm9rZSgpKVxuXHRcdFx0XHRjdHguc3Ryb2tlVGV4dChsaW5lLCAwLCAwKTtcblx0XHRcdGN0eC50cmFuc2xhdGUoMCwgbGVhZGluZyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRCb3VuZHM6IGZ1bmN0aW9uKGdldHRlciwgbWF0cml4KSB7XG5cdFx0dmFyIHN0eWxlID0gdGhpcy5fc3R5bGUsXG5cdFx0XHRsaW5lcyA9IHRoaXMuX2xpbmVzLFxuXHRcdFx0bnVtTGluZXMgPSBsaW5lcy5sZW5ndGgsXG5cdFx0XHRqdXN0aWZpY2F0aW9uID0gc3R5bGUuZ2V0SnVzdGlmaWNhdGlvbigpLFxuXHRcdFx0bGVhZGluZyA9IHN0eWxlLmdldExlYWRpbmcoKSxcblx0XHRcdHdpZHRoID0gdGhpcy5nZXRWaWV3KCkuZ2V0VGV4dFdpZHRoKHN0eWxlLmdldEZvbnRTdHlsZSgpLCBsaW5lcyksXG5cdFx0XHR4ID0gMDtcblx0XHRpZiAoanVzdGlmaWNhdGlvbiAhPT0gJ2xlZnQnKVxuXHRcdFx0eCAtPSB3aWR0aCAvIChqdXN0aWZpY2F0aW9uID09PSAnY2VudGVyJyA/IDI6IDEpO1xuXHRcdHZhciBib3VuZHMgPSBuZXcgUmVjdGFuZ2xlKHgsXG5cdFx0XHRcdFx0bnVtTGluZXMgPyAtIDAuNzUgKiBsZWFkaW5nIDogMCxcblx0XHRcdFx0XHR3aWR0aCwgbnVtTGluZXMgKiBsZWFkaW5nKTtcblx0XHRyZXR1cm4gbWF0cml4ID8gbWF0cml4Ll90cmFuc2Zvcm1Cb3VuZHMoYm91bmRzLCBib3VuZHMpIDogYm91bmRzO1xuXHR9XG59KTtcblxudmFyIENvbG9yID0gQmFzZS5leHRlbmQobmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgdHlwZXMgPSB7XG5cdFx0Z3JheTogWydncmF5J10sXG5cdFx0cmdiOiBbJ3JlZCcsICdncmVlbicsICdibHVlJ10sXG5cdFx0aHNiOiBbJ2h1ZScsICdzYXR1cmF0aW9uJywgJ2JyaWdodG5lc3MnXSxcblx0XHRoc2w6IFsnaHVlJywgJ3NhdHVyYXRpb24nLCAnbGlnaHRuZXNzJ10sXG5cdFx0Z3JhZGllbnQ6IFsnZ3JhZGllbnQnLCAnb3JpZ2luJywgJ2Rlc3RpbmF0aW9uJywgJ2hpZ2hsaWdodCddXG5cdH07XG5cblx0dmFyIGNvbXBvbmVudFBhcnNlcnMgPSB7fSxcblx0XHRjb2xvckNhY2hlID0ge30sXG5cdFx0Y29sb3JDdHg7XG5cblx0ZnVuY3Rpb24gZnJvbUNTUyhzdHJpbmcpIHtcblx0XHR2YXIgbWF0Y2ggPSBzdHJpbmcubWF0Y2goL14jKFxcd3sxLDJ9KShcXHd7MSwyfSkoXFx3ezEsMn0pJC8pLFxuXHRcdFx0Y29tcG9uZW50cztcblx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdGNvbXBvbmVudHMgPSBbMCwgMCwgMF07XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBtYXRjaFtpICsgMV07XG5cdFx0XHRcdGNvbXBvbmVudHNbaV0gPSBwYXJzZUludCh2YWx1ZS5sZW5ndGggPT0gMVxuXHRcdFx0XHRcdFx0PyB2YWx1ZSArIHZhbHVlIDogdmFsdWUsIDE2KSAvIDI1NTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKC9ecmdiYT9cXCgoLiopXFwpJC8pKSB7XG5cdFx0XHRjb21wb25lbnRzID0gbWF0Y2hbMV0uc3BsaXQoJywnKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY29tcG9uZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gK2NvbXBvbmVudHNbaV07XG5cdFx0XHRcdGNvbXBvbmVudHNbaV0gPSBpIDwgMyA/IHZhbHVlIC8gMjU1IDogdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBjYWNoZWQgPSBjb2xvckNhY2hlW3N0cmluZ107XG5cdFx0XHRpZiAoIWNhY2hlZCkge1xuXHRcdFx0XHRpZiAoIWNvbG9yQ3R4KSB7XG5cdFx0XHRcdFx0Y29sb3JDdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KDEsIDEpO1xuXHRcdFx0XHRcdGNvbG9yQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdjb3B5Jztcblx0XHRcdFx0fVxuXHRcdFx0XHRjb2xvckN0eC5maWxsU3R5bGUgPSAncmdiYSgwLDAsMCwwKSc7XG5cdFx0XHRcdGNvbG9yQ3R4LmZpbGxTdHlsZSA9IHN0cmluZztcblx0XHRcdFx0Y29sb3JDdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG5cdFx0XHRcdHZhciBkYXRhID0gY29sb3JDdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpLmRhdGE7XG5cdFx0XHRcdGNhY2hlZCA9IGNvbG9yQ2FjaGVbc3RyaW5nXSA9IFtcblx0XHRcdFx0XHRkYXRhWzBdIC8gMjU1LFxuXHRcdFx0XHRcdGRhdGFbMV0gLyAyNTUsXG5cdFx0XHRcdFx0ZGF0YVsyXSAvIDI1NVxuXHRcdFx0XHRdO1xuXHRcdFx0fVxuXHRcdFx0Y29tcG9uZW50cyA9IGNhY2hlZC5zbGljZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gY29tcG9uZW50cztcblx0fVxuXG5cdHZhciBoc2JJbmRpY2VzID0gW1xuXHRcdFswLCAzLCAxXSxcblx0XHRbMiwgMCwgMV0sXG5cdFx0WzEsIDAsIDNdLFxuXHRcdFsxLCAyLCAwXSxcblx0XHRbMywgMSwgMF0sXG5cdFx0WzAsIDEsIDJdXG5cdF07XG5cblx0dmFyIGNvbnZlcnRlcnMgPSB7XG5cdFx0J3JnYi1oc2InOiBmdW5jdGlvbihyLCBnLCBiKSB7XG5cdFx0XHR2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG5cdFx0XHRcdG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuXHRcdFx0XHRkZWx0YSA9IG1heCAtIG1pbixcblx0XHRcdFx0aCA9IGRlbHRhID09PSAwID8gMFxuXHRcdFx0XHRcdDpcdCggbWF4ID09IHIgPyAoZyAtIGIpIC8gZGVsdGEgKyAoZyA8IGIgPyA2IDogMClcblx0XHRcdFx0XHRcdDogbWF4ID09IGcgPyAoYiAtIHIpIC8gZGVsdGEgKyAyXG5cdFx0XHRcdFx0XHQ6XHRcdFx0IChyIC0gZykgLyBkZWx0YSArIDQpICogNjA7XG5cdFx0XHRyZXR1cm4gW2gsIG1heCA9PT0gMCA/IDAgOiBkZWx0YSAvIG1heCwgbWF4XTtcblx0XHR9LFxuXG5cdFx0J2hzYi1yZ2InOiBmdW5jdGlvbihoLCBzLCBiKSB7XG5cdFx0XHRoID0gKCgoaCAvIDYwKSAlIDYpICsgNikgJSA2O1xuXHRcdFx0dmFyIGkgPSBNYXRoLmZsb29yKGgpLFxuXHRcdFx0XHRmID0gaCAtIGksXG5cdFx0XHRcdGkgPSBoc2JJbmRpY2VzW2ldLFxuXHRcdFx0XHR2ID0gW1xuXHRcdFx0XHRcdGIsXG5cdFx0XHRcdFx0YiAqICgxIC0gcyksXG5cdFx0XHRcdFx0YiAqICgxIC0gcyAqIGYpLFxuXHRcdFx0XHRcdGIgKiAoMSAtIHMgKiAoMSAtIGYpKVxuXHRcdFx0XHRdO1xuXHRcdFx0cmV0dXJuIFt2W2lbMF1dLCB2W2lbMV1dLCB2W2lbMl1dXTtcblx0XHR9LFxuXG5cdFx0J3JnYi1oc2wnOiBmdW5jdGlvbihyLCBnLCBiKSB7XG5cdFx0XHR2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG5cdFx0XHRcdG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuXHRcdFx0XHRkZWx0YSA9IG1heCAtIG1pbixcblx0XHRcdFx0YWNocm9tYXRpYyA9IGRlbHRhID09PSAwLFxuXHRcdFx0XHRoID0gYWNocm9tYXRpYyA/IDBcblx0XHRcdFx0XHQ6XHQoIG1heCA9PSByID8gKGcgLSBiKSAvIGRlbHRhICsgKGcgPCBiID8gNiA6IDApXG5cdFx0XHRcdFx0XHQ6IG1heCA9PSBnID8gKGIgLSByKSAvIGRlbHRhICsgMlxuXHRcdFx0XHRcdFx0Olx0XHRcdCAociAtIGcpIC8gZGVsdGEgKyA0KSAqIDYwLFxuXHRcdFx0XHRsID0gKG1heCArIG1pbikgLyAyLFxuXHRcdFx0XHRzID0gYWNocm9tYXRpYyA/IDAgOiBsIDwgMC41XG5cdFx0XHRcdFx0XHQ/IGRlbHRhIC8gKG1heCArIG1pbilcblx0XHRcdFx0XHRcdDogZGVsdGEgLyAoMiAtIG1heCAtIG1pbik7XG5cdFx0XHRyZXR1cm4gW2gsIHMsIGxdO1xuXHRcdH0sXG5cblx0XHQnaHNsLXJnYic6IGZ1bmN0aW9uKGgsIHMsIGwpIHtcblx0XHRcdGggPSAoKChoIC8gMzYwKSAlIDEpICsgMSkgJSAxO1xuXHRcdFx0aWYgKHMgPT09IDApXG5cdFx0XHRcdHJldHVybiBbbCwgbCwgbF07XG5cdFx0XHR2YXIgdDNzID0gWyBoICsgMSAvIDMsIGgsIGggLSAxIC8gMyBdLFxuXHRcdFx0XHR0MiA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHMsXG5cdFx0XHRcdHQxID0gMiAqIGwgLSB0Mixcblx0XHRcdFx0YyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRcdFx0dmFyIHQzID0gdDNzW2ldO1xuXHRcdFx0XHRpZiAodDMgPCAwKSB0MyArPSAxO1xuXHRcdFx0XHRpZiAodDMgPiAxKSB0MyAtPSAxO1xuXHRcdFx0XHRjW2ldID0gNiAqIHQzIDwgMVxuXHRcdFx0XHRcdD8gdDEgKyAodDIgLSB0MSkgKiA2ICogdDNcblx0XHRcdFx0XHQ6IDIgKiB0MyA8IDFcblx0XHRcdFx0XHRcdD8gdDJcblx0XHRcdFx0XHRcdDogMyAqIHQzIDwgMlxuXHRcdFx0XHRcdFx0XHQ/IHQxICsgKHQyIC0gdDEpICogKCgyIC8gMykgLSB0MykgKiA2XG5cdFx0XHRcdFx0XHRcdDogdDE7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYztcblx0XHR9LFxuXG5cdFx0J3JnYi1ncmF5JzogZnVuY3Rpb24ociwgZywgYikge1xuXHRcdFx0cmV0dXJuIFtyICogMC4yOTg5ICsgZyAqIDAuNTg3ICsgYiAqIDAuMTE0XTtcblx0XHR9LFxuXG5cdFx0J2dyYXktcmdiJzogZnVuY3Rpb24oZykge1xuXHRcdFx0cmV0dXJuIFtnLCBnLCBnXTtcblx0XHR9LFxuXG5cdFx0J2dyYXktaHNiJzogZnVuY3Rpb24oZykge1xuXHRcdFx0cmV0dXJuIFswLCAwLCBnXTtcblx0XHR9LFxuXG5cdFx0J2dyYXktaHNsJzogZnVuY3Rpb24oZykge1xuXHRcdFx0cmV0dXJuIFswLCAwLCBnXTtcblx0XHR9LFxuXG5cdFx0J2dyYWRpZW50LXJnYic6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH0sXG5cblx0XHQncmdiLWdyYWRpZW50JzogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXG5cdH07XG5cblx0cmV0dXJuIEJhc2UuZWFjaCh0eXBlcywgZnVuY3Rpb24ocHJvcGVydGllcywgdHlwZSkge1xuXHRcdGNvbXBvbmVudFBhcnNlcnNbdHlwZV0gPSBbXTtcblx0XHRCYXNlLmVhY2gocHJvcGVydGllcywgZnVuY3Rpb24obmFtZSwgaW5kZXgpIHtcblx0XHRcdHZhciBwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKG5hbWUpLFxuXHRcdFx0XHRoYXNPdmVybGFwID0gL14oaHVlfHNhdHVyYXRpb24pJC8udGVzdChuYW1lKSxcblx0XHRcdFx0cGFyc2VyID0gY29tcG9uZW50UGFyc2Vyc1t0eXBlXVtpbmRleF0gPSBuYW1lID09PSAnZ3JhZGllbnQnXG5cdFx0XHRcdFx0PyBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRcdFx0dmFyIGN1cnJlbnQgPSB0aGlzLl9jb21wb25lbnRzWzBdO1xuXHRcdFx0XHRcdFx0dmFsdWUgPSBHcmFkaWVudC5yZWFkKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVcblx0XHRcdFx0XHRcdFx0XHQ6IGFyZ3VtZW50cywgMCwgeyByZWFkTnVsbDogdHJ1ZSB9KTtcblx0XHRcdFx0XHRcdGlmIChjdXJyZW50ICE9PSB2YWx1ZSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoY3VycmVudClcblx0XHRcdFx0XHRcdFx0XHRjdXJyZW50Ll9yZW1vdmVPd25lcih0aGlzKTtcblx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlKVxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlLl9hZGRPd25lcih0aGlzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0OiB0eXBlID09PSAnZ3JhZGllbnQnXG5cdFx0XHRcdFx0XHQ/IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWROdWxsOiBuYW1lID09PSAnaGlnaGxpZ2h0Jyxcblx0XHRcdFx0XHRcdFx0XHRcdGNsb25lOiB0cnVlXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCBpc05hTih2YWx1ZSkgPyAwIDogdmFsdWU7XG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHR0aGlzWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3R5cGUgPT09IHR5cGVcblx0XHRcdFx0XHR8fCBoYXNPdmVybGFwICYmIC9eaHNbYmxdJC8udGVzdCh0aGlzLl90eXBlKVxuXHRcdFx0XHRcdFx0PyB0aGlzLl9jb21wb25lbnRzW2luZGV4XVxuXHRcdFx0XHRcdFx0OiB0aGlzLl9jb252ZXJ0KHR5cGUpW2luZGV4XTtcblx0XHRcdH07XG5cblx0XHRcdHRoaXNbJ3NldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmICh0aGlzLl90eXBlICE9PSB0eXBlXG5cdFx0XHRcdFx0XHQmJiAhKGhhc092ZXJsYXAgJiYgL15oc1tibF0kLy50ZXN0KHRoaXMuX3R5cGUpKSkge1xuXHRcdFx0XHRcdHRoaXMuX2NvbXBvbmVudHMgPSB0aGlzLl9jb252ZXJ0KHR5cGUpO1xuXHRcdFx0XHRcdHRoaXMuX3Byb3BlcnRpZXMgPSB0eXBlc1t0eXBlXTtcblx0XHRcdFx0XHR0aGlzLl90eXBlID0gdHlwZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9jb21wb25lbnRzW2luZGV4XSA9IHBhcnNlci5jYWxsKHRoaXMsIHZhbHVlKTtcblx0XHRcdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdFx0fTtcblx0XHR9LCB0aGlzKTtcblx0fSwge1xuXHRcdF9jbGFzczogJ0NvbG9yJyxcblx0XHRfcmVhZEluZGV4OiB0cnVlLFxuXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gQ29sb3IoYXJnKSB7XG5cdFx0XHR2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UsXG5cdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdHJlYWQgPSAwLFxuXHRcdFx0XHR0eXBlLFxuXHRcdFx0XHRjb21wb25lbnRzLFxuXHRcdFx0XHRhbHBoYSxcblx0XHRcdFx0dmFsdWVzO1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHRcdFx0XHRhcmdzID0gYXJnO1xuXHRcdFx0XHRhcmcgPSBhcmdzWzBdO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGFyZ1R5cGUgPSBhcmcgIT0gbnVsbCAmJiB0eXBlb2YgYXJnO1xuXHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnICYmIGFyZyBpbiB0eXBlcykge1xuXHRcdFx0XHR0eXBlID0gYXJnO1xuXHRcdFx0XHRhcmcgPSBhcmdzWzFdO1xuXHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50cyA9IGFyZztcblx0XHRcdFx0XHRhbHBoYSA9IGFyZ3NbMl07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHRcdFx0cmVhZCA9IDE7XG5cdFx0XHRcdFx0YXJncyA9IHNsaWNlLmNhbGwoYXJncywgMSk7XG5cdFx0XHRcdFx0YXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICghY29tcG9uZW50cykge1xuXHRcdFx0XHR2YWx1ZXMgPSBhcmdUeXBlID09PSAnbnVtYmVyJ1xuXHRcdFx0XHRcdFx0PyBhcmdzXG5cdFx0XHRcdFx0XHQ6IGFyZ1R5cGUgPT09ICdvYmplY3QnICYmIGFyZy5sZW5ndGggIT0gbnVsbFxuXHRcdFx0XHRcdFx0XHQ/IGFyZ1xuXHRcdFx0XHRcdFx0XHQ6IG51bGw7XG5cdFx0XHRcdGlmICh2YWx1ZXMpIHtcblx0XHRcdFx0XHRpZiAoIXR5cGUpXG5cdFx0XHRcdFx0XHR0eXBlID0gdmFsdWVzLmxlbmd0aCA+PSAzXG5cdFx0XHRcdFx0XHRcdFx0PyAncmdiJ1xuXHRcdFx0XHRcdFx0XHRcdDogJ2dyYXknO1xuXHRcdFx0XHRcdHZhciBsZW5ndGggPSB0eXBlc1t0eXBlXS5sZW5ndGg7XG5cdFx0XHRcdFx0YWxwaGEgPSB2YWx1ZXNbbGVuZ3RoXTtcblx0XHRcdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdFx0XHRyZWFkICs9IHZhbHVlcyA9PT0gYXJndW1lbnRzXG5cdFx0XHRcdFx0XHRcdD8gbGVuZ3RoICsgKGFscGhhICE9IG51bGwgPyAxIDogMClcblx0XHRcdFx0XHRcdFx0OiAxO1xuXHRcdFx0XHRcdGlmICh2YWx1ZXMubGVuZ3RoID4gbGVuZ3RoKVxuXHRcdFx0XHRcdFx0dmFsdWVzID0gc2xpY2UuY2FsbCh2YWx1ZXMsIDAsIGxlbmd0aCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHR0eXBlID0gJ3JnYic7XG5cdFx0XHRcdFx0Y29tcG9uZW50cyA9IGZyb21DU1MoYXJnKTtcblx0XHRcdFx0XHRpZiAoY29tcG9uZW50cy5sZW5ndGggPT09IDQpIHtcblx0XHRcdFx0XHRcdGFscGhhID0gY29tcG9uZW50c1szXTtcblx0XHRcdFx0XHRcdGNvbXBvbmVudHMubGVuZ3RoLS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0aWYgKGFyZy5jb25zdHJ1Y3RvciA9PT0gQ29sb3IpIHtcblx0XHRcdFx0XHRcdHR5cGUgPSBhcmcuX3R5cGU7XG5cdFx0XHRcdFx0XHRjb21wb25lbnRzID0gYXJnLl9jb21wb25lbnRzLnNsaWNlKCk7XG5cdFx0XHRcdFx0XHRhbHBoYSA9IGFyZy5fYWxwaGE7XG5cdFx0XHRcdFx0XHRpZiAodHlwZSA9PT0gJ2dyYWRpZW50Jykge1xuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMSwgbCA9IGNvbXBvbmVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHBvaW50ID0gY29tcG9uZW50c1tpXTtcblx0XHRcdFx0XHRcdFx0XHRpZiAocG9pbnQpXG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wb25lbnRzW2ldID0gcG9pbnQuY2xvbmUoKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBHcmFkaWVudCkge1xuXHRcdFx0XHRcdFx0dHlwZSA9ICdncmFkaWVudCc7XG5cdFx0XHRcdFx0XHR2YWx1ZXMgPSBhcmdzO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0eXBlID0gJ2h1ZScgaW4gYXJnXG5cdFx0XHRcdFx0XHRcdD8gJ2xpZ2h0bmVzcycgaW4gYXJnXG5cdFx0XHRcdFx0XHRcdFx0PyAnaHNsJ1xuXHRcdFx0XHRcdFx0XHRcdDogJ2hzYidcblx0XHRcdFx0XHRcdFx0OiAnZ3JhZGllbnQnIGluIGFyZyB8fCAnc3RvcHMnIGluIGFyZ1xuXHRcdFx0XHRcdFx0XHRcdFx0fHwgJ3JhZGlhbCcgaW4gYXJnXG5cdFx0XHRcdFx0XHRcdFx0PyAnZ3JhZGllbnQnXG5cdFx0XHRcdFx0XHRcdFx0OiAnZ3JheScgaW4gYXJnXG5cdFx0XHRcdFx0XHRcdFx0XHQ/ICdncmF5J1xuXHRcdFx0XHRcdFx0XHRcdFx0OiAncmdiJztcblx0XHRcdFx0XHRcdHZhciBwcm9wZXJ0aWVzID0gdHlwZXNbdHlwZV07XG5cdFx0XHRcdFx0XHRcdHBhcnNlcnMgPSBjb21wb25lbnRQYXJzZXJzW3R5cGVdO1xuXHRcdFx0XHRcdFx0dGhpcy5fY29tcG9uZW50cyA9IGNvbXBvbmVudHMgPSBbXTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcHJvcGVydGllcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gYXJnW3Byb3BlcnRpZXNbaV1dO1xuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUgPT0gbnVsbCAmJiBpID09PSAwICYmIHR5cGUgPT09ICdncmFkaWVudCdcblx0XHRcdFx0XHRcdFx0XHRcdCYmICdzdG9wcycgaW4gYXJnKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdG9wczogYXJnLnN0b3BzLFxuXHRcdFx0XHRcdFx0XHRcdFx0cmFkaWFsOiBhcmcucmFkaWFsXG5cdFx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHBhcnNlcnNbaV0uY2FsbCh0aGlzLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdGlmICh2YWx1ZSAhPSBudWxsKVxuXHRcdFx0XHRcdFx0XHRcdGNvbXBvbmVudHNbaV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGFscGhhID0gYXJnLmFscGhhO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5fX3JlYWQgJiYgdHlwZSlcblx0XHRcdFx0XHRyZWFkID0gMTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3R5cGUgPSB0eXBlIHx8ICdyZ2InO1xuXHRcdFx0dGhpcy5faWQgPSBVSUQuZ2V0KENvbG9yKTtcblx0XHRcdGlmICghY29tcG9uZW50cykge1xuXHRcdFx0XHR0aGlzLl9jb21wb25lbnRzID0gY29tcG9uZW50cyA9IFtdO1xuXHRcdFx0XHR2YXIgcGFyc2VycyA9IGNvbXBvbmVudFBhcnNlcnNbdGhpcy5fdHlwZV07XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGFyc2Vycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSBwYXJzZXJzW2ldLmNhbGwodGhpcywgdmFsdWVzICYmIHZhbHVlc1tpXSk7XG5cdFx0XHRcdFx0aWYgKHZhbHVlICE9IG51bGwpXG5cdFx0XHRcdFx0XHRjb21wb25lbnRzW2ldID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX2NvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuXHRcdFx0dGhpcy5fcHJvcGVydGllcyA9IHR5cGVzW3RoaXMuX3R5cGVdO1xuXHRcdFx0dGhpcy5fYWxwaGEgPSBhbHBoYTtcblx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0dGhpcy5fX3JlYWQgPSByZWFkO1xuXHRcdH0sXG5cblx0XHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0XHR2YXIgY29tcG9uZW50cyA9IHRoaXMuZ2V0Q29tcG9uZW50cygpO1xuXHRcdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKFxuXHRcdFx0XHRcdC9eKGdyYXl8cmdiKSQvLnRlc3QodGhpcy5fdHlwZSlcblx0XHRcdFx0XHRcdD8gY29tcG9uZW50c1xuXHRcdFx0XHRcdFx0OiBbdGhpcy5fdHlwZV0uY29uY2F0KGNvbXBvbmVudHMpLFxuXHRcdFx0XHRcdG9wdGlvbnMsIHRydWUsIGRpY3Rpb25hcnkpO1xuXHRcdH0sXG5cblx0XHRfY2hhbmdlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9jYW52YXNTdHlsZSA9IG51bGw7XG5cdFx0XHRpZiAodGhpcy5fb3duZXIpXG5cdFx0XHRcdHRoaXMuX293bmVyLl9jaGFuZ2VkKDY1KTtcblx0XHR9LFxuXG5cdFx0X2NvbnZlcnQ6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHZhciBjb252ZXJ0ZXI7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdHlwZSA9PT0gdHlwZVxuXHRcdFx0XHRcdD8gdGhpcy5fY29tcG9uZW50cy5zbGljZSgpXG5cdFx0XHRcdFx0OiAoY29udmVydGVyID0gY29udmVydGVyc1t0aGlzLl90eXBlICsgJy0nICsgdHlwZV0pXG5cdFx0XHRcdFx0XHQ/IGNvbnZlcnRlci5hcHBseSh0aGlzLCB0aGlzLl9jb21wb25lbnRzKVxuXHRcdFx0XHRcdFx0OiBjb252ZXJ0ZXJzWydyZ2ItJyArIHR5cGVdLmFwcGx5KHRoaXMsXG5cdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbdGhpcy5fdHlwZSArICctcmdiJ10uYXBwbHkodGhpcyxcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9jb21wb25lbnRzKSk7XG5cdFx0fSxcblxuXHRcdGNvbnZlcnQ6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHJldHVybiBuZXcgQ29sb3IodHlwZSwgdGhpcy5fY29udmVydCh0eXBlKSwgdGhpcy5fYWxwaGEpO1xuXHRcdH0sXG5cblx0XHRnZXRUeXBlOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl90eXBlO1xuXHRcdH0sXG5cblx0XHRzZXRUeXBlOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHR0aGlzLl9jb21wb25lbnRzID0gdGhpcy5fY29udmVydCh0eXBlKTtcblx0XHRcdHRoaXMuX3Byb3BlcnRpZXMgPSB0eXBlc1t0eXBlXTtcblx0XHRcdHRoaXMuX3R5cGUgPSB0eXBlO1xuXHRcdH0sXG5cblx0XHRnZXRDb21wb25lbnRzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50cy5zbGljZSgpO1xuXHRcdFx0aWYgKHRoaXMuX2FscGhhICE9IG51bGwpXG5cdFx0XHRcdGNvbXBvbmVudHMucHVzaCh0aGlzLl9hbHBoYSk7XG5cdFx0XHRyZXR1cm4gY29tcG9uZW50cztcblx0XHR9LFxuXG5cdFx0Z2V0QWxwaGE6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2FscGhhICE9IG51bGwgPyB0aGlzLl9hbHBoYSA6IDE7XG5cdFx0fSxcblxuXHRcdHNldEFscGhhOiBmdW5jdGlvbihhbHBoYSkge1xuXHRcdFx0dGhpcy5fYWxwaGEgPSBhbHBoYSA9PSBudWxsID8gbnVsbCA6IE1hdGgubWluKE1hdGgubWF4KGFscGhhLCAwKSwgMSk7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0fSxcblxuXHRcdGhhc0FscGhhOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9hbHBoYSAhPSBudWxsO1xuXHRcdH0sXG5cblx0XHRlcXVhbHM6IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0XHR2YXIgY29sID0gQmFzZS5pc1BsYWluVmFsdWUoY29sb3IsIHRydWUpXG5cdFx0XHRcdFx0PyBDb2xvci5yZWFkKGFyZ3VtZW50cylcblx0XHRcdFx0XHQ6IGNvbG9yO1xuXHRcdFx0cmV0dXJuIGNvbCA9PT0gdGhpcyB8fCBjb2wgJiYgdGhpcy5fY2xhc3MgPT09IGNvbC5fY2xhc3Ncblx0XHRcdFx0XHQmJiB0aGlzLl90eXBlID09PSBjb2wuX3R5cGVcblx0XHRcdFx0XHQmJiB0aGlzLl9hbHBoYSA9PT0gY29sLl9hbHBoYVxuXHRcdFx0XHRcdCYmIEJhc2UuZXF1YWxzKHRoaXMuX2NvbXBvbmVudHMsIGNvbC5fY29tcG9uZW50cylcblx0XHRcdFx0XHR8fCBmYWxzZTtcblx0XHR9LFxuXG5cdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHByb3BlcnRpZXMgPSB0aGlzLl9wcm9wZXJ0aWVzLFxuXHRcdFx0XHRwYXJ0cyA9IFtdLFxuXHRcdFx0XHRpc0dyYWRpZW50ID0gdGhpcy5fdHlwZSA9PT0gJ2dyYWRpZW50Jyxcblx0XHRcdFx0ZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcHJvcGVydGllcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gdGhpcy5fY29tcG9uZW50c1tpXTtcblx0XHRcdFx0aWYgKHZhbHVlICE9IG51bGwpXG5cdFx0XHRcdFx0cGFydHMucHVzaChwcm9wZXJ0aWVzW2ldICsgJzogJ1xuXHRcdFx0XHRcdFx0XHQrIChpc0dyYWRpZW50ID8gdmFsdWUgOiBmLm51bWJlcih2YWx1ZSkpKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9hbHBoYSAhPSBudWxsKVxuXHRcdFx0XHRwYXJ0cy5wdXNoKCdhbHBoYTogJyArIGYubnVtYmVyKHRoaXMuX2FscGhhKSk7XG5cdFx0XHRyZXR1cm4gJ3sgJyArIHBhcnRzLmpvaW4oJywgJykgKyAnIH0nO1xuXHRcdH0sXG5cblx0XHR0b0NTUzogZnVuY3Rpb24oaGV4KSB7XG5cdFx0XHR2YXIgY29tcG9uZW50cyA9IHRoaXMuX2NvbnZlcnQoJ3JnYicpLFxuXHRcdFx0XHRhbHBoYSA9IGhleCB8fCB0aGlzLl9hbHBoYSA9PSBudWxsID8gMSA6IHRoaXMuX2FscGhhO1xuXHRcdFx0ZnVuY3Rpb24gY29udmVydCh2YWwpIHtcblx0XHRcdFx0cmV0dXJuIE1hdGgucm91bmQoKHZhbCA8IDAgPyAwIDogdmFsID4gMSA/IDEgOiB2YWwpICogMjU1KTtcblx0XHRcdH1cblx0XHRcdGNvbXBvbmVudHMgPSBbXG5cdFx0XHRcdGNvbnZlcnQoY29tcG9uZW50c1swXSksXG5cdFx0XHRcdGNvbnZlcnQoY29tcG9uZW50c1sxXSksXG5cdFx0XHRcdGNvbnZlcnQoY29tcG9uZW50c1syXSlcblx0XHRcdF07XG5cdFx0XHRpZiAoYWxwaGEgPCAxKVxuXHRcdFx0XHRjb21wb25lbnRzLnB1c2goYWxwaGEgPCAwID8gMCA6IGFscGhhKTtcblx0XHRcdHJldHVybiBoZXhcblx0XHRcdFx0XHQ/ICcjJyArICgoMSA8PCAyNCkgKyAoY29tcG9uZW50c1swXSA8PCAxNilcblx0XHRcdFx0XHRcdCsgKGNvbXBvbmVudHNbMV0gPDwgOClcblx0XHRcdFx0XHRcdCsgY29tcG9uZW50c1syXSkudG9TdHJpbmcoMTYpLnNsaWNlKDEpXG5cdFx0XHRcdFx0OiAoY29tcG9uZW50cy5sZW5ndGggPT0gNCA/ICdyZ2JhKCcgOiAncmdiKCcpXG5cdFx0XHRcdFx0XHQrIGNvbXBvbmVudHMuam9pbignLCcpICsgJyknO1xuXHRcdH0sXG5cblx0XHR0b0NhbnZhc1N0eWxlOiBmdW5jdGlvbihjdHgpIHtcblx0XHRcdGlmICh0aGlzLl9jYW52YXNTdHlsZSlcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NhbnZhc1N0eWxlO1xuXHRcdFx0aWYgKHRoaXMuX3R5cGUgIT09ICdncmFkaWVudCcpXG5cdFx0XHRcdHJldHVybiB0aGlzLl9jYW52YXNTdHlsZSA9IHRoaXMudG9DU1MoKTtcblx0XHRcdHZhciBjb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50cyxcblx0XHRcdFx0Z3JhZGllbnQgPSBjb21wb25lbnRzWzBdLFxuXHRcdFx0XHRzdG9wcyA9IGdyYWRpZW50Ll9zdG9wcyxcblx0XHRcdFx0b3JpZ2luID0gY29tcG9uZW50c1sxXSxcblx0XHRcdFx0ZGVzdGluYXRpb24gPSBjb21wb25lbnRzWzJdLFxuXHRcdFx0XHRjYW52YXNHcmFkaWVudDtcblx0XHRcdGlmIChncmFkaWVudC5fcmFkaWFsKSB7XG5cdFx0XHRcdHZhciByYWRpdXMgPSBkZXN0aW5hdGlvbi5nZXREaXN0YW5jZShvcmlnaW4pLFxuXHRcdFx0XHRcdGhpZ2hsaWdodCA9IGNvbXBvbmVudHNbM107XG5cdFx0XHRcdGlmIChoaWdobGlnaHQpIHtcblx0XHRcdFx0XHR2YXIgdmVjdG9yID0gaGlnaGxpZ2h0LnN1YnRyYWN0KG9yaWdpbik7XG5cdFx0XHRcdFx0aWYgKHZlY3Rvci5nZXRMZW5ndGgoKSA+IHJhZGl1cylcblx0XHRcdFx0XHRcdGhpZ2hsaWdodCA9IG9yaWdpbi5hZGQodmVjdG9yLm5vcm1hbGl6ZShyYWRpdXMgLSAwLjEpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgc3RhcnQgPSBoaWdobGlnaHQgfHwgb3JpZ2luO1xuXHRcdFx0XHRjYW52YXNHcmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChzdGFydC54LCBzdGFydC55LFxuXHRcdFx0XHRcdFx0MCwgb3JpZ2luLngsIG9yaWdpbi55LCByYWRpdXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FudmFzR3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQob3JpZ2luLngsIG9yaWdpbi55LFxuXHRcdFx0XHRcdFx0ZGVzdGluYXRpb24ueCwgZGVzdGluYXRpb24ueSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHN0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgc3RvcCA9IHN0b3BzW2ldO1xuXHRcdFx0XHRjYW52YXNHcmFkaWVudC5hZGRDb2xvclN0b3Aoc3RvcC5fcmFtcFBvaW50LFxuXHRcdFx0XHRcdFx0c3RvcC5fY29sb3IudG9DYW52YXNTdHlsZSgpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl9jYW52YXNTdHlsZSA9IGNhbnZhc0dyYWRpZW50O1xuXHRcdH0sXG5cblx0XHR0cmFuc2Zvcm06IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdFx0aWYgKHRoaXMuX3R5cGUgPT09ICdncmFkaWVudCcpIHtcblx0XHRcdFx0dmFyIGNvbXBvbmVudHMgPSB0aGlzLl9jb21wb25lbnRzO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMSwgbCA9IGNvbXBvbmVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIHBvaW50ID0gY29tcG9uZW50c1tpXTtcblx0XHRcdFx0XHRtYXRyaXguX3RyYW5zZm9ybVBvaW50KHBvaW50LCBwb2ludCwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzdGF0aWNzOiB7XG5cdFx0XHRfdHlwZXM6IHR5cGVzLFxuXG5cdFx0XHRyYW5kb206IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcmFuZG9tID0gTWF0aC5yYW5kb207XG5cdFx0XHRcdHJldHVybiBuZXcgQ29sb3IocmFuZG9tKCksIHJhbmRvbSgpLCByYW5kb20oKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn0sIG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIG9wZXJhdG9ycyA9IHtcblx0XHRhZGQ6IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHJldHVybiBhICsgYjtcblx0XHR9LFxuXG5cdFx0c3VidHJhY3Q6IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHJldHVybiBhIC0gYjtcblx0XHR9LFxuXG5cdFx0bXVsdGlwbHk6IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHJldHVybiBhICogYjtcblx0XHR9LFxuXG5cdFx0ZGl2aWRlOiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYSAvIGI7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBCYXNlLmVhY2gob3BlcmF0b3JzLCBmdW5jdGlvbihvcGVyYXRvciwgbmFtZSkge1xuXHRcdHRoaXNbbmFtZV0gPSBmdW5jdGlvbihjb2xvcikge1xuXHRcdFx0Y29sb3IgPSBDb2xvci5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG5cdFx0XHRcdGNvbXBvbmVudHMxID0gdGhpcy5fY29tcG9uZW50cyxcblx0XHRcdFx0Y29tcG9uZW50czIgPSBjb2xvci5fY29udmVydCh0eXBlKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY29tcG9uZW50czEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRjb21wb25lbnRzMltpXSA9IG9wZXJhdG9yKGNvbXBvbmVudHMxW2ldLCBjb21wb25lbnRzMltpXSk7XG5cdFx0XHRyZXR1cm4gbmV3IENvbG9yKHR5cGUsIGNvbXBvbmVudHMyLFxuXHRcdFx0XHRcdHRoaXMuX2FscGhhICE9IG51bGxcblx0XHRcdFx0XHRcdFx0PyBvcGVyYXRvcih0aGlzLl9hbHBoYSwgY29sb3IuZ2V0QWxwaGEoKSlcblx0XHRcdFx0XHRcdFx0OiBudWxsKTtcblx0XHR9O1xuXHR9LCB7XG5cdH0pO1xufSk7XG5cbkJhc2UuZWFjaChDb2xvci5fdHlwZXMsIGZ1bmN0aW9uKHByb3BlcnRpZXMsIHR5cGUpIHtcblx0dmFyIGN0b3IgPSB0aGlzW0Jhc2UuY2FwaXRhbGl6ZSh0eXBlKSArICdDb2xvciddID0gZnVuY3Rpb24oYXJnKSB7XG5cdFx0XHR2YXIgYXJnVHlwZSA9IGFyZyAhPSBudWxsICYmIHR5cGVvZiBhcmcsXG5cdFx0XHRcdGNvbXBvbmVudHMgPSBhcmdUeXBlID09PSAnb2JqZWN0JyAmJiBhcmcubGVuZ3RoICE9IG51bGxcblx0XHRcdFx0XHQ/IGFyZ1xuXHRcdFx0XHRcdDogYXJnVHlwZSA9PT0gJ3N0cmluZydcblx0XHRcdFx0XHRcdD8gbnVsbFxuXHRcdFx0XHRcdFx0OiBhcmd1bWVudHM7XG5cdFx0XHRyZXR1cm4gY29tcG9uZW50c1xuXHRcdFx0XHRcdD8gbmV3IENvbG9yKHR5cGUsIGNvbXBvbmVudHMpXG5cdFx0XHRcdFx0OiBuZXcgQ29sb3IoYXJnKTtcblx0XHR9O1xuXHRpZiAodHlwZS5sZW5ndGggPT0gMykge1xuXHRcdHZhciBhY3JvbnltID0gdHlwZS50b1VwcGVyQ2FzZSgpO1xuXHRcdENvbG9yW2Fjcm9ueW1dID0gdGhpc1thY3JvbnltICsgJ0NvbG9yJ10gPSBjdG9yO1xuXHR9XG59LCBCYXNlLmV4cG9ydHMpO1xuXG52YXIgR3JhZGllbnQgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0dyYWRpZW50JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBHcmFkaWVudChzdG9wcywgcmFkaWFsKSB7XG5cdFx0dGhpcy5faWQgPSBVSUQuZ2V0KCk7XG5cdFx0aWYgKHN0b3BzICYmIHRoaXMuX3NldChzdG9wcykpXG5cdFx0XHRzdG9wcyA9IHJhZGlhbCA9IG51bGw7XG5cdFx0aWYgKCF0aGlzLl9zdG9wcylcblx0XHRcdHRoaXMuc2V0U3RvcHMoc3RvcHMgfHwgWyd3aGl0ZScsICdibGFjayddKTtcblx0XHRpZiAodGhpcy5fcmFkaWFsID09IG51bGwpXG5cdFx0XHR0aGlzLnNldFJhZGlhbCh0eXBlb2YgcmFkaWFsID09PSAnc3RyaW5nJyAmJiByYWRpYWwgPT09ICdyYWRpYWwnXG5cdFx0XHRcdFx0fHwgcmFkaWFsIHx8IGZhbHNlKTtcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0cmV0dXJuIGRpY3Rpb25hcnkuYWRkKHRoaXMsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKFt0aGlzLl9zdG9wcywgdGhpcy5fcmFkaWFsXSxcblx0XHRcdFx0XHRvcHRpb25zLCB0cnVlLCBkaWN0aW9uYXJ5KTtcblx0XHR9KTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9vd25lcnMgJiYgdGhpcy5fb3duZXJzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHRoaXMuX293bmVyc1tpXS5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdF9hZGRPd25lcjogZnVuY3Rpb24oY29sb3IpIHtcblx0XHRpZiAoIXRoaXMuX293bmVycylcblx0XHRcdHRoaXMuX293bmVycyA9IFtdO1xuXHRcdHRoaXMuX293bmVycy5wdXNoKGNvbG9yKTtcblx0fSxcblxuXHRfcmVtb3ZlT3duZXI6IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0dmFyIGluZGV4ID0gdGhpcy5fb3duZXJzID8gdGhpcy5fb3duZXJzLmluZGV4T2YoY29sb3IpIDogLTE7XG5cdFx0aWYgKGluZGV4ICE9IC0xKSB7XG5cdFx0XHR0aGlzLl9vd25lcnMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdGlmICh0aGlzLl9vd25lcnMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHR0aGlzLl9vd25lcnMgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc3RvcHMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3N0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHN0b3BzW2ldID0gdGhpcy5fc3RvcHNbaV0uY2xvbmUoKTtcblx0XHRyZXR1cm4gbmV3IEdyYWRpZW50KHN0b3BzLCB0aGlzLl9yYWRpYWwpO1xuXHR9LFxuXG5cdGdldFN0b3BzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc3RvcHM7XG5cdH0sXG5cblx0c2V0U3RvcHM6IGZ1bmN0aW9uKHN0b3BzKSB7XG5cdFx0aWYgKHRoaXMuc3RvcHMpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHR0aGlzLl9zdG9wc1tpXS5fb3duZXIgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmIChzdG9wcy5sZW5ndGggPCAyKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdCdHcmFkaWVudCBzdG9wIGxpc3QgbmVlZHMgdG8gY29udGFpbiBhdCBsZWFzdCB0d28gc3RvcHMuJyk7XG5cdFx0dGhpcy5fc3RvcHMgPSBHcmFkaWVudFN0b3AucmVhZEFsbChzdG9wcywgMCwgeyBjbG9uZTogdHJ1ZSB9KTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3N0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHN0b3AgPSB0aGlzLl9zdG9wc1tpXTtcblx0XHRcdHN0b3AuX293bmVyID0gdGhpcztcblx0XHRcdGlmIChzdG9wLl9kZWZhdWx0UmFtcClcblx0XHRcdFx0c3RvcC5zZXRSYW1wUG9pbnQoaSAvIChsIC0gMSkpO1xuXHRcdH1cblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdH0sXG5cblx0Z2V0UmFkaWFsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmFkaWFsO1xuXHR9LFxuXG5cdHNldFJhZGlhbDogZnVuY3Rpb24ocmFkaWFsKSB7XG5cdFx0dGhpcy5fcmFkaWFsID0gcmFkaWFsO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKGdyYWRpZW50KSB7XG5cdFx0aWYgKGdyYWRpZW50ID09PSB0aGlzKVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0aWYgKGdyYWRpZW50ICYmIHRoaXMuX2NsYXNzID09PSBncmFkaWVudC5fY2xhc3Ncblx0XHRcdFx0JiYgdGhpcy5fc3RvcHMubGVuZ3RoID09PSBncmFkaWVudC5fc3RvcHMubGVuZ3RoKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3N0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpZiAoIXRoaXMuX3N0b3BzW2ldLmVxdWFscyhncmFkaWVudC5fc3RvcHNbaV0pKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0pO1xuXG52YXIgR3JhZGllbnRTdG9wID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdHcmFkaWVudFN0b3AnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEdyYWRpZW50U3RvcChhcmcwLCBhcmcxKSB7XG5cdFx0aWYgKGFyZzApIHtcblx0XHRcdHZhciBjb2xvciwgcmFtcFBvaW50O1xuXHRcdFx0aWYgKGFyZzEgPT09IHVuZGVmaW5lZCAmJiBBcnJheS5pc0FycmF5KGFyZzApKSB7XG5cdFx0XHRcdGNvbG9yID0gYXJnMFswXTtcblx0XHRcdFx0cmFtcFBvaW50ID0gYXJnMFsxXTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC5jb2xvcikge1xuXHRcdFx0XHRjb2xvciA9IGFyZzAuY29sb3I7XG5cdFx0XHRcdHJhbXBQb2ludCA9IGFyZzAucmFtcFBvaW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29sb3IgPSBhcmcwO1xuXHRcdFx0XHRyYW1wUG9pbnQgPSBhcmcxO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5zZXRDb2xvcihjb2xvcik7XG5cdFx0XHR0aGlzLnNldFJhbXBQb2ludChyYW1wUG9pbnQpO1xuXHRcdH1cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBHcmFkaWVudFN0b3AodGhpcy5fY29sb3IuY2xvbmUoKSwgdGhpcy5fcmFtcFBvaW50KTtcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKFt0aGlzLl9jb2xvciwgdGhpcy5fcmFtcFBvaW50XSwgb3B0aW9ucywgdHJ1ZSxcblx0XHRcdFx0ZGljdGlvbmFyeSk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9vd25lcilcblx0XHRcdHRoaXMuX293bmVyLl9jaGFuZ2VkKDY1KTtcblx0fSxcblxuXHRnZXRSYW1wUG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYW1wUG9pbnQ7XG5cdH0sXG5cblx0c2V0UmFtcFBvaW50OiBmdW5jdGlvbihyYW1wUG9pbnQpIHtcblx0XHR0aGlzLl9kZWZhdWx0UmFtcCA9IHJhbXBQb2ludCA9PSBudWxsO1xuXHRcdHRoaXMuX3JhbXBQb2ludCA9IHJhbXBQb2ludCB8fCAwO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0fSxcblxuXHRnZXRDb2xvcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbG9yO1xuXHR9LFxuXG5cdHNldENvbG9yOiBmdW5jdGlvbihjb2xvcikge1xuXHRcdHRoaXMuX2NvbG9yID0gQ29sb3IucmVhZChhcmd1bWVudHMpO1xuXHRcdGlmICh0aGlzLl9jb2xvciA9PT0gY29sb3IpXG5cdFx0XHR0aGlzLl9jb2xvciA9IGNvbG9yLmNsb25lKCk7XG5cdFx0dGhpcy5fY29sb3IuX293bmVyID0gdGhpcztcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihzdG9wKSB7XG5cdFx0cmV0dXJuIHN0b3AgPT09IHRoaXMgfHwgc3RvcCAmJiB0aGlzLl9jbGFzcyA9PT0gc3RvcC5fY2xhc3Ncblx0XHRcdFx0JiYgdGhpcy5fY29sb3IuZXF1YWxzKHN0b3AuX2NvbG9yKVxuXHRcdFx0XHQmJiB0aGlzLl9yYW1wUG9pbnQgPT0gc3RvcC5fcmFtcFBvaW50XG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9XG59KTtcblxudmFyIFN0eWxlID0gQmFzZS5leHRlbmQobmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgZGVmYXVsdHMgPSB7XG5cdFx0ZmlsbENvbG9yOiB1bmRlZmluZWQsXG5cdFx0c3Ryb2tlQ29sb3I6IHVuZGVmaW5lZCxcblx0XHRzdHJva2VXaWR0aDogMSxcblx0XHRzdHJva2VDYXA6ICdidXR0Jyxcblx0XHRzdHJva2VKb2luOiAnbWl0ZXInLFxuXHRcdHN0cm9rZVNjYWxpbmc6IHRydWUsXG5cdFx0bWl0ZXJMaW1pdDogMTAsXG5cdFx0ZGFzaE9mZnNldDogMCxcblx0XHRkYXNoQXJyYXk6IFtdLFxuXHRcdHdpbmRpbmdSdWxlOiAnbm9uemVybycsXG5cdFx0c2hhZG93Q29sb3I6IHVuZGVmaW5lZCxcblx0XHRzaGFkb3dCbHVyOiAwLFxuXHRcdHNoYWRvd09mZnNldDogbmV3IFBvaW50KCksXG5cdFx0c2VsZWN0ZWRDb2xvcjogdW5kZWZpbmVkLFxuXHRcdGZvbnRGYW1pbHk6ICdzYW5zLXNlcmlmJyxcblx0XHRmb250V2VpZ2h0OiAnbm9ybWFsJyxcblx0XHRmb250U2l6ZTogMTIsXG5cdFx0Zm9udDogJ3NhbnMtc2VyaWYnLFxuXHRcdGxlYWRpbmc6IG51bGwsXG5cdFx0anVzdGlmaWNhdGlvbjogJ2xlZnQnXG5cdH07XG5cblx0dmFyIGZsYWdzID0ge1xuXHRcdHN0cm9rZVdpZHRoOiA5Nyxcblx0XHRzdHJva2VDYXA6IDk3LFxuXHRcdHN0cm9rZUpvaW46IDk3LFxuXHRcdHN0cm9rZVNjYWxpbmc6IDEwNSxcblx0XHRtaXRlckxpbWl0OiA5Nyxcblx0XHRmb250RmFtaWx5OiA5LFxuXHRcdGZvbnRXZWlnaHQ6IDksXG5cdFx0Zm9udFNpemU6IDksXG5cdFx0Zm9udDogOSxcblx0XHRsZWFkaW5nOiA5LFxuXHRcdGp1c3RpZmljYXRpb246IDlcblx0fTtcblxuXHR2YXIgaXRlbSA9IHsgYmVhbnM6IHRydWUgfSxcblx0XHRmaWVsZHMgPSB7XG5cdFx0XHRfZGVmYXVsdHM6IGRlZmF1bHRzLFxuXHRcdFx0X3RleHREZWZhdWx0czogbmV3IEJhc2UoZGVmYXVsdHMsIHtcblx0XHRcdFx0ZmlsbENvbG9yOiBuZXcgQ29sb3IoKVxuXHRcdFx0fSksXG5cdFx0XHRiZWFuczogdHJ1ZVxuXHRcdH07XG5cblx0QmFzZS5lYWNoKGRlZmF1bHRzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0dmFyIGlzQ29sb3IgPSAvQ29sb3IkLy50ZXN0KGtleSksXG5cdFx0XHRpc1BvaW50ID0ga2V5ID09PSAnc2hhZG93T2Zmc2V0Jyxcblx0XHRcdHBhcnQgPSBCYXNlLmNhcGl0YWxpemUoa2V5KSxcblx0XHRcdGZsYWcgPSBmbGFnc1trZXldLFxuXHRcdFx0c2V0ID0gJ3NldCcgKyBwYXJ0LFxuXHRcdFx0Z2V0ID0gJ2dldCcgKyBwYXJ0O1xuXG5cdFx0ZmllbGRzW3NldF0gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG93bmVyID0gdGhpcy5fb3duZXIsXG5cdFx0XHRcdGNoaWxkcmVuID0gb3duZXIgJiYgb3duZXIuX2NoaWxkcmVuO1xuXHRcdFx0aWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA+IDBcblx0XHRcdFx0XHQmJiAhKG93bmVyIGluc3RhbmNlb2YgQ29tcG91bmRQYXRoKSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRjaGlsZHJlbltpXS5fc3R5bGVbc2V0XSh2YWx1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgb2xkID0gdGhpcy5fdmFsdWVzW2tleV07XG5cdFx0XHRcdGlmIChvbGQgIT09IHZhbHVlKSB7XG5cdFx0XHRcdFx0aWYgKGlzQ29sb3IpIHtcblx0XHRcdFx0XHRcdGlmIChvbGQpXG5cdFx0XHRcdFx0XHRcdG9sZC5fb3duZXIgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRpZiAodmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IENvbG9yKSB7XG5cdFx0XHRcdFx0XHRcdGlmICh2YWx1ZS5fb3duZXIpXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5jbG9uZSgpO1xuXHRcdFx0XHRcdFx0XHR2YWx1ZS5fb3duZXIgPSBvd25lcjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fdmFsdWVzW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRpZiAob3duZXIpXG5cdFx0XHRcdFx0XHRvd25lci5fY2hhbmdlZChmbGFnIHx8IDY1KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmaWVsZHNbZ2V0XSA9IGZ1bmN0aW9uKF9kb250TWVyZ2UpIHtcblx0XHRcdHZhciBvd25lciA9IHRoaXMuX293bmVyLFxuXHRcdFx0XHRjaGlsZHJlbiA9IG93bmVyICYmIG93bmVyLl9jaGlsZHJlbixcblx0XHRcdFx0dmFsdWU7XG5cdFx0XHRpZiAoIWNoaWxkcmVuIHx8IGNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCBfZG9udE1lcmdlXG5cdFx0XHRcdFx0fHwgb3duZXIgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGgpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gdGhpcy5fdmFsdWVzW2tleV07XG5cdFx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB0aGlzLl9kZWZhdWx0c1trZXldO1xuXHRcdFx0XHRcdGlmICh2YWx1ZSAmJiB2YWx1ZS5jbG9uZSlcblx0XHRcdFx0XHRcdHZhbHVlID0gdmFsdWUuY2xvbmUoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgY3RvciA9IGlzQ29sb3IgPyBDb2xvciA6IGlzUG9pbnQgPyBQb2ludCA6IG51bGw7XG5cdFx0XHRcdFx0aWYgKGN0b3IgJiYgISh2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gY3RvcikpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3ZhbHVlc1trZXldID0gdmFsdWUgPSBjdG9yLnJlYWQoW3ZhbHVlXSwgMCxcblx0XHRcdFx0XHRcdFx0XHR7IHJlYWROdWxsOiB0cnVlLCBjbG9uZTogdHJ1ZSB9KTtcblx0XHRcdFx0XHRcdGlmICh2YWx1ZSAmJiBpc0NvbG9yKVxuXHRcdFx0XHRcdFx0XHR2YWx1ZS5fb3duZXIgPSBvd25lcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkVmFsdWUgPSBjaGlsZHJlbltpXS5fc3R5bGVbZ2V0XSgpO1xuXHRcdFx0XHRpZiAoaSA9PT0gMCkge1xuXHRcdFx0XHRcdHZhbHVlID0gY2hpbGRWYWx1ZTtcblx0XHRcdFx0fSBlbHNlIGlmICghQmFzZS5lcXVhbHModmFsdWUsIGNoaWxkVmFsdWUpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH07XG5cblx0XHRpdGVtW2dldF0gPSBmdW5jdGlvbihfZG9udE1lcmdlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fc3R5bGVbZ2V0XShfZG9udE1lcmdlKTtcblx0XHR9O1xuXG5cdFx0aXRlbVtzZXRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHRoaXMuX3N0eWxlW3NldF0odmFsdWUpO1xuXHRcdH07XG5cdH0pO1xuXG5cdEl0ZW0uaW5qZWN0KGl0ZW0pO1xuXHRyZXR1cm4gZmllbGRzO1xufSwge1xuXHRfY2xhc3M6ICdTdHlsZScsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU3R5bGUoc3R5bGUsIF9vd25lciwgX3Byb2plY3QpIHtcblx0XHR0aGlzLl92YWx1ZXMgPSB7fTtcblx0XHR0aGlzLl9vd25lciA9IF9vd25lcjtcblx0XHR0aGlzLl9wcm9qZWN0ID0gX293bmVyICYmIF9vd25lci5fcHJvamVjdCB8fCBfcHJvamVjdCB8fCBwYXBlci5wcm9qZWN0O1xuXHRcdGlmIChfb3duZXIgaW5zdGFuY2VvZiBUZXh0SXRlbSlcblx0XHRcdHRoaXMuX2RlZmF1bHRzID0gdGhpcy5fdGV4dERlZmF1bHRzO1xuXHRcdGlmIChzdHlsZSlcblx0XHRcdHRoaXMuc2V0KHN0eWxlKTtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHN0eWxlKSB7XG5cdFx0dmFyIGlzU3R5bGUgPSBzdHlsZSBpbnN0YW5jZW9mIFN0eWxlLFxuXHRcdFx0dmFsdWVzID0gaXNTdHlsZSA/IHN0eWxlLl92YWx1ZXMgOiBzdHlsZTtcblx0XHRpZiAodmFsdWVzKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gdmFsdWVzKSB7XG5cdFx0XHRcdGlmIChrZXkgaW4gdGhpcy5fZGVmYXVsdHMpIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSB2YWx1ZXNba2V5XTtcblx0XHRcdFx0XHR0aGlzW2tleV0gPSB2YWx1ZSAmJiBpc1N0eWxlICYmIHZhbHVlLmNsb25lXG5cdFx0XHRcdFx0XHRcdD8gdmFsdWUuY2xvbmUoKSA6IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc3R5bGUpIHtcblx0XHRyZXR1cm4gc3R5bGUgPT09IHRoaXMgfHwgc3R5bGUgJiYgdGhpcy5fY2xhc3MgPT09IHN0eWxlLl9jbGFzc1xuXHRcdFx0XHQmJiBCYXNlLmVxdWFscyh0aGlzLl92YWx1ZXMsIHN0eWxlLl92YWx1ZXMpXG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdGhhc0ZpbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhIXRoaXMuZ2V0RmlsbENvbG9yKCk7XG5cdH0sXG5cblx0aGFzU3Ryb2tlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISF0aGlzLmdldFN0cm9rZUNvbG9yKCkgJiYgdGhpcy5nZXRTdHJva2VXaWR0aCgpID4gMDtcblx0fSxcblxuXHRoYXNTaGFkb3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhIXRoaXMuZ2V0U2hhZG93Q29sb3IoKSAmJiB0aGlzLmdldFNoYWRvd0JsdXIoKSA+IDA7XG5cdH0sXG5cblx0Z2V0VmlldzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Byb2plY3QuZ2V0VmlldygpO1xuXHR9LFxuXG5cdGdldEZvbnRTdHlsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGZvbnRTaXplID0gdGhpcy5nZXRGb250U2l6ZSgpO1xuXHRcdHJldHVybiB0aGlzLmdldEZvbnRXZWlnaHQoKVxuXHRcdFx0XHQrICcgJyArIGZvbnRTaXplICsgKC9bYS16XS9pLnRlc3QoZm9udFNpemUgKyAnJykgPyAnICcgOiAncHggJylcblx0XHRcdFx0KyB0aGlzLmdldEZvbnRGYW1pbHkoKTtcblx0fSxcblxuXHRnZXRGb250OiAnI2dldEZvbnRGYW1pbHknLFxuXHRzZXRGb250OiAnI3NldEZvbnRGYW1pbHknLFxuXG5cdGdldExlYWRpbmc6IGZ1bmN0aW9uIGdldExlYWRpbmcoKSB7XG5cdFx0dmFyIGxlYWRpbmcgPSBnZXRMZWFkaW5nLmJhc2UuY2FsbCh0aGlzKSxcblx0XHRcdGZvbnRTaXplID0gdGhpcy5nZXRGb250U2l6ZSgpO1xuXHRcdGlmICgvcHR8ZW18JXxweC8udGVzdChmb250U2l6ZSkpXG5cdFx0XHRmb250U2l6ZSA9IHRoaXMuZ2V0VmlldygpLmdldFBpeGVsU2l6ZShmb250U2l6ZSk7XG5cdFx0cmV0dXJuIGxlYWRpbmcgIT0gbnVsbCA/IGxlYWRpbmcgOiBmb250U2l6ZSAqIDEuMjtcblx0fVxuXG59KTtcblxudmFyIERvbUVsZW1lbnQgPSBuZXcgZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIGhhbmRsZVByZWZpeChlbCwgbmFtZSwgc2V0LCB2YWx1ZSkge1xuXHRcdHZhciBwcmVmaXhlcyA9IFsnJywgJ3dlYmtpdCcsICdtb3onLCAnTW96JywgJ21zJywgJ28nXSxcblx0XHRcdHN1ZmZpeCA9IG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyaW5nKDEpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7XG5cdFx0XHR2YXIgcHJlZml4ID0gcHJlZml4ZXNbaV0sXG5cdFx0XHRcdGtleSA9IHByZWZpeCA/IHByZWZpeCArIHN1ZmZpeCA6IG5hbWU7XG5cdFx0XHRpZiAoa2V5IGluIGVsKSB7XG5cdFx0XHRcdGlmIChzZXQpIHtcblx0XHRcdFx0XHRlbFtrZXldID0gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRnZXRTdHlsZXM6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHR2YXIgZG9jID0gZWwgJiYgZWwubm9kZVR5cGUgIT09IDkgPyBlbC5vd25lckRvY3VtZW50IDogZWwsXG5cdFx0XHRcdHZpZXcgPSBkb2MgJiYgZG9jLmRlZmF1bHRWaWV3O1xuXHRcdFx0cmV0dXJuIHZpZXcgJiYgdmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCAnJyk7XG5cdFx0fSxcblxuXHRcdGdldEJvdW5kczogZnVuY3Rpb24oZWwsIHZpZXdwb3J0KSB7XG5cdFx0XHR2YXIgZG9jID0gZWwub3duZXJEb2N1bWVudCxcblx0XHRcdFx0Ym9keSA9IGRvYy5ib2R5LFxuXHRcdFx0XHRodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudCxcblx0XHRcdFx0cmVjdDtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0cmVjdCA9IHsgbGVmdDogMCwgdG9wOiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG5cdFx0XHR9XG5cdFx0XHR2YXIgeCA9IHJlY3QubGVmdCAtIChodG1sLmNsaWVudExlZnQgfHwgYm9keS5jbGllbnRMZWZ0IHx8IDApLFxuXHRcdFx0XHR5ID0gcmVjdC50b3AgLSAoaHRtbC5jbGllbnRUb3AgfHwgYm9keS5jbGllbnRUb3AgfHwgMCk7XG5cdFx0XHRpZiAoIXZpZXdwb3J0KSB7XG5cdFx0XHRcdHZhciB2aWV3ID0gZG9jLmRlZmF1bHRWaWV3O1xuXHRcdFx0XHR4ICs9IHZpZXcucGFnZVhPZmZzZXQgfHwgaHRtbC5zY3JvbGxMZWZ0IHx8IGJvZHkuc2Nyb2xsTGVmdDtcblx0XHRcdFx0eSArPSB2aWV3LnBhZ2VZT2Zmc2V0IHx8IGh0bWwuc2Nyb2xsVG9wIHx8IGJvZHkuc2Nyb2xsVG9wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoeCwgeSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuXHRcdH0sXG5cblx0XHRnZXRWaWV3cG9ydEJvdW5kczogZnVuY3Rpb24oZWwpIHtcblx0XHRcdHZhciBkb2MgPSBlbC5vd25lckRvY3VtZW50LFxuXHRcdFx0XHR2aWV3ID0gZG9jLmRlZmF1bHRWaWV3LFxuXHRcdFx0XHRodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKDAsIDAsXG5cdFx0XHRcdHZpZXcuaW5uZXJXaWR0aCB8fCBodG1sLmNsaWVudFdpZHRoLFxuXHRcdFx0XHR2aWV3LmlubmVySGVpZ2h0IHx8IGh0bWwuY2xpZW50SGVpZ2h0XG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHRnZXRPZmZzZXQ6IGZ1bmN0aW9uKGVsLCB2aWV3cG9ydCkge1xuXHRcdFx0cmV0dXJuIERvbUVsZW1lbnQuZ2V0Qm91bmRzKGVsLCB2aWV3cG9ydCkuZ2V0UG9pbnQoKTtcblx0XHR9LFxuXG5cdFx0Z2V0U2l6ZTogZnVuY3Rpb24oZWwpIHtcblx0XHRcdHJldHVybiBEb21FbGVtZW50LmdldEJvdW5kcyhlbCwgdHJ1ZSkuZ2V0U2l6ZSgpO1xuXHRcdH0sXG5cblx0XHRpc0ludmlzaWJsZTogZnVuY3Rpb24oZWwpIHtcblx0XHRcdHJldHVybiBEb21FbGVtZW50LmdldFNpemUoZWwpLmVxdWFscyhuZXcgU2l6ZSgwLCAwKSk7XG5cdFx0fSxcblxuXHRcdGlzSW5WaWV3OiBmdW5jdGlvbihlbCkge1xuXHRcdFx0cmV0dXJuICFEb21FbGVtZW50LmlzSW52aXNpYmxlKGVsKVxuXHRcdFx0XHRcdCYmIERvbUVsZW1lbnQuZ2V0Vmlld3BvcnRCb3VuZHMoZWwpLmludGVyc2VjdHMoXG5cdFx0XHRcdFx0XHREb21FbGVtZW50LmdldEJvdW5kcyhlbCwgdHJ1ZSkpO1xuXHRcdH0sXG5cblx0XHRnZXRQcmVmaXhlZDogZnVuY3Rpb24oZWwsIG5hbWUpIHtcblx0XHRcdHJldHVybiBoYW5kbGVQcmVmaXgoZWwsIG5hbWUpO1xuXHRcdH0sXG5cblx0XHRzZXRQcmVmaXhlZDogZnVuY3Rpb24oZWwsIG5hbWUsIHZhbHVlKSB7XG5cdFx0XHRpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBuYW1lKVxuXHRcdFx0XHRcdGhhbmRsZVByZWZpeChlbCwga2V5LCB0cnVlLCBuYW1lW2tleV0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlUHJlZml4KGVsLCBuYW1lLCB0cnVlLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxudmFyIERvbUV2ZW50ID0ge1xuXHRhZGQ6IGZ1bmN0aW9uKGVsLCBldmVudHMpIHtcblx0XHRmb3IgKHZhciB0eXBlIGluIGV2ZW50cykge1xuXHRcdFx0dmFyIGZ1bmMgPSBldmVudHNbdHlwZV0sXG5cdFx0XHRcdHBhcnRzID0gdHlwZS5zcGxpdCgvW1xccyxdKy9nKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRlbC5hZGRFdmVudExpc3RlbmVyKHBhcnRzW2ldLCBmdW5jLCBmYWxzZSk7XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oZWwsIGV2ZW50cykge1xuXHRcdGZvciAodmFyIHR5cGUgaW4gZXZlbnRzKSB7XG5cdFx0XHR2YXIgZnVuYyA9IGV2ZW50c1t0eXBlXSxcblx0XHRcdFx0cGFydHMgPSB0eXBlLnNwbGl0KC9bXFxzLF0rL2cpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIocGFydHNbaV0sIGZ1bmMsIGZhbHNlKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHBvcyA9IGV2ZW50LnRhcmdldFRvdWNoZXNcblx0XHRcdFx0PyBldmVudC50YXJnZXRUb3VjaGVzLmxlbmd0aFxuXHRcdFx0XHRcdD8gZXZlbnQudGFyZ2V0VG91Y2hlc1swXVxuXHRcdFx0XHRcdDogZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF1cblx0XHRcdFx0OiBldmVudDtcblx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0cG9zLnBhZ2VYIHx8IHBvcy5jbGllbnRYICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsXG5cdFx0XHRwb3MucGFnZVkgfHwgcG9zLmNsaWVudFkgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXG5cdFx0KTtcblx0fSxcblxuXHRnZXRUYXJnZXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0cmV0dXJuIGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50O1xuXHR9LFxuXG5cdGdldFJlbGF0ZWRUYXJnZXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0cmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgZXZlbnQudG9FbGVtZW50O1xuXHR9LFxuXG5cdGdldE9mZnNldDogZnVuY3Rpb24oZXZlbnQsIHRhcmdldCkge1xuXHRcdHJldHVybiBEb21FdmVudC5nZXRQb2ludChldmVudCkuc3VidHJhY3QoRG9tRWxlbWVudC5nZXRPZmZzZXQoXG5cdFx0XHRcdHRhcmdldCB8fCBEb21FdmVudC5nZXRUYXJnZXQoZXZlbnQpKSk7XG5cdH0sXG5cblx0c3RvcDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHR9XG59O1xuXG5Eb21FdmVudC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBuZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBuYXRpdmVSZXF1ZXN0ID0gRG9tRWxlbWVudC5nZXRQcmVmaXhlZCh3aW5kb3csICdyZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSxcblx0XHRyZXF1ZXN0ZWQgPSBmYWxzZSxcblx0XHRjYWxsYmFja3MgPSBbXSxcblx0XHRmb2N1c2VkID0gdHJ1ZSxcblx0XHR0aW1lcjtcblxuXHREb21FdmVudC5hZGQod2luZG93LCB7XG5cdFx0Zm9jdXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Zm9jdXNlZCA9IHRydWU7XG5cdFx0fSxcblx0XHRibHVyOiBmdW5jdGlvbigpIHtcblx0XHRcdGZvY3VzZWQgPSBmYWxzZTtcblx0XHR9XG5cdH0pO1xuXG5cdGZ1bmN0aW9uIGhhbmRsZUNhbGxiYWNrcygpIHtcblx0XHRmb3IgKHZhciBpID0gY2FsbGJhY2tzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgZW50cnkgPSBjYWxsYmFja3NbaV0sXG5cdFx0XHRcdGZ1bmMgPSBlbnRyeVswXSxcblx0XHRcdFx0ZWwgPSBlbnRyeVsxXTtcblx0XHRcdGlmICghZWwgfHwgKFBhcGVyU2NvcGUuZ2V0QXR0cmlidXRlKGVsLCAna2VlcGFsaXZlJykgPT0gJ3RydWUnXG5cdFx0XHRcdFx0fHwgZm9jdXNlZCkgJiYgRG9tRWxlbWVudC5pc0luVmlldyhlbCkpIHtcblx0XHRcdFx0Y2FsbGJhY2tzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0ZnVuYygpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAobmF0aXZlUmVxdWVzdCkge1xuXHRcdFx0aWYgKGNhbGxiYWNrcy5sZW5ndGgpIHtcblx0XHRcdFx0bmF0aXZlUmVxdWVzdChoYW5kbGVDYWxsYmFja3MpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVxdWVzdGVkID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrLCBlbGVtZW50KSB7XG5cdFx0Y2FsbGJhY2tzLnB1c2goW2NhbGxiYWNrLCBlbGVtZW50XSk7XG5cdFx0aWYgKG5hdGl2ZVJlcXVlc3QpIHtcblx0XHRcdGlmICghcmVxdWVzdGVkKSB7XG5cdFx0XHRcdG5hdGl2ZVJlcXVlc3QoaGFuZGxlQ2FsbGJhY2tzKTtcblx0XHRcdFx0cmVxdWVzdGVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKCF0aW1lcikge1xuXHRcdFx0dGltZXIgPSBzZXRJbnRlcnZhbChoYW5kbGVDYWxsYmFja3MsIDEwMDAgLyA2MCk7XG5cdFx0fVxuXHR9O1xufTtcblxudmFyIFZpZXcgPSBCYXNlLmV4dGVuZChFbWl0dGVyLCB7XG5cdF9jbGFzczogJ1ZpZXcnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFZpZXcocHJvamVjdCwgZWxlbWVudCkge1xuXHRcdHRoaXMuX3Byb2plY3QgPSBwcm9qZWN0O1xuXHRcdHRoaXMuX3Njb3BlID0gcHJvamVjdC5fc2NvcGU7XG5cdFx0dGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG5cdFx0dmFyIHNpemU7XG5cdFx0aWYgKCF0aGlzLl9waXhlbFJhdGlvKVxuXHRcdFx0dGhpcy5fcGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG5cdFx0dGhpcy5faWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKTtcblx0XHRpZiAodGhpcy5faWQgPT0gbnVsbClcblx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuX2lkID0gJ3ZpZXctJyArIFZpZXcuX2lkKyspO1xuXHRcdERvbUV2ZW50LmFkZChlbGVtZW50LCB0aGlzLl92aWV3RXZlbnRzKTtcblx0XHR2YXIgbm9uZSA9ICdub25lJztcblx0XHREb21FbGVtZW50LnNldFByZWZpeGVkKGVsZW1lbnQuc3R5bGUsIHtcblx0XHRcdHVzZXJTZWxlY3Q6IG5vbmUsXG5cdFx0XHR0b3VjaEFjdGlvbjogbm9uZSxcblx0XHRcdHRvdWNoQ2FsbG91dDogbm9uZSxcblx0XHRcdGNvbnRlbnRab29taW5nOiBub25lLFxuXHRcdFx0dXNlckRyYWc6IG5vbmUsXG5cdFx0XHR0YXBIaWdobGlnaHRDb2xvcjogJ3JnYmEoMCwwLDAsMCknXG5cdFx0fSk7XG5cblx0XHRmdW5jdGlvbiBnZXRTaXplKG5hbWUpIHtcblx0XHRcdHJldHVybiBlbGVtZW50W25hbWVdIHx8IHBhcnNlSW50KGVsZW1lbnQuZ2V0QXR0cmlidXRlKG5hbWUpLCAxMCk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGdldENhbnZhc1NpemUoKSB7XG5cdFx0XHR2YXIgc2l6ZSA9IERvbUVsZW1lbnQuZ2V0U2l6ZShlbGVtZW50KTtcblx0XHRcdHJldHVybiBzaXplLmlzTmFOKCkgfHwgc2l6ZS5pc1plcm8oKVxuXHRcdFx0XHRcdD8gbmV3IFNpemUoZ2V0U2l6ZSgnd2lkdGgnKSwgZ2V0U2l6ZSgnaGVpZ2h0JykpXG5cdFx0XHRcdFx0OiBzaXplO1xuXHRcdH07XG5cblx0XHRpZiAoUGFwZXJTY29wZS5oYXNBdHRyaWJ1dGUoZWxlbWVudCwgJ3Jlc2l6ZScpKSB7XG5cdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0XHREb21FdmVudC5hZGQod2luZG93LCB0aGlzLl93aW5kb3dFdmVudHMgPSB7XG5cdFx0XHRcdHJlc2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dGhhdC5zZXRWaWV3U2l6ZShnZXRDYW52YXNTaXplKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0dGhpcy5fc2V0Vmlld1NpemUoc2l6ZSA9IGdldENhbnZhc1NpemUoKSk7XG5cdFx0aWYgKFBhcGVyU2NvcGUuaGFzQXR0cmlidXRlKGVsZW1lbnQsICdzdGF0cycpXG5cdFx0XHRcdCYmIHR5cGVvZiBTdGF0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHRoaXMuX3N0YXRzID0gbmV3IFN0YXRzKCk7XG5cdFx0XHR2YXIgc3RhdHMgPSB0aGlzLl9zdGF0cy5kb21FbGVtZW50LFxuXHRcdFx0XHRzdHlsZSA9IHN0YXRzLnN0eWxlLFxuXHRcdFx0XHRvZmZzZXQgPSBEb21FbGVtZW50LmdldE9mZnNldChlbGVtZW50KTtcblx0XHRcdHN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblx0XHRcdHN0eWxlLmxlZnQgPSBvZmZzZXQueCArICdweCc7XG5cdFx0XHRzdHlsZS50b3AgPSBvZmZzZXQueSArICdweCc7XG5cdFx0XHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN0YXRzKTtcblx0XHR9XG5cdFx0Vmlldy5fdmlld3MucHVzaCh0aGlzKTtcblx0XHRWaWV3Ll92aWV3c0J5SWRbdGhpcy5faWRdID0gdGhpcztcblx0XHR0aGlzLl92aWV3U2l6ZSA9IHNpemU7XG5cdFx0KHRoaXMuX21hdHJpeCA9IG5ldyBNYXRyaXgoKSkuX293bmVyID0gdGhpcztcblx0XHR0aGlzLl96b29tID0gMTtcblx0XHRpZiAoIVZpZXcuX2ZvY3VzZWQpXG5cdFx0XHRWaWV3Ll9mb2N1c2VkID0gdGhpcztcblx0XHR0aGlzLl9mcmFtZUl0ZW1zID0ge307XG5cdFx0dGhpcy5fZnJhbWVJdGVtQ291bnQgPSAwO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9wcm9qZWN0KVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdGlmIChWaWV3Ll9mb2N1c2VkID09PSB0aGlzKVxuXHRcdFx0Vmlldy5fZm9jdXNlZCA9IG51bGw7XG5cdFx0Vmlldy5fdmlld3Muc3BsaWNlKFZpZXcuX3ZpZXdzLmluZGV4T2YodGhpcyksIDEpO1xuXHRcdGRlbGV0ZSBWaWV3Ll92aWV3c0J5SWRbdGhpcy5faWRdO1xuXHRcdGlmICh0aGlzLl9wcm9qZWN0Ll92aWV3ID09PSB0aGlzKVxuXHRcdFx0dGhpcy5fcHJvamVjdC5fdmlldyA9IG51bGw7XG5cdFx0RG9tRXZlbnQucmVtb3ZlKHRoaXMuX2VsZW1lbnQsIHRoaXMuX3ZpZXdFdmVudHMpO1xuXHRcdERvbUV2ZW50LnJlbW92ZSh3aW5kb3csIHRoaXMuX3dpbmRvd0V2ZW50cyk7XG5cdFx0dGhpcy5fZWxlbWVudCA9IHRoaXMuX3Byb2plY3QgPSBudWxsO1xuXHRcdHRoaXMub2ZmKCdmcmFtZScpO1xuXHRcdHRoaXMuX2FuaW1hdGUgPSBmYWxzZTtcblx0XHR0aGlzLl9mcmFtZUl0ZW1zID0ge307XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X2V2ZW50czoge1xuXHRcdG9uRnJhbWU6IHtcblx0XHRcdGluc3RhbGw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnBsYXkoKTtcblx0XHRcdH0sXG5cblx0XHRcdHVuaW5zdGFsbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMucGF1c2UoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0b25SZXNpemU6IHt9XG5cdH0sXG5cblx0X2FuaW1hdGU6IGZhbHNlLFxuXHRfdGltZTogMCxcblx0X2NvdW50OiAwLFxuXG5cdF9yZXF1ZXN0RnJhbWU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHREb21FdmVudC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGF0Ll9yZXF1ZXN0ZWQgPSBmYWxzZTtcblx0XHRcdGlmICghdGhhdC5fYW5pbWF0ZSlcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dGhhdC5fcmVxdWVzdEZyYW1lKCk7XG5cdFx0XHR0aGF0Ll9oYW5kbGVGcmFtZSgpO1xuXHRcdH0sIHRoaXMuX2VsZW1lbnQpO1xuXHRcdHRoaXMuX3JlcXVlc3RlZCA9IHRydWU7XG5cdH0sXG5cblx0X2hhbmRsZUZyYW1lOiBmdW5jdGlvbigpIHtcblx0XHRwYXBlciA9IHRoaXMuX3Njb3BlO1xuXHRcdHZhciBub3cgPSBEYXRlLm5vdygpIC8gMTAwMCxcblx0XHRcdGRlbHRhID0gdGhpcy5fYmVmb3JlID8gbm93IC0gdGhpcy5fYmVmb3JlIDogMDtcblx0XHR0aGlzLl9iZWZvcmUgPSBub3c7XG5cdFx0dGhpcy5faGFuZGxpbmdGcmFtZSA9IHRydWU7XG5cdFx0dGhpcy5lbWl0KCdmcmFtZScsIG5ldyBCYXNlKHtcblx0XHRcdGRlbHRhOiBkZWx0YSxcblx0XHRcdHRpbWU6IHRoaXMuX3RpbWUgKz0gZGVsdGEsXG5cdFx0XHRjb3VudDogdGhpcy5fY291bnQrK1xuXHRcdH0pKTtcblx0XHRpZiAodGhpcy5fc3RhdHMpXG5cdFx0XHR0aGlzLl9zdGF0cy51cGRhdGUoKTtcblx0XHR0aGlzLl9oYW5kbGluZ0ZyYW1lID0gZmFsc2U7XG5cdFx0dGhpcy51cGRhdGUoKTtcblx0fSxcblxuXHRfYW5pbWF0ZUl0ZW06IGZ1bmN0aW9uKGl0ZW0sIGFuaW1hdGUpIHtcblx0XHR2YXIgaXRlbXMgPSB0aGlzLl9mcmFtZUl0ZW1zO1xuXHRcdGlmIChhbmltYXRlKSB7XG5cdFx0XHRpdGVtc1tpdGVtLl9pZF0gPSB7XG5cdFx0XHRcdGl0ZW06IGl0ZW0sXG5cdFx0XHRcdHRpbWU6IDAsXG5cdFx0XHRcdGNvdW50OiAwXG5cdFx0XHR9O1xuXHRcdFx0aWYgKCsrdGhpcy5fZnJhbWVJdGVtQ291bnQgPT09IDEpXG5cdFx0XHRcdHRoaXMub24oJ2ZyYW1lJywgdGhpcy5faGFuZGxlRnJhbWVJdGVtcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlbGV0ZSBpdGVtc1tpdGVtLl9pZF07XG5cdFx0XHRpZiAoLS10aGlzLl9mcmFtZUl0ZW1Db3VudCA9PT0gMCkge1xuXHRcdFx0XHR0aGlzLm9mZignZnJhbWUnLCB0aGlzLl9oYW5kbGVGcmFtZUl0ZW1zKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2hhbmRsZUZyYW1lSXRlbXM6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9mcmFtZUl0ZW1zKSB7XG5cdFx0XHR2YXIgZW50cnkgPSB0aGlzLl9mcmFtZUl0ZW1zW2ldO1xuXHRcdFx0ZW50cnkuaXRlbS5lbWl0KCdmcmFtZScsIG5ldyBCYXNlKGV2ZW50LCB7XG5cdFx0XHRcdHRpbWU6IGVudHJ5LnRpbWUgKz0gZXZlbnQuZGVsdGEsXG5cdFx0XHRcdGNvdW50OiBlbnRyeS5jb3VudCsrXG5cdFx0XHR9KSk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3Byb2plY3QuX25lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRpZiAodGhpcy5faGFuZGxpbmdGcmFtZSlcblx0XHRcdHJldHVybjtcblx0XHRpZiAodGhpcy5fYW5pbWF0ZSkge1xuXHRcdFx0dGhpcy5faGFuZGxlRnJhbWUoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKGZsYWdzKSB7XG5cdFx0aWYgKGZsYWdzICYgMSlcblx0XHRcdHRoaXMuX3Byb2plY3QuX25lZWRzVXBkYXRlID0gdHJ1ZTtcblx0fSxcblxuXHRfdHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR0aGlzLl9tYXRyaXguY29uY2F0ZW5hdGUobWF0cml4KTtcblx0XHR0aGlzLl9ib3VuZHMgPSBudWxsO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9lbGVtZW50O1xuXHR9LFxuXG5cdGdldFBpeGVsUmF0aW86IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9waXhlbFJhdGlvO1xuXHR9LFxuXG5cdGdldFJlc29sdXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9waXhlbFJhdGlvICogNzI7XG5cdH0sXG5cblx0Z2V0Vmlld1NpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gdGhpcy5fdmlld1NpemU7XG5cdFx0cmV0dXJuIG5ldyBMaW5rZWRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCB0aGlzLCAnc2V0Vmlld1NpemUnKTtcblx0fSxcblxuXHRzZXRWaWV3U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGRlbHRhID0gc2l6ZS5zdWJ0cmFjdCh0aGlzLl92aWV3U2l6ZSk7XG5cdFx0aWYgKGRlbHRhLmlzWmVybygpKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHRoaXMuX3ZpZXdTaXplLnNldChzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG5cdFx0dGhpcy5fc2V0Vmlld1NpemUoc2l6ZSk7XG5cdFx0dGhpcy5fYm91bmRzID0gbnVsbDtcblx0XHR0aGlzLmVtaXQoJ3Jlc2l6ZScsIHtcblx0XHRcdHNpemU6IHNpemUsXG5cdFx0XHRkZWx0YTogZGVsdGFcblx0XHR9KTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRfc2V0Vmlld1NpemU6IGZ1bmN0aW9uKHNpemUpIHtcblx0XHR2YXIgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQ7XG5cdFx0ZWxlbWVudC53aWR0aCA9IHNpemUud2lkdGg7XG5cdFx0ZWxlbWVudC5oZWlnaHQgPSBzaXplLmhlaWdodDtcblx0fSxcblxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fYm91bmRzKVxuXHRcdFx0dGhpcy5fYm91bmRzID0gdGhpcy5fbWF0cml4LmludmVydGVkKCkuX3RyYW5zZm9ybUJvdW5kcyhcblx0XHRcdFx0XHRuZXcgUmVjdGFuZ2xlKG5ldyBQb2ludCgpLCB0aGlzLl92aWV3U2l6ZSkpO1xuXHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XG5cdH0sXG5cblx0Z2V0U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Qm91bmRzKCkuZ2V0U2l6ZSgpO1xuXHR9LFxuXG5cdGdldENlbnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Qm91bmRzKCkuZ2V0Q2VudGVyKCk7XG5cdH0sXG5cblx0c2V0Q2VudGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuc2Nyb2xsQnkoY2VudGVyLnN1YnRyYWN0KHRoaXMuZ2V0Q2VudGVyKCkpKTtcblx0fSxcblxuXHRnZXRab29tOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fem9vbTtcblx0fSxcblxuXHRzZXRab29tOiBmdW5jdGlvbih6b29tKSB7XG5cdFx0dGhpcy5fdHJhbnNmb3JtKG5ldyBNYXRyaXgoKS5zY2FsZSh6b29tIC8gdGhpcy5fem9vbSxcblx0XHRcdHRoaXMuZ2V0Q2VudGVyKCkpKTtcblx0XHR0aGlzLl96b29tID0gem9vbTtcblx0fSxcblxuXHRpc1Zpc2libGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBEb21FbGVtZW50LmlzSW5WaWV3KHRoaXMuX2VsZW1lbnQpO1xuXHR9LFxuXG5cdHNjcm9sbEJ5OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl90cmFuc2Zvcm0obmV3IE1hdHJpeCgpLnRyYW5zbGF0ZShQb2ludC5yZWFkKGFyZ3VtZW50cykubmVnYXRlKCkpKTtcblx0fSxcblxuXHRwbGF5OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9hbmltYXRlID0gdHJ1ZTtcblx0XHRpZiAoIXRoaXMuX3JlcXVlc3RlZClcblx0XHRcdHRoaXMuX3JlcXVlc3RGcmFtZSgpO1xuXHR9LFxuXG5cdHBhdXNlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9hbmltYXRlID0gZmFsc2U7XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51cGRhdGUoKTtcblx0fSxcblxuXHRwcm9qZWN0VG9WaWV3OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdHZpZXdUb1Byb2plY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0oUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fVxuXG59LCB7XG5cdHN0YXRpY3M6IHtcblx0XHRfdmlld3M6IFtdLFxuXHRcdF92aWV3c0J5SWQ6IHt9LFxuXHRcdF9pZDogMCxcblxuXHRcdGNyZWF0ZTogZnVuY3Rpb24ocHJvamVjdCwgZWxlbWVudCkge1xuXHRcdFx0aWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJylcblx0XHRcdFx0ZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnQpO1xuXHRcdFx0cmV0dXJuIG5ldyBDYW52YXNWaWV3KHByb2plY3QsIGVsZW1lbnQpO1xuXHRcdH1cblx0fVxufSwgbmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgdG9vbCxcblx0XHRwcmV2Rm9jdXMsXG5cdFx0dGVtcEZvY3VzLFxuXHRcdGRyYWdnaW5nID0gZmFsc2U7XG5cblx0ZnVuY3Rpb24gZ2V0VmlldyhldmVudCkge1xuXHRcdHZhciB0YXJnZXQgPSBEb21FdmVudC5nZXRUYXJnZXQoZXZlbnQpO1xuXHRcdHJldHVybiB0YXJnZXQuZ2V0QXR0cmlidXRlICYmIFZpZXcuX3ZpZXdzQnlJZFt0YXJnZXQuZ2V0QXR0cmlidXRlKCdpZCcpXTtcblx0fVxuXG5cdGZ1bmN0aW9uIHZpZXdUb1Byb2plY3QodmlldywgZXZlbnQpIHtcblx0XHRyZXR1cm4gdmlldy52aWV3VG9Qcm9qZWN0KERvbUV2ZW50LmdldE9mZnNldChldmVudCwgdmlldy5fZWxlbWVudCkpO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlRm9jdXMoKSB7XG5cdFx0aWYgKCFWaWV3Ll9mb2N1c2VkIHx8ICFWaWV3Ll9mb2N1c2VkLmlzVmlzaWJsZSgpKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IFZpZXcuX3ZpZXdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgdmlldyA9IFZpZXcuX3ZpZXdzW2ldO1xuXHRcdFx0XHRpZiAodmlldyAmJiB2aWV3LmlzVmlzaWJsZSgpKSB7XG5cdFx0XHRcdFx0Vmlldy5fZm9jdXNlZCA9IHRlbXBGb2N1cyA9IHZpZXc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUodmlldywgcG9pbnQsIGV2ZW50KSB7XG5cdFx0dmlldy5faGFuZGxlRXZlbnQoJ21vdXNlbW92ZScsIHBvaW50LCBldmVudCk7XG5cdFx0dmFyIHRvb2wgPSB2aWV3Ll9zY29wZS50b29sO1xuXHRcdGlmICh0b29sKSB7XG5cdFx0XHR0b29sLl9oYW5kbGVFdmVudChkcmFnZ2luZyAmJiB0b29sLnJlc3BvbmRzKCdtb3VzZWRyYWcnKVxuXHRcdFx0XHRcdD8gJ21vdXNlZHJhZycgOiAnbW91c2Vtb3ZlJywgcG9pbnQsIGV2ZW50KTtcblx0XHR9XG5cdFx0dmlldy51cGRhdGUoKTtcblx0XHRyZXR1cm4gdG9vbDtcblx0fVxuXG5cdHZhciBuYXZpZ2F0b3IgPSB3aW5kb3cubmF2aWdhdG9yLFxuXHRcdG1vdXNlZG93biwgbW91c2Vtb3ZlLCBtb3VzZXVwO1xuXHRpZiAobmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkIHx8IG5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkKSB7XG5cdFx0bW91c2Vkb3duID0gJ3BvaW50ZXJkb3duIE1TUG9pbnRlckRvd24nO1xuXHRcdG1vdXNlbW92ZSA9ICdwb2ludGVybW92ZSBNU1BvaW50ZXJNb3ZlJztcblx0XHRtb3VzZXVwID0gJ3BvaW50ZXJ1cCBwb2ludGVyY2FuY2VsIE1TUG9pbnRlclVwIE1TUG9pbnRlckNhbmNlbCc7XG5cdH0gZWxzZSB7XG5cdFx0bW91c2Vkb3duID0gJ3RvdWNoc3RhcnQnO1xuXHRcdG1vdXNlbW92ZSA9ICd0b3VjaG1vdmUnO1xuXHRcdG1vdXNldXAgPSAndG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuXHRcdGlmICghKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyAmJiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKFxuXHRcdFx0XHQvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkfHNpbGsvaSkpKSB7XG5cdFx0XHRtb3VzZWRvd24gKz0gJyBtb3VzZWRvd24nO1xuXHRcdFx0bW91c2Vtb3ZlICs9ICcgbW91c2Vtb3ZlJztcblx0XHRcdG1vdXNldXAgKz0gJyBtb3VzZXVwJztcblx0XHR9XG5cdH1cblxuXHR2YXIgdmlld0V2ZW50cyA9IHtcblx0XHQnc2VsZWN0c3RhcnQgZHJhZ3N0YXJ0JzogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdGlmIChkcmFnZ2luZylcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH07XG5cblx0dmFyIGRvY0V2ZW50cyA9IHtcblx0XHRtb3VzZW91dDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHZhciB2aWV3ID0gVmlldy5fZm9jdXNlZCxcblx0XHRcdFx0dGFyZ2V0ID0gRG9tRXZlbnQuZ2V0UmVsYXRlZFRhcmdldChldmVudCk7XG5cdFx0XHRpZiAodmlldyAmJiAoIXRhcmdldCB8fCB0YXJnZXQubm9kZU5hbWUgPT09ICdIVE1MJykpXG5cdFx0XHRcdGhhbmRsZU1vdXNlTW92ZSh2aWV3LCB2aWV3VG9Qcm9qZWN0KHZpZXcsIGV2ZW50KSwgZXZlbnQpO1xuXHRcdH0sXG5cblx0XHRzY3JvbGw6IHVwZGF0ZUZvY3VzXG5cdH07XG5cblx0dmlld0V2ZW50c1ttb3VzZWRvd25dID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdmlldyA9IFZpZXcuX2ZvY3VzZWQgPSBnZXRWaWV3KGV2ZW50KSxcblx0XHRcdHBvaW50ID0gdmlld1RvUHJvamVjdCh2aWV3LCBldmVudCk7XG5cdFx0ZHJhZ2dpbmcgPSB0cnVlO1xuXHRcdHZpZXcuX2hhbmRsZUV2ZW50KCdtb3VzZWRvd24nLCBwb2ludCwgZXZlbnQpO1xuXHRcdGlmICh0b29sID0gdmlldy5fc2NvcGUudG9vbClcblx0XHRcdHRvb2wuX2hhbmRsZUV2ZW50KCdtb3VzZWRvd24nLCBwb2ludCwgZXZlbnQpO1xuXHRcdHZpZXcudXBkYXRlKCk7XG5cdH07XG5cblx0ZG9jRXZlbnRzW21vdXNlbW92ZV0gPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciB2aWV3ID0gVmlldy5fZm9jdXNlZDtcblx0XHRpZiAoIWRyYWdnaW5nKSB7XG5cdFx0XHR2YXIgdGFyZ2V0ID0gZ2V0VmlldyhldmVudCk7XG5cdFx0XHRpZiAodGFyZ2V0KSB7XG5cdFx0XHRcdGlmICh2aWV3ICE9PSB0YXJnZXQpXG5cdFx0XHRcdFx0aGFuZGxlTW91c2VNb3ZlKHZpZXcsIHZpZXdUb1Byb2plY3QodmlldywgZXZlbnQpLCBldmVudCk7XG5cdFx0XHRcdHByZXZGb2N1cyA9IHZpZXc7XG5cdFx0XHRcdHZpZXcgPSBWaWV3Ll9mb2N1c2VkID0gdGVtcEZvY3VzID0gdGFyZ2V0O1xuXHRcdFx0fSBlbHNlIGlmICh0ZW1wRm9jdXMgJiYgdGVtcEZvY3VzID09PSB2aWV3KSB7XG5cdFx0XHRcdHZpZXcgPSBWaWV3Ll9mb2N1c2VkID0gcHJldkZvY3VzO1xuXHRcdFx0XHR1cGRhdGVGb2N1cygpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAodmlldykge1xuXHRcdFx0dmFyIHBvaW50ID0gdmlld1RvUHJvamVjdCh2aWV3LCBldmVudCk7XG5cdFx0XHRpZiAoZHJhZ2dpbmcgfHwgdmlldy5nZXRCb3VuZHMoKS5jb250YWlucyhwb2ludCkpXG5cdFx0XHRcdHRvb2wgPSBoYW5kbGVNb3VzZU1vdmUodmlldywgcG9pbnQsIGV2ZW50KTtcblx0XHR9XG5cdH07XG5cblx0ZG9jRXZlbnRzW21vdXNldXBdID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdmlldyA9IFZpZXcuX2ZvY3VzZWQ7XG5cdFx0aWYgKCF2aWV3IHx8ICFkcmFnZ2luZylcblx0XHRcdHJldHVybjtcblx0XHR2YXIgcG9pbnQgPSB2aWV3VG9Qcm9qZWN0KHZpZXcsIGV2ZW50KTtcblx0XHRkcmFnZ2luZyA9IGZhbHNlO1xuXHRcdHZpZXcuX2hhbmRsZUV2ZW50KCdtb3VzZXVwJywgcG9pbnQsIGV2ZW50KTtcblx0XHRpZiAodG9vbClcblx0XHRcdHRvb2wuX2hhbmRsZUV2ZW50KCdtb3VzZXVwJywgcG9pbnQsIGV2ZW50KTtcblx0XHR2aWV3LnVwZGF0ZSgpO1xuXHR9O1xuXG5cdERvbUV2ZW50LmFkZChkb2N1bWVudCwgZG9jRXZlbnRzKTtcblxuXHREb21FdmVudC5hZGQod2luZG93LCB7XG5cdFx0bG9hZDogdXBkYXRlRm9jdXNcblx0fSk7XG5cblx0cmV0dXJuIHtcblx0XHRfdmlld0V2ZW50czogdmlld0V2ZW50cyxcblxuXHRcdF9oYW5kbGVFdmVudDogZnVuY3Rpb24oKSB7fSxcblxuXHRcdHN0YXRpY3M6IHtcblx0XHRcdHVwZGF0ZUZvY3VzOiB1cGRhdGVGb2N1c1xuXHRcdH1cblx0fTtcbn0pO1xuXG52YXIgQ2FudmFzVmlldyA9IFZpZXcuZXh0ZW5kKHtcblx0X2NsYXNzOiAnQ2FudmFzVmlldycsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gQ2FudmFzVmlldyhwcm9qZWN0LCBjYW52YXMpIHtcblx0XHRpZiAoIShjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkpIHtcblx0XHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cywgMSk7XG5cdFx0XHRpZiAoc2l6ZS5pc1plcm8oKSlcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdFx0J0Nhbm5vdCBjcmVhdGUgQ2FudmFzVmlldyB3aXRoIHRoZSBwcm92aWRlZCBhcmd1bWVudDogJ1xuXHRcdFx0XHRcdFx0KyBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuXHRcdFx0Y2FudmFzID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKHNpemUpO1xuXHRcdH1cblx0XHR0aGlzLl9jb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdFx0dGhpcy5fZXZlbnRDb3VudGVycyA9IHt9O1xuXHRcdHRoaXMuX3BpeGVsUmF0aW8gPSAxO1xuXHRcdGlmICghL15vZmZ8ZmFsc2UkLy50ZXN0KFBhcGVyU2NvcGUuZ2V0QXR0cmlidXRlKGNhbnZhcywgJ2hpZHBpJykpKSB7XG5cdFx0XHR2YXIgZGV2aWNlUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLFxuXHRcdFx0XHRiYWNraW5nU3RvcmVSYXRpbyA9IERvbUVsZW1lbnQuZ2V0UHJlZml4ZWQodGhpcy5fY29udGV4dCxcblx0XHRcdFx0XHRcdCdiYWNraW5nU3RvcmVQaXhlbFJhdGlvJykgfHwgMTtcblx0XHRcdHRoaXMuX3BpeGVsUmF0aW8gPSBkZXZpY2VSYXRpbyAvIGJhY2tpbmdTdG9yZVJhdGlvO1xuXHRcdH1cblx0XHRWaWV3LmNhbGwodGhpcywgcHJvamVjdCwgY2FudmFzKTtcblx0fSxcblxuXHRfc2V0Vmlld1NpemU6IGZ1bmN0aW9uKHNpemUpIHtcblx0XHR2YXIgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQsXG5cdFx0XHRwaXhlbFJhdGlvID0gdGhpcy5fcGl4ZWxSYXRpbyxcblx0XHRcdHdpZHRoID0gc2l6ZS53aWR0aCxcblx0XHRcdGhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdGVsZW1lbnQud2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XG5cdFx0ZWxlbWVudC5oZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xuXHRcdGlmIChwaXhlbFJhdGlvICE9PSAxKSB7XG5cdFx0XHRpZiAoIVBhcGVyU2NvcGUuaGFzQXR0cmlidXRlKGVsZW1lbnQsICdyZXNpemUnKSkge1xuXHRcdFx0XHR2YXIgc3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuXHRcdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4Jztcblx0XHRcdFx0c3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4Jztcblx0XHRcdH1cblx0XHRcdHRoaXMuX2NvbnRleHQuc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFBpeGVsU2l6ZTogZnVuY3Rpb24oc2l6ZSkge1xuXHRcdHZhciBicm93c2VyID0gcGFwZXIuYnJvd3Nlcixcblx0XHRcdHBpeGVscztcblx0XHRpZiAoYnJvd3NlciAmJiBicm93c2VyLmZpcmVmb3gpIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUsXG5cdFx0XHRcdHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRcdHRlbXAuc3R5bGUuZm9udFNpemUgPSBzaXplO1xuXHRcdFx0cGFyZW50LmFwcGVuZENoaWxkKHRlbXApO1xuXHRcdFx0cGl4ZWxzID0gcGFyc2VGbG9hdChEb21FbGVtZW50LmdldFN0eWxlcyh0ZW1wKS5mb250U2l6ZSk7XG5cdFx0XHRwYXJlbnQucmVtb3ZlQ2hpbGQodGVtcCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBjdHggPSB0aGlzLl9jb250ZXh0LFxuXHRcdFx0XHRwcmV2Rm9udCA9IGN0eC5mb250O1xuXHRcdFx0Y3R4LmZvbnQgPSBzaXplICsgJyBzZXJpZic7XG5cdFx0XHRwaXhlbHMgPSBwYXJzZUZsb2F0KGN0eC5mb250KTtcblx0XHRcdGN0eC5mb250ID0gcHJldkZvbnQ7XG5cdFx0fVxuXHRcdHJldHVybiBwaXhlbHM7XG5cdH0sXG5cblx0Z2V0VGV4dFdpZHRoOiBmdW5jdGlvbihmb250LCBsaW5lcykge1xuXHRcdHZhciBjdHggPSB0aGlzLl9jb250ZXh0LFxuXHRcdFx0cHJldkZvbnQgPSBjdHguZm9udCxcblx0XHRcdHdpZHRoID0gMDtcblx0XHRjdHguZm9udCA9IGZvbnQ7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHR3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBjdHgubWVhc3VyZVRleHQobGluZXNbaV0pLndpZHRoKTtcblx0XHRjdHguZm9udCA9IHByZXZGb250O1xuXHRcdHJldHVybiB3aWR0aDtcblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKGZvcmNlKSB7XG5cdFx0dmFyIHByb2plY3QgPSB0aGlzLl9wcm9qZWN0O1xuXHRcdGlmICghcHJvamVjdCB8fCAhZm9yY2UgJiYgIXByb2plY3QuX25lZWRzVXBkYXRlKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdHZhciBjdHggPSB0aGlzLl9jb250ZXh0LFxuXHRcdFx0c2l6ZSA9IHRoaXMuX3ZpZXdTaXplO1xuXHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgc2l6ZS53aWR0aCArIDEsIHNpemUuaGVpZ2h0ICsgMSk7XG5cdFx0cHJvamVjdC5kcmF3KGN0eCwgdGhpcy5fbWF0cml4LCB0aGlzLl9waXhlbFJhdGlvKTtcblx0XHRwcm9qZWN0Ll9uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59LCBuZXcgZnVuY3Rpb24oKSB7XG5cblx0dmFyIGRvd25Qb2ludCxcblx0XHRsYXN0UG9pbnQsXG5cdFx0b3ZlclBvaW50LFxuXHRcdGRvd25JdGVtLFxuXHRcdGxhc3RJdGVtLFxuXHRcdG92ZXJJdGVtLFxuXHRcdGRyYWdJdGVtLFxuXHRcdGRibENsaWNrLFxuXHRcdGNsaWNrVGltZTtcblxuXHRmdW5jdGlvbiBjYWxsRXZlbnQodmlldywgdHlwZSwgZXZlbnQsIHBvaW50LCB0YXJnZXQsIGxhc3RQb2ludCkge1xuXHRcdHZhciBpdGVtID0gdGFyZ2V0LFxuXHRcdFx0bW91c2VFdmVudDtcblxuXHRcdGZ1bmN0aW9uIGNhbGwob2JqKSB7XG5cdFx0XHRpZiAob2JqLnJlc3BvbmRzKHR5cGUpKSB7XG5cdFx0XHRcdGlmICghbW91c2VFdmVudCkge1xuXHRcdFx0XHRcdG1vdXNlRXZlbnQgPSBuZXcgTW91c2VFdmVudCh0eXBlLCBldmVudCwgcG9pbnQsIHRhcmdldCxcblx0XHRcdFx0XHRcdFx0bGFzdFBvaW50ID8gcG9pbnQuc3VidHJhY3QobGFzdFBvaW50KSA6IG51bGwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChvYmouZW1pdCh0eXBlLCBtb3VzZUV2ZW50KSAmJiBtb3VzZUV2ZW50LmlzU3RvcHBlZCkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR3aGlsZSAoaXRlbSkge1xuXHRcdFx0aWYgKGNhbGwoaXRlbSkpXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0aXRlbSA9IGl0ZW0uZ2V0UGFyZW50KCk7XG5cdFx0fVxuXHRcdGlmIChjYWxsKHZpZXcpKVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRfaGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKHR5cGUsIHBvaW50LCBldmVudCkge1xuXHRcdFx0aWYgKCF0aGlzLl9ldmVudENvdW50ZXJzW3R5cGVdKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3QsXG5cdFx0XHRcdGhpdCA9IHByb2plY3QuaGl0VGVzdChwb2ludCwge1xuXHRcdFx0XHRcdHRvbGVyYW5jZTogMCxcblx0XHRcdFx0XHRmaWxsOiB0cnVlLFxuXHRcdFx0XHRcdHN0cm9rZTogdHJ1ZVxuXHRcdFx0XHR9KSxcblx0XHRcdFx0aXRlbSA9IGhpdCAmJiBoaXQuaXRlbSxcblx0XHRcdFx0c3RvcHBlZCA9IGZhbHNlO1xuXHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRjYXNlICdtb3VzZWRvd24nOlxuXHRcdFx0XHRzdG9wcGVkID0gY2FsbEV2ZW50KHRoaXMsIHR5cGUsIGV2ZW50LCBwb2ludCwgaXRlbSk7XG5cdFx0XHRcdGRibENsaWNrID0gbGFzdEl0ZW0gPT0gaXRlbSAmJiAoRGF0ZS5ub3coKSAtIGNsaWNrVGltZSA8IDMwMCk7XG5cdFx0XHRcdGRvd25JdGVtID0gbGFzdEl0ZW0gPSBpdGVtO1xuXHRcdFx0XHRkb3duUG9pbnQgPSBsYXN0UG9pbnQgPSBvdmVyUG9pbnQgPSBwb2ludDtcblx0XHRcdFx0ZHJhZ0l0ZW0gPSAhc3RvcHBlZCAmJiBpdGVtO1xuXHRcdFx0XHR3aGlsZSAoZHJhZ0l0ZW0gJiYgIWRyYWdJdGVtLnJlc3BvbmRzKCdtb3VzZWRyYWcnKSlcblx0XHRcdFx0XHRkcmFnSXRlbSA9IGRyYWdJdGVtLl9wYXJlbnQ7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnbW91c2V1cCc6XG5cdFx0XHRcdHN0b3BwZWQgPSBjYWxsRXZlbnQodGhpcywgdHlwZSwgZXZlbnQsIHBvaW50LCBpdGVtLCBkb3duUG9pbnQpO1xuXHRcdFx0XHRpZiAoZHJhZ0l0ZW0pIHtcblx0XHRcdFx0XHRpZiAobGFzdFBvaW50ICYmICFsYXN0UG9pbnQuZXF1YWxzKHBvaW50KSlcblx0XHRcdFx0XHRcdGNhbGxFdmVudCh0aGlzLCAnbW91c2VkcmFnJywgZXZlbnQsIHBvaW50LCBkcmFnSXRlbSxcblx0XHRcdFx0XHRcdFx0XHRsYXN0UG9pbnQpO1xuXHRcdFx0XHRcdGlmIChpdGVtICE9PSBkcmFnSXRlbSkge1xuXHRcdFx0XHRcdFx0b3ZlclBvaW50ID0gcG9pbnQ7XG5cdFx0XHRcdFx0XHRjYWxsRXZlbnQodGhpcywgJ21vdXNlbW92ZScsIGV2ZW50LCBwb2ludCwgaXRlbSxcblx0XHRcdFx0XHRcdFx0XHRvdmVyUG9pbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXN0b3BwZWQgJiYgaXRlbSAmJiBpdGVtID09PSBkb3duSXRlbSkge1xuXHRcdFx0XHRcdGNsaWNrVGltZSA9IERhdGUubm93KCk7XG5cdFx0XHRcdFx0Y2FsbEV2ZW50KHRoaXMsIGRibENsaWNrICYmIGRvd25JdGVtLnJlc3BvbmRzKCdkb3VibGVjbGljaycpXG5cdFx0XHRcdFx0XHRcdD8gJ2RvdWJsZWNsaWNrJyA6ICdjbGljaycsIGV2ZW50LCBkb3duUG9pbnQsIGl0ZW0pO1xuXHRcdFx0XHRcdGRibENsaWNrID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZG93bkl0ZW0gPSBkcmFnSXRlbSA9IG51bGw7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnbW91c2Vtb3ZlJzpcblx0XHRcdFx0aWYgKGRyYWdJdGVtKVxuXHRcdFx0XHRcdHN0b3BwZWQgPSBjYWxsRXZlbnQodGhpcywgJ21vdXNlZHJhZycsIGV2ZW50LCBwb2ludCxcblx0XHRcdFx0XHRcdFx0ZHJhZ0l0ZW0sIGxhc3RQb2ludCk7XG5cdFx0XHRcdGlmICghc3RvcHBlZCkge1xuXHRcdFx0XHRcdGlmIChpdGVtICE9PSBvdmVySXRlbSlcblx0XHRcdFx0XHRcdG92ZXJQb2ludCA9IHBvaW50O1xuXHRcdFx0XHRcdHN0b3BwZWQgPSBjYWxsRXZlbnQodGhpcywgdHlwZSwgZXZlbnQsIHBvaW50LCBpdGVtLFxuXHRcdFx0XHRcdFx0XHRvdmVyUG9pbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxhc3RQb2ludCA9IG92ZXJQb2ludCA9IHBvaW50O1xuXHRcdFx0XHRpZiAoaXRlbSAhPT0gb3Zlckl0ZW0pIHtcblx0XHRcdFx0XHRjYWxsRXZlbnQodGhpcywgJ21vdXNlbGVhdmUnLCBldmVudCwgcG9pbnQsIG92ZXJJdGVtKTtcblx0XHRcdFx0XHRvdmVySXRlbSA9IGl0ZW07XG5cdFx0XHRcdFx0Y2FsbEV2ZW50KHRoaXMsICdtb3VzZWVudGVyJywgZXZlbnQsIHBvaW50LCBpdGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHJldHVybiBzdG9wcGVkO1xuXHRcdH1cblx0fTtcbn0pO1xuXG52YXIgRXZlbnQgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0V2ZW50JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBFdmVudChldmVudCkge1xuXHRcdHRoaXMuZXZlbnQgPSBldmVudDtcblx0fSxcblxuXHRpc1ByZXZlbnRlZDogZmFsc2UsXG5cdGlzU3RvcHBlZDogZmFsc2UsXG5cblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaXNQcmV2ZW50ZWQgPSB0cnVlO1xuXHRcdHRoaXMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0fSxcblxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcblx0XHR0aGlzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9LFxuXG5cdHN0b3A6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0dGhpcy5wcmV2ZW50RGVmYXVsdCgpO1xuXHR9LFxuXG5cdGdldE1vZGlmaWVyczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIEtleS5tb2RpZmllcnM7XG5cdH1cbn0pO1xuXG52YXIgS2V5RXZlbnQgPSBFdmVudC5leHRlbmQoe1xuXHRfY2xhc3M6ICdLZXlFdmVudCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gS2V5RXZlbnQoZG93biwga2V5LCBjaGFyYWN0ZXIsIGV2ZW50KSB7XG5cdFx0RXZlbnQuY2FsbCh0aGlzLCBldmVudCk7XG5cdFx0dGhpcy50eXBlID0gZG93biA/ICdrZXlkb3duJyA6ICdrZXl1cCc7XG5cdFx0dGhpcy5rZXkgPSBrZXk7XG5cdFx0dGhpcy5jaGFyYWN0ZXIgPSBjaGFyYWN0ZXI7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcInsgdHlwZTogJ1wiICsgdGhpcy50eXBlXG5cdFx0XHRcdCsgXCInLCBrZXk6ICdcIiArIHRoaXMua2V5XG5cdFx0XHRcdCsgXCInLCBjaGFyYWN0ZXI6ICdcIiArIHRoaXMuY2hhcmFjdGVyXG5cdFx0XHRcdCsgXCInLCBtb2RpZmllcnM6IFwiICsgdGhpcy5nZXRNb2RpZmllcnMoKVxuXHRcdFx0XHQrIFwiIH1cIjtcblx0fVxufSk7XG5cbnZhciBLZXkgPSBuZXcgZnVuY3Rpb24oKSB7XG5cblx0dmFyIHNwZWNpYWxLZXlzID0ge1xuXHRcdDg6ICdiYWNrc3BhY2UnLFxuXHRcdDk6ICd0YWInLFxuXHRcdDEzOiAnZW50ZXInLFxuXHRcdDE2OiAnc2hpZnQnLFxuXHRcdDE3OiAnY29udHJvbCcsXG5cdFx0MTg6ICdvcHRpb24nLFxuXHRcdDE5OiAncGF1c2UnLFxuXHRcdDIwOiAnY2Fwcy1sb2NrJyxcblx0XHQyNzogJ2VzY2FwZScsXG5cdFx0MzI6ICdzcGFjZScsXG5cdFx0MzU6ICdlbmQnLFxuXHRcdDM2OiAnaG9tZScsXG5cdFx0Mzc6ICdsZWZ0Jyxcblx0XHQzODogJ3VwJyxcblx0XHQzOTogJ3JpZ2h0Jyxcblx0XHQ0MDogJ2Rvd24nLFxuXHRcdDQ2OiAnZGVsZXRlJyxcblx0XHQ5MTogJ2NvbW1hbmQnLFxuXHRcdDkzOiAnY29tbWFuZCcsXG5cdFx0MjI0OiAnY29tbWFuZCdcblx0fSxcblxuXHRzcGVjaWFsQ2hhcnMgPSB7XG5cdFx0OTogdHJ1ZSxcblx0XHQxMzogdHJ1ZSxcblx0XHQzMjogdHJ1ZVxuXHR9LFxuXG5cdG1vZGlmaWVycyA9IG5ldyBCYXNlKHtcblx0XHRzaGlmdDogZmFsc2UsXG5cdFx0Y29udHJvbDogZmFsc2UsXG5cdFx0b3B0aW9uOiBmYWxzZSxcblx0XHRjb21tYW5kOiBmYWxzZSxcblx0XHRjYXBzTG9jazogZmFsc2UsXG5cdFx0c3BhY2U6IGZhbHNlXG5cdH0pLFxuXG5cdGNoYXJDb2RlTWFwID0ge30sXG5cdGtleU1hcCA9IHt9LFxuXHRjb21tYW5kRml4TWFwLFxuXHRkb3duQ29kZTtcblxuXHRmdW5jdGlvbiBoYW5kbGVLZXkoZG93biwga2V5Q29kZSwgY2hhckNvZGUsIGV2ZW50KSB7XG5cdFx0dmFyIGNoYXJhY3RlciA9IGNoYXJDb2RlID8gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSkgOiAnJyxcblx0XHRcdHNwZWNpYWxLZXkgPSBzcGVjaWFsS2V5c1trZXlDb2RlXSxcblx0XHRcdGtleSA9IHNwZWNpYWxLZXkgfHwgY2hhcmFjdGVyLnRvTG93ZXJDYXNlKCksXG5cdFx0XHR0eXBlID0gZG93biA/ICdrZXlkb3duJyA6ICdrZXl1cCcsXG5cdFx0XHR2aWV3ID0gVmlldy5fZm9jdXNlZCxcblx0XHRcdHNjb3BlID0gdmlldyAmJiB2aWV3LmlzVmlzaWJsZSgpICYmIHZpZXcuX3Njb3BlLFxuXHRcdFx0dG9vbCA9IHNjb3BlICYmIHNjb3BlLnRvb2wsXG5cdFx0XHRuYW1lO1xuXHRcdGtleU1hcFtrZXldID0gZG93bjtcblx0XHRpZiAoZG93bikge1xuXHRcdFx0Y2hhckNvZGVNYXBba2V5Q29kZV0gPSBjaGFyQ29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVsZXRlIGNoYXJDb2RlTWFwW2tleUNvZGVdO1xuXHRcdH1cblx0XHRpZiAoc3BlY2lhbEtleSAmJiAobmFtZSA9IEJhc2UuY2FtZWxpemUoc3BlY2lhbEtleSkpIGluIG1vZGlmaWVycykge1xuXHRcdFx0bW9kaWZpZXJzW25hbWVdID0gZG93bjtcblx0XHRcdHZhciBicm93c2VyID0gcGFwZXIuYnJvd3Nlcjtcblx0XHRcdGlmIChuYW1lID09PSAnY29tbWFuZCcgJiYgYnJvd3NlciAmJiBicm93c2VyLm1hYykge1xuXHRcdFx0XHRpZiAoZG93bikge1xuXHRcdFx0XHRcdGNvbW1hbmRGaXhNYXAgPSB7fTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmb3IgKHZhciBjb2RlIGluIGNvbW1hbmRGaXhNYXApIHtcblx0XHRcdFx0XHRcdGlmIChjb2RlIGluIGNoYXJDb2RlTWFwKVxuXHRcdFx0XHRcdFx0XHRoYW5kbGVLZXkoZmFsc2UsIGNvZGUsIGNvbW1hbmRGaXhNYXBbY29kZV0sIGV2ZW50KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29tbWFuZEZpeE1hcCA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGRvd24gJiYgY29tbWFuZEZpeE1hcCkge1xuXHRcdFx0Y29tbWFuZEZpeE1hcFtrZXlDb2RlXSA9IGNoYXJDb2RlO1xuXHRcdH1cblx0XHRpZiAodG9vbCAmJiB0b29sLnJlc3BvbmRzKHR5cGUpKSB7XG5cdFx0XHRwYXBlciA9IHNjb3BlO1xuXHRcdFx0dG9vbC5lbWl0KHR5cGUsIG5ldyBLZXlFdmVudChkb3duLCBrZXksIGNoYXJhY3RlciwgZXZlbnQpKTtcblx0XHRcdGlmICh2aWV3KVxuXHRcdFx0XHR2aWV3LnVwZGF0ZSgpO1xuXHRcdH1cblx0fVxuXG5cdERvbUV2ZW50LmFkZChkb2N1bWVudCwge1xuXHRcdGtleWRvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHR2YXIgY29kZSA9IGV2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGU7XG5cdFx0XHRpZiAoY29kZSBpbiBzcGVjaWFsS2V5cyB8fCBtb2RpZmllcnMuY29tbWFuZCkge1xuXHRcdFx0XHRoYW5kbGVLZXkodHJ1ZSwgY29kZSxcblx0XHRcdFx0XHRcdGNvZGUgaW4gc3BlY2lhbENoYXJzIHx8IG1vZGlmaWVycy5jb21tYW5kID8gY29kZSA6IDAsXG5cdFx0XHRcdFx0XHRldmVudCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkb3duQ29kZSA9IGNvZGU7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGtleXByZXNzOiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0aWYgKGRvd25Db2RlICE9IG51bGwpIHtcblx0XHRcdFx0aGFuZGxlS2V5KHRydWUsIGRvd25Db2RlLCBldmVudC53aGljaCB8fCBldmVudC5rZXlDb2RlLCBldmVudCk7XG5cdFx0XHRcdGRvd25Db2RlID0gbnVsbDtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0a2V5dXA6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHR2YXIgY29kZSA9IGV2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGU7XG5cdFx0XHRpZiAoY29kZSBpbiBjaGFyQ29kZU1hcClcblx0XHRcdFx0aGFuZGxlS2V5KGZhbHNlLCBjb2RlLCBjaGFyQ29kZU1hcFtjb2RlXSwgZXZlbnQpO1xuXHRcdH1cblx0fSk7XG5cblx0RG9tRXZlbnQuYWRkKHdpbmRvdywge1xuXHRcdGJsdXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRmb3IgKHZhciBjb2RlIGluIGNoYXJDb2RlTWFwKVxuXHRcdFx0XHRoYW5kbGVLZXkoZmFsc2UsIGNvZGUsIGNoYXJDb2RlTWFwW2NvZGVdLCBldmVudCk7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4ge1xuXHRcdG1vZGlmaWVyczogbW9kaWZpZXJzLFxuXG5cdFx0aXNEb3duOiBmdW5jdGlvbihrZXkpIHtcblx0XHRcdHJldHVybiAhIWtleU1hcFtrZXldO1xuXHRcdH1cblx0fTtcbn07XG5cbnZhciBNb3VzZUV2ZW50ID0gRXZlbnQuZXh0ZW5kKHtcblx0X2NsYXNzOiAnTW91c2VFdmVudCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gTW91c2VFdmVudCh0eXBlLCBldmVudCwgcG9pbnQsIHRhcmdldCwgZGVsdGEpIHtcblx0XHRFdmVudC5jYWxsKHRoaXMsIGV2ZW50KTtcblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcdHRoaXMucG9pbnQgPSBwb2ludDtcblx0XHR0aGlzLnRhcmdldCA9IHRhcmdldDtcblx0XHR0aGlzLmRlbHRhID0gZGVsdGE7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcInsgdHlwZTogJ1wiICsgdGhpcy50eXBlXG5cdFx0XHRcdCsgXCInLCBwb2ludDogXCIgKyB0aGlzLnBvaW50XG5cdFx0XHRcdCsgJywgdGFyZ2V0OiAnICsgdGhpcy50YXJnZXRcblx0XHRcdFx0KyAodGhpcy5kZWx0YSA/ICcsIGRlbHRhOiAnICsgdGhpcy5kZWx0YSA6ICcnKVxuXHRcdFx0XHQrICcsIG1vZGlmaWVyczogJyArIHRoaXMuZ2V0TW9kaWZpZXJzKClcblx0XHRcdFx0KyAnIH0nO1xuXHR9XG59KTtcblxudmFyIFRvb2xFdmVudCA9IEV2ZW50LmV4dGVuZCh7XG5cdF9jbGFzczogJ1Rvb2xFdmVudCcsXG5cdF9pdGVtOiBudWxsLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFRvb2xFdmVudCh0b29sLCB0eXBlLCBldmVudCkge1xuXHRcdHRoaXMudG9vbCA9IHRvb2w7XG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHR0aGlzLmV2ZW50ID0gZXZlbnQ7XG5cdH0sXG5cblx0X2Nob29zZVBvaW50OiBmdW5jdGlvbihwb2ludCwgdG9vbFBvaW50KSB7XG5cdFx0cmV0dXJuIHBvaW50ID8gcG9pbnQgOiB0b29sUG9pbnQgPyB0b29sUG9pbnQuY2xvbmUoKSA6IG51bGw7XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaG9vc2VQb2ludCh0aGlzLl9wb2ludCwgdGhpcy50b29sLl9wb2ludCk7XG5cdH0sXG5cblx0c2V0UG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0dGhpcy5fcG9pbnQgPSBwb2ludDtcblx0fSxcblxuXHRnZXRMYXN0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaG9vc2VQb2ludCh0aGlzLl9sYXN0UG9pbnQsIHRoaXMudG9vbC5fbGFzdFBvaW50KTtcblx0fSxcblxuXHRzZXRMYXN0UG9pbnQ6IGZ1bmN0aW9uKGxhc3RQb2ludCkge1xuXHRcdHRoaXMuX2xhc3RQb2ludCA9IGxhc3RQb2ludDtcblx0fSxcblxuXHRnZXREb3duUG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaG9vc2VQb2ludCh0aGlzLl9kb3duUG9pbnQsIHRoaXMudG9vbC5fZG93blBvaW50KTtcblx0fSxcblxuXHRzZXREb3duUG9pbnQ6IGZ1bmN0aW9uKGRvd25Qb2ludCkge1xuXHRcdHRoaXMuX2Rvd25Qb2ludCA9IGRvd25Qb2ludDtcblx0fSxcblxuXHRnZXRNaWRkbGVQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9taWRkbGVQb2ludCAmJiB0aGlzLnRvb2wuX2xhc3RQb2ludCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudG9vbC5fcG9pbnQuYWRkKHRoaXMudG9vbC5fbGFzdFBvaW50KS5kaXZpZGUoMik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9taWRkbGVQb2ludDtcblx0fSxcblxuXHRzZXRNaWRkbGVQb2ludDogZnVuY3Rpb24obWlkZGxlUG9pbnQpIHtcblx0XHR0aGlzLl9taWRkbGVQb2ludCA9IG1pZGRsZVBvaW50O1xuXHR9LFxuXG5cdGdldERlbHRhOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2RlbHRhICYmIHRoaXMudG9vbC5fbGFzdFBvaW50XG5cdFx0XHRcdD8gdGhpcy50b29sLl9wb2ludC5zdWJ0cmFjdCh0aGlzLnRvb2wuX2xhc3RQb2ludClcblx0XHRcdFx0OiB0aGlzLl9kZWx0YTtcblx0fSxcblxuXHRzZXREZWx0YTogZnVuY3Rpb24oZGVsdGEpIHtcblx0XHR0aGlzLl9kZWx0YSA9IGRlbHRhO1xuXHR9LFxuXG5cdGdldENvdW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gL15tb3VzZShkb3dufHVwKSQvLnRlc3QodGhpcy50eXBlKVxuXHRcdFx0XHQ/IHRoaXMudG9vbC5fZG93bkNvdW50XG5cdFx0XHRcdDogdGhpcy50b29sLl9jb3VudDtcblx0fSxcblxuXHRzZXRDb3VudDogZnVuY3Rpb24oY291bnQpIHtcblx0XHR0aGlzLnRvb2xbL15tb3VzZShkb3dufHVwKSQvLnRlc3QodGhpcy50eXBlKSA/ICdkb3duQ291bnQnIDogJ2NvdW50J11cblx0XHRcdD0gY291bnQ7XG5cdH0sXG5cblx0Z2V0SXRlbTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9pdGVtKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdGhpcy50b29sLl9zY29wZS5wcm9qZWN0LmhpdFRlc3QodGhpcy5nZXRQb2ludCgpKTtcblx0XHRcdGlmIChyZXN1bHQpIHtcblx0XHRcdFx0dmFyIGl0ZW0gPSByZXN1bHQuaXRlbSxcblx0XHRcdFx0XHRwYXJlbnQgPSBpdGVtLl9wYXJlbnQ7XG5cdFx0XHRcdHdoaWxlICgvXihHcm91cHxDb21wb3VuZFBhdGgpJC8udGVzdChwYXJlbnQuX2NsYXNzKSkge1xuXHRcdFx0XHRcdGl0ZW0gPSBwYXJlbnQ7XG5cdFx0XHRcdFx0cGFyZW50ID0gcGFyZW50Ll9wYXJlbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5faXRlbSA9IGl0ZW07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9pdGVtO1xuXHR9LFxuXG5cdHNldEl0ZW06IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHR0aGlzLl9pdGVtID0gaXRlbTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICd7IHR5cGU6ICcgKyB0aGlzLnR5cGVcblx0XHRcdFx0KyAnLCBwb2ludDogJyArIHRoaXMuZ2V0UG9pbnQoKVxuXHRcdFx0XHQrICcsIGNvdW50OiAnICsgdGhpcy5nZXRDb3VudCgpXG5cdFx0XHRcdCsgJywgbW9kaWZpZXJzOiAnICsgdGhpcy5nZXRNb2RpZmllcnMoKVxuXHRcdFx0XHQrICcgfSc7XG5cdH1cbn0pO1xuXG52YXIgVG9vbCA9IFBhcGVyU2NvcGVJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1Rvb2wnLFxuXHRfbGlzdDogJ3Rvb2xzJyxcblx0X3JlZmVyZW5jZTogJ3Rvb2wnLFxuXHRfZXZlbnRzOiBbICdvbkFjdGl2YXRlJywgJ29uRGVhY3RpdmF0ZScsICdvbkVkaXRPcHRpb25zJyxcblx0XHRcdCdvbk1vdXNlRG93bicsICdvbk1vdXNlVXAnLCAnb25Nb3VzZURyYWcnLCAnb25Nb3VzZU1vdmUnLFxuXHRcdFx0J29uS2V5RG93bicsICdvbktleVVwJyBdLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFRvb2wocHJvcHMpIHtcblx0XHRQYXBlclNjb3BlSXRlbS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMuX2ZpcnN0TW92ZSA9IHRydWU7XG5cdFx0dGhpcy5fY291bnQgPSAwO1xuXHRcdHRoaXMuX2Rvd25Db3VudCA9IDA7XG5cdFx0dGhpcy5fc2V0KHByb3BzKTtcblx0fSxcblxuXHRnZXRNaW5EaXN0YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21pbkRpc3RhbmNlO1xuXHR9LFxuXG5cdHNldE1pbkRpc3RhbmNlOiBmdW5jdGlvbihtaW5EaXN0YW5jZSkge1xuXHRcdHRoaXMuX21pbkRpc3RhbmNlID0gbWluRGlzdGFuY2U7XG5cdFx0aWYgKG1pbkRpc3RhbmNlICE9IG51bGwgJiYgdGhpcy5fbWF4RGlzdGFuY2UgIT0gbnVsbFxuXHRcdFx0XHQmJiBtaW5EaXN0YW5jZSA+IHRoaXMuX21heERpc3RhbmNlKSB7XG5cdFx0XHR0aGlzLl9tYXhEaXN0YW5jZSA9IG1pbkRpc3RhbmNlO1xuXHRcdH1cblx0fSxcblxuXHRnZXRNYXhEaXN0YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21heERpc3RhbmNlO1xuXHR9LFxuXG5cdHNldE1heERpc3RhbmNlOiBmdW5jdGlvbihtYXhEaXN0YW5jZSkge1xuXHRcdHRoaXMuX21heERpc3RhbmNlID0gbWF4RGlzdGFuY2U7XG5cdFx0aWYgKHRoaXMuX21pbkRpc3RhbmNlICE9IG51bGwgJiYgbWF4RGlzdGFuY2UgIT0gbnVsbFxuXHRcdFx0XHQmJiBtYXhEaXN0YW5jZSA8IHRoaXMuX21pbkRpc3RhbmNlKSB7XG5cdFx0XHR0aGlzLl9taW5EaXN0YW5jZSA9IG1heERpc3RhbmNlO1xuXHRcdH1cblx0fSxcblxuXHRnZXRGaXhlZERpc3RhbmNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWluRGlzdGFuY2UgPT0gdGhpcy5fbWF4RGlzdGFuY2Vcblx0XHRcdD8gdGhpcy5fbWluRGlzdGFuY2UgOiBudWxsO1xuXHR9LFxuXG5cdHNldEZpeGVkRGlzdGFuY2U6IGZ1bmN0aW9uKGRpc3RhbmNlKSB7XG5cdFx0dGhpcy5fbWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcblx0XHR0aGlzLl9tYXhEaXN0YW5jZSA9IGRpc3RhbmNlO1xuXHR9LFxuXG5cdF91cGRhdGVFdmVudDogZnVuY3Rpb24odHlwZSwgcG9pbnQsIG1pbkRpc3RhbmNlLCBtYXhEaXN0YW5jZSwgc3RhcnQsXG5cdFx0XHRuZWVkc0NoYW5nZSwgbWF0Y2hNYXhEaXN0YW5jZSkge1xuXHRcdGlmICghc3RhcnQpIHtcblx0XHRcdGlmIChtaW5EaXN0YW5jZSAhPSBudWxsIHx8IG1heERpc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdFx0dmFyIG1pbkRpc3QgPSBtaW5EaXN0YW5jZSAhPSBudWxsID8gbWluRGlzdGFuY2UgOiAwLFxuXHRcdFx0XHRcdHZlY3RvciA9IHBvaW50LnN1YnRyYWN0KHRoaXMuX3BvaW50KSxcblx0XHRcdFx0XHRkaXN0YW5jZSA9IHZlY3Rvci5nZXRMZW5ndGgoKTtcblx0XHRcdFx0aWYgKGRpc3RhbmNlIDwgbWluRGlzdClcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlmIChtYXhEaXN0YW5jZSAhPSBudWxsICYmIG1heERpc3RhbmNlICE9IDApIHtcblx0XHRcdFx0XHRpZiAoZGlzdGFuY2UgPiBtYXhEaXN0YW5jZSkge1xuXHRcdFx0XHRcdFx0cG9pbnQgPSB0aGlzLl9wb2ludC5hZGQodmVjdG9yLm5vcm1hbGl6ZShtYXhEaXN0YW5jZSkpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobWF0Y2hNYXhEaXN0YW5jZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKG5lZWRzQ2hhbmdlICYmIHBvaW50LmVxdWFscyh0aGlzLl9wb2ludCkpXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0dGhpcy5fbGFzdFBvaW50ID0gc3RhcnQgJiYgdHlwZSA9PSAnbW91c2Vtb3ZlJyA/IHBvaW50IDogdGhpcy5fcG9pbnQ7XG5cdFx0dGhpcy5fcG9pbnQgPSBwb2ludDtcblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRjYXNlICdtb3VzZWRvd24nOlxuXHRcdFx0dGhpcy5fbGFzdFBvaW50ID0gdGhpcy5fZG93blBvaW50O1xuXHRcdFx0dGhpcy5fZG93blBvaW50ID0gdGhpcy5fcG9pbnQ7XG5cdFx0XHR0aGlzLl9kb3duQ291bnQrKztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ21vdXNldXAnOlxuXHRcdFx0dGhpcy5fbGFzdFBvaW50ID0gdGhpcy5fZG93blBvaW50O1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdHRoaXMuX2NvdW50ID0gc3RhcnQgPyAwIDogdGhpcy5fY291bnQgKyAxO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9maXJlRXZlbnQ6IGZ1bmN0aW9uKHR5cGUsIGV2ZW50KSB7XG5cdFx0dmFyIHNldHMgPSBwYXBlci5wcm9qZWN0Ll9yZW1vdmVTZXRzO1xuXHRcdGlmIChzZXRzKSB7XG5cdFx0XHRpZiAodHlwZSA9PT0gJ21vdXNldXAnKVxuXHRcdFx0XHRzZXRzLm1vdXNlZHJhZyA9IG51bGw7XG5cdFx0XHR2YXIgc2V0ID0gc2V0c1t0eXBlXTtcblx0XHRcdGlmIChzZXQpIHtcblx0XHRcdFx0Zm9yICh2YXIgaWQgaW4gc2V0KSB7XG5cdFx0XHRcdFx0dmFyIGl0ZW0gPSBzZXRbaWRdO1xuXHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiBzZXRzKSB7XG5cdFx0XHRcdFx0XHR2YXIgb3RoZXIgPSBzZXRzW2tleV07XG5cdFx0XHRcdFx0XHRpZiAob3RoZXIgJiYgb3RoZXIgIT0gc2V0KVxuXHRcdFx0XHRcdFx0XHRkZWxldGUgb3RoZXJbaXRlbS5faWRdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpdGVtLnJlbW92ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNldHNbdHlwZV0gPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5yZXNwb25kcyh0eXBlKVxuXHRcdFx0XHQmJiB0aGlzLmVtaXQodHlwZSwgbmV3IFRvb2xFdmVudCh0aGlzLCB0eXBlLCBldmVudCkpO1xuXHR9LFxuXG5cdF9oYW5kbGVFdmVudDogZnVuY3Rpb24odHlwZSwgcG9pbnQsIGV2ZW50KSB7XG5cdFx0cGFwZXIgPSB0aGlzLl9zY29wZTtcblx0XHR2YXIgY2FsbGVkID0gZmFsc2U7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0Y2FzZSAnbW91c2Vkb3duJzpcblx0XHRcdHRoaXMuX3VwZGF0ZUV2ZW50KHR5cGUsIHBvaW50LCBudWxsLCBudWxsLCB0cnVlLCBmYWxzZSwgZmFsc2UpO1xuXHRcdFx0Y2FsbGVkID0gdGhpcy5fZmlyZUV2ZW50KHR5cGUsIGV2ZW50KTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ21vdXNlZHJhZyc6XG5cdFx0XHR2YXIgbmVlZHNDaGFuZ2UgPSBmYWxzZSxcblx0XHRcdFx0bWF0Y2hNYXhEaXN0YW5jZSA9IGZhbHNlO1xuXHRcdFx0d2hpbGUgKHRoaXMuX3VwZGF0ZUV2ZW50KHR5cGUsIHBvaW50LCB0aGlzLm1pbkRpc3RhbmNlLFxuXHRcdFx0XHRcdHRoaXMubWF4RGlzdGFuY2UsIGZhbHNlLCBuZWVkc0NoYW5nZSwgbWF0Y2hNYXhEaXN0YW5jZSkpIHtcblx0XHRcdFx0Y2FsbGVkID0gdGhpcy5fZmlyZUV2ZW50KHR5cGUsIGV2ZW50KSB8fCBjYWxsZWQ7XG5cdFx0XHRcdG5lZWRzQ2hhbmdlID0gdHJ1ZTtcblx0XHRcdFx0bWF0Y2hNYXhEaXN0YW5jZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdtb3VzZXVwJzpcblx0XHRcdGlmICghcG9pbnQuZXF1YWxzKHRoaXMuX3BvaW50KVxuXHRcdFx0XHRcdCYmIHRoaXMuX3VwZGF0ZUV2ZW50KCdtb3VzZWRyYWcnLCBwb2ludCwgdGhpcy5taW5EaXN0YW5jZSxcblx0XHRcdFx0XHRcdFx0dGhpcy5tYXhEaXN0YW5jZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSkpIHtcblx0XHRcdFx0Y2FsbGVkID0gdGhpcy5fZmlyZUV2ZW50KCdtb3VzZWRyYWcnLCBldmVudCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl91cGRhdGVFdmVudCh0eXBlLCBwb2ludCwgbnVsbCwgdGhpcy5tYXhEaXN0YW5jZSwgZmFsc2UsXG5cdFx0XHRcdFx0ZmFsc2UsIGZhbHNlKTtcblx0XHRcdGNhbGxlZCA9IHRoaXMuX2ZpcmVFdmVudCh0eXBlLCBldmVudCkgfHwgY2FsbGVkO1xuXHRcdFx0dGhpcy5fdXBkYXRlRXZlbnQodHlwZSwgcG9pbnQsIG51bGwsIG51bGwsIHRydWUsIGZhbHNlLCBmYWxzZSk7XG5cdFx0XHR0aGlzLl9maXJzdE1vdmUgPSB0cnVlO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnbW91c2Vtb3ZlJzpcblx0XHRcdHdoaWxlICh0aGlzLl91cGRhdGVFdmVudCh0eXBlLCBwb2ludCwgdGhpcy5taW5EaXN0YW5jZSxcblx0XHRcdFx0XHR0aGlzLm1heERpc3RhbmNlLCB0aGlzLl9maXJzdE1vdmUsIHRydWUsIGZhbHNlKSkge1xuXHRcdFx0XHRjYWxsZWQgPSB0aGlzLl9maXJlRXZlbnQodHlwZSwgZXZlbnQpIHx8IGNhbGxlZDtcblx0XHRcdFx0dGhpcy5fZmlyc3RNb3ZlID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0aWYgKGNhbGxlZClcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0cmV0dXJuIGNhbGxlZDtcblx0fVxuXG59KTtcblxudmFyIEh0dHAgPSB7XG5cdHJlcXVlc3Q6IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBjYWxsYmFjaywgYXN5bmMpIHtcblx0XHRhc3luYyA9IChhc3luYyA9PT0gdW5kZWZpbmVkKSA/IHRydWUgOiBhc3luYztcblx0XHR2YXIgeGhyID0gbmV3ICh3aW5kb3cuQWN0aXZlWE9iamVjdCB8fCBYTUxIdHRwUmVxdWVzdCkoXG5cdFx0XHRcdFx0J01pY3Jvc29mdC5YTUxIVFRQJyk7XG5cdFx0eGhyLm9wZW4obWV0aG9kLnRvVXBwZXJDYXNlKCksIHVybCwgYXN5bmMpO1xuXHRcdGlmICgnb3ZlcnJpZGVNaW1lVHlwZScgaW4geGhyKVxuXHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoJ3RleHQvcGxhaW4nKTtcblx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcblx0XHRcdFx0dmFyIHN0YXR1cyA9IHhoci5zdGF0dXM7XG5cdFx0XHRcdGlmIChzdGF0dXMgPT09IDAgfHwgc3RhdHVzID09PSAyMDApIHtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHhociwgeGhyLnJlc3BvbnNlVGV4dCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgbG9hZCAnICsgdXJsICsgJyAoRXJyb3IgJ1xuXHRcdFx0XHRcdFx0XHQrIHN0YXR1cyArICcpJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiB4aHIuc2VuZChudWxsKTtcblx0fVxufTtcblxudmFyIENhbnZhc1Byb3ZpZGVyID0ge1xuXHRjYW52YXNlczogW10sXG5cblx0Z2V0Q2FudmFzOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dmFyIGNhbnZhcyxcblx0XHRcdGNsZWFyID0gdHJ1ZTtcblx0XHRpZiAodHlwZW9mIHdpZHRoID09PSAnb2JqZWN0Jykge1xuXHRcdFx0aGVpZ2h0ID0gd2lkdGguaGVpZ2h0O1xuXHRcdFx0d2lkdGggPSB3aWR0aC53aWR0aDtcblx0XHR9XG5cdFx0aWYgKHRoaXMuY2FudmFzZXMubGVuZ3RoKSB7XG5cdFx0XHRjYW52YXMgPSB0aGlzLmNhbnZhc2VzLnBvcCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0XHR9XG5cdFx0dmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdGlmIChjYW52YXMud2lkdGggPT09IHdpZHRoICYmIGNhbnZhcy5oZWlnaHQgPT09IGhlaWdodCkge1xuXHRcdFx0aWYgKGNsZWFyKVxuXHRcdFx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoICsgMSwgaGVpZ2h0ICsgMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuXHRcdFx0Y2FudmFzLmhlaWdodCA9IGhlaWdodDtcblx0XHR9XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRyZXR1cm4gY2FudmFzO1xuXHR9LFxuXG5cdGdldENvbnRleHQ6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRDYW52YXMod2lkdGgsIGhlaWdodCkuZ2V0Q29udGV4dCgnMmQnKTtcblx0fSxcblxuXHRyZWxlYXNlOiBmdW5jdGlvbihvYmopIHtcblx0XHR2YXIgY2FudmFzID0gb2JqLmNhbnZhcyA/IG9iai5jYW52YXMgOiBvYmo7XG5cdFx0Y2FudmFzLmdldENvbnRleHQoJzJkJykucmVzdG9yZSgpO1xuXHRcdHRoaXMuY2FudmFzZXMucHVzaChjYW52YXMpO1xuXHR9XG59O1xuXG52YXIgQmxlbmRNb2RlID0gbmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgbWluID0gTWF0aC5taW4sXG5cdFx0bWF4ID0gTWF0aC5tYXgsXG5cdFx0YWJzID0gTWF0aC5hYnMsXG5cdFx0c3IsIHNnLCBzYiwgc2EsXG5cdFx0YnIsIGJnLCBiYiwgYmEsXG5cdFx0ZHIsIGRnLCBkYjtcblxuXHRmdW5jdGlvbiBnZXRMdW0ociwgZywgYikge1xuXHRcdHJldHVybiAwLjI5ODkgKiByICsgMC41ODcgKiBnICsgMC4xMTQgKiBiO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0THVtKHIsIGcsIGIsIGwpIHtcblx0XHR2YXIgZCA9IGwgLSBnZXRMdW0ociwgZywgYik7XG5cdFx0ZHIgPSByICsgZDtcblx0XHRkZyA9IGcgKyBkO1xuXHRcdGRiID0gYiArIGQ7XG5cdFx0dmFyIGwgPSBnZXRMdW0oZHIsIGRnLCBkYiksXG5cdFx0XHRtbiA9IG1pbihkciwgZGcsIGRiKSxcblx0XHRcdG14ID0gbWF4KGRyLCBkZywgZGIpO1xuXHRcdGlmIChtbiA8IDApIHtcblx0XHRcdHZhciBsbW4gPSBsIC0gbW47XG5cdFx0XHRkciA9IGwgKyAoZHIgLSBsKSAqIGwgLyBsbW47XG5cdFx0XHRkZyA9IGwgKyAoZGcgLSBsKSAqIGwgLyBsbW47XG5cdFx0XHRkYiA9IGwgKyAoZGIgLSBsKSAqIGwgLyBsbW47XG5cdFx0fVxuXHRcdGlmIChteCA+IDI1NSkge1xuXHRcdFx0dmFyIGxuID0gMjU1IC0gbCxcblx0XHRcdFx0bXhsID0gbXggLSBsO1xuXHRcdFx0ZHIgPSBsICsgKGRyIC0gbCkgKiBsbiAvIG14bDtcblx0XHRcdGRnID0gbCArIChkZyAtIGwpICogbG4gLyBteGw7XG5cdFx0XHRkYiA9IGwgKyAoZGIgLSBsKSAqIGxuIC8gbXhsO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGdldFNhdChyLCBnLCBiKSB7XG5cdFx0cmV0dXJuIG1heChyLCBnLCBiKSAtIG1pbihyLCBnLCBiKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldFNhdChyLCBnLCBiLCBzKSB7XG5cdFx0dmFyIGNvbCA9IFtyLCBnLCBiXSxcblx0XHRcdG14ID0gbWF4KHIsIGcsIGIpLFxuXHRcdFx0bW4gPSBtaW4ociwgZywgYiksXG5cdFx0XHRtZDtcblx0XHRtbiA9IG1uID09PSByID8gMCA6IG1uID09PSBnID8gMSA6IDI7XG5cdFx0bXggPSBteCA9PT0gciA/IDAgOiBteCA9PT0gZyA/IDEgOiAyO1xuXHRcdG1kID0gbWluKG1uLCBteCkgPT09IDAgPyBtYXgobW4sIG14KSA9PT0gMSA/IDIgOiAxIDogMDtcblx0XHRpZiAoY29sW214XSA+IGNvbFttbl0pIHtcblx0XHRcdGNvbFttZF0gPSAoY29sW21kXSAtIGNvbFttbl0pICogcyAvIChjb2xbbXhdIC0gY29sW21uXSk7XG5cdFx0XHRjb2xbbXhdID0gcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29sW21kXSA9IGNvbFtteF0gPSAwO1xuXHRcdH1cblx0XHRjb2xbbW5dID0gMDtcblx0XHRkciA9IGNvbFswXTtcblx0XHRkZyA9IGNvbFsxXTtcblx0XHRkYiA9IGNvbFsyXTtcblx0fVxuXG5cdHZhciBtb2RlcyA9IHtcblx0XHRtdWx0aXBseTogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyICogc3IgLyAyNTU7XG5cdFx0XHRkZyA9IGJnICogc2cgLyAyNTU7XG5cdFx0XHRkYiA9IGJiICogc2IgLyAyNTU7XG5cdFx0fSxcblxuXHRcdHNjcmVlbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyICsgc3IgLSAoYnIgKiBzciAvIDI1NSk7XG5cdFx0XHRkZyA9IGJnICsgc2cgLSAoYmcgKiBzZyAvIDI1NSk7XG5cdFx0XHRkYiA9IGJiICsgc2IgLSAoYmIgKiBzYiAvIDI1NSk7XG5cdFx0fSxcblxuXHRcdG92ZXJsYXk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciA8IDEyOCA/IDIgKiBiciAqIHNyIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSBicikgKiAoMjU1IC0gc3IpIC8gMjU1O1xuXHRcdFx0ZGcgPSBiZyA8IDEyOCA/IDIgKiBiZyAqIHNnIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSBiZykgKiAoMjU1IC0gc2cpIC8gMjU1O1xuXHRcdFx0ZGIgPSBiYiA8IDEyOCA/IDIgKiBiYiAqIHNiIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSBiYikgKiAoMjU1IC0gc2IpIC8gMjU1O1xuXHRcdH0sXG5cblx0XHQnc29mdC1saWdodCc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHQgPSBzciAqIGJyIC8gMjU1O1xuXHRcdFx0ZHIgPSB0ICsgYnIgKiAoMjU1IC0gKDI1NSAtIGJyKSAqICgyNTUgLSBzcikgLyAyNTUgLSB0KSAvIDI1NTtcblx0XHRcdHQgPSBzZyAqIGJnIC8gMjU1O1xuXHRcdFx0ZGcgPSB0ICsgYmcgKiAoMjU1IC0gKDI1NSAtIGJnKSAqICgyNTUgLSBzZykgLyAyNTUgLSB0KSAvIDI1NTtcblx0XHRcdHQgPSBzYiAqIGJiIC8gMjU1O1xuXHRcdFx0ZGIgPSB0ICsgYmIgKiAoMjU1IC0gKDI1NSAtIGJiKSAqICgyNTUgLSBzYikgLyAyNTUgLSB0KSAvIDI1NTtcblx0XHR9LFxuXG5cdFx0J2hhcmQtbGlnaHQnOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gc3IgPCAxMjggPyAyICogc3IgKiBiciAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gc3IpICogKDI1NSAtIGJyKSAvIDI1NTtcblx0XHRcdGRnID0gc2cgPCAxMjggPyAyICogc2cgKiBiZyAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gc2cpICogKDI1NSAtIGJnKSAvIDI1NTtcblx0XHRcdGRiID0gc2IgPCAxMjggPyAyICogc2IgKiBiYiAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gc2IpICogKDI1NSAtIGJiKSAvIDI1NTtcblx0XHR9LFxuXG5cdFx0J2NvbG9yLWRvZGdlJzogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyID09PSAwID8gMCA6IHNyID09PSAyNTUgPyAyNTUgOiBtaW4oMjU1LCAyNTUgKiBiciAvICgyNTUgLSBzcikpO1xuXHRcdFx0ZGcgPSBiZyA9PT0gMCA/IDAgOiBzZyA9PT0gMjU1ID8gMjU1IDogbWluKDI1NSwgMjU1ICogYmcgLyAoMjU1IC0gc2cpKTtcblx0XHRcdGRiID0gYmIgPT09IDAgPyAwIDogc2IgPT09IDI1NSA/IDI1NSA6IG1pbigyNTUsIDI1NSAqIGJiIC8gKDI1NSAtIHNiKSk7XG5cdFx0fSxcblxuXHRcdCdjb2xvci1idXJuJzogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyID09PSAyNTUgPyAyNTUgOiBzciA9PT0gMCA/IDAgOiBtYXgoMCwgMjU1IC0gKDI1NSAtIGJyKSAqIDI1NSAvIHNyKTtcblx0XHRcdGRnID0gYmcgPT09IDI1NSA/IDI1NSA6IHNnID09PSAwID8gMCA6IG1heCgwLCAyNTUgLSAoMjU1IC0gYmcpICogMjU1IC8gc2cpO1xuXHRcdFx0ZGIgPSBiYiA9PT0gMjU1ID8gMjU1IDogc2IgPT09IDAgPyAwIDogbWF4KDAsIDI1NSAtICgyNTUgLSBiYikgKiAyNTUgLyBzYik7XG5cdFx0fSxcblxuXHRcdGRhcmtlbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyIDwgc3IgPyBiciA6IHNyO1xuXHRcdFx0ZGcgPSBiZyA8IHNnID8gYmcgOiBzZztcblx0XHRcdGRiID0gYmIgPCBzYiA/IGJiIDogc2I7XG5cdFx0fSxcblxuXHRcdGxpZ2h0ZW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciA+IHNyID8gYnIgOiBzcjtcblx0XHRcdGRnID0gYmcgPiBzZyA/IGJnIDogc2c7XG5cdFx0XHRkYiA9IGJiID4gc2IgPyBiYiA6IHNiO1xuXHRcdH0sXG5cblx0XHRkaWZmZXJlbmNlOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgLSBzcjtcblx0XHRcdGlmIChkciA8IDApXG5cdFx0XHRcdGRyID0gLWRyO1xuXHRcdFx0ZGcgPSBiZyAtIHNnO1xuXHRcdFx0aWYgKGRnIDwgMClcblx0XHRcdFx0ZGcgPSAtZGc7XG5cdFx0XHRkYiA9IGJiIC0gc2I7XG5cdFx0XHRpZiAoZGIgPCAwKVxuXHRcdFx0XHRkYiA9IC1kYjtcblx0XHR9LFxuXG5cdFx0ZXhjbHVzaW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgKyBzciAqICgyNTUgLSBiciAtIGJyKSAvIDI1NTtcblx0XHRcdGRnID0gYmcgKyBzZyAqICgyNTUgLSBiZyAtIGJnKSAvIDI1NTtcblx0XHRcdGRiID0gYmIgKyBzYiAqICgyNTUgLSBiYiAtIGJiKSAvIDI1NTtcblx0XHR9LFxuXG5cdFx0aHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdHNldFNhdChzciwgc2csIHNiLCBnZXRTYXQoYnIsIGJnLCBiYikpO1xuXHRcdFx0c2V0THVtKGRyLCBkZywgZGIsIGdldEx1bShiciwgYmcsIGJiKSk7XG5cdFx0fSxcblxuXHRcdHNhdHVyYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0c2V0U2F0KGJyLCBiZywgYmIsIGdldFNhdChzciwgc2csIHNiKSk7XG5cdFx0XHRzZXRMdW0oZHIsIGRnLCBkYiwgZ2V0THVtKGJyLCBiZywgYmIpKTtcblx0XHR9LFxuXG5cdFx0bHVtaW5vc2l0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRzZXRMdW0oYnIsIGJnLCBiYiwgZ2V0THVtKHNyLCBzZywgc2IpKTtcblx0XHR9LFxuXG5cdFx0Y29sb3I6IGZ1bmN0aW9uKCkge1xuXHRcdFx0c2V0THVtKHNyLCBzZywgc2IsIGdldEx1bShiciwgYmcsIGJiKSk7XG5cdFx0fSxcblxuXHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IG1pbihiciArIHNyLCAyNTUpO1xuXHRcdFx0ZGcgPSBtaW4oYmcgKyBzZywgMjU1KTtcblx0XHRcdGRiID0gbWluKGJiICsgc2IsIDI1NSk7XG5cdFx0fSxcblxuXHRcdHN1YnRyYWN0OiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gbWF4KGJyIC0gc3IsIDApO1xuXHRcdFx0ZGcgPSBtYXgoYmcgLSBzZywgMCk7XG5cdFx0XHRkYiA9IG1heChiYiAtIHNiLCAwKTtcblx0XHR9LFxuXG5cdFx0YXZlcmFnZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IChiciArIHNyKSAvIDI7XG5cdFx0XHRkZyA9IChiZyArIHNnKSAvIDI7XG5cdFx0XHRkYiA9IChiYiArIHNiKSAvIDI7XG5cdFx0fSxcblxuXHRcdG5lZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gMjU1IC0gYWJzKDI1NSAtIHNyIC0gYnIpO1xuXHRcdFx0ZGcgPSAyNTUgLSBhYnMoMjU1IC0gc2cgLSBiZyk7XG5cdFx0XHRkYiA9IDI1NSAtIGFicygyNTUgLSBzYiAtIGJiKTtcblx0XHR9XG5cdH07XG5cblx0dmFyIG5hdGl2ZU1vZGVzID0gdGhpcy5uYXRpdmVNb2RlcyA9IEJhc2UuZWFjaChbXG5cdFx0J3NvdXJjZS1vdmVyJywgJ3NvdXJjZS1pbicsICdzb3VyY2Utb3V0JywgJ3NvdXJjZS1hdG9wJyxcblx0XHQnZGVzdGluYXRpb24tb3ZlcicsICdkZXN0aW5hdGlvbi1pbicsICdkZXN0aW5hdGlvbi1vdXQnLFxuXHRcdCdkZXN0aW5hdGlvbi1hdG9wJywgJ2xpZ2h0ZXInLCAnZGFya2VyJywgJ2NvcHknLCAneG9yJ1xuXHRdLCBmdW5jdGlvbihtb2RlKSB7XG5cdFx0dGhpc1ttb2RlXSA9IHRydWU7XG5cdH0sIHt9KTtcblxuXHR2YXIgY3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dCgxLCAxKTtcblx0QmFzZS5lYWNoKG1vZGVzLCBmdW5jdGlvbihmdW5jLCBtb2RlKSB7XG5cdFx0dmFyIGRhcmtlbiA9IG1vZGUgPT09ICdkYXJrZW4nLFxuXHRcdFx0b2sgPSBmYWxzZTtcblx0XHRjdHguc2F2ZSgpO1xuXHRcdHRyeSB7XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gZGFya2VuID8gJyMzMDAnIDogJyNhMDAnO1xuXHRcdFx0Y3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuXHRcdFx0Y3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IG1vZGU7XG5cdFx0XHRpZiAoY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9PT0gbW9kZSkge1xuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gZGFya2VuID8gJyNhMDAnIDogJyMzMDAnO1xuXHRcdFx0XHRjdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG5cdFx0XHRcdG9rID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhWzBdICE9PSBkYXJrZW4gPyAxNzAgOiA1MTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0bmF0aXZlTW9kZXNbbW9kZV0gPSBvaztcblx0fSk7XG5cdENhbnZhc1Byb3ZpZGVyLnJlbGVhc2UoY3R4KTtcblxuXHR0aGlzLnByb2Nlc3MgPSBmdW5jdGlvbihtb2RlLCBzcmNDb250ZXh0LCBkc3RDb250ZXh0LCBhbHBoYSwgb2Zmc2V0KSB7XG5cdFx0dmFyIHNyY0NhbnZhcyA9IHNyY0NvbnRleHQuY2FudmFzLFxuXHRcdFx0bm9ybWFsID0gbW9kZSA9PT0gJ25vcm1hbCc7XG5cdFx0aWYgKG5vcm1hbCB8fCBuYXRpdmVNb2Rlc1ttb2RlXSkge1xuXHRcdFx0ZHN0Q29udGV4dC5zYXZlKCk7XG5cdFx0XHRkc3RDb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblx0XHRcdGRzdENvbnRleHQuZ2xvYmFsQWxwaGEgPSBhbHBoYTtcblx0XHRcdGlmICghbm9ybWFsKVxuXHRcdFx0XHRkc3RDb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IG1vZGU7XG5cdFx0XHRkc3RDb250ZXh0LmRyYXdJbWFnZShzcmNDYW52YXMsIG9mZnNldC54LCBvZmZzZXQueSk7XG5cdFx0XHRkc3RDb250ZXh0LnJlc3RvcmUoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHByb2Nlc3MgPSBtb2Rlc1ttb2RlXTtcblx0XHRcdGlmICghcHJvY2Vzcylcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dmFyIGRzdERhdGEgPSBkc3RDb250ZXh0LmdldEltYWdlRGF0YShvZmZzZXQueCwgb2Zmc2V0LnksXG5cdFx0XHRcdFx0c3JjQ2FudmFzLndpZHRoLCBzcmNDYW52YXMuaGVpZ2h0KSxcblx0XHRcdFx0ZHN0ID0gZHN0RGF0YS5kYXRhLFxuXHRcdFx0XHRzcmMgPSBzcmNDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLFxuXHRcdFx0XHRcdHNyY0NhbnZhcy53aWR0aCwgc3JjQ2FudmFzLmhlaWdodCkuZGF0YTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gZHN0Lmxlbmd0aDsgaSA8IGw7IGkgKz0gNCkge1xuXHRcdFx0XHRzciA9IHNyY1tpXTtcblx0XHRcdFx0YnIgPSBkc3RbaV07XG5cdFx0XHRcdHNnID0gc3JjW2kgKyAxXTtcblx0XHRcdFx0YmcgPSBkc3RbaSArIDFdO1xuXHRcdFx0XHRzYiA9IHNyY1tpICsgMl07XG5cdFx0XHRcdGJiID0gZHN0W2kgKyAyXTtcblx0XHRcdFx0c2EgPSBzcmNbaSArIDNdO1xuXHRcdFx0XHRiYSA9IGRzdFtpICsgM107XG5cdFx0XHRcdHByb2Nlc3MoKTtcblx0XHRcdFx0dmFyIGExID0gc2EgKiBhbHBoYSAvIDI1NSxcblx0XHRcdFx0XHRhMiA9IDEgLSBhMTtcblx0XHRcdFx0ZHN0W2ldID0gYTEgKiBkciArIGEyICogYnI7XG5cdFx0XHRcdGRzdFtpICsgMV0gPSBhMSAqIGRnICsgYTIgKiBiZztcblx0XHRcdFx0ZHN0W2kgKyAyXSA9IGExICogZGIgKyBhMiAqIGJiO1xuXHRcdFx0XHRkc3RbaSArIDNdID0gc2EgKiBhbHBoYSArIGEyICogYmE7XG5cdFx0XHR9XG5cdFx0XHRkc3RDb250ZXh0LnB1dEltYWdlRGF0YShkc3REYXRhLCBvZmZzZXQueCwgb2Zmc2V0LnkpO1xuXHRcdH1cblx0fTtcbn07XG5cbnZhciBTVkdTdHlsZXMgPSBCYXNlLmVhY2goe1xuXHRmaWxsQ29sb3I6IFsnZmlsbCcsICdjb2xvciddLFxuXHRzdHJva2VDb2xvcjogWydzdHJva2UnLCAnY29sb3InXSxcblx0c3Ryb2tlV2lkdGg6IFsnc3Ryb2tlLXdpZHRoJywgJ251bWJlciddLFxuXHRzdHJva2VDYXA6IFsnc3Ryb2tlLWxpbmVjYXAnLCAnc3RyaW5nJ10sXG5cdHN0cm9rZUpvaW46IFsnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cmluZyddLFxuXHRzdHJva2VTY2FsaW5nOiBbJ3ZlY3Rvci1lZmZlY3QnLCAnbG9va3VwJywge1xuXHRcdHRydWU6ICdub25lJyxcblx0XHRmYWxzZTogJ25vbi1zY2FsaW5nLXN0cm9rZSdcblx0fSwgZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRyZXR1cm4gIXZhbHVlXG5cdFx0XHRcdCYmIChpdGVtIGluc3RhbmNlb2YgUGF0aEl0ZW1cblx0XHRcdFx0XHR8fCBpdGVtIGluc3RhbmNlb2YgU2hhcGVcblx0XHRcdFx0XHR8fCBpdGVtIGluc3RhbmNlb2YgVGV4dEl0ZW0pO1xuXHR9XSxcblx0bWl0ZXJMaW1pdDogWydzdHJva2UtbWl0ZXJsaW1pdCcsICdudW1iZXInXSxcblx0ZGFzaEFycmF5OiBbJ3N0cm9rZS1kYXNoYXJyYXknLCAnYXJyYXknXSxcblx0ZGFzaE9mZnNldDogWydzdHJva2UtZGFzaG9mZnNldCcsICdudW1iZXInXSxcblx0Zm9udEZhbWlseTogWydmb250LWZhbWlseScsICdzdHJpbmcnXSxcblx0Zm9udFdlaWdodDogWydmb250LXdlaWdodCcsICdzdHJpbmcnXSxcblx0Zm9udFNpemU6IFsnZm9udC1zaXplJywgJ251bWJlciddLFxuXHRqdXN0aWZpY2F0aW9uOiBbJ3RleHQtYW5jaG9yJywgJ2xvb2t1cCcsIHtcblx0XHRsZWZ0OiAnc3RhcnQnLFxuXHRcdGNlbnRlcjogJ21pZGRsZScsXG5cdFx0cmlnaHQ6ICdlbmQnXG5cdH1dLFxuXHRvcGFjaXR5OiBbJ29wYWNpdHknLCAnbnVtYmVyJ10sXG5cdGJsZW5kTW9kZTogWydtaXgtYmxlbmQtbW9kZScsICdzdHJpbmcnXVxufSwgZnVuY3Rpb24oZW50cnksIGtleSkge1xuXHR2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShrZXkpLFxuXHRcdGxvb2t1cCA9IGVudHJ5WzJdO1xuXHR0aGlzW2tleV0gPSB7XG5cdFx0dHlwZTogZW50cnlbMV0sXG5cdFx0cHJvcGVydHk6IGtleSxcblx0XHRhdHRyaWJ1dGU6IGVudHJ5WzBdLFxuXHRcdHRvU1ZHOiBsb29rdXAsXG5cdFx0ZnJvbVNWRzogbG9va3VwICYmIEJhc2UuZWFjaChsb29rdXAsIGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG5cdFx0XHR0aGlzW3ZhbHVlXSA9IG5hbWU7XG5cdFx0fSwge30pLFxuXHRcdGV4cG9ydEZpbHRlcjogZW50cnlbM10sXG5cdFx0Z2V0OiAnZ2V0JyArIHBhcnQsXG5cdFx0c2V0OiAnc2V0JyArIHBhcnRcblx0fTtcbn0sIHt9KTtcblxudmFyIFNWR05hbWVzcGFjZXMgPSB7XG5cdGhyZWY6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcblx0eGxpbms6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zJ1xufTtcblxubmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgZm9ybWF0dGVyO1xuXG5cdGZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMobm9kZSwgYXR0cnMpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRcdHZhciB2YWwgPSBhdHRyc1trZXldLFxuXHRcdFx0XHRuYW1lc3BhY2UgPSBTVkdOYW1lc3BhY2VzW2tleV07XG5cdFx0XHRpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpXG5cdFx0XHRcdHZhbCA9IGZvcm1hdHRlci5udW1iZXIodmFsKTtcblx0XHRcdGlmIChuYW1lc3BhY2UpIHtcblx0XHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIGtleSwgdmFsKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHRhZywgYXR0cnMpIHtcblx0XHRyZXR1cm4gc2V0QXR0cmlidXRlcyhcblx0XHRcdGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCB0YWcpLCBhdHRycyk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRUcmFuc2Zvcm0obWF0cml4LCBjb29yZGluYXRlcywgY2VudGVyKSB7XG5cdFx0dmFyIGF0dHJzID0gbmV3IEJhc2UoKSxcblx0XHRcdHRyYW5zID0gbWF0cml4LmdldFRyYW5zbGF0aW9uKCk7XG5cdFx0aWYgKGNvb3JkaW5hdGVzKSB7XG5cdFx0XHRtYXRyaXggPSBtYXRyaXguc2hpZnRsZXNzKCk7XG5cdFx0XHR2YXIgcG9pbnQgPSBtYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0odHJhbnMpO1xuXHRcdFx0YXR0cnNbY2VudGVyID8gJ2N4JyA6ICd4J10gPSBwb2ludC54O1xuXHRcdFx0YXR0cnNbY2VudGVyID8gJ2N5JyA6ICd5J10gPSBwb2ludC55O1xuXHRcdFx0dHJhbnMgPSBudWxsO1xuXHRcdH1cblx0XHRpZiAoIW1hdHJpeC5pc0lkZW50aXR5KCkpIHtcblx0XHRcdHZhciBkZWNvbXBvc2VkID0gbWF0cml4LmRlY29tcG9zZSgpO1xuXHRcdFx0aWYgKGRlY29tcG9zZWQgJiYgIWRlY29tcG9zZWQuc2hlYXJpbmcpIHtcblx0XHRcdFx0dmFyIHBhcnRzID0gW10sXG5cdFx0XHRcdFx0YW5nbGUgPSBkZWNvbXBvc2VkLnJvdGF0aW9uLFxuXHRcdFx0XHRcdHNjYWxlID0gZGVjb21wb3NlZC5zY2FsaW5nO1xuXHRcdFx0XHRpZiAodHJhbnMgJiYgIXRyYW5zLmlzWmVybygpKVxuXHRcdFx0XHRcdHBhcnRzLnB1c2goJ3RyYW5zbGF0ZSgnICsgZm9ybWF0dGVyLnBvaW50KHRyYW5zKSArICcpJyk7XG5cdFx0XHRcdGlmICghTnVtZXJpY2FsLmlzWmVybyhzY2FsZS54IC0gMSlcblx0XHRcdFx0XHRcdHx8ICFOdW1lcmljYWwuaXNaZXJvKHNjYWxlLnkgLSAxKSlcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKCdzY2FsZSgnICsgZm9ybWF0dGVyLnBvaW50KHNjYWxlKSArJyknKTtcblx0XHRcdFx0aWYgKGFuZ2xlKVxuXHRcdFx0XHRcdHBhcnRzLnB1c2goJ3JvdGF0ZSgnICsgZm9ybWF0dGVyLm51bWJlcihhbmdsZSkgKyAnKScpO1xuXHRcdFx0XHRhdHRycy50cmFuc2Zvcm0gPSBwYXJ0cy5qb2luKCcgJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhdHRycy50cmFuc2Zvcm0gPSAnbWF0cml4KCcgKyBtYXRyaXguZ2V0VmFsdWVzKCkuam9pbignLCcpICsgJyknO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gYXR0cnM7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRHcm91cChpdGVtLCBvcHRpb25zKSB7XG5cdFx0dmFyIGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCksXG5cdFx0XHRjaGlsZHJlbiA9IGl0ZW0uX2NoaWxkcmVuO1xuXHRcdHZhciBub2RlID0gY3JlYXRlRWxlbWVudCgnZycsIGF0dHJzKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cdFx0XHR2YXIgY2hpbGROb2RlID0gZXhwb3J0U1ZHKGNoaWxkLCBvcHRpb25zKTtcblx0XHRcdGlmIChjaGlsZE5vZGUpIHtcblx0XHRcdFx0aWYgKGNoaWxkLmlzQ2xpcE1hc2soKSkge1xuXHRcdFx0XHRcdHZhciBjbGlwID0gY3JlYXRlRWxlbWVudCgnY2xpcFBhdGgnKTtcblx0XHRcdFx0XHRjbGlwLmFwcGVuZENoaWxkKGNoaWxkTm9kZSk7XG5cdFx0XHRcdFx0c2V0RGVmaW5pdGlvbihjaGlsZCwgY2xpcCwgJ2NsaXAnKTtcblx0XHRcdFx0XHRzZXRBdHRyaWJ1dGVzKG5vZGUsIHtcblx0XHRcdFx0XHRcdCdjbGlwLXBhdGgnOiAndXJsKCMnICsgY2xpcC5pZCArICcpJ1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGROb2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbm9kZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydFJhc3RlcihpdGVtLCBvcHRpb25zKSB7XG5cdFx0dmFyIGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCwgdHJ1ZSksXG5cdFx0XHRzaXplID0gaXRlbS5nZXRTaXplKCksXG5cdFx0XHRpbWFnZSA9IGl0ZW0uZ2V0SW1hZ2UoKTtcblx0XHRhdHRycy54IC09IHNpemUud2lkdGggLyAyO1xuXHRcdGF0dHJzLnkgLT0gc2l6ZS5oZWlnaHQgLyAyO1xuXHRcdGF0dHJzLndpZHRoID0gc2l6ZS53aWR0aDtcblx0XHRhdHRycy5oZWlnaHQgPSBzaXplLmhlaWdodDtcblx0XHRhdHRycy5ocmVmID0gb3B0aW9ucy5lbWJlZEltYWdlcyA9PT0gZmFsc2UgJiYgaW1hZ2UgJiYgaW1hZ2Uuc3JjXG5cdFx0XHRcdHx8IGl0ZW0udG9EYXRhVVJMKCk7XG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2ltYWdlJywgYXR0cnMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0UGF0aChpdGVtLCBvcHRpb25zKSB7XG5cdFx0dmFyIG1hdGNoU2hhcGVzID0gb3B0aW9ucy5tYXRjaFNoYXBlcztcblx0XHRpZiAobWF0Y2hTaGFwZXMpIHtcblx0XHRcdHZhciBzaGFwZSA9IGl0ZW0udG9TaGFwZShmYWxzZSk7XG5cdFx0XHRpZiAoc2hhcGUpXG5cdFx0XHRcdHJldHVybiBleHBvcnRTaGFwZShzaGFwZSwgb3B0aW9ucyk7XG5cdFx0fVxuXHRcdHZhciBzZWdtZW50cyA9IGl0ZW0uX3NlZ21lbnRzLFxuXHRcdFx0dHlwZSxcblx0XHRcdGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCk7XG5cdFx0aWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMClcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdGlmIChtYXRjaFNoYXBlcyAmJiAhaXRlbS5oYXNIYW5kbGVzKCkpIHtcblx0XHRcdGlmIChzZWdtZW50cy5sZW5ndGggPj0gMykge1xuXHRcdFx0XHR0eXBlID0gaXRlbS5fY2xvc2VkID8gJ3BvbHlnb24nIDogJ3BvbHlsaW5lJztcblx0XHRcdFx0dmFyIHBhcnRzID0gW107XG5cdFx0XHRcdGZvcih2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdFx0cGFydHMucHVzaChmb3JtYXR0ZXIucG9pbnQoc2VnbWVudHNbaV0uX3BvaW50KSk7XG5cdFx0XHRcdGF0dHJzLnBvaW50cyA9IHBhcnRzLmpvaW4oJyAnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR5cGUgPSAnbGluZSc7XG5cdFx0XHRcdHZhciBmaXJzdCA9IHNlZ21lbnRzWzBdLl9wb2ludCxcblx0XHRcdFx0XHRsYXN0ID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0uX3BvaW50O1xuXHRcdFx0XHRhdHRycy5zZXQoe1xuXHRcdFx0XHRcdHgxOiBmaXJzdC54LFxuXHRcdFx0XHRcdHkxOiBmaXJzdC55LFxuXHRcdFx0XHRcdHgyOiBsYXN0LngsXG5cdFx0XHRcdFx0eTI6IGxhc3QueVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dHlwZSA9ICdwYXRoJztcblx0XHRcdGF0dHJzLmQgPSBpdGVtLmdldFBhdGhEYXRhKG51bGwsIG9wdGlvbnMucHJlY2lzaW9uKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQodHlwZSwgYXR0cnMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0U2hhcGUoaXRlbSkge1xuXHRcdHZhciB0eXBlID0gaXRlbS5fdHlwZSxcblx0XHRcdHJhZGl1cyA9IGl0ZW0uX3JhZGl1cyxcblx0XHRcdGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCwgdHJ1ZSwgdHlwZSAhPT0gJ3JlY3RhbmdsZScpO1xuXHRcdGlmICh0eXBlID09PSAncmVjdGFuZ2xlJykge1xuXHRcdFx0dHlwZSA9ICdyZWN0Jztcblx0XHRcdHZhciBzaXplID0gaXRlbS5fc2l6ZSxcblx0XHRcdFx0d2lkdGggPSBzaXplLndpZHRoLFxuXHRcdFx0XHRoZWlnaHQgPSBzaXplLmhlaWdodDtcblx0XHRcdGF0dHJzLnggLT0gd2lkdGggLyAyO1xuXHRcdFx0YXR0cnMueSAtPSBoZWlnaHQgLyAyO1xuXHRcdFx0YXR0cnMud2lkdGggPSB3aWR0aDtcblx0XHRcdGF0dHJzLmhlaWdodCA9IGhlaWdodDtcblx0XHRcdGlmIChyYWRpdXMuaXNaZXJvKCkpXG5cdFx0XHRcdHJhZGl1cyA9IG51bGw7XG5cdFx0fVxuXHRcdGlmIChyYWRpdXMpIHtcblx0XHRcdGlmICh0eXBlID09PSAnY2lyY2xlJykge1xuXHRcdFx0XHRhdHRycy5yID0gcmFkaXVzO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXR0cnMucnggPSByYWRpdXMud2lkdGg7XG5cdFx0XHRcdGF0dHJzLnJ5ID0gcmFkaXVzLmhlaWdodDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQodHlwZSwgYXR0cnMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0Q29tcG91bmRQYXRoKGl0ZW0sIG9wdGlvbnMpIHtcblx0XHR2YXIgYXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4KTtcblx0XHR2YXIgZGF0YSA9IGl0ZW0uZ2V0UGF0aERhdGEobnVsbCwgb3B0aW9ucy5wcmVjaXNpb24pO1xuXHRcdGlmIChkYXRhKVxuXHRcdFx0YXR0cnMuZCA9IGRhdGE7XG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBhdHRycyk7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRQbGFjZWRTeW1ib2woaXRlbSwgb3B0aW9ucykge1xuXHRcdHZhciBhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgsIHRydWUpLFxuXHRcdFx0c3ltYm9sID0gaXRlbS5nZXRTeW1ib2woKSxcblx0XHRcdHN5bWJvbE5vZGUgPSBnZXREZWZpbml0aW9uKHN5bWJvbCwgJ3N5bWJvbCcpLFxuXHRcdFx0ZGVmaW5pdGlvbiA9IHN5bWJvbC5nZXREZWZpbml0aW9uKCksXG5cdFx0XHRib3VuZHMgPSBkZWZpbml0aW9uLmdldEJvdW5kcygpO1xuXHRcdGlmICghc3ltYm9sTm9kZSkge1xuXHRcdFx0c3ltYm9sTm9kZSA9IGNyZWF0ZUVsZW1lbnQoJ3N5bWJvbCcsIHtcblx0XHRcdFx0dmlld0JveDogZm9ybWF0dGVyLnJlY3RhbmdsZShib3VuZHMpXG5cdFx0XHR9KTtcblx0XHRcdHN5bWJvbE5vZGUuYXBwZW5kQ2hpbGQoZXhwb3J0U1ZHKGRlZmluaXRpb24sIG9wdGlvbnMpKTtcblx0XHRcdHNldERlZmluaXRpb24oc3ltYm9sLCBzeW1ib2xOb2RlLCAnc3ltYm9sJyk7XG5cdFx0fVxuXHRcdGF0dHJzLmhyZWYgPSAnIycgKyBzeW1ib2xOb2RlLmlkO1xuXHRcdGF0dHJzLnggKz0gYm91bmRzLng7XG5cdFx0YXR0cnMueSArPSBib3VuZHMueTtcblx0XHRhdHRycy53aWR0aCA9IGZvcm1hdHRlci5udW1iZXIoYm91bmRzLndpZHRoKTtcblx0XHRhdHRycy5oZWlnaHQgPSBmb3JtYXR0ZXIubnVtYmVyKGJvdW5kcy5oZWlnaHQpO1xuXHRcdGF0dHJzLm92ZXJmbG93ID0gJ3Zpc2libGUnO1xuXHRcdHJldHVybiBjcmVhdGVFbGVtZW50KCd1c2UnLCBhdHRycyk7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRHcmFkaWVudChjb2xvcikge1xuXHRcdHZhciBncmFkaWVudE5vZGUgPSBnZXREZWZpbml0aW9uKGNvbG9yLCAnY29sb3InKTtcblx0XHRpZiAoIWdyYWRpZW50Tm9kZSkge1xuXHRcdFx0dmFyIGdyYWRpZW50ID0gY29sb3IuZ2V0R3JhZGllbnQoKSxcblx0XHRcdFx0cmFkaWFsID0gZ3JhZGllbnQuX3JhZGlhbCxcblx0XHRcdFx0b3JpZ2luID0gY29sb3IuZ2V0T3JpZ2luKCkudHJhbnNmb3JtKCksXG5cdFx0XHRcdGRlc3RpbmF0aW9uID0gY29sb3IuZ2V0RGVzdGluYXRpb24oKS50cmFuc2Zvcm0oKSxcblx0XHRcdFx0YXR0cnM7XG5cdFx0XHRpZiAocmFkaWFsKSB7XG5cdFx0XHRcdGF0dHJzID0ge1xuXHRcdFx0XHRcdGN4OiBvcmlnaW4ueCxcblx0XHRcdFx0XHRjeTogb3JpZ2luLnksXG5cdFx0XHRcdFx0cjogb3JpZ2luLmdldERpc3RhbmNlKGRlc3RpbmF0aW9uKVxuXHRcdFx0XHR9O1xuXHRcdFx0XHR2YXIgaGlnaGxpZ2h0ID0gY29sb3IuZ2V0SGlnaGxpZ2h0KCk7XG5cdFx0XHRcdGlmIChoaWdobGlnaHQpIHtcblx0XHRcdFx0XHRoaWdobGlnaHQgPSBoaWdobGlnaHQudHJhbnNmb3JtKCk7XG5cdFx0XHRcdFx0YXR0cnMuZnggPSBoaWdobGlnaHQueDtcblx0XHRcdFx0XHRhdHRycy5meSA9IGhpZ2hsaWdodC55O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhdHRycyA9IHtcblx0XHRcdFx0XHR4MTogb3JpZ2luLngsXG5cdFx0XHRcdFx0eTE6IG9yaWdpbi55LFxuXHRcdFx0XHRcdHgyOiBkZXN0aW5hdGlvbi54LFxuXHRcdFx0XHRcdHkyOiBkZXN0aW5hdGlvbi55XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRhdHRycy5ncmFkaWVudFVuaXRzID0gJ3VzZXJTcGFjZU9uVXNlJztcblx0XHRcdGdyYWRpZW50Tm9kZSA9IGNyZWF0ZUVsZW1lbnQoXG5cdFx0XHRcdFx0KHJhZGlhbCA/ICdyYWRpYWwnIDogJ2xpbmVhcicpICsgJ0dyYWRpZW50JywgYXR0cnMpO1xuXHRcdFx0dmFyIHN0b3BzID0gZ3JhZGllbnQuX3N0b3BzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHN0b3AgPSBzdG9wc1tpXSxcblx0XHRcdFx0XHRzdG9wQ29sb3IgPSBzdG9wLl9jb2xvcixcblx0XHRcdFx0XHRhbHBoYSA9IHN0b3BDb2xvci5nZXRBbHBoYSgpO1xuXHRcdFx0XHRhdHRycyA9IHtcblx0XHRcdFx0XHRvZmZzZXQ6IHN0b3AuX3JhbXBQb2ludCxcblx0XHRcdFx0XHQnc3RvcC1jb2xvcic6IHN0b3BDb2xvci50b0NTUyh0cnVlKVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoYWxwaGEgPCAxKVxuXHRcdFx0XHRcdGF0dHJzWydzdG9wLW9wYWNpdHknXSA9IGFscGhhO1xuXHRcdFx0XHRncmFkaWVudE5vZGUuYXBwZW5kQ2hpbGQoY3JlYXRlRWxlbWVudCgnc3RvcCcsIGF0dHJzKSk7XG5cdFx0XHR9XG5cdFx0XHRzZXREZWZpbml0aW9uKGNvbG9yLCBncmFkaWVudE5vZGUsICdjb2xvcicpO1xuXHRcdH1cblx0XHRyZXR1cm4gJ3VybCgjJyArIGdyYWRpZW50Tm9kZS5pZCArICcpJztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydFRleHQoaXRlbSkge1xuXHRcdHZhciBub2RlID0gY3JlYXRlRWxlbWVudCgndGV4dCcsIGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgsIHRydWUpKTtcblx0XHRub2RlLnRleHRDb250ZW50ID0gaXRlbS5fY29udGVudDtcblx0XHRyZXR1cm4gbm9kZTtcblx0fVxuXG5cdHZhciBleHBvcnRlcnMgPSB7XG5cdFx0R3JvdXA6IGV4cG9ydEdyb3VwLFxuXHRcdExheWVyOiBleHBvcnRHcm91cCxcblx0XHRSYXN0ZXI6IGV4cG9ydFJhc3Rlcixcblx0XHRQYXRoOiBleHBvcnRQYXRoLFxuXHRcdFNoYXBlOiBleHBvcnRTaGFwZSxcblx0XHRDb21wb3VuZFBhdGg6IGV4cG9ydENvbXBvdW5kUGF0aCxcblx0XHRQbGFjZWRTeW1ib2w6IGV4cG9ydFBsYWNlZFN5bWJvbCxcblx0XHRQb2ludFRleHQ6IGV4cG9ydFRleHRcblx0fTtcblxuXHRmdW5jdGlvbiBhcHBseVN0eWxlKGl0ZW0sIG5vZGUsIGlzUm9vdCkge1xuXHRcdHZhciBhdHRycyA9IHt9LFxuXHRcdFx0cGFyZW50ID0gIWlzUm9vdCAmJiBpdGVtLmdldFBhcmVudCgpO1xuXG5cdFx0aWYgKGl0ZW0uX25hbWUgIT0gbnVsbClcblx0XHRcdGF0dHJzLmlkID0gaXRlbS5fbmFtZTtcblxuXHRcdEJhc2UuZWFjaChTVkdTdHlsZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG5cdFx0XHR2YXIgZ2V0ID0gZW50cnkuZ2V0LFxuXHRcdFx0XHR0eXBlID0gZW50cnkudHlwZSxcblx0XHRcdFx0dmFsdWUgPSBpdGVtW2dldF0oKTtcblx0XHRcdGlmIChlbnRyeS5leHBvcnRGaWx0ZXJcblx0XHRcdFx0XHQ/IGVudHJ5LmV4cG9ydEZpbHRlcihpdGVtLCB2YWx1ZSlcblx0XHRcdFx0XHQ6ICFwYXJlbnQgfHwgIUJhc2UuZXF1YWxzKHBhcmVudFtnZXRdKCksIHZhbHVlKSkge1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NvbG9yJyAmJiB2YWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0dmFyIGFscGhhID0gdmFsdWUuZ2V0QWxwaGEoKTtcblx0XHRcdFx0XHRpZiAoYWxwaGEgPCAxKVxuXHRcdFx0XHRcdFx0YXR0cnNbZW50cnkuYXR0cmlidXRlICsgJy1vcGFjaXR5J10gPSBhbHBoYTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhdHRyc1tlbnRyeS5hdHRyaWJ1dGVdID0gdmFsdWUgPT0gbnVsbFxuXHRcdFx0XHRcdD8gJ25vbmUnXG5cdFx0XHRcdFx0OiB0eXBlID09PSAnbnVtYmVyJ1xuXHRcdFx0XHRcdFx0PyBmb3JtYXR0ZXIubnVtYmVyKHZhbHVlKVxuXHRcdFx0XHRcdFx0OiB0eXBlID09PSAnY29sb3InXG5cdFx0XHRcdFx0XHRcdD8gdmFsdWUuZ3JhZGllbnRcblx0XHRcdFx0XHRcdFx0XHQ/IGV4cG9ydEdyYWRpZW50KHZhbHVlLCBpdGVtKVxuXHRcdFx0XHRcdFx0XHRcdDogdmFsdWUudG9DU1ModHJ1ZSlcblx0XHRcdFx0XHRcdFx0OiB0eXBlID09PSAnYXJyYXknXG5cdFx0XHRcdFx0XHRcdFx0PyB2YWx1ZS5qb2luKCcsJylcblx0XHRcdFx0XHRcdFx0XHQ6IHR5cGUgPT09ICdsb29rdXAnXG5cdFx0XHRcdFx0XHRcdFx0XHQ/IGVudHJ5LnRvU1ZHW3ZhbHVlXVxuXHRcdFx0XHRcdFx0XHRcdFx0OiB2YWx1ZTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGlmIChhdHRycy5vcGFjaXR5ID09PSAxKVxuXHRcdFx0ZGVsZXRlIGF0dHJzLm9wYWNpdHk7XG5cblx0XHRpZiAoIWl0ZW0uX3Zpc2libGUpXG5cdFx0XHRhdHRycy52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cblx0XHRyZXR1cm4gc2V0QXR0cmlidXRlcyhub2RlLCBhdHRycyk7XG5cdH1cblxuXHR2YXIgZGVmaW5pdGlvbnM7XG5cdGZ1bmN0aW9uIGdldERlZmluaXRpb24oaXRlbSwgdHlwZSkge1xuXHRcdGlmICghZGVmaW5pdGlvbnMpXG5cdFx0XHRkZWZpbml0aW9ucyA9IHsgaWRzOiB7fSwgc3Znczoge30gfTtcblx0XHRyZXR1cm4gaXRlbSAmJiBkZWZpbml0aW9ucy5zdmdzW3R5cGUgKyAnLScgKyBpdGVtLl9pZF07XG5cdH1cblxuXHRmdW5jdGlvbiBzZXREZWZpbml0aW9uKGl0ZW0sIG5vZGUsIHR5cGUpIHtcblx0XHRpZiAoIWRlZmluaXRpb25zKVxuXHRcdFx0Z2V0RGVmaW5pdGlvbigpO1xuXHRcdHZhciBpZCA9IGRlZmluaXRpb25zLmlkc1t0eXBlXSA9IChkZWZpbml0aW9ucy5pZHNbdHlwZV0gfHwgMCkgKyAxO1xuXHRcdG5vZGUuaWQgPSB0eXBlICsgJy0nICsgaWQ7XG5cdFx0ZGVmaW5pdGlvbnMuc3Znc1t0eXBlICsgJy0nICsgaXRlbS5faWRdID0gbm9kZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydERlZmluaXRpb25zKG5vZGUsIG9wdGlvbnMpIHtcblx0XHR2YXIgc3ZnID0gbm9kZSxcblx0XHRcdGRlZnMgPSBudWxsO1xuXHRcdGlmIChkZWZpbml0aW9ucykge1xuXHRcdFx0c3ZnID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3ZnJyAmJiBub2RlO1xuXHRcdFx0Zm9yICh2YXIgaSBpbiBkZWZpbml0aW9ucy5zdmdzKSB7XG5cdFx0XHRcdGlmICghZGVmcykge1xuXHRcdFx0XHRcdGlmICghc3ZnKSB7XG5cdFx0XHRcdFx0XHRzdmcgPSBjcmVhdGVFbGVtZW50KCdzdmcnKTtcblx0XHRcdFx0XHRcdHN2Zy5hcHBlbmRDaGlsZChub2RlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGVmcyA9IHN2Zy5pbnNlcnRCZWZvcmUoY3JlYXRlRWxlbWVudCgnZGVmcycpLFxuXHRcdFx0XHRcdFx0XHRzdmcuZmlyc3RDaGlsZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVmcy5hcHBlbmRDaGlsZChkZWZpbml0aW9ucy5zdmdzW2ldKTtcblx0XHRcdH1cblx0XHRcdGRlZmluaXRpb25zID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIG9wdGlvbnMuYXNTdHJpbmdcblx0XHRcdFx0PyBuZXcgWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKHN2Zylcblx0XHRcdFx0OiBzdmc7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRTVkcoaXRlbSwgb3B0aW9ucywgaXNSb290KSB7XG5cdFx0dmFyIGV4cG9ydGVyID0gZXhwb3J0ZXJzW2l0ZW0uX2NsYXNzXSxcblx0XHRcdG5vZGUgPSBleHBvcnRlciAmJiBleHBvcnRlcihpdGVtLCBvcHRpb25zKTtcblx0XHRpZiAobm9kZSkge1xuXHRcdFx0dmFyIG9uRXhwb3J0ID0gb3B0aW9ucy5vbkV4cG9ydDtcblx0XHRcdGlmIChvbkV4cG9ydClcblx0XHRcdFx0bm9kZSA9IG9uRXhwb3J0KGl0ZW0sIG5vZGUsIG9wdGlvbnMpIHx8IG5vZGU7XG5cdFx0XHR2YXIgZGF0YSA9IEpTT04uc3RyaW5naWZ5KGl0ZW0uX2RhdGEpO1xuXHRcdFx0aWYgKGRhdGEgJiYgZGF0YSAhPT0gJ3t9JyAmJiBkYXRhICE9PSAnbnVsbCcpXG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKCdkYXRhLXBhcGVyLWRhdGEnLCBkYXRhKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5vZGUgJiYgYXBwbHlTdHlsZShpdGVtLCBub2RlLCBpc1Jvb3QpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG5cdFx0aWYgKCFvcHRpb25zKVxuXHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdGZvcm1hdHRlciA9IG5ldyBGb3JtYXR0ZXIob3B0aW9ucy5wcmVjaXNpb24pO1xuXHRcdHJldHVybiBvcHRpb25zO1xuXHR9XG5cblx0SXRlbS5pbmplY3Qoe1xuXHRcdGV4cG9ydFNWRzogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdFx0b3B0aW9ucyA9IHNldE9wdGlvbnMob3B0aW9ucyk7XG5cdFx0XHRyZXR1cm4gZXhwb3J0RGVmaW5pdGlvbnMoZXhwb3J0U1ZHKHRoaXMsIG9wdGlvbnMsIHRydWUpLCBvcHRpb25zKTtcblx0XHR9XG5cdH0pO1xuXG5cdFByb2plY3QuaW5qZWN0KHtcblx0XHRleHBvcnRTVkc6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRcdG9wdGlvbnMgPSBzZXRPcHRpb25zKG9wdGlvbnMpO1xuXHRcdFx0dmFyIGxheWVycyA9IHRoaXMubGF5ZXJzLFxuXHRcdFx0XHR2aWV3ID0gdGhpcy5nZXRWaWV3KCksXG5cdFx0XHRcdHNpemUgPSB2aWV3LmdldFZpZXdTaXplKCksXG5cdFx0XHRcdG5vZGUgPSBjcmVhdGVFbGVtZW50KCdzdmcnLCB7XG5cdFx0XHRcdFx0eDogMCxcblx0XHRcdFx0XHR5OiAwLFxuXHRcdFx0XHRcdHdpZHRoOiBzaXplLndpZHRoLFxuXHRcdFx0XHRcdGhlaWdodDogc2l6ZS5oZWlnaHQsXG5cdFx0XHRcdFx0dmVyc2lvbjogJzEuMScsXG5cdFx0XHRcdFx0eG1sbnM6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG5cdFx0XHRcdFx0J3htbG5zOnhsaW5rJzogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnXG5cdFx0XHRcdH0pLFxuXHRcdFx0XHRwYXJlbnQgPSBub2RlLFxuXHRcdFx0XHRtYXRyaXggPSB2aWV3Ll9tYXRyaXg7XG5cdFx0XHRpZiAoIW1hdHJpeC5pc0lkZW50aXR5KCkpXG5cdFx0XHRcdHBhcmVudCA9IG5vZGUuYXBwZW5kQ2hpbGQoXG5cdFx0XHRcdFx0XHRjcmVhdGVFbGVtZW50KCdnJywgZ2V0VHJhbnNmb3JtKG1hdHJpeCkpKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0cGFyZW50LmFwcGVuZENoaWxkKGV4cG9ydFNWRyhsYXllcnNbaV0sIG9wdGlvbnMsIHRydWUpKTtcblx0XHRcdHJldHVybiBleHBvcnREZWZpbml0aW9ucyhub2RlLCBvcHRpb25zKTtcblx0XHR9XG5cdH0pO1xufTtcblxubmV3IGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIGdldFZhbHVlKG5vZGUsIG5hbWUsIGlzU3RyaW5nLCBhbGxvd051bGwpIHtcblx0XHR2YXIgbmFtZXNwYWNlID0gU1ZHTmFtZXNwYWNlc1tuYW1lXSxcblx0XHRcdHZhbHVlID0gbmFtZXNwYWNlXG5cdFx0XHRcdD8gbm9kZS5nZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIG5hbWUpXG5cdFx0XHRcdDogbm9kZS5nZXRBdHRyaWJ1dGUobmFtZSk7XG5cdFx0aWYgKHZhbHVlID09PSAnbnVsbCcpXG5cdFx0XHR2YWx1ZSA9IG51bGw7XG5cdFx0cmV0dXJuIHZhbHVlID09IG51bGxcblx0XHRcdFx0PyBhbGxvd051bGxcblx0XHRcdFx0XHQ/IG51bGxcblx0XHRcdFx0XHQ6IGlzU3RyaW5nXG5cdFx0XHRcdFx0XHQ/ICcnXG5cdFx0XHRcdFx0XHQ6IDBcblx0XHRcdFx0OiBpc1N0cmluZ1xuXHRcdFx0XHRcdD8gdmFsdWVcblx0XHRcdFx0XHQ6IHBhcnNlRmxvYXQodmFsdWUpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0UG9pbnQobm9kZSwgeCwgeSwgYWxsb3dOdWxsKSB7XG5cdFx0eCA9IGdldFZhbHVlKG5vZGUsIHgsIGZhbHNlLCBhbGxvd051bGwpO1xuXHRcdHkgPSBnZXRWYWx1ZShub2RlLCB5LCBmYWxzZSwgYWxsb3dOdWxsKTtcblx0XHRyZXR1cm4gYWxsb3dOdWxsICYmICh4ID09IG51bGwgfHwgeSA9PSBudWxsKSA/IG51bGxcblx0XHRcdFx0OiBuZXcgUG9pbnQoeCwgeSk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRTaXplKG5vZGUsIHcsIGgsIGFsbG93TnVsbCkge1xuXHRcdHcgPSBnZXRWYWx1ZShub2RlLCB3LCBmYWxzZSwgYWxsb3dOdWxsKTtcblx0XHRoID0gZ2V0VmFsdWUobm9kZSwgaCwgZmFsc2UsIGFsbG93TnVsbCk7XG5cdFx0cmV0dXJuIGFsbG93TnVsbCAmJiAodyA9PSBudWxsIHx8IGggPT0gbnVsbCkgPyBudWxsXG5cdFx0XHRcdDogbmV3IFNpemUodywgaCk7XG5cdH1cblxuXHRmdW5jdGlvbiBjb252ZXJ0VmFsdWUodmFsdWUsIHR5cGUsIGxvb2t1cCkge1xuXHRcdHJldHVybiB2YWx1ZSA9PT0gJ25vbmUnXG5cdFx0XHRcdD8gbnVsbFxuXHRcdFx0XHQ6IHR5cGUgPT09ICdudW1iZXInXG5cdFx0XHRcdFx0PyBwYXJzZUZsb2F0KHZhbHVlKVxuXHRcdFx0XHRcdDogdHlwZSA9PT0gJ2FycmF5J1xuXHRcdFx0XHRcdFx0PyB2YWx1ZSA/IHZhbHVlLnNwbGl0KC9bXFxzLF0rL2cpLm1hcChwYXJzZUZsb2F0KSA6IFtdXG5cdFx0XHRcdFx0XHQ6IHR5cGUgPT09ICdjb2xvcidcblx0XHRcdFx0XHRcdFx0PyBnZXREZWZpbml0aW9uKHZhbHVlKSB8fCB2YWx1ZVxuXHRcdFx0XHRcdFx0XHQ6IHR5cGUgPT09ICdsb29rdXAnXG5cdFx0XHRcdFx0XHRcdFx0PyBsb29rdXBbdmFsdWVdXG5cdFx0XHRcdFx0XHRcdFx0OiB2YWx1ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGltcG9ydEdyb3VwKG5vZGUsIHR5cGUsIG9wdGlvbnMsIGlzUm9vdCkge1xuXHRcdHZhciBub2RlcyA9IG5vZGUuY2hpbGROb2Rlcyxcblx0XHRcdGlzQ2xpcCA9IHR5cGUgPT09ICdjbGlwcGF0aCcsXG5cdFx0XHRpdGVtID0gbmV3IEdyb3VwKCksXG5cdFx0XHRwcm9qZWN0ID0gaXRlbS5fcHJvamVjdCxcblx0XHRcdGN1cnJlbnRTdHlsZSA9IHByb2plY3QuX2N1cnJlbnRTdHlsZSxcblx0XHRcdGNoaWxkcmVuID0gW107XG5cdFx0aWYgKCFpc0NsaXApIHtcblx0XHRcdGl0ZW0gPSBhcHBseUF0dHJpYnV0ZXMoaXRlbSwgbm9kZSwgaXNSb290KTtcblx0XHRcdHByb2plY3QuX2N1cnJlbnRTdHlsZSA9IGl0ZW0uX3N0eWxlLmNsb25lKCk7XG5cdFx0fVxuXHRcdGlmIChpc1Jvb3QpIHtcblx0XHRcdHZhciBkZWZzID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdkZWZzJyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGRlZnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGltcG9ydFNWRyhkZWZzW2ldLCBvcHRpb25zLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hpbGROb2RlID0gbm9kZXNbaV0sXG5cdFx0XHRcdGNoaWxkO1xuXHRcdFx0aWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gMVxuXHRcdFx0XHRcdCYmIGNoaWxkTm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnZGVmcydcblx0XHRcdFx0XHQmJiAoY2hpbGQgPSBpbXBvcnRTVkcoY2hpbGROb2RlLCBvcHRpb25zLCBmYWxzZSkpXG5cdFx0XHRcdFx0JiYgIShjaGlsZCBpbnN0YW5jZW9mIFN5bWJvbCkpXG5cdFx0XHRcdGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuXHRcdH1cblx0XHRpdGVtLmFkZENoaWxkcmVuKGNoaWxkcmVuKTtcblx0XHRpZiAoaXNDbGlwKVxuXHRcdFx0aXRlbSA9IGFwcGx5QXR0cmlidXRlcyhpdGVtLnJlZHVjZSgpLCBub2RlLCBpc1Jvb3QpO1xuXHRcdHByb2plY3QuX2N1cnJlbnRTdHlsZSA9IGN1cnJlbnRTdHlsZTtcblx0XHRpZiAoaXNDbGlwIHx8IHR5cGUgPT09ICdkZWZzJykge1xuXHRcdFx0aXRlbS5yZW1vdmUoKTtcblx0XHRcdGl0ZW0gPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gaXRlbTtcblx0fVxuXG5cdGZ1bmN0aW9uIGltcG9ydFBvbHkobm9kZSwgdHlwZSkge1xuXHRcdHZhciBjb29yZHMgPSBub2RlLmdldEF0dHJpYnV0ZSgncG9pbnRzJykubWF0Y2goXG5cdFx0XHRcdFx0L1srLV0/KD86XFxkKlxcLlxcZCt8XFxkK1xcLj8pKD86W2VFXVsrLV0/XFxkKyk/L2cpLFxuXHRcdFx0cG9pbnRzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjb29yZHMubGVuZ3RoOyBpIDwgbDsgaSArPSAyKVxuXHRcdFx0cG9pbnRzLnB1c2gobmV3IFBvaW50KFxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoY29vcmRzW2ldKSxcblx0XHRcdFx0XHRwYXJzZUZsb2F0KGNvb3Jkc1tpICsgMV0pKSk7XG5cdFx0dmFyIHBhdGggPSBuZXcgUGF0aChwb2ludHMpO1xuXHRcdGlmICh0eXBlID09PSAncG9seWdvbicpXG5cdFx0XHRwYXRoLmNsb3NlUGF0aCgpO1xuXHRcdHJldHVybiBwYXRoO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW1wb3J0UGF0aChub2RlKSB7XG5cdFx0dmFyIGRhdGEgPSBub2RlLmdldEF0dHJpYnV0ZSgnZCcpLFxuXHRcdFx0cGFyYW0gPSB7IHBhdGhEYXRhOiBkYXRhIH07XG5cdFx0cmV0dXJuIChkYXRhLm1hdGNoKC9tL2dpKSB8fCBbXSkubGVuZ3RoID4gMSB8fCAvelxcUysvaS50ZXN0KGRhdGEpXG5cdFx0XHRcdD8gbmV3IENvbXBvdW5kUGF0aChwYXJhbSlcblx0XHRcdFx0OiBuZXcgUGF0aChwYXJhbSk7XG5cdH1cblxuXHRmdW5jdGlvbiBpbXBvcnRHcmFkaWVudChub2RlLCB0eXBlKSB7XG5cdFx0dmFyIGlkID0gKGdldFZhbHVlKG5vZGUsICdocmVmJywgdHJ1ZSkgfHwgJycpLnN1YnN0cmluZygxKSxcblx0XHRcdGlzUmFkaWFsID0gdHlwZSA9PT0gJ3JhZGlhbGdyYWRpZW50Jyxcblx0XHRcdGdyYWRpZW50O1xuXHRcdGlmIChpZCkge1xuXHRcdFx0Z3JhZGllbnQgPSBkZWZpbml0aW9uc1tpZF0uZ2V0R3JhZGllbnQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIG5vZGVzID0gbm9kZS5jaGlsZE5vZGVzLFxuXHRcdFx0XHRzdG9wcyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkID0gbm9kZXNbaV07XG5cdFx0XHRcdGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSlcblx0XHRcdFx0XHRzdG9wcy5wdXNoKGFwcGx5QXR0cmlidXRlcyhuZXcgR3JhZGllbnRTdG9wKCksIGNoaWxkKSk7XG5cdFx0XHR9XG5cdFx0XHRncmFkaWVudCA9IG5ldyBHcmFkaWVudChzdG9wcywgaXNSYWRpYWwpO1xuXHRcdH1cblx0XHR2YXIgb3JpZ2luLCBkZXN0aW5hdGlvbiwgaGlnaGxpZ2h0O1xuXHRcdGlmIChpc1JhZGlhbCkge1xuXHRcdFx0b3JpZ2luID0gZ2V0UG9pbnQobm9kZSwgJ2N4JywgJ2N5Jyk7XG5cdFx0XHRkZXN0aW5hdGlvbiA9IG9yaWdpbi5hZGQoZ2V0VmFsdWUobm9kZSwgJ3InKSwgMCk7XG5cdFx0XHRoaWdobGlnaHQgPSBnZXRQb2ludChub2RlLCAnZngnLCAnZnknLCB0cnVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b3JpZ2luID0gZ2V0UG9pbnQobm9kZSwgJ3gxJywgJ3kxJyk7XG5cdFx0XHRkZXN0aW5hdGlvbiA9IGdldFBvaW50KG5vZGUsICd4MicsICd5MicpO1xuXHRcdH1cblx0XHRhcHBseUF0dHJpYnV0ZXMoXG5cdFx0XHRuZXcgQ29sb3IoZ3JhZGllbnQsIG9yaWdpbiwgZGVzdGluYXRpb24sIGhpZ2hsaWdodCksIG5vZGUpO1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0dmFyIGltcG9ydGVycyA9IHtcblx0XHQnI2RvY3VtZW50JzogZnVuY3Rpb24gKG5vZGUsIHR5cGUsIG9wdGlvbnMsIGlzUm9vdCkge1xuXHRcdFx0dmFyIG5vZGVzID0gbm9kZS5jaGlsZE5vZGVzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkID0gbm9kZXNbaV07XG5cdFx0XHRcdGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSkge1xuXHRcdFx0XHRcdHZhciBuZXh0ID0gY2hpbGQubmV4dFNpYmxpbmc7XG5cdFx0XHRcdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjaGlsZCk7XG5cdFx0XHRcdFx0dmFyIGl0ZW0gPSBpbXBvcnRTVkcoY2hpbGQsIG9wdGlvbnMsIGlzUm9vdCk7XG5cdFx0XHRcdFx0aWYgKG5leHQpIHtcblx0XHRcdFx0XHRcdG5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkLCBuZXh0KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBpdGVtO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRnOiBpbXBvcnRHcm91cCxcblx0XHRzdmc6IGltcG9ydEdyb3VwLFxuXHRcdGNsaXBwYXRoOiBpbXBvcnRHcm91cCxcblx0XHRwb2x5Z29uOiBpbXBvcnRQb2x5LFxuXHRcdHBvbHlsaW5lOiBpbXBvcnRQb2x5LFxuXHRcdHBhdGg6IGltcG9ydFBhdGgsXG5cdFx0bGluZWFyZ3JhZGllbnQ6IGltcG9ydEdyYWRpZW50LFxuXHRcdHJhZGlhbGdyYWRpZW50OiBpbXBvcnRHcmFkaWVudCxcblxuXHRcdGltYWdlOiBmdW5jdGlvbiAobm9kZSkge1xuXHRcdFx0dmFyIHJhc3RlciA9IG5ldyBSYXN0ZXIoZ2V0VmFsdWUobm9kZSwgJ2hyZWYnLCB0cnVlKSk7XG5cdFx0XHRyYXN0ZXIub24oJ2xvYWQnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHNpemUgPSBnZXRTaXplKG5vZGUsICd3aWR0aCcsICdoZWlnaHQnKTtcblx0XHRcdFx0dGhpcy5zZXRTaXplKHNpemUpO1xuXHRcdFx0XHR2YXIgY2VudGVyID0gdGhpcy5fbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChcblx0XHRcdFx0XHRcdGdldFBvaW50KG5vZGUsICd4JywgJ3knKS5hZGQoc2l6ZS5kaXZpZGUoMikpKTtcblx0XHRcdFx0dGhpcy50cmFuc2xhdGUoY2VudGVyKTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHJhc3Rlcjtcblx0XHR9LFxuXG5cdFx0c3ltYm9sOiBmdW5jdGlvbihub2RlLCB0eXBlLCBvcHRpb25zLCBpc1Jvb3QpIHtcblx0XHRcdHJldHVybiBuZXcgU3ltYm9sKGltcG9ydEdyb3VwKG5vZGUsIHR5cGUsIG9wdGlvbnMsIGlzUm9vdCksIHRydWUpO1xuXHRcdH0sXG5cblx0XHRkZWZzOiBpbXBvcnRHcm91cCxcblxuXHRcdHVzZTogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0dmFyIGlkID0gKGdldFZhbHVlKG5vZGUsICdocmVmJywgdHJ1ZSkgfHwgJycpLnN1YnN0cmluZygxKSxcblx0XHRcdFx0ZGVmaW5pdGlvbiA9IGRlZmluaXRpb25zW2lkXSxcblx0XHRcdFx0cG9pbnQgPSBnZXRQb2ludChub2RlLCAneCcsICd5Jyk7XG5cdFx0XHRyZXR1cm4gZGVmaW5pdGlvblxuXHRcdFx0XHRcdD8gZGVmaW5pdGlvbiBpbnN0YW5jZW9mIFN5bWJvbFxuXHRcdFx0XHRcdFx0PyBkZWZpbml0aW9uLnBsYWNlKHBvaW50KVxuXHRcdFx0XHRcdFx0OiBkZWZpbml0aW9uLmNsb25lKCkudHJhbnNsYXRlKHBvaW50KVxuXHRcdFx0XHRcdDogbnVsbDtcblx0XHR9LFxuXG5cdFx0Y2lyY2xlOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNoYXBlLkNpcmNsZShnZXRQb2ludChub2RlLCAnY3gnLCAnY3knKSxcblx0XHRcdFx0XHRnZXRWYWx1ZShub2RlLCAncicpKTtcblx0XHR9LFxuXG5cdFx0ZWxsaXBzZTogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0cmV0dXJuIG5ldyBTaGFwZS5FbGxpcHNlKHtcblx0XHRcdFx0Y2VudGVyOiBnZXRQb2ludChub2RlLCAnY3gnLCAnY3knKSxcblx0XHRcdFx0cmFkaXVzOiBnZXRTaXplKG5vZGUsICdyeCcsICdyeScpXG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0cmVjdDogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0dmFyIHBvaW50ID0gZ2V0UG9pbnQobm9kZSwgJ3gnLCAneScpLFxuXHRcdFx0XHRzaXplID0gZ2V0U2l6ZShub2RlLCAnd2lkdGgnLCAnaGVpZ2h0JyksXG5cdFx0XHRcdHJhZGl1cyA9IGdldFNpemUobm9kZSwgJ3J4JywgJ3J5Jyk7XG5cdFx0XHRyZXR1cm4gbmV3IFNoYXBlLlJlY3RhbmdsZShuZXcgUmVjdGFuZ2xlKHBvaW50LCBzaXplKSwgcmFkaXVzKTtcblx0XHR9LFxuXG5cdFx0bGluZTogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0cmV0dXJuIG5ldyBQYXRoLkxpbmUoZ2V0UG9pbnQobm9kZSwgJ3gxJywgJ3kxJyksXG5cdFx0XHRcdFx0Z2V0UG9pbnQobm9kZSwgJ3gyJywgJ3kyJykpO1xuXHRcdH0sXG5cblx0XHR0ZXh0OiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHR2YXIgdGV4dCA9IG5ldyBQb2ludFRleHQoZ2V0UG9pbnQobm9kZSwgJ3gnLCAneScpXG5cdFx0XHRcdFx0LmFkZChnZXRQb2ludChub2RlLCAnZHgnLCAnZHknKSkpO1xuXHRcdFx0dGV4dC5zZXRDb250ZW50KG5vZGUudGV4dENvbnRlbnQudHJpbSgpIHx8ICcnKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiBhcHBseVRyYW5zZm9ybShpdGVtLCB2YWx1ZSwgbmFtZSwgbm9kZSkge1xuXHRcdHZhciB0cmFuc2Zvcm1zID0gKG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpIHx8ICcnKS5zcGxpdCgvXFwpXFxzKi9nKSxcblx0XHRcdG1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRyYW5zZm9ybXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgdHJhbnNmb3JtID0gdHJhbnNmb3Jtc1tpXTtcblx0XHRcdGlmICghdHJhbnNmb3JtKVxuXHRcdFx0XHRicmVhaztcblx0XHRcdHZhciBwYXJ0cyA9IHRyYW5zZm9ybS5zcGxpdCgvXFwoXFxzKi8pLFxuXHRcdFx0XHRjb21tYW5kID0gcGFydHNbMF0sXG5cdFx0XHRcdHYgPSBwYXJ0c1sxXS5zcGxpdCgvW1xccyxdKy9nKTtcblx0XHRcdGZvciAodmFyIGogPSAwLCBtID0gdi5sZW5ndGg7IGogPCBtOyBqKyspXG5cdFx0XHRcdHZbal0gPSBwYXJzZUZsb2F0KHZbal0pO1xuXHRcdFx0c3dpdGNoIChjb21tYW5kKSB7XG5cdFx0XHRjYXNlICdtYXRyaXgnOlxuXHRcdFx0XHRtYXRyaXguY29uY2F0ZW5hdGUoXG5cdFx0XHRcdFx0XHRuZXcgTWF0cml4KHZbMF0sIHZbMV0sIHZbMl0sIHZbM10sIHZbNF0sIHZbNV0pKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdyb3RhdGUnOlxuXHRcdFx0XHRtYXRyaXgucm90YXRlKHZbMF0sIHZbMV0sIHZbMl0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3RyYW5zbGF0ZSc6XG5cdFx0XHRcdG1hdHJpeC50cmFuc2xhdGUodlswXSwgdlsxXSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnc2NhbGUnOlxuXHRcdFx0XHRtYXRyaXguc2NhbGUodik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnc2tld1gnOlxuXHRcdFx0XHRtYXRyaXguc2tldyh2WzBdLCAwKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdza2V3WSc6XG5cdFx0XHRcdG1hdHJpeC5za2V3KDAsIHZbMF0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0aXRlbS50cmFuc2Zvcm0obWF0cml4KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFwcGx5T3BhY2l0eShpdGVtLCB2YWx1ZSwgbmFtZSkge1xuXHRcdHZhciBjb2xvciA9IGl0ZW1bbmFtZSA9PT0gJ2ZpbGwtb3BhY2l0eScgPyAnZ2V0RmlsbENvbG9yJ1xuXHRcdFx0XHQ6ICdnZXRTdHJva2VDb2xvciddKCk7XG5cdFx0aWYgKGNvbG9yKVxuXHRcdFx0Y29sb3Iuc2V0QWxwaGEocGFyc2VGbG9hdCh2YWx1ZSkpO1xuXHR9XG5cblx0dmFyIGF0dHJpYnV0ZXMgPSBCYXNlLnNldChCYXNlLmVhY2goU1ZHU3R5bGVzLCBmdW5jdGlvbihlbnRyeSkge1xuXHRcdHRoaXNbZW50cnkuYXR0cmlidXRlXSA9IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRpdGVtW2VudHJ5LnNldF0oY29udmVydFZhbHVlKHZhbHVlLCBlbnRyeS50eXBlLCBlbnRyeS5mcm9tU1ZHKSk7XG5cdFx0XHRpZiAoZW50cnkudHlwZSA9PT0gJ2NvbG9yJyAmJiBpdGVtIGluc3RhbmNlb2YgU2hhcGUpIHtcblx0XHRcdFx0dmFyIGNvbG9yID0gaXRlbVtlbnRyeS5nZXRdKCk7XG5cdFx0XHRcdGlmIChjb2xvcilcblx0XHRcdFx0XHRjb2xvci50cmFuc2Zvcm0obmV3IE1hdHJpeCgpLnRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdFx0aXRlbS5nZXRQb3NpdGlvbih0cnVlKS5uZWdhdGUoKSkpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0sIHt9KSwge1xuXHRcdGlkOiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0ZGVmaW5pdGlvbnNbdmFsdWVdID0gaXRlbTtcblx0XHRcdGlmIChpdGVtLnNldE5hbWUpXG5cdFx0XHRcdGl0ZW0uc2V0TmFtZSh2YWx1ZSk7XG5cdFx0fSxcblxuXHRcdCdjbGlwLXBhdGgnOiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0dmFyIGNsaXAgPSBnZXREZWZpbml0aW9uKHZhbHVlKTtcblx0XHRcdGlmIChjbGlwKSB7XG5cdFx0XHRcdGNsaXAgPSBjbGlwLmNsb25lKCk7XG5cdFx0XHRcdGNsaXAuc2V0Q2xpcE1hc2sodHJ1ZSk7XG5cdFx0XHRcdGlmIChpdGVtIGluc3RhbmNlb2YgR3JvdXApIHtcblx0XHRcdFx0XHRpdGVtLmluc2VydENoaWxkKDAsIGNsaXApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgR3JvdXAoY2xpcCwgaXRlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Z3JhZGllbnRUcmFuc2Zvcm06IGFwcGx5VHJhbnNmb3JtLFxuXHRcdHRyYW5zZm9ybTogYXBwbHlUcmFuc2Zvcm0sXG5cblx0XHQnZmlsbC1vcGFjaXR5JzogYXBwbHlPcGFjaXR5LFxuXHRcdCdzdHJva2Utb3BhY2l0eSc6IGFwcGx5T3BhY2l0eSxcblxuXHRcdHZpc2liaWxpdHk6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRpdGVtLnNldFZpc2libGUodmFsdWUgPT09ICd2aXNpYmxlJyk7XG5cdFx0fSxcblxuXHRcdGRpc3BsYXk6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRpdGVtLnNldFZpc2libGUodmFsdWUgIT09IG51bGwpO1xuXHRcdH0sXG5cblx0XHQnc3RvcC1jb2xvcic6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRpZiAoaXRlbS5zZXRDb2xvcilcblx0XHRcdFx0aXRlbS5zZXRDb2xvcih2YWx1ZSk7XG5cdFx0fSxcblxuXHRcdCdzdG9wLW9wYWNpdHknOiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0aWYgKGl0ZW0uX2NvbG9yKVxuXHRcdFx0XHRpdGVtLl9jb2xvci5zZXRBbHBoYShwYXJzZUZsb2F0KHZhbHVlKSk7XG5cdFx0fSxcblxuXHRcdG9mZnNldDogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdHZhciBwZXJjZW50YWdlID0gdmFsdWUubWF0Y2goLyguKiklJC8pO1xuXHRcdFx0aXRlbS5zZXRSYW1wUG9pbnQocGVyY2VudGFnZVxuXHRcdFx0XHRcdD8gcGVyY2VudGFnZVsxXSAvIDEwMFxuXHRcdFx0XHRcdDogcGFyc2VGbG9hdCh2YWx1ZSkpO1xuXHRcdH0sXG5cblx0XHR2aWV3Qm94OiBmdW5jdGlvbihpdGVtLCB2YWx1ZSwgbmFtZSwgbm9kZSwgc3R5bGVzKSB7XG5cdFx0XHR2YXIgcmVjdCA9IG5ldyBSZWN0YW5nbGUoY29udmVydFZhbHVlKHZhbHVlLCAnYXJyYXknKSksXG5cdFx0XHRcdHNpemUgPSBnZXRTaXplKG5vZGUsICd3aWR0aCcsICdoZWlnaHQnLCB0cnVlKTtcblx0XHRcdGlmIChpdGVtIGluc3RhbmNlb2YgR3JvdXApIHtcblx0XHRcdFx0dmFyIHNjYWxlID0gc2l6ZSA/IHJlY3QuZ2V0U2l6ZSgpLmRpdmlkZShzaXplKSA6IDEsXG5cdFx0XHRcdFx0bWF0cml4ID0gbmV3IE1hdHJpeCgpLnRyYW5zbGF0ZShyZWN0LmdldFBvaW50KCkpLnNjYWxlKHNjYWxlKTtcblx0XHRcdFx0aXRlbS50cmFuc2Zvcm0obWF0cml4LmludmVydGVkKCkpO1xuXHRcdFx0fSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgU3ltYm9sKSB7XG5cdFx0XHRcdGlmIChzaXplKVxuXHRcdFx0XHRcdHJlY3Quc2V0U2l6ZShzaXplKTtcblx0XHRcdFx0dmFyIGNsaXAgPSBnZXRBdHRyaWJ1dGUobm9kZSwgJ292ZXJmbG93Jywgc3R5bGVzKSAhPSAndmlzaWJsZScsXG5cdFx0XHRcdFx0Z3JvdXAgPSBpdGVtLl9kZWZpbml0aW9uO1xuXHRcdFx0XHRpZiAoY2xpcCAmJiAhcmVjdC5jb250YWlucyhncm91cC5nZXRCb3VuZHMoKSkpIHtcblx0XHRcdFx0XHRjbGlwID0gbmV3IFNoYXBlLlJlY3RhbmdsZShyZWN0KS50cmFuc2Zvcm0oZ3JvdXAuX21hdHJpeCk7XG5cdFx0XHRcdFx0Y2xpcC5zZXRDbGlwTWFzayh0cnVlKTtcblx0XHRcdFx0XHRncm91cC5hZGRDaGlsZChjbGlwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0ZnVuY3Rpb24gZ2V0QXR0cmlidXRlKG5vZGUsIG5hbWUsIHN0eWxlcykge1xuXHRcdHZhciBhdHRyID0gbm9kZS5hdHRyaWJ1dGVzW25hbWVdLFxuXHRcdFx0dmFsdWUgPSBhdHRyICYmIGF0dHIudmFsdWU7XG5cdFx0aWYgKCF2YWx1ZSkge1xuXHRcdFx0dmFyIHN0eWxlID0gQmFzZS5jYW1lbGl6ZShuYW1lKTtcblx0XHRcdHZhbHVlID0gbm9kZS5zdHlsZVtzdHlsZV07XG5cdFx0XHRpZiAoIXZhbHVlICYmIHN0eWxlcy5ub2RlW3N0eWxlXSAhPT0gc3R5bGVzLnBhcmVudFtzdHlsZV0pXG5cdFx0XHRcdHZhbHVlID0gc3R5bGVzLm5vZGVbc3R5bGVdO1xuXHRcdH1cblx0XHRyZXR1cm4gIXZhbHVlXG5cdFx0XHRcdD8gdW5kZWZpbmVkXG5cdFx0XHRcdDogdmFsdWUgPT09ICdub25lJ1xuXHRcdFx0XHRcdD8gbnVsbFxuXHRcdFx0XHRcdDogdmFsdWU7XG5cdH1cblxuXHRmdW5jdGlvbiBhcHBseUF0dHJpYnV0ZXMoaXRlbSwgbm9kZSwgaXNSb290KSB7XG5cdFx0dmFyIHN0eWxlcyA9IHtcblx0XHRcdG5vZGU6IERvbUVsZW1lbnQuZ2V0U3R5bGVzKG5vZGUpIHx8IHt9LFxuXHRcdFx0cGFyZW50OiAhaXNSb290ICYmIERvbUVsZW1lbnQuZ2V0U3R5bGVzKG5vZGUucGFyZW50Tm9kZSkgfHwge31cblx0XHR9O1xuXHRcdEJhc2UuZWFjaChhdHRyaWJ1dGVzLCBmdW5jdGlvbihhcHBseSwgbmFtZSkge1xuXHRcdFx0dmFyIHZhbHVlID0gZ2V0QXR0cmlidXRlKG5vZGUsIG5hbWUsIHN0eWxlcyk7XG5cdFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcblx0XHRcdFx0aXRlbSA9IEJhc2UucGljayhhcHBseShpdGVtLCB2YWx1ZSwgbmFtZSwgbm9kZSwgc3R5bGVzKSwgaXRlbSk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIGl0ZW07XG5cdH1cblxuXHR2YXIgZGVmaW5pdGlvbnMgPSB7fTtcblx0ZnVuY3Rpb24gZ2V0RGVmaW5pdGlvbih2YWx1ZSkge1xuXHRcdHZhciBtYXRjaCA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKC9cXCgoPzojfCkoW14pJ10rKS8pO1xuXHRcdHJldHVybiBtYXRjaCAmJiBkZWZpbml0aW9uc1ttYXRjaFsxXV07XG5cdH1cblxuXHRmdW5jdGlvbiBpbXBvcnRTVkcoc291cmNlLCBvcHRpb25zLCBpc1Jvb3QpIHtcblx0XHRpZiAoIXNvdXJjZSlcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdGlmICghb3B0aW9ucykge1xuXHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdG9wdGlvbnMgPSB7IG9uTG9hZDogb3B0aW9ucyB9O1xuXHRcdH1cblxuXHRcdHZhciBub2RlID0gc291cmNlLFxuXHRcdFx0c2NvcGUgPSBwYXBlcjtcblxuXHRcdGZ1bmN0aW9uIG9uTG9hZENhbGxiYWNrKHN2Zykge1xuXHRcdFx0cGFwZXIgPSBzY29wZTtcblx0XHRcdHZhciBpdGVtID0gaW1wb3J0U1ZHKHN2Zywgb3B0aW9ucywgaXNSb290KSxcblx0XHRcdFx0b25Mb2FkID0gb3B0aW9ucy5vbkxvYWQsXG5cdFx0XHRcdHZpZXcgPSBzY29wZS5wcm9qZWN0ICYmIHNjb3BlLmdldFZpZXcoKTtcblx0XHRcdGlmIChvbkxvYWQpXG5cdFx0XHRcdG9uTG9hZC5jYWxsKHRoaXMsIGl0ZW0pO1xuXHRcdFx0dmlldy51cGRhdGUoKTtcblx0XHR9XG5cblx0XHRpZiAoaXNSb290KSB7XG5cdFx0XHRpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgJiYgIS9eLio8Ly50ZXN0KHNvdXJjZSkpIHtcblx0XHRcdFx0bm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNvdXJjZSk7XG5cdFx0XHRcdGlmIChub2RlKSB7XG5cdFx0XHRcdFx0c291cmNlID0gbnVsbDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gSHR0cC5yZXF1ZXN0KCdnZXQnLCBzb3VyY2UsIG9uTG9hZENhbGxiYWNrKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgRmlsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgc291cmNlIGluc3RhbmNlb2YgRmlsZSkge1xuXHRcdFx0XHR2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblx0XHRcdFx0cmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdG9uTG9hZENhbGxiYWNrKHJlYWRlci5yZXN1bHQpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gcmVhZGVyLnJlYWRBc1RleHQoc291cmNlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpXG5cdFx0XHRub2RlID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhzb3VyY2UsICdpbWFnZS9zdmcreG1sJyk7XG5cdFx0aWYgKCFub2RlLm5vZGVOYW1lKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBTVkcgc291cmNlOiAnICsgc291cmNlKTtcblx0XHR2YXIgdHlwZSA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdGltcG9ydGVyID0gaW1wb3J0ZXJzW3R5cGVdLFxuXHRcdFx0aXRlbSxcblx0XHRcdGRhdGEgPSBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1wYXBlci1kYXRhJyksXG5cdFx0XHRzZXR0aW5ncyA9IHNjb3BlLnNldHRpbmdzLFxuXHRcdFx0YXBwbHlNYXRyaXggPSBzZXR0aW5ncy5hcHBseU1hdHJpeDtcblx0XHRzZXR0aW5ncy5hcHBseU1hdHJpeCA9IGZhbHNlO1xuXHRcdGl0ZW0gPSBpbXBvcnRlciAmJiBpbXBvcnRlcihub2RlLCB0eXBlLCBvcHRpb25zLCBpc1Jvb3QpIHx8IG51bGw7XG5cdFx0c2V0dGluZ3MuYXBwbHlNYXRyaXggPSBhcHBseU1hdHJpeDtcblx0XHRpZiAoaXRlbSkge1xuXHRcdFx0aWYgKHR5cGUgIT09ICcjZG9jdW1lbnQnICYmICEoaXRlbSBpbnN0YW5jZW9mIEdyb3VwKSlcblx0XHRcdFx0aXRlbSA9IGFwcGx5QXR0cmlidXRlcyhpdGVtLCBub2RlLCBpc1Jvb3QpO1xuXHRcdFx0dmFyIG9uSW1wb3J0ID0gb3B0aW9ucy5vbkltcG9ydDtcblx0XHRcdGlmIChvbkltcG9ydClcblx0XHRcdFx0aXRlbSA9IG9uSW1wb3J0KG5vZGUsIGl0ZW0sIG9wdGlvbnMpIHx8IGl0ZW07XG5cdFx0XHRpZiAob3B0aW9ucy5leHBhbmRTaGFwZXMgJiYgaXRlbSBpbnN0YW5jZW9mIFNoYXBlKSB7XG5cdFx0XHRcdGl0ZW0ucmVtb3ZlKCk7XG5cdFx0XHRcdGl0ZW0gPSBpdGVtLnRvUGF0aCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGRhdGEpXG5cdFx0XHRcdGl0ZW0uX2RhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuXHRcdH1cblx0XHRpZiAoaXNSb290KSB7XG5cdFx0XHRkZWZpbml0aW9ucyA9IHt9O1xuXHRcdFx0aWYgKGl0ZW0gJiYgQmFzZS5waWNrKG9wdGlvbnMuYXBwbHlNYXRyaXgsIGFwcGx5TWF0cml4KSlcblx0XHRcdFx0aXRlbS5tYXRyaXguYXBwbHkodHJ1ZSwgdHJ1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiBpdGVtO1xuXHR9XG5cblx0SXRlbS5pbmplY3Qoe1xuXHRcdGltcG9ydFNWRzogZnVuY3Rpb24obm9kZSwgb3B0aW9ucykge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkQ2hpbGQoaW1wb3J0U1ZHKG5vZGUsIG9wdGlvbnMsIHRydWUpKTtcblx0XHR9XG5cdH0pO1xuXG5cdFByb2plY3QuaW5qZWN0KHtcblx0XHRpbXBvcnRTVkc6IGZ1bmN0aW9uKG5vZGUsIG9wdGlvbnMpIHtcblx0XHRcdHRoaXMuYWN0aXZhdGUoKTtcblx0XHRcdHJldHVybiBpbXBvcnRTVkcobm9kZSwgb3B0aW9ucywgdHJ1ZSk7XG5cdFx0fVxuXHR9KTtcbn07XG5cbkJhc2UuZXhwb3J0cy5QYXBlclNjcmlwdCA9IChmdW5jdGlvbigpIHtcblx0dmFyIGV4cG9ydHMsIGRlZmluZSxcblx0XHRzY29wZSA9IHRoaXM7XG4hZnVuY3Rpb24oZSxyKXtyZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9yKGV4cG9ydHMpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wiZXhwb3J0c1wiXSxyKToocihlLmFjb3JufHwoZS5hY29ybj17fSkpLHZvaWQgMCl9KHRoaXMsZnVuY3Rpb24oZSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtmcj1lfHx7fTtmb3IodmFyIHIgaW4gbXIpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZyLHIpfHwoZnJbcl09bXJbcl0pO2hyPWZyLnNvdXJjZUZpbGV8fG51bGx9ZnVuY3Rpb24gdChlLHIpe3ZhciB0PXZyKGRyLGUpO3IrPVwiIChcIit0LmxpbmUrXCI6XCIrdC5jb2x1bW4rXCIpXCI7dmFyIG49bmV3IFN5bnRheEVycm9yKHIpO3Rocm93IG4ucG9zPWUsbi5sb2M9dCxuLnJhaXNlZEF0PWJyLG59ZnVuY3Rpb24gbihlKXtmdW5jdGlvbiByKGUpe2lmKDE9PWUubGVuZ3RoKXJldHVybiB0Kz1cInJldHVybiBzdHIgPT09IFwiK0pTT04uc3RyaW5naWZ5KGVbMF0pK1wiO1wiO3QrPVwic3dpdGNoKHN0cil7XCI7Zm9yKHZhciByPTA7cjxlLmxlbmd0aDsrK3IpdCs9XCJjYXNlIFwiK0pTT04uc3RyaW5naWZ5KGVbcl0pK1wiOlwiO3QrPVwicmV0dXJuIHRydWV9cmV0dXJuIGZhbHNlO1wifWU9ZS5zcGxpdChcIiBcIik7dmFyIHQ9XCJcIixuPVtdO2U6Zm9yKHZhciBhPTA7YTxlLmxlbmd0aDsrK2Epe2Zvcih2YXIgbz0wO288bi5sZW5ndGg7KytvKWlmKG5bb11bMF0ubGVuZ3RoPT1lW2FdLmxlbmd0aCl7bltvXS5wdXNoKGVbYV0pO2NvbnRpbnVlIGV9bi5wdXNoKFtlW2FdXSl9aWYobi5sZW5ndGg+Myl7bi5zb3J0KGZ1bmN0aW9uKGUscil7cmV0dXJuIHIubGVuZ3RoLWUubGVuZ3RofSksdCs9XCJzd2l0Y2goc3RyLmxlbmd0aCl7XCI7Zm9yKHZhciBhPTA7YTxuLmxlbmd0aDsrK2Epe3ZhciBpPW5bYV07dCs9XCJjYXNlIFwiK2lbMF0ubGVuZ3RoK1wiOlwiLHIoaSl9dCs9XCJ9XCJ9ZWxzZSByKGUpO3JldHVybiBuZXcgRnVuY3Rpb24oXCJzdHJcIix0KX1mdW5jdGlvbiBhKCl7dGhpcy5saW5lPUFyLHRoaXMuY29sdW1uPWJyLVNyfWZ1bmN0aW9uIG8oKXtBcj0xLGJyPVNyPTAsRXI9ITAsdSgpfWZ1bmN0aW9uIGkoZSxyKXtncj1icixmci5sb2NhdGlvbnMmJihrcj1uZXcgYSksd3I9ZSx1KCksQ3I9cixFcj1lLmJlZm9yZUV4cHJ9ZnVuY3Rpb24gcygpe3ZhciBlPWZyLm9uQ29tbWVudCYmZnIubG9jYXRpb25zJiZuZXcgYSxyPWJyLG49ZHIuaW5kZXhPZihcIiovXCIsYnIrPTIpO2lmKC0xPT09biYmdChici0yLFwiVW50ZXJtaW5hdGVkIGNvbW1lbnRcIiksYnI9bisyLGZyLmxvY2F0aW9ucyl7S3QubGFzdEluZGV4PXI7Zm9yKHZhciBvOyhvPUt0LmV4ZWMoZHIpKSYmby5pbmRleDxicjspKytBcixTcj1vLmluZGV4K29bMF0ubGVuZ3RofWZyLm9uQ29tbWVudCYmZnIub25Db21tZW50KCEwLGRyLnNsaWNlKHIrMixuKSxyLGJyLGUsZnIubG9jYXRpb25zJiZuZXcgYSl9ZnVuY3Rpb24gYygpe2Zvcih2YXIgZT1icixyPWZyLm9uQ29tbWVudCYmZnIubG9jYXRpb25zJiZuZXcgYSx0PWRyLmNoYXJDb2RlQXQoYnIrPTIpO3ByPmJyJiYxMCE9PXQmJjEzIT09dCYmODIzMiE9PXQmJjgyMzMhPT10OykrK2JyLHQ9ZHIuY2hhckNvZGVBdChicik7ZnIub25Db21tZW50JiZmci5vbkNvbW1lbnQoITEsZHIuc2xpY2UoZSsyLGJyKSxlLGJyLHIsZnIubG9jYXRpb25zJiZuZXcgYSl9ZnVuY3Rpb24gdSgpe2Zvcig7cHI+YnI7KXt2YXIgZT1kci5jaGFyQ29kZUF0KGJyKTtpZigzMj09PWUpKyticjtlbHNlIGlmKDEzPT09ZSl7Kyticjt2YXIgcj1kci5jaGFyQ29kZUF0KGJyKTsxMD09PXImJisrYnIsZnIubG9jYXRpb25zJiYoKytBcixTcj1icil9ZWxzZSBpZigxMD09PWV8fDgyMzI9PT1lfHw4MjMzPT09ZSkrK2JyLGZyLmxvY2F0aW9ucyYmKCsrQXIsU3I9YnIpO2Vsc2UgaWYoZT44JiYxND5lKSsrYnI7ZWxzZSBpZig0Nz09PWUpe3ZhciByPWRyLmNoYXJDb2RlQXQoYnIrMSk7aWYoNDI9PT1yKXMoKTtlbHNle2lmKDQ3IT09cilicmVhaztjKCl9fWVsc2UgaWYoMTYwPT09ZSkrK2JyO2Vsc2V7aWYoIShlPj01NzYwJiZKdC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoZSkpKSlicmVhazsrK2JyfX19ZnVuY3Rpb24gbCgpe3ZhciBlPWRyLmNoYXJDb2RlQXQoYnIrMSk7cmV0dXJuIGU+PTQ4JiY1Nz49ZT9FKCEwKTooKyticixpKHh0KSl9ZnVuY3Rpb24gZigpe3ZhciBlPWRyLmNoYXJDb2RlQXQoYnIrMSk7cmV0dXJuIEVyPygrK2JyLGsoKSk6NjE9PT1lP3goRXQsMik6eCh3dCwxKX1mdW5jdGlvbiBkKCl7dmFyIGU9ZHIuY2hhckNvZGVBdChicisxKTtyZXR1cm4gNjE9PT1lP3goRXQsMik6eChEdCwxKX1mdW5jdGlvbiBwKGUpe3ZhciByPWRyLmNoYXJDb2RlQXQoYnIrMSk7cmV0dXJuIHI9PT1lP3goMTI0PT09ZT9MdDpVdCwyKTo2MT09PXI/eChFdCwyKTp4KDEyND09PWU/UnQ6VHQsMSl9ZnVuY3Rpb24gaCgpe3ZhciBlPWRyLmNoYXJDb2RlQXQoYnIrMSk7cmV0dXJuIDYxPT09ZT94KEV0LDIpOngoVnQsMSl9ZnVuY3Rpb24gbShlKXt2YXIgcj1kci5jaGFyQ29kZUF0KGJyKzEpO3JldHVybiByPT09ZT80NT09ciYmNjI9PWRyLmNoYXJDb2RlQXQoYnIrMikmJkd0LnRlc3QoZHIuc2xpY2UoTHIsYnIpKT8oYnIrPTMsYygpLHUoKSxnKCkpOngoU3QsMik6NjE9PT1yP3goRXQsMik6eChBdCwxKX1mdW5jdGlvbiB2KGUpe3ZhciByPWRyLmNoYXJDb2RlQXQoYnIrMSksdD0xO3JldHVybiByPT09ZT8odD02Mj09PWUmJjYyPT09ZHIuY2hhckNvZGVBdChicisyKT8zOjIsNjE9PT1kci5jaGFyQ29kZUF0KGJyK3QpP3goRXQsdCsxKTp4KGp0LHQpKTozMz09ciYmNjA9PWUmJjQ1PT1kci5jaGFyQ29kZUF0KGJyKzIpJiY0NT09ZHIuY2hhckNvZGVBdChiciszKT8oYnIrPTQsYygpLHUoKSxnKCkpOig2MT09PXImJih0PTYxPT09ZHIuY2hhckNvZGVBdChicisyKT8zOjIpLHgoT3QsdCkpfWZ1bmN0aW9uIGIoZSl7dmFyIHI9ZHIuY2hhckNvZGVBdChicisxKTtyZXR1cm4gNjE9PT1yP3gocXQsNjE9PT1kci5jaGFyQ29kZUF0KGJyKzIpPzM6Mik6eCg2MT09PWU/Q3Q6SXQsMSl9ZnVuY3Rpb24geShlKXtzd2l0Y2goZSl7Y2FzZSA0NjpyZXR1cm4gbCgpO2Nhc2UgNDA6cmV0dXJuKyticixpKG10KTtjYXNlIDQxOnJldHVybisrYnIsaSh2dCk7Y2FzZSA1OTpyZXR1cm4rK2JyLGkoeXQpO2Nhc2UgNDQ6cmV0dXJuKyticixpKGJ0KTtjYXNlIDkxOnJldHVybisrYnIsaShmdCk7Y2FzZSA5MzpyZXR1cm4rK2JyLGkoZHQpO2Nhc2UgMTIzOnJldHVybisrYnIsaShwdCk7Y2FzZSAxMjU6cmV0dXJuKyticixpKGh0KTtjYXNlIDU4OnJldHVybisrYnIsaShndCk7Y2FzZSA2MzpyZXR1cm4rK2JyLGkoa3QpO2Nhc2UgNDg6dmFyIHI9ZHIuY2hhckNvZGVBdChicisxKTtpZigxMjA9PT1yfHw4OD09PXIpcmV0dXJuIEMoKTtjYXNlIDQ5OmNhc2UgNTA6Y2FzZSA1MTpjYXNlIDUyOmNhc2UgNTM6Y2FzZSA1NDpjYXNlIDU1OmNhc2UgNTY6Y2FzZSA1NzpyZXR1cm4gRSghMSk7Y2FzZSAzNDpjYXNlIDM5OnJldHVybiBBKGUpO2Nhc2UgNDc6cmV0dXJuIGYoZSk7Y2FzZSAzNzpjYXNlIDQyOnJldHVybiBkKCk7Y2FzZSAxMjQ6Y2FzZSAzODpyZXR1cm4gcChlKTtjYXNlIDk0OnJldHVybiBoKCk7Y2FzZSA0MzpjYXNlIDQ1OnJldHVybiBtKGUpO2Nhc2UgNjA6Y2FzZSA2MjpyZXR1cm4gdihlKTtjYXNlIDYxOmNhc2UgMzM6cmV0dXJuIGIoZSk7Y2FzZSAxMjY6cmV0dXJuIHgoSXQsMSl9cmV0dXJuITF9ZnVuY3Rpb24gZyhlKXtpZihlP2JyPXlyKzE6eXI9YnIsZnIubG9jYXRpb25zJiYoeHI9bmV3IGEpLGUpcmV0dXJuIGsoKTtpZihicj49cHIpcmV0dXJuIGkoQnIpO3ZhciByPWRyLmNoYXJDb2RlQXQoYnIpO2lmKFF0KHIpfHw5Mj09PXIpcmV0dXJuIEwoKTt2YXIgbj15KHIpO2lmKG49PT0hMSl7dmFyIG89U3RyaW5nLmZyb21DaGFyQ29kZShyKTtpZihcIlxcXFxcIj09PW98fCR0LnRlc3QobykpcmV0dXJuIEwoKTt0KGJyLFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiK28rXCInXCIpfXJldHVybiBufWZ1bmN0aW9uIHgoZSxyKXt2YXIgdD1kci5zbGljZShicixicityKTticis9cixpKGUsdCl9ZnVuY3Rpb24gaygpe2Zvcih2YXIgZSxyLG49XCJcIixhPWJyOzspe2JyPj1wciYmdChhLFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTt2YXIgbz1kci5jaGFyQXQoYnIpO2lmKEd0LnRlc3QobykmJnQoYSxcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIiksZSllPSExO2Vsc2V7aWYoXCJbXCI9PT1vKXI9ITA7ZWxzZSBpZihcIl1cIj09PW8mJnIpcj0hMTtlbHNlIGlmKFwiL1wiPT09byYmIXIpYnJlYWs7ZT1cIlxcXFxcIj09PW99Kyticn12YXIgbj1kci5zbGljZShhLGJyKTsrK2JyO3ZhciBzPUkoKTtyZXR1cm4gcyYmIS9eW2dtc2l5XSokLy50ZXN0KHMpJiZ0KGEsXCJJbnZhbGlkIHJlZ2V4cCBmbGFnXCIpLGkoanIsbmV3IFJlZ0V4cChuLHMpKX1mdW5jdGlvbiB3KGUscil7Zm9yKHZhciB0PWJyLG49MCxhPTAsbz1udWxsPT1yPzEvMDpyO28+YTsrK2Epe3ZhciBpLHM9ZHIuY2hhckNvZGVBdChicik7aWYoaT1zPj05Nz9zLTk3KzEwOnM+PTY1P3MtNjUrMTA6cz49NDgmJjU3Pj1zP3MtNDg6MS8wLGk+PWUpYnJlYWs7KyticixuPW4qZStpfXJldHVybiBicj09PXR8fG51bGwhPXImJmJyLXQhPT1yP251bGw6bn1mdW5jdGlvbiBDKCl7YnIrPTI7dmFyIGU9dygxNik7cmV0dXJuIG51bGw9PWUmJnQoeXIrMixcIkV4cGVjdGVkIGhleGFkZWNpbWFsIG51bWJlclwiKSxRdChkci5jaGFyQ29kZUF0KGJyKSkmJnQoYnIsXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKSxpKE9yLGUpfWZ1bmN0aW9uIEUoZSl7dmFyIHI9YnIsbj0hMSxhPTQ4PT09ZHIuY2hhckNvZGVBdChicik7ZXx8bnVsbCE9PXcoMTApfHx0KHIsXCJJbnZhbGlkIG51bWJlclwiKSw0Nj09PWRyLmNoYXJDb2RlQXQoYnIpJiYoKyticix3KDEwKSxuPSEwKTt2YXIgbz1kci5jaGFyQ29kZUF0KGJyKTsoNjk9PT1vfHwxMDE9PT1vKSYmKG89ZHIuY2hhckNvZGVBdCgrK2JyKSwoNDM9PT1vfHw0NT09PW8pJiYrK2JyLG51bGw9PT13KDEwKSYmdChyLFwiSW52YWxpZCBudW1iZXJcIiksbj0hMCksUXQoZHIuY2hhckNvZGVBdChicikpJiZ0KGJyLFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7dmFyIHMsYz1kci5zbGljZShyLGJyKTtyZXR1cm4gbj9zPXBhcnNlRmxvYXQoYyk6YSYmMSE9PWMubGVuZ3RoPy9bODldLy50ZXN0KGMpfHxUcj90KHIsXCJJbnZhbGlkIG51bWJlclwiKTpzPXBhcnNlSW50KGMsOCk6cz1wYXJzZUludChjLDEwKSxpKE9yLHMpfWZ1bmN0aW9uIEEoZSl7YnIrKztmb3IodmFyIHI9XCJcIjs7KXticj49cHImJnQoeXIsXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpO3ZhciBuPWRyLmNoYXJDb2RlQXQoYnIpO2lmKG49PT1lKXJldHVybisrYnIsaShEcixyKTtpZig5Mj09PW4pe249ZHIuY2hhckNvZGVBdCgrK2JyKTt2YXIgYT0vXlswLTddKy8uZXhlYyhkci5zbGljZShicixiciszKSk7Zm9yKGEmJihhPWFbMF0pO2EmJnBhcnNlSW50KGEsOCk+MjU1OylhPWEuc2xpY2UoMCxhLmxlbmd0aC0xKTtpZihcIjBcIj09PWEmJihhPW51bGwpLCsrYnIsYSlUciYmdChici0yLFwiT2N0YWwgbGl0ZXJhbCBpbiBzdHJpY3QgbW9kZVwiKSxyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGEsOCkpLGJyKz1hLmxlbmd0aC0xO2Vsc2Ugc3dpdGNoKG4pe2Nhc2UgMTEwOnIrPVwiXFxuXCI7YnJlYWs7Y2FzZSAxMTQ6cis9XCJcXHJcIjticmVhaztjYXNlIDEyMDpyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKFMoMikpO2JyZWFrO2Nhc2UgMTE3OnIrPVN0cmluZy5mcm9tQ2hhckNvZGUoUyg0KSk7YnJlYWs7Y2FzZSA4NTpyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKFMoOCkpO2JyZWFrO2Nhc2UgMTE2OnIrPVwiXHRcIjticmVhaztjYXNlIDk4OnIrPVwiXFxiXCI7YnJlYWs7Y2FzZSAxMTg6cis9XCJcdTAwMGJcIjticmVhaztjYXNlIDEwMjpyKz1cIlxcZlwiO2JyZWFrO2Nhc2UgNDg6cis9XCJcXDBcIjticmVhaztjYXNlIDEzOjEwPT09ZHIuY2hhckNvZGVBdChicikmJisrYnI7Y2FzZSAxMDpmci5sb2NhdGlvbnMmJihTcj1iciwrK0FyKTticmVhaztkZWZhdWx0OnIrPVN0cmluZy5mcm9tQ2hhckNvZGUobil9fWVsc2UoMTM9PT1ufHwxMD09PW58fDgyMzI9PT1ufHw4MjMzPT09bikmJnQoeXIsXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpLHIrPVN0cmluZy5mcm9tQ2hhckNvZGUobiksKyticn19ZnVuY3Rpb24gUyhlKXt2YXIgcj13KDE2LGUpO3JldHVybiBudWxsPT09ciYmdCh5cixcIkJhZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlXCIpLHJ9ZnVuY3Rpb24gSSgpe0J0PSExO2Zvcih2YXIgZSxyPSEwLG49YnI7Oyl7dmFyIGE9ZHIuY2hhckNvZGVBdChicik7aWYoWXQoYSkpQnQmJihlKz1kci5jaGFyQXQoYnIpKSwrK2JyO2Vsc2V7aWYoOTIhPT1hKWJyZWFrO0J0fHwoZT1kci5zbGljZShuLGJyKSksQnQ9ITAsMTE3IT1kci5jaGFyQ29kZUF0KCsrYnIpJiZ0KGJyLFwiRXhwZWN0aW5nIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlIFxcXFx1WFhYWFwiKSwrK2JyO3ZhciBvPVMoNCksaT1TdHJpbmcuZnJvbUNoYXJDb2RlKG8pO2l8fHQoYnItMSxcIkludmFsaWQgVW5pY29kZSBlc2NhcGVcIiksKHI/UXQobyk6WXQobykpfHx0KGJyLTQsXCJJbnZhbGlkIFVuaWNvZGUgZXNjYXBlXCIpLGUrPWl9cj0hMX1yZXR1cm4gQnQ/ZTpkci5zbGljZShuLGJyKX1mdW5jdGlvbiBMKCl7dmFyIGU9SSgpLHI9RnI7cmV0dXJuIEJ0fHwoV3QoZSk/cj1sdFtlXTooZnIuZm9yYmlkUmVzZXJ2ZWQmJigzPT09ZnIuZWNtYVZlcnNpb24/TXQ6enQpKGUpfHxUciYmWHQoZSkpJiZ0KHlyLFwiVGhlIGtleXdvcmQgJ1wiK2UrXCInIGlzIHJlc2VydmVkXCIpKSxpKHIsZSl9ZnVuY3Rpb24gVSgpe0lyPXlyLExyPWdyLFVyPWtyLGcoKX1mdW5jdGlvbiBSKGUpe2lmKFRyPWUsYnI9THIsZnIubG9jYXRpb25zKWZvcig7U3I+YnI7KVNyPWRyLmxhc3RJbmRleE9mKFwiXFxuXCIsU3ItMikrMSwtLUFyO3UoKSxnKCl9ZnVuY3Rpb24gVigpe3RoaXMudHlwZT1udWxsLHRoaXMuc3RhcnQ9eXIsdGhpcy5lbmQ9bnVsbH1mdW5jdGlvbiBUKCl7dGhpcy5zdGFydD14cix0aGlzLmVuZD1udWxsLG51bGwhPT1ociYmKHRoaXMuc291cmNlPWhyKX1mdW5jdGlvbiBxKCl7dmFyIGU9bmV3IFY7cmV0dXJuIGZyLmxvY2F0aW9ucyYmKGUubG9jPW5ldyBUKSxmci5yYW5nZXMmJihlLnJhbmdlPVt5ciwwXSksZX1mdW5jdGlvbiBPKGUpe3ZhciByPW5ldyBWO3JldHVybiByLnN0YXJ0PWUuc3RhcnQsZnIubG9jYXRpb25zJiYoci5sb2M9bmV3IFQsci5sb2Muc3RhcnQ9ZS5sb2Muc3RhcnQpLGZyLnJhbmdlcyYmKHIucmFuZ2U9W2UucmFuZ2VbMF0sMF0pLHJ9ZnVuY3Rpb24gaihlLHIpe3JldHVybiBlLnR5cGU9cixlLmVuZD1Mcixmci5sb2NhdGlvbnMmJihlLmxvYy5lbmQ9VXIpLGZyLnJhbmdlcyYmKGUucmFuZ2VbMV09THIpLGV9ZnVuY3Rpb24gRChlKXtyZXR1cm4gZnIuZWNtYVZlcnNpb24+PTUmJlwiRXhwcmVzc2lvblN0YXRlbWVudFwiPT09ZS50eXBlJiZcIkxpdGVyYWxcIj09PWUuZXhwcmVzc2lvbi50eXBlJiZcInVzZSBzdHJpY3RcIj09PWUuZXhwcmVzc2lvbi52YWx1ZX1mdW5jdGlvbiBGKGUpe3JldHVybiB3cj09PWU/KFUoKSwhMCk6dm9pZCAwfWZ1bmN0aW9uIEIoKXtyZXR1cm4hZnIuc3RyaWN0U2VtaWNvbG9ucyYmKHdyPT09QnJ8fHdyPT09aHR8fEd0LnRlc3QoZHIuc2xpY2UoTHIseXIpKSl9ZnVuY3Rpb24gTSgpe0YoeXQpfHxCKCl8fFgoKX1mdW5jdGlvbiB6KGUpe3dyPT09ZT9VKCk6WCgpfWZ1bmN0aW9uIFgoKXt0KHlyLFwiVW5leHBlY3RlZCB0b2tlblwiKX1mdW5jdGlvbiBOKGUpe1wiSWRlbnRpZmllclwiIT09ZS50eXBlJiZcIk1lbWJlckV4cHJlc3Npb25cIiE9PWUudHlwZSYmdChlLnN0YXJ0LFwiQXNzaWduaW5nIHRvIHJ2YWx1ZVwiKSxUciYmXCJJZGVudGlmaWVyXCI9PT1lLnR5cGUmJk50KGUubmFtZSkmJnQoZS5zdGFydCxcIkFzc2lnbmluZyB0byBcIitlLm5hbWUrXCIgaW4gc3RyaWN0IG1vZGVcIil9ZnVuY3Rpb24gVyhlKXtJcj1Mcj1icixmci5sb2NhdGlvbnMmJihVcj1uZXcgYSksUnI9VHI9bnVsbCxWcj1bXSxnKCk7dmFyIHI9ZXx8cSgpLHQ9ITA7Zm9yKGV8fChyLmJvZHk9W10pO3dyIT09QnI7KXt2YXIgbj1KKCk7ci5ib2R5LnB1c2gobiksdCYmRChuKSYmUighMCksdD0hMX1yZXR1cm4gaihyLFwiUHJvZ3JhbVwiKX1mdW5jdGlvbiBKKCl7KHdyPT09d3R8fHdyPT09RXQmJlwiLz1cIj09Q3IpJiZnKCEwKTt2YXIgZT13cixyPXEoKTtzd2l0Y2goZSl7Y2FzZSBNcjpjYXNlIE5yOlUoKTt2YXIgbj1lPT09TXI7Rih5dCl8fEIoKT9yLmxhYmVsPW51bGw6d3IhPT1Gcj9YKCk6KHIubGFiZWw9bHIoKSxNKCkpO2Zvcih2YXIgYT0wO2E8VnIubGVuZ3RoOysrYSl7dmFyIG89VnJbYV07aWYobnVsbD09ci5sYWJlbHx8by5uYW1lPT09ci5sYWJlbC5uYW1lKXtpZihudWxsIT1vLmtpbmQmJihufHxcImxvb3BcIj09PW8ua2luZCkpYnJlYWs7aWYoci5sYWJlbCYmbilicmVha319cmV0dXJuIGE9PT1Wci5sZW5ndGgmJnQoci5zdGFydCxcIlVuc3ludGFjdGljIFwiK2Uua2V5d29yZCksaihyLG4/XCJCcmVha1N0YXRlbWVudFwiOlwiQ29udGludWVTdGF0ZW1lbnRcIik7Y2FzZSBXcjpyZXR1cm4gVSgpLE0oKSxqKHIsXCJEZWJ1Z2dlclN0YXRlbWVudFwiKTtjYXNlIFByOnJldHVybiBVKCksVnIucHVzaChadCksci5ib2R5PUooKSxWci5wb3AoKSx6KHR0KSxyLnRlc3Q9UCgpLE0oKSxqKHIsXCJEb1doaWxlU3RhdGVtZW50XCIpO2Nhc2UgX3I6aWYoVSgpLFZyLnB1c2goWnQpLHoobXQpLHdyPT09eXQpcmV0dXJuICQocixudWxsKTtpZih3cj09PXJ0KXt2YXIgaT1xKCk7cmV0dXJuIFUoKSxHKGksITApLGooaSxcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiksMT09PWkuZGVjbGFyYXRpb25zLmxlbmd0aCYmRih1dCk/XyhyLGkpOiQocixpKX12YXIgaT1LKCExLCEwKTtyZXR1cm4gRih1dCk/KE4oaSksXyhyLGkpKTokKHIsaSk7Y2FzZSBHcjpyZXR1cm4gVSgpLGNyKHIsITApO2Nhc2UgS3I6cmV0dXJuIFUoKSxyLnRlc3Q9UCgpLHIuY29uc2VxdWVudD1KKCksci5hbHRlcm5hdGU9RihIcik/SigpOm51bGwsaihyLFwiSWZTdGF0ZW1lbnRcIik7Y2FzZSBRcjpyZXR1cm4gUnJ8fHQoeXIsXCIncmV0dXJuJyBvdXRzaWRlIG9mIGZ1bmN0aW9uXCIpLFUoKSxGKHl0KXx8QigpP3IuYXJndW1lbnQ9bnVsbDooci5hcmd1bWVudD1LKCksTSgpKSxqKHIsXCJSZXR1cm5TdGF0ZW1lbnRcIik7Y2FzZSBZcjpVKCksci5kaXNjcmltaW5hbnQ9UCgpLHIuY2FzZXM9W10seihwdCksVnIucHVzaChlbik7Zm9yKHZhciBzLGM7d3IhPWh0OylpZih3cj09PXpyfHx3cj09PUpyKXt2YXIgdT13cj09PXpyO3MmJmoocyxcIlN3aXRjaENhc2VcIiksci5jYXNlcy5wdXNoKHM9cSgpKSxzLmNvbnNlcXVlbnQ9W10sVSgpLHU/cy50ZXN0PUsoKTooYyYmdChJcixcIk11bHRpcGxlIGRlZmF1bHQgY2xhdXNlc1wiKSxjPSEwLHMudGVzdD1udWxsKSx6KGd0KX1lbHNlIHN8fFgoKSxzLmNvbnNlcXVlbnQucHVzaChKKCkpO3JldHVybiBzJiZqKHMsXCJTd2l0Y2hDYXNlXCIpLFUoKSxWci5wb3AoKSxqKHIsXCJTd2l0Y2hTdGF0ZW1lbnRcIik7Y2FzZSBacjpyZXR1cm4gVSgpLEd0LnRlc3QoZHIuc2xpY2UoTHIseXIpKSYmdChMcixcIklsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvd1wiKSxyLmFyZ3VtZW50PUsoKSxNKCksaihyLFwiVGhyb3dTdGF0ZW1lbnRcIik7Y2FzZSBldDppZihVKCksci5ibG9jaz1IKCksci5oYW5kbGVyPW51bGwsd3I9PT1Ycil7dmFyIGw9cSgpO1UoKSx6KG10KSxsLnBhcmFtPWxyKCksVHImJk50KGwucGFyYW0ubmFtZSkmJnQobC5wYXJhbS5zdGFydCxcIkJpbmRpbmcgXCIrbC5wYXJhbS5uYW1lK1wiIGluIHN0cmljdCBtb2RlXCIpLHoodnQpLGwuZ3VhcmQ9bnVsbCxsLmJvZHk9SCgpLHIuaGFuZGxlcj1qKGwsXCJDYXRjaENsYXVzZVwiKX1yZXR1cm4gci5ndWFyZGVkSGFuZGxlcnM9cXIsci5maW5hbGl6ZXI9Rigkcik/SCgpOm51bGwsci5oYW5kbGVyfHxyLmZpbmFsaXplcnx8dChyLnN0YXJ0LFwiTWlzc2luZyBjYXRjaCBvciBmaW5hbGx5IGNsYXVzZVwiKSxqKHIsXCJUcnlTdGF0ZW1lbnRcIik7Y2FzZSBydDpyZXR1cm4gVSgpLEcociksTSgpLGoocixcIlZhcmlhYmxlRGVjbGFyYXRpb25cIik7Y2FzZSB0dDpyZXR1cm4gVSgpLHIudGVzdD1QKCksVnIucHVzaChadCksci5ib2R5PUooKSxWci5wb3AoKSxqKHIsXCJXaGlsZVN0YXRlbWVudFwiKTtjYXNlIG50OnJldHVybiBUciYmdCh5cixcIid3aXRoJyBpbiBzdHJpY3QgbW9kZVwiKSxVKCksci5vYmplY3Q9UCgpLHIuYm9keT1KKCksaihyLFwiV2l0aFN0YXRlbWVudFwiKTtjYXNlIHB0OnJldHVybiBIKCk7Y2FzZSB5dDpyZXR1cm4gVSgpLGoocixcIkVtcHR5U3RhdGVtZW50XCIpO2RlZmF1bHQ6dmFyIGY9Q3IsZD1LKCk7aWYoZT09PUZyJiZcIklkZW50aWZpZXJcIj09PWQudHlwZSYmRihndCkpe2Zvcih2YXIgYT0wO2E8VnIubGVuZ3RoOysrYSlWclthXS5uYW1lPT09ZiYmdChkLnN0YXJ0LFwiTGFiZWwgJ1wiK2YrXCInIGlzIGFscmVhZHkgZGVjbGFyZWRcIik7dmFyIHA9d3IuaXNMb29wP1wibG9vcFwiOndyPT09WXI/XCJzd2l0Y2hcIjpudWxsO3JldHVybiBWci5wdXNoKHtuYW1lOmYsa2luZDpwfSksci5ib2R5PUooKSxWci5wb3AoKSxyLmxhYmVsPWQsaihyLFwiTGFiZWxlZFN0YXRlbWVudFwiKX1yZXR1cm4gci5leHByZXNzaW9uPWQsTSgpLGoocixcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIil9fWZ1bmN0aW9uIFAoKXt6KG10KTt2YXIgZT1LKCk7cmV0dXJuIHoodnQpLGV9ZnVuY3Rpb24gSChlKXt2YXIgcix0PXEoKSxuPSEwLGE9ITE7Zm9yKHQuYm9keT1bXSx6KHB0KTshRihodCk7KXt2YXIgbz1KKCk7dC5ib2R5LnB1c2gobyksbiYmZSYmRChvKSYmKHI9YSxSKGE9ITApKSxuPSExfXJldHVybiBhJiYhciYmUighMSksaih0LFwiQmxvY2tTdGF0ZW1lbnRcIil9ZnVuY3Rpb24gJChlLHIpe3JldHVybiBlLmluaXQ9cix6KHl0KSxlLnRlc3Q9d3I9PT15dD9udWxsOksoKSx6KHl0KSxlLnVwZGF0ZT13cj09PXZ0P251bGw6SygpLHoodnQpLGUuYm9keT1KKCksVnIucG9wKCksaihlLFwiRm9yU3RhdGVtZW50XCIpfWZ1bmN0aW9uIF8oZSxyKXtyZXR1cm4gZS5sZWZ0PXIsZS5yaWdodD1LKCkseih2dCksZS5ib2R5PUooKSxWci5wb3AoKSxqKGUsXCJGb3JJblN0YXRlbWVudFwiKX1mdW5jdGlvbiBHKGUscil7Zm9yKGUuZGVjbGFyYXRpb25zPVtdLGUua2luZD1cInZhclwiOzspe3ZhciBuPXEoKTtpZihuLmlkPWxyKCksVHImJk50KG4uaWQubmFtZSkmJnQobi5pZC5zdGFydCxcIkJpbmRpbmcgXCIrbi5pZC5uYW1lK1wiIGluIHN0cmljdCBtb2RlXCIpLG4uaW5pdD1GKEN0KT9LKCEwLHIpOm51bGwsZS5kZWNsYXJhdGlvbnMucHVzaChqKG4sXCJWYXJpYWJsZURlY2xhcmF0b3JcIikpLCFGKGJ0KSlicmVha31yZXR1cm4gZX1mdW5jdGlvbiBLKGUscil7dmFyIHQ9UShyKTtpZighZSYmd3I9PT1idCl7dmFyIG49Tyh0KTtmb3Iobi5leHByZXNzaW9ucz1bdF07RihidCk7KW4uZXhwcmVzc2lvbnMucHVzaChRKHIpKTtyZXR1cm4gaihuLFwiU2VxdWVuY2VFeHByZXNzaW9uXCIpfXJldHVybiB0fWZ1bmN0aW9uIFEoZSl7dmFyIHI9WShlKTtpZih3ci5pc0Fzc2lnbil7dmFyIHQ9TyhyKTtyZXR1cm4gdC5vcGVyYXRvcj1Dcix0LmxlZnQ9cixVKCksdC5yaWdodD1RKGUpLE4ociksaih0LFwiQXNzaWdubWVudEV4cHJlc3Npb25cIil9cmV0dXJuIHJ9ZnVuY3Rpb24gWShlKXt2YXIgcj1aKGUpO2lmKEYoa3QpKXt2YXIgdD1PKHIpO3JldHVybiB0LnRlc3Q9cix0LmNvbnNlcXVlbnQ9SyghMCkseihndCksdC5hbHRlcm5hdGU9SyghMCxlKSxqKHQsXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIil9cmV0dXJuIHJ9ZnVuY3Rpb24gWihlKXtyZXR1cm4gZXIocnIoKSwtMSxlKX1mdW5jdGlvbiBlcihlLHIsdCl7dmFyIG49d3IuYmlub3A7aWYobnVsbCE9biYmKCF0fHx3ciE9PXV0KSYmbj5yKXt2YXIgYT1PKGUpO2EubGVmdD1lLGEub3BlcmF0b3I9Q3IsVSgpLGEucmlnaHQ9ZXIocnIoKSxuLHQpO3ZhciBvPWooYSwvJiZ8XFx8XFx8Ly50ZXN0KGEub3BlcmF0b3IpP1wiTG9naWNhbEV4cHJlc3Npb25cIjpcIkJpbmFyeUV4cHJlc3Npb25cIik7cmV0dXJuIGVyKG8scix0KX1yZXR1cm4gZX1mdW5jdGlvbiBycigpe2lmKHdyLnByZWZpeCl7dmFyIGU9cSgpLHI9d3IuaXNVcGRhdGU7cmV0dXJuIGUub3BlcmF0b3I9Q3IsZS5wcmVmaXg9ITAsRXI9ITAsVSgpLGUuYXJndW1lbnQ9cnIoKSxyP04oZS5hcmd1bWVudCk6VHImJlwiZGVsZXRlXCI9PT1lLm9wZXJhdG9yJiZcIklkZW50aWZpZXJcIj09PWUuYXJndW1lbnQudHlwZSYmdChlLnN0YXJ0LFwiRGVsZXRpbmcgbG9jYWwgdmFyaWFibGUgaW4gc3RyaWN0IG1vZGVcIiksaihlLHI/XCJVcGRhdGVFeHByZXNzaW9uXCI6XCJVbmFyeUV4cHJlc3Npb25cIil9Zm9yKHZhciBuPXRyKCk7d3IucG9zdGZpeCYmIUIoKTspe3ZhciBlPU8obik7ZS5vcGVyYXRvcj1DcixlLnByZWZpeD0hMSxlLmFyZ3VtZW50PW4sTihuKSxVKCksbj1qKGUsXCJVcGRhdGVFeHByZXNzaW9uXCIpfXJldHVybiBufWZ1bmN0aW9uIHRyKCl7cmV0dXJuIG5yKGFyKCkpfWZ1bmN0aW9uIG5yKGUscil7aWYoRih4dCkpe3ZhciB0PU8oZSk7cmV0dXJuIHQub2JqZWN0PWUsdC5wcm9wZXJ0eT1scighMCksdC5jb21wdXRlZD0hMSxucihqKHQsXCJNZW1iZXJFeHByZXNzaW9uXCIpLHIpfWlmKEYoZnQpKXt2YXIgdD1PKGUpO3JldHVybiB0Lm9iamVjdD1lLHQucHJvcGVydHk9SygpLHQuY29tcHV0ZWQ9ITAseihkdCksbnIoaih0LFwiTWVtYmVyRXhwcmVzc2lvblwiKSxyKX1pZighciYmRihtdCkpe3ZhciB0PU8oZSk7cmV0dXJuIHQuY2FsbGVlPWUsdC5hcmd1bWVudHM9dXIodnQsITEpLG5yKGoodCxcIkNhbGxFeHByZXNzaW9uXCIpLHIpfXJldHVybiBlfWZ1bmN0aW9uIGFyKCl7c3dpdGNoKHdyKXtjYXNlIG90OnZhciBlPXEoKTtyZXR1cm4gVSgpLGooZSxcIlRoaXNFeHByZXNzaW9uXCIpO2Nhc2UgRnI6cmV0dXJuIGxyKCk7Y2FzZSBPcjpjYXNlIERyOmNhc2UganI6dmFyIGU9cSgpO3JldHVybiBlLnZhbHVlPUNyLGUucmF3PWRyLnNsaWNlKHlyLGdyKSxVKCksaihlLFwiTGl0ZXJhbFwiKTtjYXNlIGl0OmNhc2Ugc3Q6Y2FzZSBjdDp2YXIgZT1xKCk7cmV0dXJuIGUudmFsdWU9d3IuYXRvbVZhbHVlLGUucmF3PXdyLmtleXdvcmQsVSgpLGooZSxcIkxpdGVyYWxcIik7Y2FzZSBtdDp2YXIgcj14cix0PXlyO1UoKTt2YXIgbj1LKCk7cmV0dXJuIG4uc3RhcnQ9dCxuLmVuZD1ncixmci5sb2NhdGlvbnMmJihuLmxvYy5zdGFydD1yLG4ubG9jLmVuZD1rciksZnIucmFuZ2VzJiYobi5yYW5nZT1bdCxncl0pLHoodnQpLG47Y2FzZSBmdDp2YXIgZT1xKCk7cmV0dXJuIFUoKSxlLmVsZW1lbnRzPXVyKGR0LCEwLCEwKSxqKGUsXCJBcnJheUV4cHJlc3Npb25cIik7Y2FzZSBwdDpyZXR1cm4gaXIoKTtjYXNlIEdyOnZhciBlPXEoKTtyZXR1cm4gVSgpLGNyKGUsITEpO2Nhc2UgYXQ6cmV0dXJuIG9yKCk7ZGVmYXVsdDpYKCl9fWZ1bmN0aW9uIG9yKCl7dmFyIGU9cSgpO3JldHVybiBVKCksZS5jYWxsZWU9bnIoYXIoKSwhMCksZS5hcmd1bWVudHM9RihtdCk/dXIodnQsITEpOnFyLGooZSxcIk5ld0V4cHJlc3Npb25cIil9ZnVuY3Rpb24gaXIoKXt2YXIgZT1xKCkscj0hMCxuPSExO2ZvcihlLnByb3BlcnRpZXM9W10sVSgpOyFGKGh0KTspe2lmKHIpcj0hMTtlbHNlIGlmKHooYnQpLGZyLmFsbG93VHJhaWxpbmdDb21tYXMmJkYoaHQpKWJyZWFrO3ZhciBhLG89e2tleTpzcigpfSxpPSExO2lmKEYoZ3QpPyhvLnZhbHVlPUsoITApLGE9by5raW5kPVwiaW5pdFwiKTpmci5lY21hVmVyc2lvbj49NSYmXCJJZGVudGlmaWVyXCI9PT1vLmtleS50eXBlJiYoXCJnZXRcIj09PW8ua2V5Lm5hbWV8fFwic2V0XCI9PT1vLmtleS5uYW1lKT8oaT1uPSEwLGE9by5raW5kPW8ua2V5Lm5hbWUsby5rZXk9c3IoKSx3ciE9PW10JiZYKCksby52YWx1ZT1jcihxKCksITEpKTpYKCksXCJJZGVudGlmaWVyXCI9PT1vLmtleS50eXBlJiYoVHJ8fG4pKWZvcih2YXIgcz0wO3M8ZS5wcm9wZXJ0aWVzLmxlbmd0aDsrK3Mpe3ZhciBjPWUucHJvcGVydGllc1tzXTtpZihjLmtleS5uYW1lPT09by5rZXkubmFtZSl7dmFyIHU9YT09Yy5raW5kfHxpJiZcImluaXRcIj09PWMua2luZHx8XCJpbml0XCI9PT1hJiYoXCJnZXRcIj09PWMua2luZHx8XCJzZXRcIj09PWMua2luZCk7dSYmIVRyJiZcImluaXRcIj09PWEmJlwiaW5pdFwiPT09Yy5raW5kJiYodT0hMSksdSYmdChvLmtleS5zdGFydCxcIlJlZGVmaW5pdGlvbiBvZiBwcm9wZXJ0eVwiKX19ZS5wcm9wZXJ0aWVzLnB1c2gobyl9cmV0dXJuIGooZSxcIk9iamVjdEV4cHJlc3Npb25cIil9ZnVuY3Rpb24gc3IoKXtyZXR1cm4gd3I9PT1Pcnx8d3I9PT1Ecj9hcigpOmxyKCEwKX1mdW5jdGlvbiBjcihlLHIpe3dyPT09RnI/ZS5pZD1scigpOnI/WCgpOmUuaWQ9bnVsbCxlLnBhcmFtcz1bXTt2YXIgbj0hMDtmb3IoeihtdCk7IUYodnQpOyluP249ITE6eihidCksZS5wYXJhbXMucHVzaChscigpKTt2YXIgYT1ScixvPVZyO2lmKFJyPSEwLFZyPVtdLGUuYm9keT1IKCEwKSxScj1hLFZyPW8sVHJ8fGUuYm9keS5ib2R5Lmxlbmd0aCYmRChlLmJvZHkuYm9keVswXSkpZm9yKHZhciBpPWUuaWQ/LTE6MDtpPGUucGFyYW1zLmxlbmd0aDsrK2kpe3ZhciBzPTA+aT9lLmlkOmUucGFyYW1zW2ldO2lmKChYdChzLm5hbWUpfHxOdChzLm5hbWUpKSYmdChzLnN0YXJ0LFwiRGVmaW5pbmcgJ1wiK3MubmFtZStcIicgaW4gc3RyaWN0IG1vZGVcIiksaT49MClmb3IodmFyIGM9MDtpPmM7KytjKXMubmFtZT09PWUucGFyYW1zW2NdLm5hbWUmJnQocy5zdGFydCxcIkFyZ3VtZW50IG5hbWUgY2xhc2ggaW4gc3RyaWN0IG1vZGVcIil9cmV0dXJuIGooZSxyP1wiRnVuY3Rpb25EZWNsYXJhdGlvblwiOlwiRnVuY3Rpb25FeHByZXNzaW9uXCIpfWZ1bmN0aW9uIHVyKGUscix0KXtmb3IodmFyIG49W10sYT0hMDshRihlKTspe2lmKGEpYT0hMTtlbHNlIGlmKHooYnQpLHImJmZyLmFsbG93VHJhaWxpbmdDb21tYXMmJkYoZSkpYnJlYWs7dCYmd3I9PT1idD9uLnB1c2gobnVsbCk6bi5wdXNoKEsoITApKX1yZXR1cm4gbn1mdW5jdGlvbiBscihlKXt2YXIgcj1xKCk7cmV0dXJuIHIubmFtZT13cj09PUZyP0NyOmUmJiFmci5mb3JiaWRSZXNlcnZlZCYmd3Iua2V5d29yZHx8WCgpLEVyPSExLFUoKSxqKHIsXCJJZGVudGlmaWVyXCIpfWUudmVyc2lvbj1cIjAuNC4wXCI7dmFyIGZyLGRyLHByLGhyO2UucGFyc2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZHI9U3RyaW5nKGUpLHByPWRyLmxlbmd0aCxyKHQpLG8oKSxXKGZyLnByb2dyYW0pfTt2YXIgbXI9ZS5kZWZhdWx0T3B0aW9ucz17ZWNtYVZlcnNpb246NSxzdHJpY3RTZW1pY29sb25zOiExLGFsbG93VHJhaWxpbmdDb21tYXM6ITAsZm9yYmlkUmVzZXJ2ZWQ6ITEsbG9jYXRpb25zOiExLG9uQ29tbWVudDpudWxsLHJhbmdlczohMSxwcm9ncmFtOm51bGwsc291cmNlRmlsZTpudWxsfSx2cj1lLmdldExpbmVJbmZvPWZ1bmN0aW9uKGUscil7Zm9yKHZhciB0PTEsbj0wOzspe0t0Lmxhc3RJbmRleD1uO3ZhciBhPUt0LmV4ZWMoZSk7aWYoIShhJiZhLmluZGV4PHIpKWJyZWFrOysrdCxuPWEuaW5kZXgrYVswXS5sZW5ndGh9cmV0dXJue2xpbmU6dCxjb2x1bW46ci1ufX07ZS50b2tlbml6ZT1mdW5jdGlvbihlLHQpe2Z1bmN0aW9uIG4oZSl7cmV0dXJuIGcoZSksYS5zdGFydD15cixhLmVuZD1ncixhLnN0YXJ0TG9jPXhyLGEuZW5kTG9jPWtyLGEudHlwZT13cixhLnZhbHVlPUNyLGF9ZHI9U3RyaW5nKGUpLHByPWRyLmxlbmd0aCxyKHQpLG8oKTt2YXIgYT17fTtyZXR1cm4gbi5qdW1wVG89ZnVuY3Rpb24oZSxyKXtpZihicj1lLGZyLmxvY2F0aW9ucyl7QXI9MSxTcj1LdC5sYXN0SW5kZXg9MDtmb3IodmFyIHQ7KHQ9S3QuZXhlYyhkcikpJiZ0LmluZGV4PGU7KSsrQXIsU3I9dC5pbmRleCt0WzBdLmxlbmd0aH1Fcj1yLHUoKX0sbn07dmFyIGJyLHlyLGdyLHhyLGtyLHdyLENyLEVyLEFyLFNyLElyLExyLFVyLFJyLFZyLFRyLHFyPVtdLE9yPXt0eXBlOlwibnVtXCJ9LGpyPXt0eXBlOlwicmVnZXhwXCJ9LERyPXt0eXBlOlwic3RyaW5nXCJ9LEZyPXt0eXBlOlwibmFtZVwifSxCcj17dHlwZTpcImVvZlwifSxNcj17a2V5d29yZDpcImJyZWFrXCJ9LHpyPXtrZXl3b3JkOlwiY2FzZVwiLGJlZm9yZUV4cHI6ITB9LFhyPXtrZXl3b3JkOlwiY2F0Y2hcIn0sTnI9e2tleXdvcmQ6XCJjb250aW51ZVwifSxXcj17a2V5d29yZDpcImRlYnVnZ2VyXCJ9LEpyPXtrZXl3b3JkOlwiZGVmYXVsdFwifSxQcj17a2V5d29yZDpcImRvXCIsaXNMb29wOiEwfSxIcj17a2V5d29yZDpcImVsc2VcIixiZWZvcmVFeHByOiEwfSwkcj17a2V5d29yZDpcImZpbmFsbHlcIn0sX3I9e2tleXdvcmQ6XCJmb3JcIixpc0xvb3A6ITB9LEdyPXtrZXl3b3JkOlwiZnVuY3Rpb25cIn0sS3I9e2tleXdvcmQ6XCJpZlwifSxRcj17a2V5d29yZDpcInJldHVyblwiLGJlZm9yZUV4cHI6ITB9LFlyPXtrZXl3b3JkOlwic3dpdGNoXCJ9LFpyPXtrZXl3b3JkOlwidGhyb3dcIixiZWZvcmVFeHByOiEwfSxldD17a2V5d29yZDpcInRyeVwifSxydD17a2V5d29yZDpcInZhclwifSx0dD17a2V5d29yZDpcIndoaWxlXCIsaXNMb29wOiEwfSxudD17a2V5d29yZDpcIndpdGhcIn0sYXQ9e2tleXdvcmQ6XCJuZXdcIixiZWZvcmVFeHByOiEwfSxvdD17a2V5d29yZDpcInRoaXNcIn0saXQ9e2tleXdvcmQ6XCJudWxsXCIsYXRvbVZhbHVlOm51bGx9LHN0PXtrZXl3b3JkOlwidHJ1ZVwiLGF0b21WYWx1ZTohMH0sY3Q9e2tleXdvcmQ6XCJmYWxzZVwiLGF0b21WYWx1ZTohMX0sdXQ9e2tleXdvcmQ6XCJpblwiLGJpbm9wOjcsYmVmb3JlRXhwcjohMH0sbHQ9e1wiYnJlYWtcIjpNcixcImNhc2VcIjp6cixcImNhdGNoXCI6WHIsXCJjb250aW51ZVwiOk5yLFwiZGVidWdnZXJcIjpXcixcImRlZmF1bHRcIjpKcixcImRvXCI6UHIsXCJlbHNlXCI6SHIsXCJmaW5hbGx5XCI6JHIsXCJmb3JcIjpfcixcImZ1bmN0aW9uXCI6R3IsXCJpZlwiOktyLFwicmV0dXJuXCI6UXIsXCJzd2l0Y2hcIjpZcixcInRocm93XCI6WnIsXCJ0cnlcIjpldCxcInZhclwiOnJ0LFwid2hpbGVcIjp0dCxcIndpdGhcIjpudCxcIm51bGxcIjppdCxcInRydWVcIjpzdCxcImZhbHNlXCI6Y3QsXCJuZXdcIjphdCxcImluXCI6dXQsXCJpbnN0YW5jZW9mXCI6e2tleXdvcmQ6XCJpbnN0YW5jZW9mXCIsYmlub3A6NyxiZWZvcmVFeHByOiEwfSxcInRoaXNcIjpvdCxcInR5cGVvZlwiOntrZXl3b3JkOlwidHlwZW9mXCIscHJlZml4OiEwLGJlZm9yZUV4cHI6ITB9LFwidm9pZFwiOntrZXl3b3JkOlwidm9pZFwiLHByZWZpeDohMCxiZWZvcmVFeHByOiEwfSxcImRlbGV0ZVwiOntrZXl3b3JkOlwiZGVsZXRlXCIscHJlZml4OiEwLGJlZm9yZUV4cHI6ITB9fSxmdD17dHlwZTpcIltcIixiZWZvcmVFeHByOiEwfSxkdD17dHlwZTpcIl1cIn0scHQ9e3R5cGU6XCJ7XCIsYmVmb3JlRXhwcjohMH0saHQ9e3R5cGU6XCJ9XCJ9LG10PXt0eXBlOlwiKFwiLGJlZm9yZUV4cHI6ITB9LHZ0PXt0eXBlOlwiKVwifSxidD17dHlwZTpcIixcIixiZWZvcmVFeHByOiEwfSx5dD17dHlwZTpcIjtcIixiZWZvcmVFeHByOiEwfSxndD17dHlwZTpcIjpcIixiZWZvcmVFeHByOiEwfSx4dD17dHlwZTpcIi5cIn0sa3Q9e3R5cGU6XCI/XCIsYmVmb3JlRXhwcjohMH0sd3Q9e2Jpbm9wOjEwLGJlZm9yZUV4cHI6ITB9LEN0PXtpc0Fzc2lnbjohMCxiZWZvcmVFeHByOiEwfSxFdD17aXNBc3NpZ246ITAsYmVmb3JlRXhwcjohMH0sQXQ9e2Jpbm9wOjkscHJlZml4OiEwLGJlZm9yZUV4cHI6ITB9LFN0PXtwb3N0Zml4OiEwLHByZWZpeDohMCxpc1VwZGF0ZTohMH0sSXQ9e3ByZWZpeDohMCxiZWZvcmVFeHByOiEwfSxMdD17Ymlub3A6MSxiZWZvcmVFeHByOiEwfSxVdD17Ymlub3A6MixiZWZvcmVFeHByOiEwfSxSdD17Ymlub3A6MyxiZWZvcmVFeHByOiEwfSxWdD17Ymlub3A6NCxiZWZvcmVFeHByOiEwfSxUdD17Ymlub3A6NSxiZWZvcmVFeHByOiEwfSxxdD17Ymlub3A6NixiZWZvcmVFeHByOiEwfSxPdD17Ymlub3A6NyxiZWZvcmVFeHByOiEwfSxqdD17Ymlub3A6OCxiZWZvcmVFeHByOiEwfSxEdD17Ymlub3A6MTAsYmVmb3JlRXhwcjohMH07ZS50b2tUeXBlcz17YnJhY2tldEw6ZnQsYnJhY2tldFI6ZHQsYnJhY2VMOnB0LGJyYWNlUjpodCxwYXJlbkw6bXQscGFyZW5SOnZ0LGNvbW1hOmJ0LHNlbWk6eXQsY29sb246Z3QsZG90Onh0LHF1ZXN0aW9uOmt0LHNsYXNoOnd0LGVxOkN0LG5hbWU6RnIsZW9mOkJyLG51bTpPcixyZWdleHA6anIsc3RyaW5nOkRyfTtmb3IodmFyIEZ0IGluIGx0KWUudG9rVHlwZXNbXCJfXCIrRnRdPWx0W0Z0XTt2YXIgQnQsTXQ9bihcImFic3RyYWN0IGJvb2xlYW4gYnl0ZSBjaGFyIGNsYXNzIGRvdWJsZSBlbnVtIGV4cG9ydCBleHRlbmRzIGZpbmFsIGZsb2F0IGdvdG8gaW1wbGVtZW50cyBpbXBvcnQgaW50IGludGVyZmFjZSBsb25nIG5hdGl2ZSBwYWNrYWdlIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyBzaG9ydCBzdGF0aWMgc3VwZXIgc3luY2hyb25pemVkIHRocm93cyB0cmFuc2llbnQgdm9sYXRpbGVcIiksenQ9bihcImNsYXNzIGVudW0gZXh0ZW5kcyBzdXBlciBjb25zdCBleHBvcnQgaW1wb3J0XCIpLFh0PW4oXCJpbXBsZW1lbnRzIGludGVyZmFjZSBsZXQgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc3RhdGljIHlpZWxkXCIpLE50PW4oXCJldmFsIGFyZ3VtZW50c1wiKSxXdD1uKFwiYnJlYWsgY2FzZSBjYXRjaCBjb250aW51ZSBkZWJ1Z2dlciBkZWZhdWx0IGRvIGVsc2UgZmluYWxseSBmb3IgZnVuY3Rpb24gaWYgcmV0dXJuIHN3aXRjaCB0aHJvdyB0cnkgdmFyIHdoaWxlIHdpdGggbnVsbCB0cnVlIGZhbHNlIGluc3RhbmNlb2YgdHlwZW9mIHZvaWQgZGVsZXRlIG5ldyBpbiB0aGlzXCIpLEp0PS9bXFx1MTY4MFxcdTE4MGVcXHUyMDAwLVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmXS8sUHQ9XCJcXHhhYVxceGI1XFx4YmFcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJjMVxcdTAyYzYtXFx1MDJkMVxcdTAyZTAtXFx1MDJlNFxcdTAyZWNcXHUwMmVlXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdhLVxcdTAzN2RcXHUwMzg2XFx1MDM4OC1cXHUwMzhhXFx1MDM4Y1xcdTAzOGUtXFx1MDNhMVxcdTAzYTMtXFx1MDNmNVxcdTAzZjctXFx1MDQ4MVxcdTA0OGEtXFx1MDUyN1xcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNWQwLVxcdTA1ZWFcXHUwNWYwLVxcdTA1ZjJcXHUwNjIwLVxcdTA2NGFcXHUwNjZlXFx1MDY2ZlxcdTA2NzEtXFx1MDZkM1xcdTA2ZDVcXHUwNmU1XFx1MDZlNlxcdTA2ZWVcXHUwNmVmXFx1MDZmYS1cXHUwNmZjXFx1MDZmZlxcdTA3MTBcXHUwNzEyLVxcdTA3MmZcXHUwNzRkLVxcdTA3YTVcXHUwN2IxXFx1MDdjYS1cXHUwN2VhXFx1MDdmNFxcdTA3ZjVcXHUwN2ZhXFx1MDgwMC1cXHUwODE1XFx1MDgxYVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhhMFxcdTA4YTItXFx1MDhhY1xcdTA5MDQtXFx1MDkzOVxcdTA5M2RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTc3XFx1MDk3OS1cXHUwOTdmXFx1MDk4NS1cXHUwOThjXFx1MDk4ZlxcdTA5OTBcXHUwOTkzLVxcdTA5YThcXHUwOWFhLVxcdTA5YjBcXHUwOWIyXFx1MDliNi1cXHUwOWI5XFx1MDliZFxcdTA5Y2VcXHUwOWRjXFx1MDlkZFxcdTA5ZGYtXFx1MDllMVxcdTA5ZjBcXHUwOWYxXFx1MGEwNS1cXHUwYTBhXFx1MGEwZlxcdTBhMTBcXHUwYTEzLVxcdTBhMjhcXHUwYTJhLVxcdTBhMzBcXHUwYTMyXFx1MGEzM1xcdTBhMzVcXHUwYTM2XFx1MGEzOFxcdTBhMzlcXHUwYTU5LVxcdTBhNWNcXHUwYTVlXFx1MGE3Mi1cXHUwYTc0XFx1MGE4NS1cXHUwYThkXFx1MGE4Zi1cXHUwYTkxXFx1MGE5My1cXHUwYWE4XFx1MGFhYS1cXHUwYWIwXFx1MGFiMlxcdTBhYjNcXHUwYWI1LVxcdTBhYjlcXHUwYWJkXFx1MGFkMFxcdTBhZTBcXHUwYWUxXFx1MGIwNS1cXHUwYjBjXFx1MGIwZlxcdTBiMTBcXHUwYjEzLVxcdTBiMjhcXHUwYjJhLVxcdTBiMzBcXHUwYjMyXFx1MGIzM1xcdTBiMzUtXFx1MGIzOVxcdTBiM2RcXHUwYjVjXFx1MGI1ZFxcdTBiNWYtXFx1MGI2MVxcdTBiNzFcXHUwYjgzXFx1MGI4NS1cXHUwYjhhXFx1MGI4ZS1cXHUwYjkwXFx1MGI5Mi1cXHUwYjk1XFx1MGI5OVxcdTBiOWFcXHUwYjljXFx1MGI5ZVxcdTBiOWZcXHUwYmEzXFx1MGJhNFxcdTBiYTgtXFx1MGJhYVxcdTBiYWUtXFx1MGJiOVxcdTBiZDBcXHUwYzA1LVxcdTBjMGNcXHUwYzBlLVxcdTBjMTBcXHUwYzEyLVxcdTBjMjhcXHUwYzJhLVxcdTBjMzNcXHUwYzM1LVxcdTBjMzlcXHUwYzNkXFx1MGM1OFxcdTBjNTlcXHUwYzYwXFx1MGM2MVxcdTBjODUtXFx1MGM4Y1xcdTBjOGUtXFx1MGM5MFxcdTBjOTItXFx1MGNhOFxcdTBjYWEtXFx1MGNiM1xcdTBjYjUtXFx1MGNiOVxcdTBjYmRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDUtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ2MFxcdTBkNjFcXHUwZDdhLVxcdTBkN2ZcXHUwZDg1LVxcdTBkOTZcXHUwZDlhLVxcdTBkYjFcXHUwZGIzLVxcdTBkYmJcXHUwZGJkXFx1MGRjMC1cXHUwZGM2XFx1MGUwMS1cXHUwZTMwXFx1MGUzMlxcdTBlMzNcXHUwZTQwLVxcdTBlNDZcXHUwZTgxXFx1MGU4MlxcdTBlODRcXHUwZTg3XFx1MGU4OFxcdTBlOGFcXHUwZThkXFx1MGU5NC1cXHUwZTk3XFx1MGU5OS1cXHUwZTlmXFx1MGVhMS1cXHUwZWEzXFx1MGVhNVxcdTBlYTdcXHUwZWFhXFx1MGVhYlxcdTBlYWQtXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y0XFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmYwXFx1MTcwMC1cXHUxNzBjXFx1MTcwZS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFjXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTljMS1cXHUxOWM3XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0YlxcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YxXFx1MWNmNVxcdTFjZjZcXHUxZDAwLVxcdTFkYmZcXHUxZTAwLVxcdTFmMTVcXHUxZjE4LVxcdTFmMWRcXHUxZjIwLVxcdTFmNDVcXHUxZjQ4LVxcdTFmNGRcXHUxZjUwLVxcdTFmNTdcXHUxZjU5XFx1MWY1YlxcdTFmNWRcXHUxZjVmLVxcdTFmN2RcXHUxZjgwLVxcdTFmYjRcXHUxZmI2LVxcdTFmYmNcXHUxZmJlXFx1MWZjMi1cXHUxZmM0XFx1MWZjNi1cXHUxZmNjXFx1MWZkMC1cXHUxZmQzXFx1MWZkNi1cXHUxZmRiXFx1MWZlMC1cXHUxZmVjXFx1MWZmMi1cXHUxZmY0XFx1MWZmNi1cXHUxZmZjXFx1MjA3MVxcdTIwN2ZcXHUyMDkwLVxcdTIwOWNcXHUyMTAyXFx1MjEwN1xcdTIxMGEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMWRcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJhLVxcdTIxMmRcXHUyMTJmLVxcdTIxMzlcXHUyMTNjLVxcdTIxM2ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRlXFx1MjE2MC1cXHUyMTg4XFx1MmMwMC1cXHUyYzJlXFx1MmMzMC1cXHUyYzVlXFx1MmM2MC1cXHUyY2U0XFx1MmNlYi1cXHUyY2VlXFx1MmNmMlxcdTJjZjNcXHUyZDAwLVxcdTJkMjVcXHUyZDI3XFx1MmQyZFxcdTJkMzAtXFx1MmQ2N1xcdTJkNmZcXHUyZDgwLVxcdTJkOTZcXHUyZGEwLVxcdTJkYTZcXHUyZGE4LVxcdTJkYWVcXHUyZGIwLVxcdTJkYjZcXHUyZGI4LVxcdTJkYmVcXHUyZGMwLVxcdTJkYzZcXHUyZGM4LVxcdTJkY2VcXHUyZGQwLVxcdTJkZDZcXHUyZGQ4LVxcdTJkZGVcXHUyZTJmXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5ZC1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJkXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJhXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmNjXFx1YTAwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OTdcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3OGVcXHVhNzkwLVxcdWE3OTNcXHVhN2EwLVxcdWE3YWFcXHVhN2Y4LVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YTkwYS1cXHVhOTI1XFx1YTkzMC1cXHVhOTQ2XFx1YTk2MC1cXHVhOTdjXFx1YTk4NC1cXHVhOWIyXFx1YTljZlxcdWFhMDAtXFx1YWEyOFxcdWFhNDAtXFx1YWE0MlxcdWFhNDQtXFx1YWE0YlxcdWFhNjAtXFx1YWE3NlxcdWFhN2FcXHVhYTgwLVxcdWFhYWZcXHVhYWIxXFx1YWFiNVxcdWFhYjZcXHVhYWI5LVxcdWFhYmRcXHVhYWMwXFx1YWFjMlxcdWFhZGItXFx1YWFkZFxcdWFhZTAtXFx1YWFlYVxcdWFhZjItXFx1YWFmNFxcdWFiMDEtXFx1YWIwNlxcdWFiMDktXFx1YWIwZVxcdWFiMTEtXFx1YWIxNlxcdWFiMjAtXFx1YWIyNlxcdWFiMjgtXFx1YWIyZVxcdWFiYzAtXFx1YWJlMlxcdWFjMDAtXFx1ZDdhM1xcdWQ3YjAtXFx1ZDdjNlxcdWQ3Y2ItXFx1ZDdmYlxcdWY5MDAtXFx1ZmE2ZFxcdWZhNzAtXFx1ZmFkOVxcdWZiMDAtXFx1ZmIwNlxcdWZiMTMtXFx1ZmIxN1xcdWZiMWRcXHVmYjFmLVxcdWZiMjhcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MFxcdWZiNDFcXHVmYjQzXFx1ZmI0NFxcdWZiNDYtXFx1ZmJiMVxcdWZiZDMtXFx1ZmQzZFxcdWZkNTAtXFx1ZmQ4ZlxcdWZkOTItXFx1ZmRjN1xcdWZkZjAtXFx1ZmRmYlxcdWZlNzAtXFx1ZmU3NFxcdWZlNzYtXFx1ZmVmY1xcdWZmMjEtXFx1ZmYzYVxcdWZmNDEtXFx1ZmY1YVxcdWZmNjYtXFx1ZmZiZVxcdWZmYzItXFx1ZmZjN1xcdWZmY2EtXFx1ZmZjZlxcdWZmZDItXFx1ZmZkN1xcdWZmZGEtXFx1ZmZkY1wiLEh0PVwiXFx1MDMwMC1cXHUwMzZmXFx1MDQ4My1cXHUwNDg3XFx1MDU5MS1cXHUwNWJkXFx1MDViZlxcdTA1YzFcXHUwNWMyXFx1MDVjNFxcdTA1YzVcXHUwNWM3XFx1MDYxMC1cXHUwNjFhXFx1MDYyMC1cXHUwNjQ5XFx1MDY3Mi1cXHUwNmQzXFx1MDZlNy1cXHUwNmU4XFx1MDZmYi1cXHUwNmZjXFx1MDczMC1cXHUwNzRhXFx1MDgwMC1cXHUwODE0XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg0MC1cXHUwODU3XFx1MDhlNC1cXHUwOGZlXFx1MDkwMC1cXHUwOTAzXFx1MDkzYS1cXHUwOTNjXFx1MDkzZS1cXHUwOTRmXFx1MDk1MS1cXHUwOTU3XFx1MDk2Mi1cXHUwOTYzXFx1MDk2Ni1cXHUwOTZmXFx1MDk4MS1cXHUwOTgzXFx1MDliY1xcdTA5YmUtXFx1MDljNFxcdTA5YzdcXHUwOWM4XFx1MDlkN1xcdTA5ZGYtXFx1MDllMFxcdTBhMDEtXFx1MGEwM1xcdTBhM2NcXHUwYTNlLVxcdTBhNDJcXHUwYTQ3XFx1MGE0OFxcdTBhNGItXFx1MGE0ZFxcdTBhNTFcXHUwYTY2LVxcdTBhNzFcXHUwYTc1XFx1MGE4MS1cXHUwYTgzXFx1MGFiY1xcdTBhYmUtXFx1MGFjNVxcdTBhYzctXFx1MGFjOVxcdTBhY2ItXFx1MGFjZFxcdTBhZTItXFx1MGFlM1xcdTBhZTYtXFx1MGFlZlxcdTBiMDEtXFx1MGIwM1xcdTBiM2NcXHUwYjNlLVxcdTBiNDRcXHUwYjQ3XFx1MGI0OFxcdTBiNGItXFx1MGI0ZFxcdTBiNTZcXHUwYjU3XFx1MGI1Zi1cXHUwYjYwXFx1MGI2Ni1cXHUwYjZmXFx1MGI4MlxcdTBiYmUtXFx1MGJjMlxcdTBiYzYtXFx1MGJjOFxcdTBiY2EtXFx1MGJjZFxcdTBiZDdcXHUwYmU2LVxcdTBiZWZcXHUwYzAxLVxcdTBjMDNcXHUwYzQ2LVxcdTBjNDhcXHUwYzRhLVxcdTBjNGRcXHUwYzU1XFx1MGM1NlxcdTBjNjItXFx1MGM2M1xcdTBjNjYtXFx1MGM2ZlxcdTBjODJcXHUwYzgzXFx1MGNiY1xcdTBjYmUtXFx1MGNjNFxcdTBjYzYtXFx1MGNjOFxcdTBjY2EtXFx1MGNjZFxcdTBjZDVcXHUwY2Q2XFx1MGNlMi1cXHUwY2UzXFx1MGNlNi1cXHUwY2VmXFx1MGQwMlxcdTBkMDNcXHUwZDQ2LVxcdTBkNDhcXHUwZDU3XFx1MGQ2Mi1cXHUwZDYzXFx1MGQ2Ni1cXHUwZDZmXFx1MGQ4MlxcdTBkODNcXHUwZGNhXFx1MGRjZi1cXHUwZGQ0XFx1MGRkNlxcdTBkZDgtXFx1MGRkZlxcdTBkZjJcXHUwZGYzXFx1MGUzNC1cXHUwZTNhXFx1MGU0MC1cXHUwZTQ1XFx1MGU1MC1cXHUwZTU5XFx1MGViNC1cXHUwZWI5XFx1MGVjOC1cXHUwZWNkXFx1MGVkMC1cXHUwZWQ5XFx1MGYxOFxcdTBmMTlcXHUwZjIwLVxcdTBmMjlcXHUwZjM1XFx1MGYzN1xcdTBmMzlcXHUwZjQxLVxcdTBmNDdcXHUwZjcxLVxcdTBmODRcXHUwZjg2LVxcdTBmODdcXHUwZjhkLVxcdTBmOTdcXHUwZjk5LVxcdTBmYmNcXHUwZmM2XFx1MTAwMC1cXHUxMDI5XFx1MTA0MC1cXHUxMDQ5XFx1MTA2Ny1cXHUxMDZkXFx1MTA3MS1cXHUxMDc0XFx1MTA4Mi1cXHUxMDhkXFx1MTA4Zi1cXHUxMDlkXFx1MTM1ZC1cXHUxMzVmXFx1MTcwZS1cXHUxNzEwXFx1MTcyMC1cXHUxNzMwXFx1MTc0MC1cXHUxNzUwXFx1MTc3MlxcdTE3NzNcXHUxNzgwLVxcdTE3YjJcXHUxN2RkXFx1MTdlMC1cXHUxN2U5XFx1MTgwYi1cXHUxODBkXFx1MTgxMC1cXHUxODE5XFx1MTkyMC1cXHUxOTJiXFx1MTkzMC1cXHUxOTNiXFx1MTk1MS1cXHUxOTZkXFx1MTliMC1cXHUxOWMwXFx1MTljOC1cXHUxOWM5XFx1MTlkMC1cXHUxOWQ5XFx1MWEwMC1cXHUxYTE1XFx1MWEyMC1cXHUxYTUzXFx1MWE2MC1cXHUxYTdjXFx1MWE3Zi1cXHUxYTg5XFx1MWE5MC1cXHUxYTk5XFx1MWI0Ni1cXHUxYjRiXFx1MWI1MC1cXHUxYjU5XFx1MWI2Yi1cXHUxYjczXFx1MWJiMC1cXHUxYmI5XFx1MWJlNi1cXHUxYmYzXFx1MWMwMC1cXHUxYzIyXFx1MWM0MC1cXHUxYzQ5XFx1MWM1Yi1cXHUxYzdkXFx1MWNkMC1cXHUxY2QyXFx1MWQwMC1cXHUxZGJlXFx1MWUwMS1cXHUxZjE1XFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNTRcXHUyMGQwLVxcdTIwZGNcXHUyMGUxXFx1MjBlNS1cXHUyMGYwXFx1MmQ4MS1cXHUyZDk2XFx1MmRlMC1cXHUyZGZmXFx1MzAyMS1cXHUzMDI4XFx1MzA5OVxcdTMwOWFcXHVhNjQwLVxcdWE2NmRcXHVhNjc0LVxcdWE2N2RcXHVhNjlmXFx1YTZmMC1cXHVhNmYxXFx1YTdmOC1cXHVhODAwXFx1YTgwNlxcdWE4MGJcXHVhODIzLVxcdWE4MjdcXHVhODgwLVxcdWE4ODFcXHVhOGI0LVxcdWE4YzRcXHVhOGQwLVxcdWE4ZDlcXHVhOGYzLVxcdWE4ZjdcXHVhOTAwLVxcdWE5MDlcXHVhOTI2LVxcdWE5MmRcXHVhOTMwLVxcdWE5NDVcXHVhOTgwLVxcdWE5ODNcXHVhOWIzLVxcdWE5YzBcXHVhYTAwLVxcdWFhMjdcXHVhYTQwLVxcdWFhNDFcXHVhYTRjLVxcdWFhNGRcXHVhYTUwLVxcdWFhNTlcXHVhYTdiXFx1YWFlMC1cXHVhYWU5XFx1YWFmMi1cXHVhYWYzXFx1YWJjMC1cXHVhYmUxXFx1YWJlY1xcdWFiZWRcXHVhYmYwLVxcdWFiZjlcXHVmYjIwLVxcdWZiMjhcXHVmZTAwLVxcdWZlMGZcXHVmZTIwLVxcdWZlMjZcXHVmZTMzXFx1ZmUzNFxcdWZlNGQtXFx1ZmU0ZlxcdWZmMTAtXFx1ZmYxOVxcdWZmM2ZcIiwkdD1uZXcgUmVnRXhwKFwiW1wiK1B0K1wiXVwiKSxfdD1uZXcgUmVnRXhwKFwiW1wiK1B0K0h0K1wiXVwiKSxHdD0vW1xcblxcclxcdTIwMjhcXHUyMDI5XS8sS3Q9L1xcclxcbnxbXFxuXFxyXFx1MjAyOFxcdTIwMjldL2csUXQ9ZS5pc0lkZW50aWZpZXJTdGFydD1mdW5jdGlvbihlKXtyZXR1cm4gNjU+ZT8zNj09PWU6OTE+ZT8hMDo5Nz5lPzk1PT09ZToxMjM+ZT8hMDplPj0xNzAmJiR0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShlKSl9LFl0PWUuaXNJZGVudGlmaWVyQ2hhcj1mdW5jdGlvbihlKXtyZXR1cm4gNDg+ZT8zNj09PWU6NTg+ZT8hMDo2NT5lPyExOjkxPmU/ITA6OTc+ZT85NT09PWU6MTIzPmU/ITA6ZT49MTcwJiZfdC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoZSkpfSxadD17a2luZDpcImxvb3BcIn0sZW49e2tpbmQ6XCJzd2l0Y2hcIn19KTtcblxuXHR2YXIgYmluYXJ5T3BlcmF0b3JzID0ge1xuXHRcdCcrJzogJ19fYWRkJyxcblx0XHQnLSc6ICdfX3N1YnRyYWN0Jyxcblx0XHQnKic6ICdfX211bHRpcGx5Jyxcblx0XHQnLyc6ICdfX2RpdmlkZScsXG5cdFx0JyUnOiAnX19tb2R1bG8nLFxuXHRcdCc9PSc6ICdlcXVhbHMnLFxuXHRcdCchPSc6ICdlcXVhbHMnXG5cdH07XG5cblx0dmFyIHVuYXJ5T3BlcmF0b3JzID0ge1xuXHRcdCctJzogJ19fbmVnYXRlJyxcblx0XHQnKyc6IG51bGxcblx0fTtcblxuXHR2YXIgZmllbGRzID0gQmFzZS5lYWNoKFxuXHRcdFsnYWRkJywgJ3N1YnRyYWN0JywgJ211bHRpcGx5JywgJ2RpdmlkZScsICdtb2R1bG8nLCAnbmVnYXRlJ10sXG5cdFx0ZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0dGhpc1snX18nICsgbmFtZV0gPSAnIycgKyBuYW1lO1xuXHRcdH0sXG5cdFx0e31cblx0KTtcblx0UG9pbnQuaW5qZWN0KGZpZWxkcyk7XG5cdFNpemUuaW5qZWN0KGZpZWxkcyk7XG5cdENvbG9yLmluamVjdChmaWVsZHMpO1xuXG5cdGZ1bmN0aW9uIF9fJF9fKGxlZnQsIG9wZXJhdG9yLCByaWdodCkge1xuXHRcdHZhciBoYW5kbGVyID0gYmluYXJ5T3BlcmF0b3JzW29wZXJhdG9yXTtcblx0XHRpZiAobGVmdCAmJiBsZWZ0W2hhbmRsZXJdKSB7XG5cdFx0XHR2YXIgcmVzID0gbGVmdFtoYW5kbGVyXShyaWdodCk7XG5cdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09ICchPScgPyAhcmVzIDogcmVzO1xuXHRcdH1cblx0XHRzd2l0Y2ggKG9wZXJhdG9yKSB7XG5cdFx0Y2FzZSAnKyc6IHJldHVybiBsZWZ0ICsgcmlnaHQ7XG5cdFx0Y2FzZSAnLSc6IHJldHVybiBsZWZ0IC0gcmlnaHQ7XG5cdFx0Y2FzZSAnKic6IHJldHVybiBsZWZ0ICogcmlnaHQ7XG5cdFx0Y2FzZSAnLyc6IHJldHVybiBsZWZ0IC8gcmlnaHQ7XG5cdFx0Y2FzZSAnJSc6IHJldHVybiBsZWZ0ICUgcmlnaHQ7XG5cdFx0Y2FzZSAnPT0nOiByZXR1cm4gbGVmdCA9PSByaWdodDtcblx0XHRjYXNlICchPSc6IHJldHVybiBsZWZ0ICE9IHJpZ2h0O1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uICRfXyhvcGVyYXRvciwgdmFsdWUpIHtcblx0XHR2YXIgaGFuZGxlciA9IHVuYXJ5T3BlcmF0b3JzW29wZXJhdG9yXTtcblx0XHRpZiAoaGFuZGxlciAmJiB2YWx1ZSAmJiB2YWx1ZVtoYW5kbGVyXSlcblx0XHRcdHJldHVybiB2YWx1ZVtoYW5kbGVyXSgpO1xuXHRcdHN3aXRjaCAob3BlcmF0b3IpIHtcblx0XHRjYXNlICcrJzogcmV0dXJuICt2YWx1ZTtcblx0XHRjYXNlICctJzogcmV0dXJuIC12YWx1ZTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBwYXJzZShjb2RlLCBvcHRpb25zKSB7XG5cdFx0cmV0dXJuIHNjb3BlLmFjb3JuLnBhcnNlKGNvZGUsIG9wdGlvbnMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gY29tcGlsZShjb2RlLCB1cmwsIG9wdGlvbnMpIHtcblx0XHRpZiAoIWNvZGUpXG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0dXJsID0gdXJsIHx8ICcnO1xuXG5cdFx0dmFyIGluc2VydGlvbnMgPSBbXTtcblxuXHRcdGZ1bmN0aW9uIGdldE9mZnNldChvZmZzZXQpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gaW5zZXJ0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGluc2VydGlvbiA9IGluc2VydGlvbnNbaV07XG5cdFx0XHRcdGlmIChpbnNlcnRpb25bMF0gPj0gb2Zmc2V0KVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRvZmZzZXQgKz0gaW5zZXJ0aW9uWzFdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9mZnNldDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRDb2RlKG5vZGUpIHtcblx0XHRcdHJldHVybiBjb2RlLnN1YnN0cmluZyhnZXRPZmZzZXQobm9kZS5yYW5nZVswXSksXG5cdFx0XHRcdFx0Z2V0T2Zmc2V0KG5vZGUucmFuZ2VbMV0pKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRCZXR3ZWVuKGxlZnQsIHJpZ2h0KSB7XG5cdFx0XHRyZXR1cm4gY29kZS5zdWJzdHJpbmcoZ2V0T2Zmc2V0KGxlZnQucmFuZ2VbMV0pLFxuXHRcdFx0XHRcdGdldE9mZnNldChyaWdodC5yYW5nZVswXSkpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlcGxhY2VDb2RlKG5vZGUsIHN0cikge1xuXHRcdFx0dmFyIHN0YXJ0ID0gZ2V0T2Zmc2V0KG5vZGUucmFuZ2VbMF0pLFxuXHRcdFx0XHRlbmQgPSBnZXRPZmZzZXQobm9kZS5yYW5nZVsxXSksXG5cdFx0XHRcdGluc2VydCA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gaW5zZXJ0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRpZiAoc3RhcnQgPiBpbnNlcnRpb25zW2ldWzBdKSB7XG5cdFx0XHRcdFx0aW5zZXJ0ID0gaSArIDE7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGluc2VydGlvbnMuc3BsaWNlKGluc2VydCwgMCwgW3N0YXJ0LCBzdHIubGVuZ3RoIC0gZW5kICsgc3RhcnRdKTtcblx0XHRcdGNvZGUgPSBjb2RlLnN1YnN0cmluZygwLCBzdGFydCkgKyBzdHIgKyBjb2RlLnN1YnN0cmluZyhlbmQpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHdhbGtBU1Qobm9kZSwgcGFyZW50KSB7XG5cdFx0XHRpZiAoIW5vZGUpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdGZvciAodmFyIGtleSBpbiBub2RlKSB7XG5cdFx0XHRcdGlmIChrZXkgPT09ICdyYW5nZScgfHwga2V5ID09PSAnbG9jJylcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0dmFyIHZhbHVlID0gbm9kZVtrZXldO1xuXHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRcdHdhbGtBU1QodmFsdWVbaV0sIG5vZGUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHR3YWxrQVNUKHZhbHVlLCBub2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0c3dpdGNoIChub2RlLnR5cGUpIHtcblx0XHRcdGNhc2UgJ1VuYXJ5RXhwcmVzc2lvbic6XG5cdFx0XHRcdGlmIChub2RlLm9wZXJhdG9yIGluIHVuYXJ5T3BlcmF0b3JzXG5cdFx0XHRcdFx0XHQmJiBub2RlLmFyZ3VtZW50LnR5cGUgIT09ICdMaXRlcmFsJykge1xuXHRcdFx0XHRcdHZhciBhcmcgPSBnZXRDb2RlKG5vZGUuYXJndW1lbnQpO1xuXHRcdFx0XHRcdHJlcGxhY2VDb2RlKG5vZGUsICckX18oXCInICsgbm9kZS5vcGVyYXRvciArICdcIiwgJ1xuXHRcdFx0XHRcdFx0XHQrIGFyZyArICcpJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdCaW5hcnlFeHByZXNzaW9uJzpcblx0XHRcdFx0aWYgKG5vZGUub3BlcmF0b3IgaW4gYmluYXJ5T3BlcmF0b3JzXG5cdFx0XHRcdFx0XHQmJiBub2RlLmxlZnQudHlwZSAhPT0gJ0xpdGVyYWwnKSB7XG5cdFx0XHRcdFx0dmFyIGxlZnQgPSBnZXRDb2RlKG5vZGUubGVmdCksXG5cdFx0XHRcdFx0XHRyaWdodCA9IGdldENvZGUobm9kZS5yaWdodCksXG5cdFx0XHRcdFx0XHRiZXR3ZWVuID0gZ2V0QmV0d2Vlbihub2RlLmxlZnQsIG5vZGUucmlnaHQpLFxuXHRcdFx0XHRcdFx0b3BlcmF0b3IgPSBub2RlLm9wZXJhdG9yO1xuXHRcdFx0XHRcdHJlcGxhY2VDb2RlKG5vZGUsICdfXyRfXygnICsgbGVmdCArICcsJ1xuXHRcdFx0XHRcdFx0XHQrIGJldHdlZW4ucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcJyArIG9wZXJhdG9yKSxcblx0XHRcdFx0XHRcdFx0XHQnXCInICsgb3BlcmF0b3IgKyAnXCInKVxuXHRcdFx0XHRcdFx0XHQrICcsICcgKyByaWdodCArICcpJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdVcGRhdGVFeHByZXNzaW9uJzpcblx0XHRcdGNhc2UgJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJzpcblx0XHRcdFx0dmFyIHBhcmVudFR5cGUgPSBwYXJlbnQgJiYgcGFyZW50LnR5cGU7XG5cdFx0XHRcdGlmICghKFxuXHRcdFx0XHRcdFx0cGFyZW50VHlwZSA9PT0gJ0ZvclN0YXRlbWVudCdcblx0XHRcdFx0XHRcdHx8IHBhcmVudFR5cGUgPT09ICdCaW5hcnlFeHByZXNzaW9uJ1xuXHRcdFx0XHRcdFx0XHQmJiAvXls9ITw+XS8udGVzdChwYXJlbnQub3BlcmF0b3IpXG5cdFx0XHRcdFx0XHR8fCBwYXJlbnRUeXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicgJiYgcGFyZW50LmNvbXB1dGVkXG5cdFx0XHRcdCkpIHtcblx0XHRcdFx0XHRpZiAobm9kZS50eXBlID09PSAnVXBkYXRlRXhwcmVzc2lvbicpIHtcblx0XHRcdFx0XHRcdHZhciBhcmcgPSBnZXRDb2RlKG5vZGUuYXJndW1lbnQpLFxuXHRcdFx0XHRcdFx0XHRleHAgPSAnX18kX18oJyArIGFyZyArICcsIFwiJyArIG5vZGUub3BlcmF0b3JbMF1cblx0XHRcdFx0XHRcdFx0XHRcdCsgJ1wiLCAxKScsXG5cdFx0XHRcdFx0XHRcdHN0ciA9IGFyZyArICcgPSAnICsgZXhwO1xuXHRcdFx0XHRcdFx0aWYgKCFub2RlLnByZWZpeFxuXHRcdFx0XHRcdFx0XHRcdCYmIChwYXJlbnRUeXBlID09PSAnQXNzaWdubWVudEV4cHJlc3Npb24nXG5cdFx0XHRcdFx0XHRcdFx0XHR8fCBwYXJlbnRUeXBlID09PSAnVmFyaWFibGVEZWNsYXJhdG9yJykpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGdldENvZGUocGFyZW50LmxlZnQgfHwgcGFyZW50LmlkKSA9PT0gYXJnKVxuXHRcdFx0XHRcdFx0XHRcdHN0ciA9IGV4cDtcblx0XHRcdFx0XHRcdFx0c3RyID0gYXJnICsgJzsgJyArIHN0cjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJlcGxhY2VDb2RlKG5vZGUsIHN0cik7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmICgvXi49JC8udGVzdChub2RlLm9wZXJhdG9yKVxuXHRcdFx0XHRcdFx0XHRcdCYmIG5vZGUubGVmdC50eXBlICE9PSAnTGl0ZXJhbCcpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGxlZnQgPSBnZXRDb2RlKG5vZGUubGVmdCksXG5cdFx0XHRcdFx0XHRcdFx0cmlnaHQgPSBnZXRDb2RlKG5vZGUucmlnaHQpO1xuXHRcdFx0XHRcdFx0XHRyZXBsYWNlQ29kZShub2RlLCBsZWZ0ICsgJyA9IF9fJF9fKCcgKyBsZWZ0ICsgJywgXCInXG5cdFx0XHRcdFx0XHRcdFx0XHQrIG5vZGUub3BlcmF0b3JbMF0gKyAnXCIsICcgKyByaWdodCArICcpJyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgc291cmNlTWFwID0gbnVsbCxcblx0XHRcdGJyb3dzZXIgPSBwYXBlci5icm93c2VyLFxuXHRcdFx0dmVyc2lvbiA9IGJyb3dzZXIudmVyc2lvbk51bWJlcixcblx0XHRcdGxpbmVCcmVha3MgPSAvXFxyXFxufFxcbnxcXHIvbWc7XG5cdFx0aWYgKGJyb3dzZXIuY2hyb21lICYmIHZlcnNpb24gPj0gMzBcblx0XHRcdFx0fHwgYnJvd3Nlci53ZWJraXQgJiYgdmVyc2lvbiA+PSA1MzcuNzZcblx0XHRcdFx0fHwgYnJvd3Nlci5maXJlZm94ICYmIHZlcnNpb24gPj0gMjMpIHtcblx0XHRcdHZhciBvZmZzZXQgPSAwO1xuXHRcdFx0aWYgKHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YodXJsKSA9PT0gMCkge1xuXHRcdFx0XHR2YXIgaHRtbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdodG1sJylbMF0uaW5uZXJIVE1MO1xuXHRcdFx0XHRvZmZzZXQgPSBodG1sLnN1YnN0cigwLCBodG1sLmluZGV4T2YoY29kZSkgKyAxKS5tYXRjaChcblx0XHRcdFx0XHRcdGxpbmVCcmVha3MpLmxlbmd0aCArIDE7XG5cdFx0XHR9XG5cdFx0XHR2YXIgbWFwcGluZ3MgPSBbJ0FBQUEnXTtcblx0XHRcdG1hcHBpbmdzLmxlbmd0aCA9IChjb2RlLm1hdGNoKGxpbmVCcmVha3MpIHx8IFtdKS5sZW5ndGggKyAxICsgb2Zmc2V0O1xuXHRcdFx0c291cmNlTWFwID0ge1xuXHRcdFx0XHR2ZXJzaW9uOiAzLFxuXHRcdFx0XHRmaWxlOiB1cmwsXG5cdFx0XHRcdG5hbWVzOltdLFxuXHRcdFx0XHRtYXBwaW5nczogbWFwcGluZ3Muam9pbignO0FBQ0EnKSxcblx0XHRcdFx0c291cmNlUm9vdDogJycsXG5cdFx0XHRcdHNvdXJjZXM6IFt1cmxdXG5cdFx0XHR9O1xuXHRcdFx0dmFyIHNvdXJjZSA9IG9wdGlvbnMuc291cmNlIHx8ICF1cmwgJiYgY29kZTtcblx0XHRcdGlmIChzb3VyY2UpXG5cdFx0XHRcdHNvdXJjZU1hcC5zb3VyY2VzQ29udGVudCA9IFtzb3VyY2VdO1xuXHRcdH1cblx0XHR3YWxrQVNUKHBhcnNlKGNvZGUsIHsgcmFuZ2VzOiB0cnVlIH0pKTtcblx0XHRpZiAoc291cmNlTWFwKSB7XG5cdFx0XHRjb2RlID0gbmV3IEFycmF5KG9mZnNldCArIDEpLmpvaW4oJ1xcbicpICsgY29kZVxuXHRcdFx0XHRcdCsgXCJcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiXG5cdFx0XHRcdFx0KyAoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoXG5cdFx0XHRcdFx0XHRKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpKVxuXHRcdFx0XHRcdCsgXCJcXG4vLyMgc291cmNlVVJMPVwiICsgKHVybCB8fCAncGFwZXJzY3JpcHQnKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNvZGU7XG5cdH1cblxuXHRmdW5jdGlvbiBleGVjdXRlKGNvZGUsIHNjb3BlLCB1cmwsIG9wdGlvbnMpIHtcblx0XHRwYXBlciA9IHNjb3BlO1xuXHRcdHZhciB2aWV3ID0gc2NvcGUuZ2V0VmlldygpLFxuXHRcdFx0dG9vbCA9IC9cXHMrb24oPzpLZXl8TW91c2UpKD86VXB8RG93bnxNb3ZlfERyYWcpXFxiLy50ZXN0KGNvZGUpXG5cdFx0XHRcdFx0PyBuZXcgVG9vbCgpXG5cdFx0XHRcdFx0OiBudWxsLFxuXHRcdFx0dG9vbEhhbmRsZXJzID0gdG9vbCA/IHRvb2wuX2V2ZW50cyA6IFtdLFxuXHRcdFx0aGFuZGxlcnMgPSBbJ29uRnJhbWUnLCAnb25SZXNpemUnXS5jb25jYXQodG9vbEhhbmRsZXJzKSxcblx0XHRcdHBhcmFtcyA9IFtdLFxuXHRcdFx0YXJncyA9IFtdLFxuXHRcdFx0ZnVuYztcblx0XHRjb2RlID0gY29tcGlsZShjb2RlLCB1cmwsIG9wdGlvbnMpO1xuXHRcdGZ1bmN0aW9uIGV4cG9zZShzY29wZSwgaGlkZGVuKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gc2NvcGUpIHtcblx0XHRcdFx0aWYgKChoaWRkZW4gfHwgIS9eXy8udGVzdChrZXkpKSAmJiBuZXcgUmVnRXhwKCcoW1xcXFxiXFxcXHNcXFxcV118XiknXG5cdFx0XHRcdFx0XHQrIGtleS5yZXBsYWNlKC9cXCQvZywgJ1xcXFwkJykgKyAnXFxcXGInKS50ZXN0KGNvZGUpKSB7XG5cdFx0XHRcdFx0cGFyYW1zLnB1c2goa2V5KTtcblx0XHRcdFx0XHRhcmdzLnB1c2goc2NvcGVba2V5XSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXhwb3NlKHsgX18kX186IF9fJF9fLCAkX186ICRfXywgcGFwZXI6IHNjb3BlLCB2aWV3OiB2aWV3LCB0b29sOiB0b29sIH0sXG5cdFx0XHRcdHRydWUpO1xuXHRcdGV4cG9zZShzY29wZSk7XG5cdFx0aGFuZGxlcnMgPSBCYXNlLmVhY2goaGFuZGxlcnMsIGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0aWYgKG5ldyBSZWdFeHAoJ1xcXFxzKycgKyBrZXkgKyAnXFxcXGInKS50ZXN0KGNvZGUpKSB7XG5cdFx0XHRcdHBhcmFtcy5wdXNoKGtleSk7XG5cdFx0XHRcdHRoaXMucHVzaChrZXkgKyAnOiAnICsga2V5KTtcblx0XHRcdH1cblx0XHR9LCBbXSkuam9pbignLCAnKTtcblx0XHRpZiAoaGFuZGxlcnMpXG5cdFx0XHRjb2RlICs9ICdcXG5yZXR1cm4geyAnICsgaGFuZGxlcnMgKyAnIH07Jztcblx0XHR2YXIgYnJvd3NlciA9IHBhcGVyLmJyb3dzZXI7XG5cdFx0aWYgKGJyb3dzZXIuY2hyb21lIHx8IGJyb3dzZXIuZmlyZWZveCkge1xuXHRcdFx0dmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpLFxuXHRcdFx0XHRoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuXHRcdFx0aWYgKGJyb3dzZXIuZmlyZWZveClcblx0XHRcdFx0Y29kZSA9ICdcXG4nICsgY29kZTtcblx0XHRcdHNjcmlwdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcblx0XHRcdFx0J3BhcGVyLl9leGVjdXRlID0gZnVuY3Rpb24oJyArIHBhcmFtcyArICcpIHsnICsgY29kZSArICdcXG59J1xuXHRcdFx0KSk7XG5cdFx0XHRoZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cdFx0XHRmdW5jID0gcGFwZXIuX2V4ZWN1dGU7XG5cdFx0XHRkZWxldGUgcGFwZXIuX2V4ZWN1dGU7XG5cdFx0XHRoZWFkLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZ1bmMgPSBGdW5jdGlvbihwYXJhbXMsIGNvZGUpO1xuXHRcdH1cblx0XHR2YXIgcmVzID0gZnVuYy5hcHBseShzY29wZSwgYXJncykgfHwge307XG5cdFx0QmFzZS5lYWNoKHRvb2xIYW5kbGVycywgZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHR2YXIgdmFsdWUgPSByZXNba2V5XTtcblx0XHRcdGlmICh2YWx1ZSlcblx0XHRcdFx0dG9vbFtrZXldID0gdmFsdWU7XG5cdFx0fSk7XG5cdFx0aWYgKHZpZXcpIHtcblx0XHRcdGlmIChyZXMub25SZXNpemUpXG5cdFx0XHRcdHZpZXcuc2V0T25SZXNpemUocmVzLm9uUmVzaXplKTtcblx0XHRcdHZpZXcuZW1pdCgncmVzaXplJywge1xuXHRcdFx0XHRzaXplOiB2aWV3LnNpemUsXG5cdFx0XHRcdGRlbHRhOiBuZXcgUG9pbnQoKVxuXHRcdFx0fSk7XG5cdFx0XHRpZiAocmVzLm9uRnJhbWUpXG5cdFx0XHRcdHZpZXcuc2V0T25GcmFtZShyZXMub25GcmFtZSk7XG5cdFx0XHR2aWV3LnVwZGF0ZSgpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGxvYWRTY3JpcHQoc2NyaXB0KSB7XG5cdFx0aWYgKC9edGV4dFxcLyg/OngtfClwYXBlcnNjcmlwdCQvLnRlc3Qoc2NyaXB0LnR5cGUpXG5cdFx0XHRcdCYmIFBhcGVyU2NvcGUuZ2V0QXR0cmlidXRlKHNjcmlwdCwgJ2lnbm9yZScpICE9PSAndHJ1ZScpIHtcblx0XHRcdHZhciBjYW52YXNJZCA9IFBhcGVyU2NvcGUuZ2V0QXR0cmlidXRlKHNjcmlwdCwgJ2NhbnZhcycpLFxuXHRcdFx0XHRjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXNJZCksXG5cdFx0XHRcdHNyYyA9IHNjcmlwdC5zcmMgfHwgc2NyaXB0LmdldEF0dHJpYnV0ZSgnZGF0YS1zcmMnKSxcblx0XHRcdFx0YXN5bmMgPSBQYXBlclNjb3BlLmhhc0F0dHJpYnV0ZShzY3JpcHQsICdhc3luYycpLFxuXHRcdFx0XHRzY29wZUF0dHJpYnV0ZSA9ICdkYXRhLXBhcGVyLXNjb3BlJztcblx0XHRcdGlmICghY2FudmFzKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIGNhbnZhcyB3aXRoIGlkIFwiJ1xuXHRcdFx0XHRcdFx0KyBjYW52YXNJZCArICdcIicpO1xuXHRcdFx0dmFyIHNjb3BlID0gUGFwZXJTY29wZS5nZXQoY2FudmFzLmdldEF0dHJpYnV0ZShzY29wZUF0dHJpYnV0ZSkpXG5cdFx0XHRcdFx0XHR8fCBuZXcgUGFwZXJTY29wZSgpLnNldHVwKGNhbnZhcyk7XG5cdFx0XHRjYW52YXMuc2V0QXR0cmlidXRlKHNjb3BlQXR0cmlidXRlLCBzY29wZS5faWQpO1xuXHRcdFx0aWYgKHNyYykge1xuXHRcdFx0XHRIdHRwLnJlcXVlc3QoJ2dldCcsIHNyYywgZnVuY3Rpb24oY29kZSkge1xuXHRcdFx0XHRcdGV4ZWN1dGUoY29kZSwgc2NvcGUsIHNyYyk7XG5cdFx0XHRcdH0sIGFzeW5jKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV4ZWN1dGUoc2NyaXB0LmlubmVySFRNTCwgc2NvcGUsIHNjcmlwdC5iYXNlVVJJKTtcblx0XHRcdH1cblx0XHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcGFwZXItaWdub3JlJywgJ3RydWUnKTtcblx0XHRcdHJldHVybiBzY29wZTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBsb2FkQWxsKCkge1xuXHRcdEJhc2UuZWFjaChkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JyksIGxvYWRTY3JpcHQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gbG9hZChzY3JpcHQpIHtcblx0XHRyZXR1cm4gc2NyaXB0ID8gbG9hZFNjcmlwdChzY3JpcHQpIDogbG9hZEFsbCgpO1xuXHR9XG5cblx0aWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcblx0XHRzZXRUaW1lb3V0KGxvYWRBbGwpO1xuXHR9IGVsc2Uge1xuXHRcdERvbUV2ZW50LmFkZCh3aW5kb3csIHsgbG9hZDogbG9hZEFsbCB9KTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0Y29tcGlsZTogY29tcGlsZSxcblx0XHRleGVjdXRlOiBleGVjdXRlLFxuXHRcdGxvYWQ6IGxvYWQsXG5cdFx0cGFyc2U6IHBhcnNlXG5cdH07XG5cbn0pLmNhbGwodGhpcyk7XG5cbnBhcGVyID0gbmV3IChQYXBlclNjb3BlLmluamVjdChCYXNlLmV4cG9ydHMsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0QmFzZTogQmFzZSxcblx0TnVtZXJpY2FsOiBOdW1lcmljYWwsXG5cdEtleTogS2V5XG59KSkoKTtcblxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuXHRkZWZpbmUoJ3BhcGVyJywgcGFwZXIpO1xufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSBwYXBlcjtcbn1cblxucmV0dXJuIHBhcGVyO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9ib3dlcl9jb21wb25lbnRzL3BhcGVyL2Rpc3QvcGFwZXItZnVsbC5qc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBQYXBlciA9IHJlcXVpcmUoJ3BhcGVyJyk7XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGFuZ2VDZW50ZXIob2xkQ2VudGVyLCBvZmZzZXQsIGZhY3Rvcikge1xuICBvZmZzZXQgPSBvZmZzZXQubXVsdGlwbHkoZmFjdG9yKTtcbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoYW5nZVpvb20ob2xkWm9vbSwgZGVsdGEsIGNlbnRlciwgcG9zaXRpb24pe1xuICB2YXIgZmFjdG9yID0gMS4wNVxuICB2YXIgbmV3Wm9vbSA9IGRlbHRhIDwgMCA/IG9sZFpvb20gKiBmYWN0b3IgOiBvbGRab29tIC8gZmFjdG9yO1xuICB2YXIgYmV0YSA9IG9sZFpvb20gLyBuZXdab29tO1xuICB2YXIgcGMgPSBwb3NpdGlvbi5zdWJ0cmFjdChjZW50ZXIpO1xuICB2YXIgb2Zmc2V0ID0gcG9zaXRpb24uc3VidHJhY3QocGMubXVsdGlwbHkoYmV0YSkpLnN1YnRyYWN0KGNlbnRlcik7XG4gIHJldHVybiB7bmV3Wm9vbSwgb2Zmc2V0fTtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL3ZpZXdzL3V0aWxzLmpzXG4gKiovIiwidmFyIFBhcGVyID0gcmVxdWlyZSgncGFwZXInKTtcblxudmFyIGFuaW1hdGlvbnMgPSBbXTtcblxuZnVuY3Rpb24gc3RvcChpbmRleCl7XG4gIGFuaW1hdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbn1cblxuZnVuY3Rpb24gb25GcmFtZShldmVudCl7XG4gIGlmKGV2ZW50LmRlbHRhID09PSAwKSByZXR1cm47XG4gIGFuaW1hdGlvbnMuZm9yRWFjaCgoYW5pbWF0aW9uLCBpbmRleCkgPT4ge1xuICAgIGFuaW1hdGlvbi5lbGFwc2VkVGltZSArPSBldmVudC5kZWx0YTtcbiAgICB2YXIgY29udGludWVBbmltYXRpb24gPSBhbmltYXRpb24uY2FsbGJhY2soYW5pbWF0aW9uLmVsYXBzZWRUaW1lKTtcbiAgICBpZihjb250aW51ZUFuaW1hdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgIHN0b3AoaW5kZXgpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCl7XG4gIFBhcGVyLnZpZXcub25GcmFtZSA9IG9uRnJhbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQoY2FsbGJhY2spe1xuICBhbmltYXRpb25zLnB1c2goe1xuICAgIGNhbGxiYWNrLFxuICAgIGVsYXBzZWRUaW1lOiAwXG4gIH0pO1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvdmlld3MvYW5pbWF0aW9uLmpzXG4gKiovIiwidmFyIFBhcGVyID0gcmVxdWlyZSgncGFwZXInKTtcbnZhciB2aWV3ID0gcmVxdWlyZSgnLi92aWV3Jyk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lbnV7XG4gIGNvbnN0cnVjdG9yKG9uRG9uZSwgcGFyYW1zKXtcbiAgICB2aWV3LnJlc2V0KCk7XG4gICAgdGhpcy5vbkRvbmUgPSBvbkRvbmU7XG4gICAgdGhpcy5zYXZlZE1hcHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvY2FsU3RvcmFnZS5sZW5ndGg7IGkrKyl7XG4gICAgICB2YXIga2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKTtcbiAgICAgIGlmKGtleS5pbmRleE9mKCdtYXAnKSA9PT0gMCl7XG4gICAgICAgIHRoaXMuc2F2ZWRNYXBzLnB1c2goSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5tZW51ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI21lbnUnKTtcbiAgICB0aGlzLm1lbnUuc3R5bGUuZGlzcGxheSA9ICdpbml0aWFsJztcblxuICAgIHZhciBjcmVhdGVNYXBCdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjY3JlYXRlTWFwQnV0dG9uJyk7XG4gICAgY3JlYXRlTWFwQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy5vbkRvbmUoeyB2aWV3OiAnQ3JlYXRlIG1hcCcgfSkpO1xuXG4gICAgdGhpcy5tYXBzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI21hcHMnKTtcblxuICAgIHRoaXMuc2F2ZWRNYXBzLmZvckVhY2gobWFwID0+IHtcbiAgICAgIHZhciBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgIGltZy5zcmMgPSBtYXAuZGF0YVVSTDtcbiAgICAgIGltZy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMub25Eb25lKHsgdmlldzogJ0dhbWUnLCBwYXJhbXM6IG1hcC5tYXAgfSkpO1xuICAgICAgdGhpcy5tYXBzLmFwcGVuZENoaWxkKGltZyk7XG4gICAgfSk7XG4gIH1cblxuICBkaXNwb3NlKCl7XG4gICAgdGhpcy5tZW51LnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICB3aGlsZSAodGhpcy5tYXBzLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHRoaXMubWFwcy5yZW1vdmVDaGlsZCh0aGlzLm1hcHMuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy92aWV3cy9tZW51LmpzXG4gKiovIiwidmFyIFBhcGVyID0gcmVxdWlyZSgncGFwZXInKTtcbnZhciB2aWV3ID0gcmVxdWlyZSgnLi92aWV3Jyk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hcEVkaXRvcntcbiAgY29uc3RydWN0b3IoY2FsbGJhY2spe1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLmNvdXJzZTtcbiAgICB0aGlzLnRyYWNrO1xuICAgIHRoaXMuc3RhcnQ7XG4gICAgdGhpcy5lbmQ7XG5cbiAgICB0aGlzLm1vdXNlQ29udHJvbHMgPSBuZXcgUGFwZXIuVG9vbCgpO1xuICAgIHZhciBsYXN0Q2xpY2s7XG4gICAgdGhpcy5tb3VzZUNvbnRyb2xzLm9uTW91c2VEb3duID0gZSA9PiB7XG4gICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgIGlmKG5vdyAtIGxhc3RDbGljayA8IDIwMCkge1xuICAgICAgICB0aGlzLm9uRG91YmxlQ2xpY2soZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uTW91c2VEb3duKGUpO1xuICAgICAgfVxuICAgICAgbGFzdENsaWNrID0gbm93O1xuICAgIH1cbiAgICB0aGlzLm1vdXNlQ29udHJvbHMub25Nb3VzZURyYWcgPSBlID0+IHRoaXMub25Nb3VzZURyYWcoZSk7XG4gIH1cblxuICBvbk1vdXNlRG93bihldmVudCkge1xuICAgIGlmKCF0aGlzLnRyYWNrKXtcbiAgICAgIHRoaXMudHJhY2sgPSBuZXcgUGFwZXIuUGF0aC5DaXJjbGUoZXZlbnQucG9pbnQsIDQwKTtcbiAgICAgIHRoaXMudHJhY2suZmlsbENvbG9yID0gJ3B1cnBsZSc7XG4gICAgICB0aGlzLmNvdXJzZSA9IG5ldyBQYXBlci5Hcm91cCh0aGlzLnRyYWNrKTtcbiAgICAgIHZpZXcuYWRkQ291cnNlKHRoaXMuY291cnNlKTtcbiAgICB9XG4gICAgaWYodGhpcy50cmFjay5jb250YWlucyhldmVudC5wb2ludCkpIHtcbiAgICAgIHRoaXMuaXNBZGRpbmcgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlzQWRkaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgb25Eb3VibGVDbGljayhldmVudCkge1xuICAgIGlmKCF0aGlzLnN0YXJ0KSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gbmV3IFBhcGVyLlBhdGguQ2lyY2xlKGV2ZW50LnBvaW50LCA2MCkuaW50ZXJzZWN0KHRoaXMudHJhY2spO1xuICAgICAgdGhpcy5zdGFydC5maWxsQ29sb3IgPSAndGVhbCc7XG4gICAgICB0aGlzLmNvdXJzZS5hZGRDaGlsZCh0aGlzLnN0YXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbmQgPSBuZXcgUGFwZXIuUGF0aC5DaXJjbGUoZXZlbnQucG9pbnQsIDYwKS5pbnRlcnNlY3QodGhpcy50cmFjayk7XG4gICAgICB0aGlzLmVuZC5maWxsQ29sb3IgPSAneWVsbG93JztcbiAgICAgIHRoaXMuY291cnNlLmFkZENoaWxkKHRoaXMuZW5kKTtcbiAgICAgIHRoaXMuZG9uZSgpO1xuICAgIH1cbiAgfVxuXG4gIG9uTW91c2VEcmFnKGV2ZW50KSB7XG4gICAgdmFyIGVkaXRDaXJjbGUgPSBuZXcgUGFwZXIuUGF0aC5DaXJjbGUoZXZlbnQucG9pbnQsIDQwKTtcbiAgICB2YXIgbmV3VHJhY2s7XG4gICAgaWYodGhpcy5pc0FkZGluZyl7XG4gICAgICBuZXdUcmFjayA9IHRoaXMudHJhY2sudW5pdGUoZWRpdENpcmNsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1RyYWNrID0gdGhpcy50cmFjay5zdWJ0cmFjdChlZGl0Q2lyY2xlKTtcbiAgICB9XG4gICAgdGhpcy50cmFjay5yZW1vdmUoKTtcbiAgICB0aGlzLnRyYWNrID0gbmV3VHJhY2s7XG4gIH1cblxuICBkb25lKCl7XG4gICAgdGhpcy5tb3VzZUNvbnRyb2xzLnJlbW92ZSgpO1xuXG4gICAgdmFyIG1hcCA9IHtcbiAgICAgIHRyYWNrOiB0aGlzLnRyYWNrLnRvSlNPTigpLFxuICAgICAgc3RhcnQ6IHRoaXMuc3RhcnQudG9KU09OKCksXG4gICAgICBlbmQ6IHRoaXMuZW5kLnRvSlNPTigpXG4gICAgfVxuXG4gICAgdmlldy5zZXRWaWV3KHRoaXMudHJhY2suYm91bmRzLmV4cGFuZCgxMDApKTtcblxuICAgIHZhciBkYXRhVVJMID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignY2FudmFzJykudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xuXG4gICAgdGhpcy5jb3Vyc2UucmVtb3ZlKCk7XG4gICAgdmFyIGtleSA9ICdtYXAtJyArIChuZXcgRGF0ZSgpKS50b0lTT1N0cmluZygpO1xuICAgIHZhciB2YWx1ZSA9IHsgZGF0YVVSTCwgbWFwIH07XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgIHRoaXMuY2FsbGJhY2soeyB2aWV3OiAnTWVudScgfSk7XG4gIH1cblxuICBkaXNwb3NlKCl7XG4gICAgdGhpcy5jb3Vyc2UucmVtb3ZlKCk7XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL3ZpZXdzL21hcEVkaXRvci5qc1xuICoqLyIsInZhciBQYXBlciA9IHJlcXVpcmUoJ3BhcGVyJyk7XG52YXIgUGxheWVyID0gcmVxdWlyZSgnLi9wbGF5ZXInKTtcbnZhciBHYW1lID0gcmVxdWlyZSgnLi4vZ2FtZScpO1xudmFyIHZpZXcgPSByZXF1aXJlKCcuL3ZpZXcnKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2FtZUd1aXtcbiAgY29uc3RydWN0b3IoY2FsbGJhY2ssIHBhcmFtcyl7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuZ2FtZTtcbiAgICB0aGlzLm5ick9mUGxheWVycyA9IDI7XG4gICAgdGhpcy5wbGF5ZXJzID0gW107XG4gICAgdGhpcy5jb2xvcnMgPSBbJyNmZjAwMDAnLCAnIzAwMDBmZiddO1xuICAgIHRoaXMuY29udHJvbHMgPSBuZXcgUGFwZXIuR3JvdXAoKTtcbiAgICB0aGlzLmZvcmVHcm91bmQgPSBuZXcgUGFwZXIuR3JvdXAoW3RoaXMuY29udHJvbHNdKTtcbiAgICB0aGlzLmNvdXJzZSA9IG5ldyBQYXBlci5Hcm91cCgpO1xuICAgIHRoaXMubW91c2VDb250cm9scyA9IG5ldyBQYXBlci5Ub29sKCk7XG4gICAgdGhpcy5tb3VzZUNvbnRyb2xzLm9uTW91c2VEb3duID0gZSA9PiB0aGlzLmFkZFBsYXllckNsaWNrRXZlbnQoZSk7XG5cbiAgICB0aGlzLmdhbWUgPSBuZXcgR2FtZShwYXJhbXMpO1xuXG4gICAgdmFyIHRyYWNrID0gdGhpcy5nYW1lLnRyYWNrO1xuICAgIHRyYWNrLmNsb3NlZCA9IHRydWU7XG4gICAgdHJhY2suZmlsbENvbG9yID0gJ3B1cnBsZSc7XG5cbiAgICB2YXIgc3RhcnRBcmVhID0gdGhpcy5nYW1lLnN0YXJ0O1xuICAgIHN0YXJ0QXJlYS5maWxsQ29sb3IgPSAndGVhbCc7XG5cbiAgICB2YXIgZW5kQXJlYSA9IHRoaXMuZ2FtZS5lbmQ7XG4gICAgZW5kQXJlYS5maWxsQ29sb3IgPSAneWVsbG93JztcblxuICAgIHRoaXMuY291cnNlLmFkZENoaWxkKHRyYWNrKTtcbiAgICB0aGlzLmNvdXJzZS5hZGRDaGlsZChzdGFydEFyZWEpO1xuICAgIHRoaXMuY291cnNlLmFkZENoaWxkKGVuZEFyZWEpO1xuICAgIHZpZXcuYWRkQ291cnNlKHRoaXMuY291cnNlKTtcblxuICAgIHRoaXMuc2V0Vmlld1RvVHJhY2soKTtcblxuICAgIHRoaXMubW91c2V3aGVlbExpc3RlbmVyID0gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIGV2ZW50ID0+IHtcbiAgICAgIGlmKGV2ZW50LndoZWVsRGVsdGEgPT09IDApIHJldHVybjtcbiAgICAgIHRoaXMubW91c2V3aGVlbChldmVudC53aGVlbERlbHRhIDwgMCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmdlc3R1cmVlbmRMaXN0ZW5lciA9IGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2dlc3R1cmVlbmQnLCBlID0+IHRoaXMubW91c2V3aGVlbChlLnNjYWxlIDwgMSksIGZhbHNlKTtcbiAgfVxuXG4gIGdldCBjdXJyZW50UGxheWVyKCl7XG4gICAgcmV0dXJuIHRoaXMucGxheWVyc1t0aGlzLmdhbWUuY3VycmVudFBsYXllckluZGV4XTtcbiAgfVxuXG4gIGFkZFBsYXllckNsaWNrRXZlbnQoZXZlbnQpe1xuICAgIHZhciB4ID0gTWF0aC5yb3VuZChldmVudC5wb2ludC54IC8gMjApICogMjA7XG4gICAgdmFyIHkgPSBNYXRoLnJvdW5kKGV2ZW50LnBvaW50LnkgLyAyMCkgKiAyMDtcbiAgICB2YXIgcG9pbnQgPSBuZXcgUGFwZXIuUG9pbnQoeCwgeSk7XG4gICAgaWYodGhpcy5nYW1lLnN0YXJ0LmNvbnRhaW5zKHBvaW50KSl7XG4gICAgICB0aGlzLmdhbWUuYWRkUGxheWVyKHBvaW50LCBuZXcgUGFwZXIuUG9pbnQoMCwgMCkpO1xuICAgICAgdGhpcy5wbGF5ZXJzLnB1c2gobmV3IFBsYXllcih0aGlzLmNvbG9ycy5wb3AoKSwgcG9pbnQpKTtcbiAgICAgIGlmKHRoaXMucGxheWVycy5sZW5ndGggPT09IHRoaXMubmJyT2ZQbGF5ZXJzKXtcbiAgICAgICAgdGhpcy5zdGFydEdhbWUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdGFydEdhbWUoKXtcbiAgICB0aGlzLnBsYXllcnMuZm9yRWFjaChwID0+IHRoaXMuZm9yZUdyb3VuZC5hcHBlbmRCb3R0b20ocC5lbGVtZW50cykpO1xuICAgIHRoaXMubW91c2VDb250cm9scy5vbk1vdXNlRG93biA9IGUgPT4gdGhpcy5vbk1vdXNlRG93bihlKTtcbiAgICB0aGlzLmdhbWUuc3RhcnRHYW1lKCk7XG4gICAgdGhpcy5kcmF3Q29udHJvbHMoKTtcbiAgfVxuXG4gIG9uTW91c2VEb3duKGV2ZW50KXtcbiAgICB2YXIgaXRlbSA9IGV2ZW50LmdldEl0ZW0oKTtcbiAgICBpZighaXRlbSl7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpdGVtQ2xpY2tlZCA9IGl0ZW0uaGl0VGVzdChldmVudC5wb2ludCkuaXRlbTtcbiAgICBpZihpdGVtQ2xpY2tlZCAmJiBpdGVtQ2xpY2tlZC5tb3ZlUGxheWVyRGF0YSl7XG4gICAgICB0aGlzLm1vdmVQbGF5ZXIoaXRlbUNsaWNrZWQubW92ZVBsYXllckRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIG1vdXNld2hlZWwoc2hvdWxkWm9vbU91dCl7XG4gICAgaWYoc2hvdWxkWm9vbU91dCkge1xuICAgICAgdGhpcy5zZXRWaWV3VG9UcmFjaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFZpZXdUb0NvbnRyb2xzKCk7XG4gICAgfVxuICB9XG5cbiAgbW92ZVBsYXllcihyZWxhdGl2ZVZlY3Rvcil7XG4gICAgdmFyIGd1aVBsYXllciA9IHRoaXMucGxheWVyc1t0aGlzLmdhbWUuY3VycmVudFBsYXllckluZGV4XTtcbiAgICB2YXIgcGxheWVyID0gdGhpcy5nYW1lLm1vdmVQbGF5ZXIocmVsYXRpdmVWZWN0b3IpO1xuICAgIGlmKHBsYXllci5pc0luRW5kWm9uZSl7XG4gICAgICB0aGlzLmVuZEdhbWUocGxheWVyKTtcbiAgICB9XG4gICAgZ3VpUGxheWVyLmFkZFBvc2l0aW9uKHBsYXllci5wb3NpdGlvbik7XG4gICAgdGhpcy5uZXh0VHVybigpO1xuICB9XG5cbiAgbmV4dFR1cm4oKXtcbiAgICB0aGlzLmdhbWUubmV4dFR1cm4oKTtcbiAgICB0aGlzLmNvbnRyb2xzLnJlbW92ZUNoaWxkcmVuKCk7XG4gICAgaWYoIXRoaXMuZ2FtZS5jdXJyZW50UGxheWVyLmlzQWxpdmUpe1xuICAgICAgdGhpcy5uZXh0VHVybigpO1xuICAgIH1cbiAgICB0aGlzLmRyYXdDb250cm9scygpO1xuICB9XG5cbiAgZHJhd0NvbnRyb2xzKCl7XG4gICAgdGhpcy5nYW1lLnZlY3RvcnNGb3JDb250cm9sc1xuICAgICAgLm1hcCh2ID0+IHRoaXMuY3JlYXRlQ29udHJvbCh2KSlcbiAgICAgIC5mb3JFYWNoKGNvbnRyb2wgPT4gdGhpcy5jb250cm9scy5hZGRDaGlsZChjb250cm9sKSk7XG4gICAgdGhpcy5zZXRWaWV3VG9Db250cm9scygpO1xuICB9XG5cbiAgc2V0Vmlld1RvQ29udHJvbHMoKXtcbiAgICBpZighdGhpcy5nYW1lLmN1cnJlbnRQbGF5ZXIpIHJldHVybjtcbiAgICB2YXIgcGxheWVyQm91bmRzID0gdGhpcy5jb250cm9scy5ib3VuZHMuaW5jbHVkZSh0aGlzLmdhbWUuY3VycmVudFBsYXllci5wb3NpdGlvbik7XG4gICAgdmlldy5zZXRWaWV3KHBsYXllckJvdW5kcy5leHBhbmQoMTAwKSk7XG4gIH1cblxuICBzZXRWaWV3VG9UcmFjaygpe1xuICAgIHZpZXcuc2V0Vmlldyh0aGlzLmdhbWUudHJhY2suYm91bmRzKTtcbiAgfVxuXG4gIGNyZWF0ZUNvbnRyb2woY29udHJvbE9iamVjdCl7XG4gICAgdmFyIGNpcmNsZSA9IHRoaXMuY3VycmVudFBsYXllci5jcmVhdGVQb3NpdGlvbkVsZW1lbnQoY29udHJvbE9iamVjdC5hYnNvbHV0ZSk7XG4gICAgY2lyY2xlLm1vdmVQbGF5ZXJEYXRhID0gY29udHJvbE9iamVjdC5yZWxhdGl2ZTtcbiAgICByZXR1cm4gY2lyY2xlO1xuICB9XG5cbiAgZW5kR2FtZShwbGF5ZXIpe1xuICAgIHRoaXMuY2FsbGJhY2soeyB2aWV3OiAnTWVudScsIHBhcmFtczogcGxheWVyIH0pO1xuICB9XG5cbiAgZGlzcG9zZSgpe1xuICAgIHRoaXMuY291cnNlLnJlbW92ZSgpO1xuICAgIHRoaXMuZm9yZUdyb3VuZC5yZW1vdmUoKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdnZXN0dXJlZW5kJywgdGhpcy5nZXN0dXJlZW5kTGlzdGVuZXIpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vc2V3aGVlbCcsIHRoaXMubW91c2V3aGVlbExpc3RlbmVyKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMubW91c2VDb250cm9scy5yZW1vdmUoKSk7XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL3ZpZXdzL2dhbWVHdWkuanNcbiAqKi8iLCJ2YXIgUGFwZXIgPSByZXF1aXJlKCdwYXBlcicpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQbGF5ZXJ7XG4gIGNvbnN0cnVjdG9yKGNvbG9yLCBwb3NpdGlvbil7XG4gICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgIHRoaXMucGF0aCA9IG5ldyBQYXBlci5QYXRoKHtcbiAgICAgIHN0cm9rZUNvbG9yOiAnd2hpdGUnLFxuICAgICAgc3Ryb2tlV2lkdGg6IDFcbiAgICB9KTtcbiAgICB0aGlzLmVsZW1lbnRzID0gbmV3IFBhcGVyLkdyb3VwKFt0aGlzLnBhdGhdKTtcblxuICAgIHRoaXMuYWRkUG9zaXRpb24ocG9zaXRpb24pO1xuICB9XG5cbiAgYWRkUG9zaXRpb24ocG9zaXRpb24pe1xuICAgIHRoaXMucGF0aC5hZGQocG9zaXRpb24pO1xuICAgIHRoaXMucGF0aC5zbW9vdGgoKTtcbiAgICB2YXIgY2lyY2xlID0gdGhpcy5jcmVhdGVQb3NpdGlvbkVsZW1lbnQocG9zaXRpb24pO1xuICAgIHRoaXMuZWxlbWVudHMuYWRkQ2hpbGQoY2lyY2xlKTtcbiAgfVxuXG4gIGNyZWF0ZVBvc2l0aW9uRWxlbWVudChwb3NpdGlvbil7XG4gICAgdmFyIGNpcmNsZSA9IG5ldyBQYXBlci5QYXRoLkNpcmNsZShwb3NpdGlvbiwgNSk7XG4gICAgY2lyY2xlLmZpbGxDb2xvciA9IHRoaXMuY29sb3I7XG4gICAgY2lyY2xlLnN0cm9rZUNvbG9yID0gJ3doaXRlJztcbiAgICBjaXJjbGUuc3Ryb2tlV2lkdGggPSAwLjU7XG4gICAgcmV0dXJuIGNpcmNsZTtcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvdmlld3MvcGxheWVyLmpzXG4gKiovIiwidmFyIENhciA9IHJlcXVpcmUoJy4vY2FyJyk7XG52YXIgUGFwZXIgPSByZXF1aXJlKCdwYXBlcicpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHYW1le1xuICBjb25zdHJ1Y3RvcihtYXApe1xuICAgIHRoaXMuc2NhbGUgPSAyMDtcbiAgICB0aGlzLnBsYXllcnMgPSBbXTtcbiAgICB0aGlzLnN0YXJ0ID0gUGFwZXIucHJvamVjdC5pbXBvcnRKU09OKG1hcC5zdGFydCk7XG4gICAgdGhpcy5lbmQgPSBQYXBlci5wcm9qZWN0LmltcG9ydEpTT04obWFwLmVuZCk7XG4gICAgdGhpcy50cmFjayA9IFBhcGVyLnByb2plY3QuaW1wb3J0SlNPTihtYXAudHJhY2spO1xuICAgIHRoaXMuY3VycmVudFBsYXllckluZGV4ID0gMDtcbiAgICB0aGlzLnZlY3RvcnNGb3JDb250cm9scyA9IFtdO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRQbGF5ZXIoKXtcbiAgICByZXR1cm4gdGhpcy5wbGF5ZXJzW3RoaXMuY3VycmVudFBsYXllckluZGV4XTtcbiAgfVxuXG4gIHN0YXJ0R2FtZSgpe1xuICAgIHRoaXMuc2V0VmVjdG9yc0ZvckNvbnRyb2xzKCk7XG4gIH1cblxuICBzZXRWZWN0b3JzRm9yQ29udHJvbHMoKXtcbiAgICB2YXIgcGxheWVyID0gdGhpcy5jdXJyZW50UGxheWVyO1xuICAgIHZhciB2ZWN0b3JzRm9yQ29udHJvbHMgPSBbXTtcbiAgICBmb3IodmFyIHkgPSAxOyB5ID49IC0xOyB5LS0pe1xuICAgICAgZm9yKHZhciB4ID0gLTE7IHggPD0gMTsgeCsrKXtcbiAgICAgICAgdmFyIHBsYXllclJlbGF0aXZlVmVjdG9yID0gbmV3IFBhcGVyLlBvaW50KHRoaXMuc2NhbGUgKiB4LCB0aGlzLnNjYWxlICogeSkuY2xvbmUoKS5hZGQocGxheWVyLmRpcmVjdGlvbik7XG4gICAgICAgIHZhciBhYnNvbHV0ZVZlY3RvciA9IHBsYXllclJlbGF0aXZlVmVjdG9yLmNsb25lKCkuYWRkKHBsYXllci5wb3NpdGlvbik7XG4gICAgICAgIGlmKHRoaXMuaXNQb3NzaWJsZVBvc2l0aW9uKGFic29sdXRlVmVjdG9yKSkge1xuICAgICAgICAgIHZlY3RvcnNGb3JDb250cm9scy5wdXNoKHtcbiAgICAgICAgICAgIHJlbGF0aXZlOiBwbGF5ZXJSZWxhdGl2ZVZlY3RvcixcbiAgICAgICAgICAgIGFic29sdXRlOiBhYnNvbHV0ZVZlY3RvclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYodmVjdG9yc0ZvckNvbnRyb2xzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcGxheWVyLmlzQWxpdmUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnZlY3RvcnNGb3JDb250cm9scyA9IHZlY3RvcnNGb3JDb250cm9scztcbiAgfVxuXG4gIGFkZFBsYXllcihwb2ludCwgZGlyZWN0aW9uKXtcbiAgICB0aGlzLnBsYXllcnMucHVzaChuZXcgQ2FyKHBvaW50LCBkaXJlY3Rpb24pKTtcbiAgfVxuXG4gIG1vdmVQbGF5ZXIodmVjdG9yKXtcbiAgICB0aGlzLmN1cnJlbnRQbGF5ZXIubW92ZSh2ZWN0b3IpO1xuICAgIHZhciBwbGF5ZXIgPSB0aGlzLmN1cnJlbnRQbGF5ZXI7XG4gICAgcGxheWVyLmlzSW5FbmRab25lID0gdGhpcy5pc0luWm9uZSh0aGlzLmVuZCwgcGxheWVyLnBvc2l0aW9uKTtcbiAgICByZXR1cm4gcGxheWVyO1xuICB9XG5cbiAgbmV4dFR1cm4oKXtcbiAgICB0aGlzLnNldE5leHRQbGF5ZXIoKTtcbiAgICB0aGlzLnNldFZlY3RvcnNGb3JDb250cm9scygpO1xuICB9XG5cbiAgc2V0TmV4dFBsYXllcigpe1xuICAgIHRoaXMuY3VycmVudFBsYXllckluZGV4Kys7XG4gICAgaWYodGhpcy5jdXJyZW50UGxheWVySW5kZXggPT09IHRoaXMucGxheWVycy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuY3VycmVudFBsYXllckluZGV4ID0gMDtcbiAgICB9XG4gIH1cblxuICBpc1Bvc3NpYmxlUG9zaXRpb24odikge1xuICAgIHZhciBjYXJzT25UaGlzUG9zaXRpb24gPSB0aGlzLnBsYXllcnMuZmlsdGVyKHAgPT4gcC5wb3NpdGlvbi5jbG9uZSgpLnN1YnRyYWN0KHYpLmxlbmd0aCA9PT0gMCk7XG4gICAgdmFyIG5vT3RoZXJDYXJzID0gY2Fyc09uVGhpc1Bvc2l0aW9uLmxlbmd0aCA9PT0gMDtcbiAgICB2YXIgaXNPblRyYWNrID0gdGhpcy50cmFjay5jb250YWlucyh2KTtcbiAgICByZXR1cm4gbm9PdGhlckNhcnMgJiYgaXNPblRyYWNrO1xuICB9XG5cbiAgaXNJblpvbmUoem9uZSwgcG9zaXRpb24pe1xuICAgIHJldHVybiB6b25lLmNvbnRhaW5zKHBvc2l0aW9uKTtcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvZ2FtZS5qc1xuICoqLyIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIENhciB7XG4gIGNvbnN0cnVjdG9yKHBvc2l0aW9uLCBkaXJlY3Rpb24pe1xuICAgIHRoaXMucG9zaXRpb25zID0gW3Bvc2l0aW9uXTtcbiAgICB0aGlzLmN1cnJlbnRQb3NpdGlvbkluZGV4ID0gMDtcbiAgICB0aGlzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICB0aGlzLmlzQWxpdmUgPSB0cnVlO1xuICAgIHRoaXMuaXNJbkVuZFpvbmUgPSBmYWxzZTtcbiAgfVxuXG4gIGdldCBwb3NpdGlvbigpe1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uc1t0aGlzLmN1cnJlbnRQb3NpdGlvbkluZGV4XTtcbiAgfVxuXG4gIGdldCBsYXN0UG9zaXRpb24oKXtcbiAgICByZXR1cm4gdGhpcy5wb3NpdGlvbnNbdGhpcy5jdXJyZW50UG9zaXRpb25JbmRleCAtIDFdO1xuICB9XG5cbiAgc2V0IHBvc2l0aW9uKHZhbHVlKXtcbiAgICB0aGlzLnBvc2l0aW9ucy5wdXNoKHZhbHVlKTtcbiAgICB0aGlzLmN1cnJlbnRQb3NpdGlvbkluZGV4Kys7XG4gIH1cblxuICBtb3ZlKHZlY3Rvcikge1xuICAgIGlmKCF0aGlzLmlzVmFsaWRNb3ZlKHRoaXMuZGlyZWN0aW9uLCB2ZWN0b3IpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb24uY2xvbmUoKS5hZGQodmVjdG9yKTtcbiAgICB0aGlzLmRpcmVjdGlvbiA9IHZlY3RvcjtcbiAgfVxuXG4gIGlzVmFsaWRNb3ZlKGRpcmVjdGlvbiwgbW92ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9jYXIuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9